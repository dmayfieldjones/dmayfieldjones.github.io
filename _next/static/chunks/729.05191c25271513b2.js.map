{"version":3,"file":"static/chunks/729.05191c25271513b2.js","mappings":"+NAQe,iBAA4B,wBAAsB,CACjE,sBACA,yBACA,MAA2B,GAAM,EACjC,WAAwB,kBAAY,kCACpC,CAAS,EACT,uBACA,MAA2B,GAAG,EAC9B,kBACS,EACT,OACA,SACA,SACA,QACA,CACA,CACA,mBAOA,OANA,cACA,6CAEA,MADA,oBACA,CACA,EAAa,EAEb,aAEA,qBACA,IAAgB,UAAS,wBACzB,gCACA,CACA,2BACA,WAAgB,GAAS,wBAOzB,MANA,iEAA6F,OAAc,mBAC3G,gBACA,UACA,QACA,KACA,CAAS,OAAO,OAAO,YAEvB,mBACA,SACA,eACA,oCACA,WACA,EAAS,CACT,CACA,gBACA,+BACA,KACA,gBACA,YAA4B,OAAc,mBAC1C,uBACA,UACA,QACA,4BACa,OAAO,OAAO,KAC3B,SACA,CACA,eACA,CACA,mBACA,WAAgB,YAAiB,wBACjC,SAAgB,cAAoB,EACpC,QAAgB,QAAkB,UAClC,OACA,UACA,WACA,SAAuB,KAAS,CAChC,kCAAqD,iBAAe,UACpE,CACA,CACA,yBAA8B,8DAAgE,EAC9F,MACA,mBAAgB,UAA6B,EAC7C,8BACA,iCACA,QAAgB,YAAiB,MAAQ,kBAAY,+CACrD,QAA4B,kBAAY,qEACxC,2BACS,GACT,gBACA,+BACA,2BACA,KACA,eACA,WACA,YAEA,SACA,UAEA,MACA,OAGA,MACA,sBACA,8BACA,OACA,KACA,YACA,SACA,CAAqB,CACrB,OACA,WACA,mBACA,eACA,CAAiB,EACjB,MACA,CACA,CACA,SACA,kCACA,wCAEA,gBACA,OACA,UACA,GAAmB,QAAW,EAC9B,GAAmB,MAAS,KAC5B,wDACA,CACA,iBACA,oBACa,EACb,OACA,MACA,UAEA,aAAoB,4JAA4M,EAChO,EAAsB,QAAY,EAClC,KACA,cACA,YACA,SACA,WACA,cACA,UACA,kBACa,EACb,EACA,aAGoB,oBAAc,+BAClC,WAAsC,eAAa,EACnD,MAA+B,QAAQ,GAAG,EAAS,EACnD,MACA,CAAqB,EAGrB,CACA,gCACA,QACA,MAAsB,SAAG,oBACzB,EAAsB,SAAG,kBACzB,GAAgB,oBAAc,qBAC9B,0DACA,WAAkC,eAAa,EAC/C,MAA2B,QAAQ,GAAG,8CAAgE,SACtG,MACA,YACA,cACA,wDACA,OACA,QACA,MACA,kBACqB,CACJ,EACjB,CACA,CAAS,EACT,YACA,CACA,kBAAgC,EAChC,MAAe,sBAAgB,WAC/B,IACA,8BACA,OACA,KACA,cACA,UACqB,CACrB,OACA,WACA,kBACA,CAAiB,CACjB,CACA,SACA,UACA,CACA,CAAS,aACT,CACA,iBACA","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-bed/esm/BigBedAdapter/BigBedAdapter.js"],"sourcesContent":["import { BigBed } from '@gmod/bbi';\nimport BED from '@gmod/bed';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { SimpleFeature, doesIntersect2, max, min, updateStatus, } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { firstValueFrom, toArray } from 'rxjs';\nimport { featureData2 } from '../util';\nexport default class BigBedAdapter extends BaseFeatureDataAdapter {\n    async configurePre(opts) {\n        const pm = this.pluginManager;\n        const bigbed = new BigBed({\n            filehandle: openLocation(this.getConf('bigBedLocation'), pm),\n        });\n        const header = await bigbed.getHeader(opts);\n        const parser = new BED({\n            autoSql: header.autoSql,\n        });\n        return {\n            bigbed,\n            header,\n            parser,\n        };\n    }\n    async configure(opts) {\n        if (!this.cachedP) {\n            this.cachedP = this.configurePre(opts).catch((e) => {\n                this.cachedP = undefined;\n                throw e;\n            });\n        }\n        return this.cachedP;\n    }\n    async getRefNames(opts) {\n        const { header } = await this.configure(opts);\n        return Object.keys(header.refsByName);\n    }\n    async getRefNameAliases(opts) {\n        const { header } = await this.configure(opts);\n        const ret = await Promise.all(Object.keys(header.refsByName).map(async (r) => (await firstValueFrom(this.getFeatures({\n            assemblyName: '',\n            refName: r,\n            start: 0,\n            end: 1,\n        }).pipe(toArray())))[0]));\n        return ret\n            .map(r => r.toJSON())\n            .map(r => ({\n            refName: r.ucsc,\n            aliases: [r.ncbi, r.refseq, r.genbank],\n            override: true,\n        }));\n    }\n    async getData() {\n        const refNames = await this.getRefNames();\n        const features = [];\n        for (const refName of refNames) {\n            const f = await firstValueFrom(this.getFeatures({\n                assemblyName: 'unknown',\n                refName,\n                start: 0,\n                end: Number.MAX_SAFE_INTEGER,\n            }).pipe(toArray()));\n            features.push(f);\n        }\n        return features.flat();\n    }\n    async getHeader(opts) {\n        const { parser, header } = await this.configure(opts);\n        const { version, fileType } = header;\n        const { fields, ...rest } = parser.autoSql;\n        return {\n            version,\n            fileType,\n            autoSql: { ...rest },\n            fields: Object.fromEntries(fields.map(({ name, comment }) => [name, comment])),\n        };\n    }\n    async getFeaturesHelper({ query, opts, observer, allowRedispatch, originalQuery = query, }) {\n        var _a;\n        const { statusCallback = () => { } } = opts;\n        const scoreColumn = this.getConf('scoreColumn');\n        const aggregateField = this.getConf('aggregateField');\n        const { parser, bigbed } = await updateStatus('Downloading header', statusCallback, () => this.configure(opts));\n        const feats = await updateStatus('Downloading features', statusCallback, () => bigbed.getFeatures(query.refName, query.start, query.end, {\n            basesPerSpan: query.end - query.start,\n        }));\n        if (allowRedispatch && feats.length) {\n            let minStart = Number.POSITIVE_INFINITY;\n            let maxEnd = Number.NEGATIVE_INFINITY;\n            let hasAnyAggregationField = false;\n            for (const feat of feats) {\n                if (feat.start < minStart) {\n                    minStart = feat.start;\n                }\n                if (feat.end > maxEnd) {\n                    maxEnd = feat.end;\n                }\n                if (feat[aggregateField]) {\n                    hasAnyAggregationField = true;\n                }\n            }\n            if (hasAnyAggregationField &&\n                (maxEnd > query.end || minStart < query.start)) {\n                await this.getFeaturesHelper({\n                    query: {\n                        ...query,\n                        start: minStart - 500000,\n                        end: maxEnd + 500000,\n                    },\n                    opts,\n                    observer,\n                    allowRedispatch: false,\n                    originalQuery: query,\n                });\n                return;\n            }\n        }\n        const parentAggregation = {};\n        if (feats.some(f => f.uniqueId === undefined)) {\n            throw new Error('found uniqueId undefined');\n        }\n        for (const feat of feats) {\n            const splitLine = [\n                query.refName,\n                `${feat.start}`,\n                `${feat.end}`,\n                ...(((_a = feat.rest) === null || _a === void 0 ? void 0 : _a.split('\\t')) || []),\n            ];\n            const data = parser.parseLine(splitLine, {\n                uniqueId: feat.uniqueId,\n            });\n            const aggr = data[aggregateField];\n            if (!parentAggregation[aggr]) {\n                parentAggregation[aggr] = [];\n            }\n            const { uniqueId, type, chrom, chromStart, chromEnd, description, chromStarts: chromStarts2, blockStarts: blockStarts2, blockSizes: blockSizes2, score: score2, blockCount, thickStart, thickEnd, strand, ...rest } = data;\n            const f = featureData2({\n                ...rest,\n                scoreColumn,\n                splitLine,\n                parser,\n                uniqueId,\n                start: feat.start,\n                end: feat.end,\n                refName: query.refName,\n            });\n            if (aggr) {\n                parentAggregation[aggr].push(f);\n            }\n            else {\n                if (doesIntersect2(f.start, f.end, originalQuery.start, originalQuery.end)) {\n                    observer.next(new SimpleFeature({\n                        id: `${this.id}-${uniqueId}`,\n                        data: f,\n                    }));\n                }\n            }\n        }\n        Object.entries(parentAggregation).map(([name, subfeatures]) => {\n            var _a, _b;\n            const s = min(subfeatures.map(f => f.start));\n            const e = max(subfeatures.map(f => f.end));\n            if (doesIntersect2(s, e, originalQuery.start, originalQuery.end)) {\n                const subs = subfeatures.sort((a, b) => a.uniqueId.localeCompare(b.uniqueId));\n                observer.next(new SimpleFeature({\n                    id: `${this.id}-${(_a = subs[0]) === null || _a === void 0 ? void 0 : _a.uniqueId}-parent`,\n                    data: {\n                        type: 'gene',\n                        subfeatures: subs,\n                        strand: ((_b = subs[0]) === null || _b === void 0 ? void 0 : _b.strand) || 1,\n                        name,\n                        start: s,\n                        end: e,\n                        refName: query.refName,\n                    },\n                }));\n            }\n        });\n        observer.complete();\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            try {\n                await this.getFeaturesHelper({\n                    query: {\n                        ...query,\n                        start: query.start,\n                        end: query.end,\n                    },\n                    opts,\n                    observer,\n                    allowRedispatch: true,\n                });\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.stopToken);\n    }\n    freeResources() { }\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0]}