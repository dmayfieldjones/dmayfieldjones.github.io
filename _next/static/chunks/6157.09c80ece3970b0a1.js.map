{"version":3,"file":"static/chunks/6157.09c80ece3970b0a1.js","mappings":"iKACO,OACP,sCACA,sCACA,2BACA,2BACA,iCACA,iCACA,0BACA,6BACA,wBACA,qBACA,qBACA,sBACA,yBACA,0BACA,uBACA,yBACA,oBACA,EACO,GACP,sCACA,sCACA,2BACA,2BACA,iCACA,iCACA,6BACA,6BACA,wBACA,wBACA,wBACA,wBACA,yBACA,2BACA,2BACA,4BACA,oBACA,EACO,kBACP,4BACA,6BACA,mCACA,wCAEA,mCACA,0CAEA,EAIA,OAHA,wCAMA,wCACO,kBACP,aACA,UACA,CACA,CACO,cAEP,QADiB,EAAgB,IACjC,wBACA,EAAkB,IAAO,IACzB,eACA,OACA,YAEO,cACP,cACA,4FCnEA,cACA,0BACA,CACA,oBACA,gBACA,cACA,cACA,cACA,UACA,CACO,oBACP,IAAY,kFAA6E,EACzF,MACA,OAEA,MAAiB,uBAAiB,IAClC,iBAAY,GAAkB,CAAE,eAAU,IAC1C,CAAY,kBAAgB,EAC5B,EAAsB,QAAc,IACpC,4BACA,sDACA,KA2FA,aAxFA,cAwFA,GACA,oBACA,WACA,oBACA,OACA,uBACA,oBACA,kBACA,iBAEA,WACA,KACA,CACA,YAAwC,QAAW,8DACnD,YAAgC,aAAyB,IAGzD,EAFA,KACA,OACA,KAEA,CACA,KACA,CACA,QACA,2CACA,EACA,iCACA,0BACA,YAA4B,aAAoB,IAChD,mBAEA,CArHA,oBACA,UACA,eACA,WAEA,SACA,EAFA,OAEA,cACA,oCACA,8CACA,8CACA,qBAAuC,mBAAyB,oBAChE,qBAAuC,mBAAyB,oBAChE,2BACA,cACA,cACA,eACA,eACA,OACA,OACA,cACA,gBAGA,cACA,eAEA,KACA,oBAGA,EACA,+BACA,cAA0C,QAAsC,WAEhF,kBACA,cAA0C,QAAyB,OAEnE,iBACA,cACA,UAAmC,QAAwB,8BAE3D,gBACA,sBAAiD,iBAAwB,YAIzE,kDACA,cACA,qBAEA,cACA,sBAGA,qBAGA,gBACA,sBAAiD,iBAAwB,YAIzE,YACA,qBACA,EACA,OACA,oBACA,sBAEA,EACA,8BAIA,uCACA,aAIA,uCACA,WAEA,MACA,MACA,4BAEA,CAiCA","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/shared/color.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/LinearReadArcsDisplay/drawFeats.js"],"sourcesContent":["import { orientationTypes, pairMap } from '../util';\nexport const fillColor = {\n    color_fwd_strand_not_proper: '#ECC8C8',\n    color_rev_strand_not_proper: '#BEBED8',\n    color_fwd_strand: '#EC8B8B',\n    color_rev_strand: '#8F8FD8',\n    color_fwd_missing_mate: '#D11919',\n    color_rev_missing_mate: '#1919D1',\n    color_fwd_diff_chr: '#000',\n    color_rev_diff_chr: '#969696',\n    color_pair_lr: '#c8c8c8',\n    color_pair_rr: 'navy',\n    color_pair_rl: 'teal',\n    color_pair_ll: 'green',\n    color_nostrand: '#c8c8c8',\n    color_interchrom: 'purple',\n    color_longinsert: 'red',\n    color_shortinsert: 'pink',\n    color_unknown: 'grey',\n};\nexport const strokeColor = {\n    color_fwd_strand_not_proper: '#CA6767',\n    color_rev_strand_not_proper: '#7272AA',\n    color_fwd_strand: '#DC2A2A',\n    color_rev_strand: '#4141BA',\n    color_fwd_missing_mate: '#921111',\n    color_rev_missing_mate: '#111192',\n    color_fwd_diff_chr: '#000000',\n    color_rev_diff_chr: '#696969',\n    color_pair_lr: '#8C8C8C',\n    color_pair_rr: '#00005A',\n    color_pair_rl: '#005A5A',\n    color_pair_ll: '#005A00',\n    color_nostrand: '#8C8C8C',\n    color_interchrom: '#5A005A',\n    color_longinsert: '#B30000',\n    color_shortinsert: '#FF3A5C',\n    color_unknown: 'grey',\n};\nexport function getPairedInsertSizeColor(f1, f2, stats) {\n    const sameRef = f1.refName === f2.refName;\n    const tlen = Math.abs(f1.tlen || 0);\n    if (sameRef && tlen > ((stats === null || stats === void 0 ? void 0 : stats.upper) || 0)) {\n        return [fillColor.color_longinsert, strokeColor.color_longinsert];\n    }\n    else if (sameRef && tlen < ((stats === null || stats === void 0 ? void 0 : stats.lower) || 0)) {\n        return [fillColor.color_shortinsert, strokeColor.color_shortinsert];\n    }\n    else if (!sameRef) {\n        return [fillColor.color_interchrom, strokeColor.color_interchrom];\n    }\n    else {\n        return undefined;\n    }\n}\nconst defaultColor = [fillColor.color_unknown, fillColor.color_unknown];\nexport function getPairedInsertSizeAndOrientationColor(f1, f2, stats) {\n    return (getPairedOrientationColorOrDefault(f1) ||\n        getPairedInsertSizeColor(f1, f2, stats) ||\n        defaultColor);\n}\nexport function getPairedOrientationColorOrDefault(f) {\n    const type = orientationTypes.fr;\n    const r = type[f.pair_orientation || ''];\n    const type2 = pairMap[r];\n    return r === 'LR'\n        ? undefined\n        : [fillColor[type2], strokeColor[type2]];\n}\nexport function getPairedOrientationColor(f) {\n    return getPairedOrientationColorOrDefault(f) || defaultColor;\n}\n","import { getContainingView, getSession } from '@jbrowse/core/util';\nimport { featurizeSA } from '../MismatchParser';\nimport { getPairedInsertSizeAndOrientationColor, getPairedInsertSizeColor, getPairedOrientationColor, } from '../shared/color';\nimport { hasPairedReads } from '../shared/util';\nfunction jitter(n) {\n    return Math.random() * 2 * n - n;\n}\nfunction drawLineAtOffset(ctx, offset, height, color) {\n    ctx.strokeStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(offset, 0);\n    ctx.lineTo(offset, height);\n    ctx.stroke();\n}\nexport function drawFeats(self, ctx, width, height) {\n    const { chainData, colorBy, drawInter, drawLongRange, lineWidthSetting, jitterVal, } = self;\n    if (!chainData) {\n        return;\n    }\n    const view = getContainingView(self);\n    const { assemblyManager } = getSession(self);\n    const { chains, stats } = chainData;\n    const hasPaired = hasPairedReads(chainData);\n    const asm = assemblyManager.get(view.assemblyNames[0]);\n    const type = (colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) || 'insertSizeAndOrientation';\n    if (!asm) {\n        return;\n    }\n    ctx.lineWidth = lineWidthSetting;\n    function draw(k1, k2, assembly, longRange) {\n        var _a, _b, _c;\n        const s1 = k1.strand;\n        const s2 = k2.strand;\n        const f1 = s1 === -1;\n        const f2 = s2 === -1;\n        const p1 = f1 ? k1.start : k1.end;\n        const p2 = hasPaired ? (f2 ? k2.start : k2.end) : f2 ? k2.end : k2.start;\n        const ra1 = assembly.getCanonicalRefName(k1.refName) || k1.refName;\n        const ra2 = assembly.getCanonicalRefName(k2.refName) || k2.refName;\n        const r1 = (_a = view.bpToPx({ refName: ra1, coord: p1 })) === null || _a === void 0 ? void 0 : _a.offsetPx;\n        const r2 = (_b = view.bpToPx({ refName: ra2, coord: p2 })) === null || _b === void 0 ? void 0 : _b.offsetPx;\n        if (r1 !== undefined && r2 !== undefined) {\n            const radius = (r2 - r1) / 2;\n            const absrad = Math.abs(radius);\n            const p = r1 - view.offsetPx;\n            const p2 = r2 - view.offsetPx;\n            const drawArcInsteadOfBezier = absrad > 10000;\n            if (longRange && drawArcInsteadOfBezier) {\n                ctx.moveTo(p, 0);\n                ctx.beginPath();\n            }\n            else {\n                ctx.beginPath();\n                ctx.moveTo(p, 0);\n            }\n            if (longRange && drawArcInsteadOfBezier) {\n                ctx.strokeStyle = 'red';\n            }\n            else {\n                if (hasPaired) {\n                    if (type === 'insertSizeAndOrientation') {\n                        ctx.strokeStyle = getPairedInsertSizeAndOrientationColor(k1, k2, stats)[0];\n                    }\n                    else if (type === 'orientation') {\n                        ctx.strokeStyle = getPairedOrientationColor(k1)[0];\n                    }\n                    else if (type === 'insertSize') {\n                        ctx.strokeStyle =\n                            ((_c = getPairedInsertSizeColor(k1, k2, stats)) === null || _c === void 0 ? void 0 : _c[0]) || 'grey';\n                    }\n                    else if (type === 'gradient') {\n                        ctx.strokeStyle = `hsl(${Math.log10(absrad) * 10},50%,50%)`;\n                    }\n                }\n                else {\n                    if (type === 'orientation' || type === 'insertSizeAndOrientation') {\n                        if (s1 === -1 && s2 === 1) {\n                            ctx.strokeStyle = 'navy';\n                        }\n                        else if (s1 === 1 && s2 === -1) {\n                            ctx.strokeStyle = 'green';\n                        }\n                        else {\n                            ctx.strokeStyle = 'grey';\n                        }\n                    }\n                    else if (type === 'gradient') {\n                        ctx.strokeStyle = `hsl(${Math.log10(absrad) * 10},50%,50%)`;\n                    }\n                }\n            }\n            const destX = p + radius * 2;\n            const destY = Math.min(height + jitter(jitterVal), absrad);\n            if (longRange) {\n                if (absrad > 100000) {\n                    drawLineAtOffset(ctx, p + jitter(jitterVal), height, 'red');\n                    drawLineAtOffset(ctx, p2 + jitter(jitterVal), height, 'red');\n                }\n                else if (drawArcInsteadOfBezier) {\n                    ctx.arc(p + radius + jitter(jitterVal), 0, absrad, 0, Math.PI);\n                    ctx.stroke();\n                }\n                else {\n                    ctx.bezierCurveTo(p + jitter(jitterVal), destY, destX, destY, destX + jitter(jitterVal), 0);\n                    ctx.stroke();\n                }\n            }\n            else {\n                ctx.bezierCurveTo(p + jitter(jitterVal), destY, destX, destY, destX + jitter(jitterVal), 0);\n                ctx.stroke();\n            }\n        }\n        else if (r1 && drawInter) {\n            drawLineAtOffset(ctx, r1 - view.offsetPx, height, 'purple');\n        }\n    }\n    for (const chain of chains) {\n        if (chain.length === 1 && drawLongRange) {\n            const f = chain[0];\n            if (hasPaired && !(f.flags & 8)) {\n                const mate = {\n                    refName: f.next_ref || '',\n                    start: f.next_pos || 0,\n                    end: f.next_pos || 0,\n                    strand: f.strand,\n                };\n                draw(f, mate, asm, true);\n            }\n            else {\n                const features = [f, ...featurizeSA(f.SA, f.id, f.strand, f.name)].sort((a, b) => a.clipPos - b.clipPos);\n                for (let i = 0; i < features.length - 1; i++) {\n                    const f = features[i];\n                    const v1 = features[i + 1];\n                    draw(f, v1, asm, true);\n                }\n            }\n        }\n        else {\n            const res = hasPaired\n                ? chain.filter(f => !(f.flags & 2048) && !(f.flags & 8))\n                : chain\n                    .sort((a, b) => a.clipPos - b.clipPos)\n                    .filter(f => !(f.flags & 256));\n            for (let i = 0; i < res.length - 1; i++) {\n                draw(res[i], res[i + 1], asm, false);\n            }\n        }\n    }\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0,1]}