{"version":3,"file":"static/chunks/5124.e0bd50752b4d1bd3.js","mappings":"iKACO,OACP,sCACA,sCACA,2BACA,2BACA,iCACA,iCACA,0BACA,6BACA,wBACA,qBACA,qBACA,sBACA,yBACA,0BACA,uBACA,yBACA,oBACA,EACO,GACP,sCACA,sCACA,2BACA,2BACA,iCACA,iCACA,6BACA,6BACA,wBACA,wBACA,wBACA,wBACA,yBACA,2BACA,2BACA,4BACA,oBACA,EACO,kBACP,4BACA,6BACA,mCACA,wCAEA,mCACA,0CAEA,EAIA,OAHA,wCAMA,wCACO,kBACP,aACA,UACA,CACA,CACO,cAEP,QADiB,EAAgB,IACjC,wBACA,EAAkB,IAAO,IACzB,eACA,OACA,YAEO,cACP,cACA,mFCpEO,gBACP,sBACA,eACA,EAAe,QAAS,kBACxB,KAA4B,QAAU,iBACtC,MACA,MAA8B,QAAe,QAC7C,EAA8B,QAAmB,IACjD,KACA,IACA,aAAqB,eAAkB,KACvC,YAAyB,SAAW,CAAG,OAAa,OACpD,uDACA,QAOA,CACA,WACA,MACA,2BACA,wBACA,sBACA,CACA,MAbA,MACA,OACA,OACA,aAWA,CACA,YAEA,QACA,CAEA,gIIpCO,0BACP,aAGA,GACA,gBAEA,oBACA,CACO,cACP,SAAY,wDAAuD,UACnE,OACA,WACA,WACA,WACA,WACA,WACA,YACA,WACA,WACA,MACA,CACA,CAaO,aAGP,OAAa,UAFS,iBAAW,MAEpB,WADU,iBAAW,OACrB,CACb,iDQjCO,gBAAyB,6CAA8C,EAC9E,IAAY,uDAAgE,EAC5E,EAA0B,oBAAc,oBACxC,EAA+B,oBAAc,yBAC7C,EAAyC,oBAAc,mCACvD,EAA4B,oBAAc,sBAC1C,EAAuC,SAAd,oBAAc,YACvC,EAAkB,wBAAkB,IACpC,EAAqB,EAAe,GACpC,ERSA,QQVoC,SACP,CRS7B,iBQT+C,KRS/C,cACA,EACA,6BACA,EQXA,0CACA,cAAY,gBAAwB,IACpC,ERYA,YQbwD,EAC9B,CRY1B,kBQZ6C,ORY7C,EQZ6C,wBRY7C,IQVA,oBACA,eACA,0BACY,oBAAc,IAC1B,qBHlBO,UAA2B,KGoBX,CHpBW,wGAAsG,EACxI,WAAY,kDA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","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/shared/color.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/shared/getMaximumModificationAtEachPosition.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/PileupRenderer/colorBy.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/PileupRenderer/getAlignmentShapeColor.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/PileupRenderer/renderAlignmentShape.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/PileupRenderer/util.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/PileupRenderer/renderModifications.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/PileupRenderer/renderPerBaseLettering.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/PileupRenderer/renderPerBaseQuality.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/PileupRenderer/renderMethylation.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/PileupRenderer/renderAlignment.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/PileupRenderer/renderMismatches.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/PileupRenderer/renderSoftClipping.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/PileupRenderer/makeImageData.js"],"sourcesContent":["import { orientationTypes, pairMap } from '../util';\nexport const fillColor = {\n    color_fwd_strand_not_proper: '#ECC8C8',\n    color_rev_strand_not_proper: '#BEBED8',\n    color_fwd_strand: '#EC8B8B',\n    color_rev_strand: '#8F8FD8',\n    color_fwd_missing_mate: '#D11919',\n    color_rev_missing_mate: '#1919D1',\n    color_fwd_diff_chr: '#000',\n    color_rev_diff_chr: '#969696',\n    color_pair_lr: '#c8c8c8',\n    color_pair_rr: 'navy',\n    color_pair_rl: 'teal',\n    color_pair_ll: 'green',\n    color_nostrand: '#c8c8c8',\n    color_interchrom: 'purple',\n    color_longinsert: 'red',\n    color_shortinsert: 'pink',\n    color_unknown: 'grey',\n};\nexport const strokeColor = {\n    color_fwd_strand_not_proper: '#CA6767',\n    color_rev_strand_not_proper: '#7272AA',\n    color_fwd_strand: '#DC2A2A',\n    color_rev_strand: '#4141BA',\n    color_fwd_missing_mate: '#921111',\n    color_rev_missing_mate: '#111192',\n    color_fwd_diff_chr: '#000000',\n    color_rev_diff_chr: '#696969',\n    color_pair_lr: '#8C8C8C',\n    color_pair_rr: '#00005A',\n    color_pair_rl: '#005A5A',\n    color_pair_ll: '#005A00',\n    color_nostrand: '#8C8C8C',\n    color_interchrom: '#5A005A',\n    color_longinsert: '#B30000',\n    color_shortinsert: '#FF3A5C',\n    color_unknown: 'grey',\n};\nexport function getPairedInsertSizeColor(f1, f2, stats) {\n    const sameRef = f1.refName === f2.refName;\n    const tlen = Math.abs(f1.tlen || 0);\n    if (sameRef && tlen > ((stats === null || stats === void 0 ? void 0 : stats.upper) || 0)) {\n        return [fillColor.color_longinsert, strokeColor.color_longinsert];\n    }\n    else if (sameRef && tlen < ((stats === null || stats === void 0 ? void 0 : stats.lower) || 0)) {\n        return [fillColor.color_shortinsert, strokeColor.color_shortinsert];\n    }\n    else if (!sameRef) {\n        return [fillColor.color_interchrom, strokeColor.color_interchrom];\n    }\n    else {\n        return undefined;\n    }\n}\nconst defaultColor = [fillColor.color_unknown, fillColor.color_unknown];\nexport function getPairedInsertSizeAndOrientationColor(f1, f2, stats) {\n    return (getPairedOrientationColorOrDefault(f1) ||\n        getPairedInsertSizeColor(f1, f2, stats) ||\n        defaultColor);\n}\nexport function getPairedOrientationColorOrDefault(f) {\n    const type = orientationTypes.fr;\n    const r = type[f.pair_orientation || ''];\n    const type2 = pairMap[r];\n    return r === 'LR'\n        ? undefined\n        : [fillColor[type2], strokeColor[type2]];\n}\nexport function getPairedOrientationColor(f) {\n    return getPairedOrientationColorOrDefault(f) || defaultColor;\n}\n","import { getNextRefPos, parseCigar } from '../MismatchParser';\nimport { getModPositions, getModProbabilities } from '../ModificationParser';\nimport { getTagAlt } from '../util';\nexport function getMaxProbModAtEachPosition(feature, cigarOps) {\n    const fstrand = feature.get('strand');\n    const seq = feature.get('seq');\n    const mm = getTagAlt(feature, 'MM', 'Mm') || '';\n    const ops = cigarOps || parseCigar(feature.get('CIGAR'));\n    if (seq) {\n        const modifications = getModPositions(mm, seq, fstrand);\n        const probabilities = getModProbabilities(feature);\n        const maxProbModForPosition = [];\n        let probIndex = 0;\n        for (const { type, positions } of modifications) {\n            for (const { ref, idx } of getNextRefPos(ops, positions)) {\n                const prob = (probabilities === null || probabilities === void 0 ? void 0 : probabilities[probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)]) || 0;\n                if (!maxProbModForPosition[ref]) {\n                    maxProbModForPosition[ref] = {\n                        type,\n                        prob,\n                        allProbs: [prob],\n                    };\n                }\n                else {\n                    const old = maxProbModForPosition[ref];\n                    maxProbModForPosition[ref] = {\n                        allProbs: [...old.allProbs, prob],\n                        prob: Math.max(old.prob, prob),\n                        type: old.prob > prob ? old.type : type,\n                    };\n                }\n            }\n            probIndex += positions.length;\n        }\n        return maxProbModForPosition;\n    }\n    return undefined;\n}\n","import { readConfObject } from '@jbrowse/core/configuration';\nimport { fillColor } from '../shared/color';\nimport { orientationTypes } from '../util';\nexport function colorByInsertSize(feature) {\n    return feature.get('is_paired') &&\n        feature.get('refName') !== feature.get('next_ref')\n        ? '#555'\n        : `hsl(${Math.abs(feature.get('template_length')) / 10},50%,50%)`;\n}\nexport function colorByMappingQuality(feature) {\n    return `hsl(${feature.get('score')},50%,50%)`;\n}\nfunction getOrientation(feature, config) {\n    const orientationType = readConfObject(config, 'orientationType');\n    const type = orientationTypes[orientationType];\n    const orientation = type[feature.get('pair_orientation')];\n    return {\n        LR: 'color_pair_lr',\n        RR: 'color_pair_rr',\n        RL: 'color_pair_rl',\n        LL: 'color_pair_ll',\n    }[orientation];\n}\nexport function colorByStrand(feature) {\n    return feature.get('strand') === -1 ? '#8F8FD8' : '#EC8B8B';\n}\nexport function colorByOrientation(feature, config) {\n    return fillColor[getOrientation(feature, config) || 'color_nostrand'];\n}\nfunction getStranded(feature) {\n    const flags = feature.get('flags');\n    const strand = feature.get('strand');\n    if (flags & 1) {\n        const flipper = flags & 64 ? -1 : 1;\n        if (flags & 2) {\n            return strand * flipper === 1 ? 'color_rev_strand' : 'color_fwd_strand';\n        }\n        if (flags & 8) {\n            return strand * flipper === 1\n                ? 'color_rev_missing_mate'\n                : 'color_fwd_missing_mate';\n        }\n        if (feature.get('refName') === feature.get('next_ref')) {\n            return strand * flipper === 1\n                ? 'color_rev_strand_not_proper'\n                : 'color_fwd_strand_not_proper';\n        }\n        return strand === 1 ? 'color_fwd_diff_chr' : 'color_rev_diff_chr';\n    }\n    return 'color_unknown';\n}\nexport function colorByStrandedRnaSeq(feature) {\n    return fillColor[getStranded(feature)];\n}\n","import { readConfObject } from '@jbrowse/core/configuration';\nimport { colorByInsertSize, colorByMappingQuality, colorByOrientation, colorByStrand, colorByStrandedRnaSeq, } from './colorBy';\nimport { fillColor } from '../shared/color';\nexport function getAlignmentShapeColor({ colorType, tag, feature, config, defaultColor, colorTagMap, }) {\n    switch (colorType) {\n        case 'insertSize':\n            return colorByInsertSize(feature);\n        case 'strand':\n            return colorByStrand(feature);\n        case 'mappingQuality':\n            return colorByMappingQuality(feature);\n        case 'pairOrientation':\n            return colorByOrientation(feature, config);\n        case 'stranded':\n            return colorByStrandedRnaSeq(feature);\n        case 'xs':\n        case 'tag': {\n            const tags = feature.get('tags');\n            const val = tags ? tags[tag] : feature.get(tag);\n            if (tag === 'XS' || tag === 'TS') {\n                if (val === '-') {\n                    return fillColor.color_rev_strand;\n                }\n                else if (val === '+') {\n                    return fillColor.color_fwd_strand;\n                }\n                else {\n                    return fillColor.color_nostrand;\n                }\n            }\n            if (tag === 'ts') {\n                if (val === '-') {\n                    return feature.get('strand') === -1\n                        ? fillColor.color_fwd_strand\n                        : fillColor.color_rev_strand;\n                }\n                else if (val === '+') {\n                    return feature.get('strand') === -1\n                        ? fillColor.color_rev_strand\n                        : fillColor.color_fwd_strand;\n                }\n                else {\n                    return fillColor.color_nostrand;\n                }\n            }\n            return colorTagMap[val] || fillColor.color_nostrand;\n        }\n        case 'insertSizeAndPairOrientation':\n            break;\n        case 'modifications':\n        case 'methylation':\n            return feature.get('flags') & 16 ? '#c8dcc8' : '#c8c8c8';\n        default:\n            return defaultColor\n                ? 'lightgrey'\n                : readConfObject(config, 'color', { feature });\n    }\n}\n","import { bpSpanPx } from '@jbrowse/core/util';\nimport { parseCigar } from '../MismatchParser';\nexport function renderAlignmentShape({ ctx, feat, renderArgs, }) {\n    const { regions, bpPerPx } = renderArgs;\n    const { heightPx, topPx, feature } = feat;\n    const region = regions[0];\n    const s = feature.get('start');\n    const e = feature.get('end');\n    const CIGAR = feature.get('CIGAR');\n    const flip = region.reversed ? -1 : 1;\n    const strand = feature.get('strand') * flip;\n    const renderChevrons = bpPerPx < 10 && heightPx > 5;\n    if (CIGAR === null || CIGAR === void 0 ? void 0 : CIGAR.includes('N')) {\n        const cigarOps = parseCigar(CIGAR);\n        if (strand === 1) {\n            let drawLen = 0;\n            let drawStart = s;\n            for (let i = 0; i < cigarOps.length; i += 2) {\n                const opLen = +cigarOps[i];\n                const op = cigarOps[i + 1];\n                if (op === 'M' || op === 'X' || op === '=' || op === 'D') {\n                    drawLen += opLen;\n                }\n                else if (op === 'N') {\n                    if (drawStart !== drawLen) {\n                        const [leftPx, rightPx] = bpSpanPx(drawStart, drawStart + drawLen, region, bpPerPx);\n                        const w = rightPx - leftPx;\n                        ctx.fillRect(leftPx, topPx, w, heightPx);\n                    }\n                    drawStart += drawLen + opLen;\n                    drawLen = 0;\n                }\n            }\n            if (drawStart !== drawLen) {\n                const [leftPx, rightPx] = bpSpanPx(drawStart, drawStart + drawLen, region, bpPerPx);\n                const w = rightPx - leftPx;\n                if (renderChevrons) {\n                    ctx.beginPath();\n                    ctx.moveTo(leftPx, topPx);\n                    ctx.lineTo(leftPx, topPx + heightPx);\n                    ctx.lineTo(rightPx, topPx + heightPx);\n                    ctx.lineTo(rightPx + 5, topPx + heightPx / 2);\n                    ctx.lineTo(rightPx, topPx);\n                    ctx.closePath();\n                    ctx.fill();\n                }\n                else {\n                    ctx.fillRect(leftPx, topPx, w, heightPx);\n                }\n            }\n        }\n        else if (strand === -1) {\n            let drawLen = 0;\n            let drawStart = e;\n            for (let i = cigarOps.length - 2; i >= 0; i -= 2) {\n                const opLen = +cigarOps[i];\n                const op = cigarOps[i + 1];\n                if (op === 'M' || op === 'X' || op === '=' || op === 'D') {\n                    drawLen += opLen;\n                }\n                else if (op === 'N') {\n                    if (drawLen !== 0) {\n                        const [leftPx, rightPx] = bpSpanPx(drawStart - drawLen, drawStart, region, bpPerPx);\n                        ctx.fillRect(leftPx, topPx, rightPx - leftPx, heightPx);\n                    }\n                    drawStart -= drawLen + opLen;\n                    drawLen = 0;\n                }\n            }\n            if (drawLen !== 0) {\n                const [leftPx, rightPx] = bpSpanPx(drawStart - drawLen, drawStart, region, bpPerPx);\n                const w = rightPx - leftPx;\n                if (renderChevrons) {\n                    ctx.beginPath();\n                    ctx.moveTo(leftPx - 5, topPx + heightPx / 2);\n                    ctx.lineTo(leftPx, topPx + heightPx);\n                    ctx.lineTo(rightPx, topPx + heightPx);\n                    ctx.lineTo(rightPx, topPx);\n                    ctx.lineTo(leftPx, topPx);\n                    ctx.closePath();\n                    ctx.fill();\n                }\n                else {\n                    ctx.fillRect(leftPx, topPx, w, heightPx);\n                }\n            }\n        }\n    }\n    else {\n        const [leftPx, rightPx] = bpSpanPx(s, e, region, bpPerPx);\n        if (bpPerPx < 10 && heightPx > 5) {\n            if (strand === -1) {\n                ctx.beginPath();\n                ctx.moveTo(leftPx - 5, topPx + heightPx / 2);\n                ctx.lineTo(leftPx, topPx + heightPx);\n                ctx.lineTo(rightPx, topPx + heightPx);\n                ctx.lineTo(rightPx, topPx);\n                ctx.lineTo(leftPx, topPx);\n                ctx.closePath();\n                ctx.fill();\n            }\n            else {\n                ctx.beginPath();\n                ctx.moveTo(leftPx, topPx);\n                ctx.lineTo(leftPx, topPx + heightPx);\n                ctx.lineTo(rightPx, topPx + heightPx);\n                ctx.lineTo(rightPx + 5, topPx + heightPx / 2);\n                ctx.lineTo(rightPx, topPx);\n                ctx.closePath();\n                ctx.fill();\n            }\n        }\n        else {\n            ctx.fillRect(leftPx, topPx, rightPx - leftPx, heightPx);\n        }\n    }\n}\n","import { measureText } from '@jbrowse/core/util';\nexport function fillRect(ctx, l, t, w, h, cw, color) {\n    if (l + w < 0 || l > cw) {\n        return;\n    }\n    if (color) {\n        ctx.fillStyle = color;\n    }\n    ctx.fillRect(l, t, w, h);\n}\nexport function getColorBaseMap(theme) {\n    const { skip, deletion, insertion, hardclip, softclip, bases } = theme.palette;\n    return {\n        A: bases.A.main,\n        C: bases.C.main,\n        G: bases.G.main,\n        T: bases.T.main,\n        deletion,\n        insertion,\n        hardclip,\n        softclip,\n        skip,\n    };\n}\nexport function getContrastBaseMap(theme) {\n    return Object.fromEntries(Object.entries(getColorBaseMap(theme)).map(([key, value]) => [\n        key,\n        theme.palette.getContrastText(value),\n    ]));\n}\nexport function shouldDrawSNPsMuted(type) {\n    return ['methylation', 'modifications'].includes(type || '');\n}\nexport function shouldDrawIndels() {\n    return true;\n}\nexport function getCharWidthHeight() {\n    const charWidth = measureText('A');\n    const charHeight = measureText('M') - 2;\n    return { charWidth, charHeight };\n}\n","import { bpSpanPx, max, sum } from '@jbrowse/core/util';\nimport { fillRect } from './util';\nimport { getMaxProbModAtEachPosition } from '../shared/getMaximumModificationAtEachPosition';\nimport { alphaColor } from '../shared/util';\nexport function renderModifications({ ctx, feat, region, bpPerPx, renderArgs, canvasWidth, cigarOps, }) {\n    var _a, _b;\n    const { feature, topPx, heightPx } = feat;\n    const { colorBy, visibleModifications = {} } = renderArgs;\n    const seq = feature.get('seq');\n    if (!seq) {\n        return;\n    }\n    const start = feature.get('start');\n    const isolatedModification = (_a = colorBy === null || colorBy === void 0 ? void 0 : colorBy.modifications) === null || _a === void 0 ? void 0 : _a.isolatedModification;\n    const twoColor = (_b = colorBy === null || colorBy === void 0 ? void 0 : colorBy.modifications) === null || _b === void 0 ? void 0 : _b.twoColor;\n    const probs = getMaxProbModAtEachPosition(feature, cigarOps);\n    if (probs) {\n        let pos = 0;\n        for (const { allProbs, prob, type } of probs) {\n            const r = start + pos;\n            const [leftPx, rightPx] = bpSpanPx(r, r + 1, region, bpPerPx);\n            const mod = visibleModifications[type];\n            if (!mod) {\n                console.warn(`${type} not known yet`);\n                return;\n            }\n            if (isolatedModification && mod.type !== isolatedModification) {\n                return;\n            }\n            const col = mod.color || 'black';\n            const s = 1 - sum(allProbs);\n            if (twoColor && s > max(allProbs)) {\n                const c = alphaColor('blue', s);\n                const w = rightPx - leftPx + 0.5;\n                fillRect(ctx, leftPx, topPx, w, heightPx, canvasWidth, c);\n            }\n            else {\n                const c = alphaColor(col, prob);\n                const w = rightPx - leftPx + 0.5;\n                fillRect(ctx, leftPx, topPx, w, heightPx, canvasWidth, c);\n            }\n            pos++;\n        }\n    }\n}\n","import { bpSpanPx } from '@jbrowse/core/util';\nimport { fillRect } from './util';\nexport function renderPerBaseLettering({ ctx, feat, region, bpPerPx, colorMap, colorContrastMap, charWidth, charHeight, canvasWidth, cigarOps, }) {\n    const heightLim = charHeight - 2;\n    const { feature, topPx, heightPx } = feat;\n    const seq = feature.get('seq');\n    const w = 1 / bpPerPx;\n    const start = feature.get('start');\n    let soffset = 0;\n    let roffset = 0;\n    if (!seq) {\n        return;\n    }\n    for (let i = 0; i < cigarOps.length; i += 2) {\n        const len = +cigarOps[i];\n        const op = cigarOps[i + 1];\n        if (op === 'S' || op === 'I') {\n            soffset += len;\n        }\n        else if (op === 'D' || op === 'N') {\n            roffset += len;\n        }\n        else if (op === 'M' || op === 'X' || op === '=') {\n            for (let m = 0; m < len; m++) {\n                const letter = seq[soffset + m];\n                const r = start + roffset + m;\n                const [leftPx] = bpSpanPx(r, r + 1, region, bpPerPx);\n                const c = colorMap[letter];\n                fillRect(ctx, leftPx, topPx, w + 0.5, heightPx, canvasWidth, c);\n                if (w >= charWidth && heightPx >= heightLim) {\n                    ctx.fillStyle = colorContrastMap[letter];\n                    ctx.fillText(letter, leftPx + (w - charWidth) / 2 + 1, topPx + heightPx);\n                }\n            }\n            soffset += len;\n            roffset += len;\n        }\n    }\n}\n","import { bpSpanPx } from '@jbrowse/core/util';\nimport { fillRect } from './util';\nexport function renderPerBaseQuality({ ctx, feat, region, bpPerPx, canvasWidth, cigarOps, }) {\n    const { feature, topPx, heightPx } = feat;\n    const qual = feature.get('qual') || '';\n    const scores = qual.split(' ').map(val => +val);\n    const w = 1 / bpPerPx;\n    const start = feature.get('start');\n    let soffset = 0;\n    let roffset = 0;\n    for (let i = 0; i < cigarOps.length; i += 2) {\n        const len = +cigarOps[i];\n        const op = cigarOps[i + 1];\n        if (op === 'S' || op === 'I') {\n            soffset += len;\n        }\n        else if (op === 'D' || op === 'N') {\n            roffset += len;\n        }\n        else if (op === 'M' || op === 'X' || op === '=') {\n            for (let m = 0; m < len; m++) {\n                const score = scores[soffset + m];\n                const start0 = start + roffset + m;\n                const leftPx = bpSpanPx(start0, start0 + 1, region, bpPerPx)[0];\n                const c = `hsl(${score === 255 ? 150 : score * 1.5},55%,50%)`;\n                fillRect(ctx, leftPx, topPx, w + 0.5, heightPx, canvasWidth, c);\n            }\n            soffset += len;\n            roffset += len;\n        }\n    }\n}\n","import { bpSpanPx } from '@jbrowse/core/util';\nimport { colord } from '@jbrowse/core/util/colord';\nimport { fillRect } from './util';\nimport { getMethBins } from '../ModificationParser';\nexport function renderMethylation({ ctx, feat, region, bpPerPx, renderArgs, canvasWidth, cigarOps, }) {\n    const { regionSequence } = renderArgs;\n    const { feature, topPx, heightPx } = feat;\n    if (!regionSequence) {\n        throw new Error('region sequence required for methylation');\n    }\n    const seq = feature.get('seq');\n    if (!seq) {\n        return;\n    }\n    const fstart = feature.get('start');\n    const fend = feature.get('end');\n    const { methBins, methProbs, hydroxyMethBins, hydroxyMethProbs } = getMethBins(feature, cigarOps);\n    function getCol(k) {\n        if (methBins[k]) {\n            const p = methProbs[k] || 0;\n            return (p > 0.5\n                ? colord('red').alpha((p - 0.5) * 2)\n                : colord('blue').alpha(1 - p * 2)).toHslString();\n        }\n        if (hydroxyMethBins[k]) {\n            const p = hydroxyMethProbs[k] || 0;\n            return (p > 0.5\n                ? colord('pink').alpha((p - 0.5) * 2)\n                : colord('purple').alpha(1 - p * 2)).toHslString();\n        }\n        return undefined;\n    }\n    const r = regionSequence.toLowerCase();\n    for (let i = 0; i < fend - fstart; i++) {\n        const j = i + fstart;\n        const l1 = r[j - region.start + 1];\n        const l2 = r[j - region.start + 2];\n        if (l1 === 'c' && l2 === 'g') {\n            if (bpPerPx > 2) {\n                const [leftPx, rightPx] = bpSpanPx(j, j + 2, region, bpPerPx);\n                const w = rightPx - leftPx + 0.5;\n                const c = getCol(i) || getCol(i + 1) || 'blue';\n                fillRect(ctx, leftPx, topPx, w, heightPx, canvasWidth, c);\n            }\n            else {\n                const [leftPx, rightPx] = bpSpanPx(j, j + 1, region, bpPerPx);\n                const w = rightPx - leftPx + 0.5;\n                const c = getCol(i) || 'blue';\n                fillRect(ctx, leftPx, topPx, w, heightPx, canvasWidth, c);\n                const [leftPx2, rightPx2] = bpSpanPx(j + 1, j + 2, region, bpPerPx);\n                const w2 = rightPx2 - leftPx2 + 0.5;\n                const c2 = getCol(i + 1) || 'blue';\n                fillRect(ctx, leftPx2, topPx, w2, heightPx, canvasWidth, c2);\n            }\n        }\n    }\n}\n","import { getAlignmentShapeColor } from './getAlignmentShapeColor';\nimport { renderAlignmentShape } from './renderAlignmentShape';\nimport { renderModifications } from './renderModifications';\nimport { renderPerBaseLettering } from './renderPerBaseLettering';\nimport { renderPerBaseQuality } from './renderPerBaseQuality';\nimport { parseCigar } from '../MismatchParser';\nimport { renderMethylation } from './renderMethylation';\nexport function renderAlignment({ ctx, feat, renderArgs, colorMap, colorContrastMap, charWidth, charHeight, defaultColor, canvasWidth, }) {\n    const { config, bpPerPx, regions, colorBy, colorTagMap = {} } = renderArgs;\n    const { tag = '', type: colorType = '' } = colorBy || {};\n    const { feature } = feat;\n    const region = regions[0];\n    ctx.fillStyle = getAlignmentShapeColor({\n        feature,\n        config,\n        tag,\n        defaultColor,\n        colorType,\n        colorTagMap,\n    });\n    renderAlignmentShape({ ctx, feat, renderArgs });\n    switch (colorType) {\n        case 'perBaseQuality': {\n            const cigarOps = parseCigar(feature.get('CIGAR'));\n            renderPerBaseQuality({\n                ctx,\n                feat,\n                region,\n                bpPerPx,\n                canvasWidth,\n                cigarOps,\n            });\n            break;\n        }\n        case 'perBaseLettering': {\n            const cigarOps = parseCigar(feature.get('CIGAR'));\n            renderPerBaseLettering({\n                ctx,\n                feat,\n                region,\n                bpPerPx,\n                colorMap,\n                colorContrastMap,\n                charWidth,\n                charHeight,\n                canvasWidth,\n                cigarOps,\n            });\n            break;\n        }\n        case 'modifications': {\n            const cigarOps = parseCigar(feature.get('CIGAR'));\n            renderModifications({\n                ctx,\n                feat,\n                region,\n                bpPerPx,\n                renderArgs,\n                canvasWidth,\n                cigarOps,\n            });\n            break;\n        }\n        case 'methylation': {\n            const cigarOps = parseCigar(feature.get('CIGAR'));\n            renderMethylation({\n                ctx,\n                feat,\n                region,\n                bpPerPx,\n                renderArgs,\n                canvasWidth,\n                cigarOps,\n            });\n            break;\n        }\n    }\n}\n","import { bpSpanPx, measureText } from '@jbrowse/core/util';\nimport { colord } from '@jbrowse/core/util/colord';\nimport { fillRect } from './util';\nexport function renderMismatches({ ctx, feat, renderArgs, minSubfeatureWidth, largeInsertionIndicatorScale, mismatchAlpha, charWidth, charHeight, colorMap, colorContrastMap, hideSmallIndels, canvasWidth, drawSNPsMuted, drawIndels = true, }) {\n    const { bpPerPx, regions } = renderArgs;\n    const { heightPx, topPx, feature } = feat;\n    const region = regions[0];\n    const start = feature.get('start');\n    const pxPerBp = Math.min(1 / bpPerPx, 2);\n    const mismatches = feature.get('mismatches');\n    const heightLim = charHeight - 2;\n    const extraHorizontallyFlippedOffset = region.reversed ? 1 / bpPerPx + 1 : -1;\n    if (!mismatches) {\n        return;\n    }\n    for (const mismatch of mismatches) {\n        const mstart = start + mismatch.start;\n        const mlen = mismatch.length;\n        const mbase = mismatch.base;\n        const [leftPx, rightPx] = bpSpanPx(mstart, mstart + mlen, region, bpPerPx);\n        const widthPx = Math.max(minSubfeatureWidth, rightPx - leftPx);\n        if (mismatch.type === 'mismatch') {\n            if (!drawSNPsMuted) {\n                const baseColor = colorMap[mismatch.base] || '#888';\n                const c = mismatchAlpha && mismatch.qual !== undefined\n                    ? colord(baseColor)\n                        .alpha(Math.min(1, mismatch.qual / 50))\n                        .toHslString()\n                    : baseColor;\n                fillRect(ctx, Math.round(leftPx), topPx, widthPx, heightPx, canvasWidth, c);\n            }\n            if (widthPx >= charWidth && heightPx >= heightLim) {\n                const contrastColor = drawSNPsMuted\n                    ? 'black'\n                    : colorContrastMap[mismatch.base] || 'black';\n                ctx.fillStyle =\n                    mismatchAlpha && mismatch.qual !== undefined\n                        ? colord(contrastColor)\n                            .alpha(Math.min(1, mismatch.qual / 50))\n                            .toHslString()\n                        : contrastColor;\n                ctx.fillText(mbase, leftPx + (widthPx - charWidth) / 2 + 1, topPx + heightPx);\n            }\n        }\n        else if (mismatch.type === 'deletion' && drawIndels) {\n            const len = mismatch.length;\n            if (!hideSmallIndels || len >= 10) {\n                fillRect(ctx, leftPx, topPx, Math.abs(leftPx - rightPx), heightPx, canvasWidth, colorMap.deletion);\n                const txt = `${mismatch.length}`;\n                const rwidth = measureText(txt, 10);\n                if (widthPx >= rwidth && heightPx >= heightLim) {\n                    ctx.fillStyle = colorContrastMap.deletion;\n                    ctx.fillText(txt, (leftPx + rightPx) / 2 - rwidth / 2, topPx + heightPx);\n                }\n            }\n        }\n        else if (mismatch.type === 'insertion' && drawIndels) {\n            const pos = leftPx + extraHorizontallyFlippedOffset;\n            const len = +mismatch.base || mismatch.length;\n            const insW = Math.max(0, Math.min(1.2, 1 / bpPerPx));\n            if (len < 10) {\n                if (!hideSmallIndels) {\n                    fillRect(ctx, pos, topPx, insW, heightPx, canvasWidth, colorMap.insertion);\n                    if (1 / bpPerPx >= charWidth && heightPx >= heightLim) {\n                        const l = Math.round(pos - insW);\n                        fillRect(ctx, l, topPx, insW * 3, 1, canvasWidth);\n                        fillRect(ctx, l, topPx + heightPx - 1, insW * 3, 1, canvasWidth);\n                        ctx.fillText(`(${mismatch.base})`, pos + 3, topPx + heightPx);\n                    }\n                }\n            }\n        }\n        else if (mismatch.type === 'hardclip' || mismatch.type === 'softclip') {\n            const pos = leftPx + extraHorizontallyFlippedOffset;\n            const c = colorMap[mismatch.type];\n            const clipW = Math.max(minSubfeatureWidth, pxPerBp);\n            fillRect(ctx, pos, topPx, clipW, heightPx, canvasWidth, c);\n            if (1 / bpPerPx >= charWidth && heightPx >= heightLim) {\n                const l = pos - clipW;\n                fillRect(ctx, l, topPx, clipW * 3, 1, canvasWidth);\n                fillRect(ctx, l, topPx + heightPx - 1, clipW * 3, 1, canvasWidth);\n                ctx.fillText(`(${mismatch.base})`, pos + 3, topPx + heightPx);\n            }\n        }\n        else if (mismatch.type === 'skip') {\n            if (leftPx + widthPx > 0) {\n                const adjustPx = widthPx - (bpPerPx > 10 ? 1.5 : 0);\n                const l = Math.max(0, leftPx);\n                const t = topPx + heightPx / 2 - 1;\n                const w = adjustPx + Math.min(leftPx, 0);\n                const h = 1;\n                fillRect(ctx, l, t, w, h, canvasWidth, colorMap.skip);\n            }\n        }\n    }\n    if (drawIndels) {\n        for (const mismatch of mismatches) {\n            const mstart = start + mismatch.start;\n            const mlen = mismatch.length;\n            const len = +mismatch.base || mismatch.length;\n            if (mismatch.type === 'insertion' && len >= 10) {\n                const [leftPx] = bpSpanPx(mstart, mstart + mlen, region, bpPerPx);\n                const txt = `${len}`;\n                if (bpPerPx > largeInsertionIndicatorScale) {\n                    fillRect(ctx, leftPx - 1, topPx, 2, heightPx, canvasWidth, colorMap.insertion);\n                }\n                else if (heightPx > charHeight) {\n                    const rwidth = measureText(txt);\n                    const padding = 5;\n                    fillRect(ctx, leftPx - rwidth / 2 - padding, topPx, rwidth + 2 * padding, heightPx, canvasWidth, 'purple');\n                    ctx.fillStyle = colorContrastMap.insertion;\n                    ctx.fillText(txt, leftPx - rwidth / 2, topPx + heightPx);\n                }\n                else {\n                    const padding = 2;\n                    fillRect(ctx, leftPx - padding, topPx, 2 * padding, heightPx, canvasWidth, colorMap.insertion);\n                }\n            }\n        }\n    }\n}\n","import { readConfObject } from '@jbrowse/core/configuration';\nimport { bpSpanPx } from '@jbrowse/core/util';\nimport { fillRect, getCharWidthHeight } from './util';\nimport { parseCigar } from '../MismatchParser';\nexport function renderSoftClipping({ ctx, feat, renderArgs, config, theme, colorMap, canvasWidth, }) {\n    const { feature, topPx, heightPx } = feat;\n    const { regions, bpPerPx } = renderArgs;\n    const region = regions[0];\n    const minFeatWidth = readConfObject(config, 'minSubfeatureWidth');\n    const mismatches = feature.get('mismatches');\n    const seq = feature.get('seq');\n    const { charWidth, charHeight } = getCharWidthHeight();\n    if (!(seq && mismatches)) {\n        return;\n    }\n    const heightLim = charHeight - 2;\n    let seqOffset = 0;\n    let refOffset = 0;\n    const CIGAR = feature.get('CIGAR');\n    const cigarOps = parseCigar(CIGAR);\n    for (let i = 0; i < cigarOps.length; i += 2) {\n        const op = cigarOps[i + 1];\n        const len = +cigarOps[i];\n        if (op === 'S') {\n            for (let k = 0; k < len; k++) {\n                const base = seq[seqOffset + k];\n                const s0 = feature.get('start') - (i === 0 ? len : 0) + refOffset + k;\n                const [leftPx, rightPx] = bpSpanPx(s0, s0 + 1, region, bpPerPx);\n                const widthPx = Math.max(minFeatWidth, rightPx - leftPx);\n                const baseColor = colorMap[base] || '#000000';\n                ctx.fillStyle = baseColor;\n                fillRect(ctx, leftPx, topPx, widthPx, heightPx, canvasWidth);\n                if (widthPx >= charWidth && heightPx >= heightLim) {\n                    ctx.fillStyle = theme.palette.getContrastText(baseColor);\n                    ctx.fillText(base, leftPx + (widthPx - charWidth) / 2 + 1, topPx + heightPx);\n                }\n            }\n            seqOffset += len;\n        }\n        if (op === 'N') {\n            refOffset += len;\n        }\n        if (op === 'M' || op === '=' || op === 'X') {\n            refOffset += len;\n            seqOffset += len;\n        }\n        if (op === 'H') {\n        }\n        if (op === 'D') {\n            refOffset += len;\n        }\n        if (op === 'I') {\n            seqOffset += len;\n        }\n    }\n}\n","import { readConfObject } from '@jbrowse/core/configuration';\nimport { createJBrowseTheme } from '@jbrowse/core/ui';\nimport { checkStopToken } from '@jbrowse/core/util/stopToken';\nimport { renderAlignment } from './renderAlignment';\nimport { renderMismatches } from './renderMismatches';\nimport { renderSoftClipping } from './renderSoftClipping';\nimport { getCharWidthHeight, getColorBaseMap, getContrastBaseMap, shouldDrawIndels, shouldDrawSNPsMuted, } from './util';\nexport function makeImageData({ ctx, layoutRecords, canvasWidth, renderArgs, }) {\n    const { stopToken, config, showSoftClip, colorBy, theme: configTheme, } = renderArgs;\n    const mismatchAlpha = readConfObject(config, 'mismatchAlpha');\n    const minSubfeatureWidth = readConfObject(config, 'minSubfeatureWidth');\n    const largeInsertionIndicatorScale = readConfObject(config, 'largeInsertionIndicatorScale');\n    const hideSmallIndels = readConfObject(config, 'hideSmallIndels');\n    const defaultColor = readConfObject(config, 'color') === '#f0f';\n    const theme = createJBrowseTheme(configTheme);\n    const colorMap = getColorBaseMap(theme);\n    const colorContrastMap = getContrastBaseMap(theme);\n    ctx.font = 'bold 10px Courier New,monospace';\n    const { charWidth, charHeight } = getCharWidthHeight();\n    const drawSNPsMuted = shouldDrawSNPsMuted(colorBy === null || colorBy === void 0 ? void 0 : colorBy.type);\n    const drawIndels = shouldDrawIndels();\n    let start = performance.now();\n    for (const feat of layoutRecords) {\n        if (performance.now() - start > 400) {\n            checkStopToken(stopToken);\n            start = performance.now();\n        }\n        renderAlignment({\n            ctx,\n            feat,\n            renderArgs,\n            defaultColor,\n            colorMap,\n            colorContrastMap,\n            charWidth,\n            charHeight,\n            canvasWidth,\n        });\n        renderMismatches({\n            ctx,\n            feat,\n            renderArgs,\n            hideSmallIndels,\n            mismatchAlpha,\n            drawSNPsMuted,\n            drawIndels,\n            largeInsertionIndicatorScale,\n            minSubfeatureWidth,\n            charWidth,\n            charHeight,\n            colorMap,\n            colorContrastMap,\n            canvasWidth,\n        });\n        if (showSoftClip) {\n            renderSoftClipping({\n                ctx,\n                feat,\n                renderArgs,\n                colorMap,\n                config,\n                theme,\n                canvasWidth,\n            });\n        }\n    }\n    return undefined;\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13]}