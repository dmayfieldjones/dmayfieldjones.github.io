{"version":3,"file":"static/chunks/3943.62bf6a70a734c9ba.js","mappings":"kHqBEO,EKAH,EACG,EACA,EQJP,cREU,qY1BDV,MADA,YACe,OAAO,EAAC,sBEDvB,cACA,gDACA,eACA,CAEe,WAAS,KACxB,yBACA,CCPA,cACA,gDACA,sBACA,CAEe,WAAS,KACxB,yBACA,CCPA,QAAY,CACZ,IAAY,CAKZ,cACA,6BAAoC,sBACpC,2CACA,CAAG,cAAgB,EACnB,CAUA,cACA,0BACA,KAUA,OARA,sBACA,eACA,QACA,cAGA,CAAG,EAEH,CACA,CAEA,gBACA,sBACA,mCACA,CAqBe,WAAS,GACxB,6BACA,kBAWA,gBACA,IAIA,EAJA,KACA,WACA,IACA,IAEA,OACA,KAMA,IANqB,KAMrB,IACA,cACA,mBAGA,YACA,GAzFA,KAyFA,iBACA,YA1FA,KA0FA,iBA1FA,KA0FA,oBAIA,MAHA,cACA,gCA1FA,KA2FA,IAAiC,KA5FjC,IA4F6C,uBAC7C,mCACA,CAGA,WACA,0CACA,GAlGA,KAkGA,EAAiC,KAnGjC,IAmG6C,2BAC7C,kBACA,mBACA,CAGA,wBACA,CAEA,IA5GA,KA+EA,uBA9EA,KA+EA,uBA4BA,cAEA,IADA,SACA,8BACA,uBACA,SACA,CAEA,QACA,CAEA,gBACA,yBACA,yBACA,cACA,CAAO,SACP,CAAK,CACL,CAgBA,cACA,uBACA,CAEA,kBArGA,EACA,EACA,EACA,EACA,EAVA,EA4GA,kBACA,mBAtGA,GADA,EAuGA,GAtGA,cACA,oBACA,oBACA,yBACA,wBAVA,EADA,EAYA,oBAXA,cACA,kBACA,QASA,mDACA,mDACA,uCACA,+BACA,KA8FA,2CACA,CACA,CAEA,OACA,MA5FA,cACA,gCAnDA,EAoDA,oBACA,UArDA,IAqDA,GApDA,cACA,OAmDA,EAnDA,OAmDA,EAlDA,GAkDA,IACA,CAAK,EAEL,OADA,gBACA,CACA,EAsFA,YACA,OA5BA,cAEA,OADA,kBACA,4CACA,EA0BA,WAxBA,cAEA,OADA,kBACA,iBACA,EAsBA,WApBA,YACA,0BACA,EAmBA,YACA,aACA,CACA,CCjKA,MAAU,EAAG,KAEN,UACA,YACA,SACA,aACA,aACA,YAC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AmD,EAAc,6BAIjE,EAEA,KADA,gBACA,OACA,iCACA,uCACA,eACA,KACA,CACA,CAEA,CAGA,oBAGA,iCACA,8BAMA,OAHA,8CAGA,GACA,kBAAuE,KACvE,mBAAuE,KACvE,qDAAsI,KACtI,kBACA,CAEA,WAHsE,CAUtE,OAtEA,eACA,4CACA,2BAgEA,sBACA,WACA,EAEA,CACA,CAYA,OACA,SACA,aAZA,cACA,YAAmC,GAAe,iBAClD,sCAAgD,EAAQ,QACxD,kBACA,YACA,mBACA,eACA,CACA,CAKA,CACA,CCvIe,eAIf,OAFA,EAAW,CADT,EAAS,GAAY,IACN,OACjB,EAAiB,CADA,CACM,aACd,CACT,CCfe,GDaQ,MCbR,GAAS,GACxB,GDae,ICbf,YAAsB,EAAQ,aAC9B,CCFe,YAAS,KACxB,sDAAyD,EAAQ,QAAqB,EAAQ,aAC9F,CCFe,YAAS,KAExB,kBAAqB,EADrB,MAC6B,CAD7B,wBACqC,EAAQ,KAC7C,CHCA,IACA,cACA,aACA,iBACA,CAAC,iBMVD,IACA,MACA,mBACA,8BACA,YACA,2BACA,0BACA,0BACA,yBACA,CAAK,CACL,gBACA,mBACA,uBACA,yBACA,mBACA,mBACA,kBACA,kBACA,CAAG,CACH,OACA,mBACA,8BACA,YACA,2BACA,0BACA,0BACA,0BACA,CAAK,CACL,gBACA,mBACA,uBACA,yBACA,mBACA,kBACA,CAAG,CACH,MACA,wBACA,iCACA,YACA,0BACA,uDACA,+BACA,CAAK,CACL,gBACA,kBACA,CAAG,CACH,OACA,iBACA,mCACA,YACA,0BACA,4BACA,CAAK,CACL,gBACA,mBACA,kBACA,CAAG,CACH,MACA,yBACA,sCACA,YACA,0BACA,wBACA,CACA,CAAG,CACH,MACA,kBACA,8BACA,YACA,0BACA,6BACA,CACA,CAAG,CACH,MACA,mBACA,0BACA,YACA,0BACA,6BACA,CACA,CAAG,CACH,MACA,oBACA,gCACA,YACA,cACA,CACA,CAAG,CACH,MACA,iBACA,yCACA,YACA,0BACA,0CACA,CAAK,CACL,kBACA,CAAG,CACH,MACA,sBACA,mCACA,YACA,yBACA,CACA,CAAG,CACH,QACA,mCACA,uCACA,YACA,yBACA,CACA,CAAG,CACH,QACA,sCACA,YACA,yBACA,CACA,CAAG,CACH,MACA,wBACA,mCACA,YACA,yBACA,CACA,CAAG,CACH,MACA,kBACA,oCACA,YACA,yBACA,CACA,CAAG,CACH,OACA,yBACA,yCACA,YACA,yBACA,CACA,CAAG,CACH,OACA,0BACA,qCACA,YACA,yBACA,CACA,CAAG,CACH,MACA,2BACA,oCACA,YACA,yBACA,CACA,CAAG,CACH,MACA,iBACA,6BACA,YACA,yBACA,CAAK,CACL,eACA,CAAG,CACH,MACA,qBACA,+BACA,YACA,yBACA,CAAK,CACL,gBACA,kBACA,CAAG,CACH,MACA,qBACA,iCACA,YACA,yBACA,CACA,CAAG,CACH,MACA,oBACA,iCACA,YACA,yBACA,CACA,CAAG,CACH,MACA,iCACA,qCACA,YACA,yBACA,CAAK,CACL,gBACA,mBACA,kBACA,CAAG,CACH,MACA,4BACA,gCACA,YACA,yBACA,CAAK,CACL,gBACA,mBACA,kBACA,CAAG,CACH,MACA,oBACA,8BACA,YACA,yBACA,CACA,CAAG,CACH,MACA,iBACA,wCACA,YACA,yBACA,CAAK,CACL,gBACA,mBACA,kBACA,CAAG,CACH,MACA,iBACA,4BACA,YACA,yBACA,CAAK,CACL,gBACA,mBACA,kBACA,CAAG,CACH,MACA,mBACA,0CACA,YACA,0BACA,qBACA,CACA,CAAG,CACH,MACA,8BACA,uCACA,YACA,0BACA,+BACA,CACA,CAAG,CACH,MACA,kBACA,wCACA,YACA,yBACA,CAAK,CACL,gBACA,mBACA,kBACA,CAAG,CACH,MACA,oBACA,sCACA,YACA,yBACA,CACA,CAAG,CACH,MACA,oBACA,iCACA,YACA,yBACA,CACA,CAAG,CACH,MACA,8BACA,qCACA,YACA,yBACA,CACA,CACA,ECvQA,iBACA,EAAI,CAAE,EAAS,EAAS,CAAF,CAAc,GAapC,UAba,IAcb,MACA,MAf4C,OAe5C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EAEA,mBACA,YACA,+BACA,EAEA,iBACA,YACA,wCACA,EAEA,eAA0B,iBAG1B,mBACA,gBACA,MACA,uBACA,aAEA,uEAEA,OADA,uBACA,CACA,EAsBA,IACA,iBACA,qBACA,yBACA,mBACA,kBACA,qBAEA,cACA,qBACA,uBACA,8BACA,oBACA,mBACA,mBAEA,CAEA,mBACA,sBAIA,GAHA,SACA,yBACA,8BACA,GACA,QACA,QACA,EAEA,mBAEA,eACA,oBACA,oBAEA,YAEA,UACA,GACA,OAEA,GACA,gBAEA,kBACA,eAEA,QAEA,8BACA,SACA,GACA,CACA,EAEA,mDAEA,MACA,GACA,OAEA,YAEA,kBAEA,GADA,KACA,GAiBA,QACA,uBACA,SAEA,uCACA,mBACA,MAKA,QAHA,YAEA,aACA,IAAgC,IAAW,IAE3C,uBAEA,OAKA,QAHA,EAA0B,GAAG,cAE7B,YACA,IAAgC,KAAO,CACvC,mBAEA,QAEA,YAEA,QACA,aAEA,CAEA,YAOA,IANA,MACA,8BACA,MACA,qBACA,OACA,wBACA,KACA,QACA,CACA,CAzBA,IA2BA,kCAEA,EAAsB,GAAG,GAEzB,EAAsB,GAFG,GAGzB,KADyB,EACzB,KACA,WACA,MAEA,UAtEA,CAEA,uCACA,QACA,GACA,MACA,KACA,CAEA,GACA,OAEA,yBAEA,yBACA,QACA,CAuDA,QACA,GACA,MACA,KACA,CACA,CAGA,GACA,YAGA,IAFA,0BACA,KACgB,KAEhB,2BAEA,GADA,UACA,GACA,GACA,MACA,KACA,CAGA,GAFA,GACA,MACA,MACA,cACA,WACA,WACA,KACA,KACA,CACA,YAEA,UAEA,oBACA,yBACA,IACA,CAEA,2BACA,GACA,MACA,QACA,YACA,QACA,YACA,wBACA,CACA,QACA,GACA,MACA,KACA,CACA,GACA,YAEA,IADA,UACuB,IAAU,KACjC,YACA,gBACA,gBACA,gBAEA,GACA,CACA,CACA,wBACA,GACA,uBACA,EAAM,SACN,8BACA,EAEA,mBACA,QACA,WACA,SACA,aACA,EAEA,mBACA,QACA,WACA,SACA,cACA,cACA,EAEA,iBAGA,QADA,KACA,IAAoB,WAAc,IAClC,MACA,QAAqB,WAAe,EAHpC,IAKA,WACA,YACA,MACA,aACA,SACA,uBAEA,OADA,YACA,MAEA,qBAA6B,eAAmB,EAGhD,QAAa,aAAiB,EAC9B,8BAOA,IANA,MAAa,wBAMb,QACA,2BACA,iCACA,QAAoB,wBAGpB,QADA,SACA,IAAoB,IAAO,IAC3B,UACA,WAHA,IAMA,cAEA,iBACA,QAIA,YAEA,aAEA,IADA,qBAAkC,8BAAwC,EAC3D,IAAO,KACtB,aACA,UACA,iBACA,YAGA,KACA,CAEA,IADA,OACA,MACA,aACA,OACA,iBAEA,GACA,CACA,KAAe,QAAc,KAC7B,aACA,UACA,OACA,IAEA,CACA,GACA,CACA,qBAGA,mBACA,eACA,sCACA,QACA,EAEA,eAGA,IAFA,eAEA,aAMA,QAJA,cAEA,eACA,cAA2B,UAC3B,IAAoB,KAAQ,IAC5B,iBACA,QACA,CACA,YACA,KAAuB,MAAW,OAClC,SACA,MACA,mCACA,IAEA,MACA,QAEA,IADA,SACuB,IAAS,KAChC,QACA,KACA,oBACA,CACA,UACA,KACA,IACA,OAGA,2BAGA,iBAEA,QADA,IACA,IAAoB,WAAe,IACnC,aACA,QACA,EAGA,mBAEA,eACA,SACA,YACA,aACA,gBACA,kBACA,YAAoB,IAAO,IAC3B,cACA,eACA,EAEA,mCACA,YACA,SAMA,QAaA,QAlBA,yBACA,yBACA,sBACA,sBACA,aACA,IAAoB,WAAiB,IACrC,aACA,YAAoB,WAAiB,IACrC,aAGA,IAXA,IASA,wBACA,KACW,iBAAkC,KAE7C,aACA,sBACA,6DACA,cACA,iCAGA,GADA,qBACA,KACA,gCACA,gBACA,cACA,cACA,eACA,MACA,YAAwB,IAAU,IAClC,qBACA,OAEA,QADA,QACA,IAAyB,IAAQ,IAEjC,QADA,OACA,IAA4B,WAAiB,KAC7C,cACA,qBACA,MACA,mCACA,CAEA,MAEA,EAldwB,KAkdxB,OAhdwB,KAgdxB,KAEA,EApduC,EAodvC,QAAoB,IAAQ,IAC5B,aACA,mBACA,6BACA,KACA,gCACA,cACA,qBACA,KACA,gCACA,MAEA,2BAIA,OADA,eACA,UAGA,+EAEA,aAEA,yBACA,eACA,uCAEA,2BACA,IACA,WACA,YAAwB,KAAQ,UAEhC,cACA,MAEA,YAEA,2BACA,KAEA,CAeA,IAdA,cACA,kBACA,WAEA,8BACA,uBACA,cAAiC,oCAGjC,eAEA,2BAEA,wBACe,IAAO,KAGtB,WAEA,iBAKA,GAJA,OACA,OAGA,MAEA,UACA,4BACA,8BACA,YACA,YAAoC,MAAS,IAC7C,OACA,YAAoC,KAAQ,IAC5C,MACA,CAEA,4BACA,kBAMA,IALA,sBACA,oBAGA,kBACA,kBACA,qBAEA,IADA,QACmC,sBAA6C,KAEhF,QAGA,GAFA,QAEA,IACA,MAMA,QAFA,kBACA,IACA,IAAgD,IAAS,KACzD,wBACA,OACA,kBACA,KACA,SACA,CACA,CACA,CAEA,SACA,kBACA,CAGA,MAGA,kCACA,0BACA,eACA,WACA,OACA,MACA,GACA,MAEA,YACA,UAGA,CACA,8BAEA,SACA,gBACA,CACA,wBACA,EAsDA,iBACA,SACA,eACA,UACA,eACA,UACA,QACA,EAQA,mBAIA,QAHA,MACA,eACA,6EACA,IAAoB,WAAe,KACnC,kBACA,yBACA,KAAuB,QACvB,mBACA,gBAEA,mCACA,yBACA,8BACA,MAGA,aADA,KACA,YACA,KAAmC,uDAInC,IACA,MAEA,MACA,CACA,WACA,EAGA,eACA,SACA,eACA,aACA,iDAGA,QACA,EAEA,qBAEA,aAEA,EAhBW,EAgBX,IAHA,EAEA,SAAiC,cACjC,IAAwB,IAAO,IAC/B,iCACA,gBACA,CACA,WAAmB,aACnB,UArBS,IAqBT,SAA4B,sBAAsB,sCAAsC,2BAAkC,cAC1H,EAaA,eAA2B,kCAE3B,eAAyB,kCAsCzB,iBAA2B,uBAE3B,iBAA2B,kDAC3B,iBAA2B,sCAE3B,mBACA,KAAW,EAAG,IACd,aACA,EAeA,eACA,gCACA,0BACA,WACA,IACA,MACA,wBACA,4BAAmD,IAAQ,YAE3D,cACA,EAEA,eACA,eACA,kDACA,EASA,eACA,+CACA,0BACA,SACA,4DACA,EAoJO,iBACP,cAC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yBAGA,OAFA,WACA,sBAEA,CAwEA,iBACA,+BACA,CAuEA,uBACA,SAEA,wBACA,wBAKA,GAFA,oDAA4D,GAAe,CAE3E,YAEA,eACA,MACA,4BAKA,MAAmB,GADnB,QAC8B,SAJ9B,WACA,OAKA,mCAIA,EADA,OAAqB,GAAe,MACpC,MADoC,MAGpC,YAAkB,WAAkB,KAEpC,MA3FA,cAEA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,cAEA,cACA,4BAEA,SAKA,EA1EA,cACA,SAEA,UACA,QAAa,6BAAgC,EAM7C,mBAEA,YAAkB,WAA+B,KAEjD,cADA,gBAEA,MAAqB,UACrB,SACA,CAEA,QACA,EAsDA,kBACA,yBACA,KACA,2BAEA,uBACA,MACA,SACA,YA3DA,KACA,SAEA,eAEA,YAAkB,WAA0B,KAE5C,WADA,eACA,YACA,MAAgB,UAChB,SACA,CAEA,QACA,EA+CA,8BACA,EAIA,YAoBA,MAlBA,CACA,wBACA,SACA,iBApBA,EAqBA,YACA,YACA,WACA,eACA,4BACA,uBACA,oCACA,cACA,wBACA,QAjBA,cAkBA,SACA,qBACA,CAGA,EA6BA,KACA,EACA,oCACA,SACA,CAEA,QACA,CAEA,eAGA,kBADA,iBAEA,CCnKO,qBAEP,sBAEA,iBAEA,OAGA,GAFA,2BAEA,cAIA,mBACA,iBACA,oBACA,wBACA,oBACA,EAWA,OATA,+BACA,0BACA,oBACA,mBACA,wBACA,qBAIA,CAEA,CACA,CADI,EACJ,cACA,oBACA,wBACA,+BACA,0BACA,oBACA,oBACA,mBACA,wBACA,oBAIA,CAEA,QACA,MACA,4BACA,GAgDA,YACA,IACA,QACA,MAEA,EAEA,qBACA,mBACA,cACA,YACA,gBACA,YACA,aACA,UAEA,CACA,EA/DA,QRlEO,CQkEM,QRlEN,MQkEoB,GRpD3B,EAbA,SACA,KACA,KACA,KACA,KACA,KACA,KACA,KAIA,KAIA,oBACA,oBACA,+CAEA,oBACA,YAAkB,WAAkB,KACpC,WACA,mBACA,CAD+B,EAC/B,YACA,4BACA,2BAEA,QA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MAHA,mCAGA,GAEA,CAEA,8BAEA,IAIA,EAJA,8BACA,eACA,cACA,aAIA,uBAUA,kCAEA,cADA,WAMA,CADA,gBADA,gCAEA,KACA,EAEA,QAOA,qBAEA,iDAGA,QAFA,EAEA,IAAsB,iCAAoC,IAC1D,uBACA,oDAEA,CAEA,0BAGA,iCACA,oDACA,CAEA,8BACA,gCACA,CACA,CCzLA,iBAA+B,GAE/B,GAFqC,SAErC,KACA,WACA,+BACA,aACA,QACA,MACA,CACA,CAEA,iBACA,MAAiB,GAAM,oCAKvB,OAJA,uBACA,SAGA,CACA,CAEA,uBAEA,QAMA,EACA,mCAII,EAAE,sBACN,aACA,oBACA,YAGA,8BACI,EAAE,6BACN,YACA,oBACA,kBACA,QACA,QACA,eACA,2BACA,6CACA,CAAO,EACP,aACA,uBACA,yBACA,CAAO,EACP,8BACA,mBACA,aACA,aACA,mBAEA,wCACA,CAEA,oBACA,wCAEI,EAAE,sBACN,aACA,oBACA,YAEI,EAAE,yCACN,mBACA,SAEA,0CACA,CAEA,aACA,uCAEA,yCACA,uCAQA,MAFA,IAHA,+BAGA,EAEA,6BACA,CAEA,WACA,kDAGA,8BACA,WACA,CAEA,+BACA,WACA,CAEA,0BACA,QACA,CAEA,0BACA,SACA,CAEA,iCACA,WACA,CAEA,6BAGA,mBAFA,sBAEA,KADA,mCACA,GACA,CAEA,8BAEA,4BACA,oCAKA,qBAEA,oBAGA,YAAsB,iCAAoC,IAC1D,mBACA,oDAEA,CAEA,0BAGA,yCACA,wBACA,oCAEA,GAEA,CAEA,kCACA,iCACA,eACA,cACA,aASA,OANA,aACA,MAEA,KAIA,CAEA,8BACA,SACA,CAEA,8BACA,6BAGA,CClLA,iBAA2B,GAE3B,GAFiC,SAEjC,KACA,WAEA,2BAEA,aACA,OACA,CACA,CAEA,YACA,mDAGA,WACA,WACA,CAEA,2BACA,yDAGA,2BACA,4BACA,+CAGA,gCACA,qBACA,CAEA,qCACA,uCACA,8CAEA,OACA,IACA,IACA,+CACA,CACA,CAEA,8BACA,sBAGA,iCACA,gCACA,CAEA,iCACA,mBACA,CAEA,6BACA,yCAC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ACA,MACA,MAEA,qCACA,oCAGA,SA/DA,OACA,YACA,4BACA,4BACA,yCAEA,QAGA,QAAc,WAAmB,IAKjC,GAHA,KADA,QACA,eACA,qBACA,oBACA,GACA,6CACA,4BACA,EAAM,IACN,+BAIA,KACA,QAAgB,WAAyB,IACzC,UACA,UACA,mBACA,oCACA,8BACA,4BACA,yCAGA,EA8BA,EADA,SA/FA,OACA,YACA,UACA,KACA,4BACA,0BAGA,QAAc,IAAoB,IAClC,gCACA,oBACA,CADkC,CAClC,EACA,cACA,qCAWA,QATa,EAAE,mDACf,iBACA,aACA,kBACA,iBACA,6BACA,qBACA,wBACA,4BACA,IAGA,QACA,EAmEA,OACA,IDpGA,cACA,YACA,4BAYA,IARA,IAHA,qCAGA,IAIA,CAFA,CAFsC,CAGlC,EAAE,8DACN,SAEA,gCAEA,IAAc,WAAmB,IACjC,EACA,6BACA,cACA,oCACA,mBACA,6BACA,6BACA,uBACA,gCACA,4BACA,4BACA,qBACA,aAtBA,GAsBA,CAtBU,CAsBV,MACA,wBACA,6BACA,wCACA,2BACA,UAGA,EAMe,GC8DG,MD9DM,ECgExB,8CACA,EGpCgC,KAC5B,sCACJ,OAAW,SFjBX,KEiByB,IF7DzB,IA6CA,IACA,qBACA,uBACA,uBACA,+CAaA,IAXE,EAAE,iCAEF,EAAE,kCACJ,0BACE,EAAE,yCArDJ,EAuDA,sBAvDA,aACA,CAD2B,CAC3B,EAwDA,EAxDA,6CAwDA,EA/CA,EARa,mDACb,iBACA,aACA,aAoDA,GAnDA,cAmDA,GAlDA,6BACA,qBACA,mBACA,4BAkDA,IAAc,WAA4B,KAxC1C,gBACA,UACA,4BACA,uBAKA,QAHA,WAGc,WAAmB,IACjC,iBACA,UACA,6BAEA,EA4BA,KACA,IAGA,yBACA,wBAEA,EETyB,KAQzB,IALE,EAAE,kDDpDJ,YACE,EAAE,UCqDsB,MDrDtB,6CACJ,cACA,iCACA,mBACA,6BACA,6BACA,uBACA,gCACA,4BACA,4BACA,uBACA,EC0C0B,GAG1B,IAAc,WAA4B,IAE1C,cACA,wBACA,oBAII,SAhDK,CAAgB,QACzB,MA+CoB,EA/CpB,IAGA,GAJyB,CAIzB,IAAc,WAAmB,IAGjC,CADA,KADA,QACA,aACA,kBACA,iBACA,8BAEA,EAqCoB,EA7EpB,SAAS,CAAa,QACtB,GA2EgC,CA3EhC,QACA,KACA,0BAKA,QAAc,IAAoB,IAClC,4BACA,oBACA,CADkC,CAClC,UANA,EAeA,CAfsB,CAetB,KARa,EAAE,mDACf,iBACA,aACA,gBACA,iBACA,6BACA,qBACA,6BAIA,QACA,EAoDgC,EAFhC,wCAEgC,KACZ,KAGlB,EAAE,yCACJ,2BAAiC,GDRjC,MAzBA,EACA,GCgC+C,CDhC/C,IA0BA,sCAGA,EADA,GAAW,GCIoC,EDJ3B,EACpB,EADoB,EACpB,SAGE,EAAE,oDACJ,YACA,gBACA,iBACA,wBACA,oCACA,QAEA,OAzCA,EAyCA,EArCA,MC6B+C,CD7B/C,yCAGA,IAFiB,mCACjB,WACA,wBAEA,EAAa,EAAE,oDACf,mCACA,EAAY,EAAE,QCsBiC,EDtBjC,6BACd,wBAMA,CAJA,qCACA,QAbA,CAaA,EAboB,CAcpB,qCAEA,EAyBE,SA9DO,CAAiB,MACxB,EAAE,YA6De,IA7Df,KADsB,KACtB,0BACJ,mBACA,qBACA,oBACA,6BACA,wCACA,2BACA,0BACA,qCACA,CAAK,EACL,yBACA,KACA,CAAK,CACL,EAgDmB,ICV4B,GAAc,EAC7D,yBAAgC,GAA0B,GAAQ,EAElE,kBAF0D,IAE1D,EACA,wBAEA,CA8DA,eACA,IAnBA,EAmBA,QACA,uBACA,SACA,WAIA,QADA,KACc,EAHd,KAGc,uBAAiC,IAC/C,EAJA,KAIA,uBACA,qBAGA,EAhDA,gBACA,QACA,KAEA,QAAc,WAA0B,IAOxC,QAA0B,IAL1B,CADA,QACA,IAK0B,OAF1B,SA/BA,OACA,kBACA,KAEA,QAAc,WAAsB,IAEpC,QADA,OACgB,WAA8B,IAC9C,eAEA,CAF8B,CAE9B,QAEA,EAAc,GADd,gCACkC,GAElC,IACA,cACA,UAIA,QACA,EAWA,EADA,SACA,EAE0B,CAAyB,EAEnD,QACA,EAmCA,IATA,MAWA,2BACA,sBAZA,KAcA,iBAdA,KAeA,mBAtCA,uBACA,IAsBA,CAtBA,cACA,uDAsCA,CAtCA,QAuCA,CCzLA,cACA,+BACA,CASA,cACA,+BACA,CAEA,cACE,EAAE,6CACJ,cACA,mBACA,8BACA,CAWA,cACA,WAEA,kCACA,OAIA,sCACA,oCAGA,uDACA,IACA,CAAG,IAIH,sBACA,uDACA,qBACA,CAAG,KACH,CAoDA,uBACA,mDACA,CAEA,cACA,wCACA,CAKA,eACA,wBACA,gCACA,4BACA,CAeA,uBACA,UAGA,QAFA,KAEA,yBASA,GAPA,iBAJA,CAIA,yBAJA,KAMA,gCACA,SAPA,KAOA,qCAIA,UACA,KACA,MACA,CAdA,KAgBA,4BAGA,CAFA,EAAY,EAAE,CACd,WAlBA,KAkBgB,iCAAuC,oBACvD,YAGA,CAHuB,EAGvB,YAhFA,YACA,M/C8CA,EAWA,E+CtCA,OAjBA,2CACA,sBACA,uBACI,aAEJ,+BACA,c/CsCA,E+CnDA,SAaA,EAbA,KAaA,EAbA,O/CkEA,CAJA,GATA,CAAK,kBAAqB,CAC1B,CAAK,qBAAwB,CAC7B,CAAK,qBAAwB,CAC7B,CAAK,qBAAwB,CAC7B,CAAK,sBAAyB,CAC9B,CAAK,sBAAyB,CAC9B,CAAK,uBACL,CAEA,2BACA,iBACA,CAAG,GAEH,oBAfA,QAeA,QALA,2BAKA,wB+CrDA,OAEA,4CAAsD,EAAM,SAC5D,KAEA,SAEA,EADA,qCACA,EACA,MAGA,OA4DA,EADA,IAvGA,oBACA,0CACA,iBACA,eAEA,UACA,mBACA,qBACA,0BACA,yCACA,6BACA,0BACA,uCACA,CAAK,EACL,yBACA,gCACA,CAAK,CACL,EA0FA,IADA,0BACA,EAzBA,MA2BA,IA3BA,CA2BA,+BACA,IA5BA,CA4BA,gCAEA,CCzKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAGA,eACA,+BAGA,mBACE,EAAE,qDACF,EAAE,iDACF,EAAE,wCACJ,CAEA,qBACA,IACA,eACA,SAEA,0BACA,gCACA,OACA,kCACI,EAAE,uCACF,CACJ,sBACA,wBACA,OAEA,kCACM,EAAE,kCAER,CAEA,iBACA,wCACA,gCAOA,iBACA,wCACA,uBAEA,uDACA,UACA,CAAK,KAEL,CAyCA,iBAEA,IADA,EACA,KAYA,OAXA,qBACA,GACA,qBACA,GACA,aACA,IACA,KAEA,CAAK,CACL,CAAG,EAEH,CACA,CAGA,iBACA,kBACA,WAKA,UAHA,wCAGA,YAEA,4BAEA,EACA,6DASA,EAPmB,GAAW,UAC9B,MAKA,mBAGA,2CAWA,OALA,EADA,eAFA,EAEA,GAFA,EAQA,KAAU,iBAJV,oBACA,EAGU,sBARV,EAQU,KAFV,YAGA,CASA,mBACA,MAKA,SAFA,OAFA,WAKA,WAIA,SAhHA,OAEA,qBACA,8CACA,oCACA,uBAGA,YAEA,EAAe,GAAO,GAEtB,CAFsB,CAEtB,mCAEA,EAAS,GAAc,GAEvB,QAFuB,UAEvB,EAAkC,UAAgB,GAAG,eAAqB,GACxE,EAAE,oCACJ,aACA,+BACA,gCAAsC,EAAU,GAChD,gBACA,gBACA,6BACA,aAGA,cADA,GAEA,gBAAsC,EAAU,KAAK,WAAe,GAElE,EAAE,oCACJ,mCACA,gCAAsC,EAAc,GACpD,yBACA,wBACA,0BACA,EA4EA,EAFA,iCAAuC,gBAA6B,EAPpE,KAUA,CA8KA,uBACA,WAEA,EhDsBA,agDtBiB,GhDsBjB,KgDtByB,IhDsBzB,CgDtByB,IAGzB,WAHyC,OAGzC,GAEA,SACA,KAMA,cACA,sBAKA,kBACA,cAEA,aACA,yCACA,MACA,CAGA,2BACA,MA3MA,gBACA,aA8LA,EA7LA,SA6LA,EA5LA,UA4LA,EA3LA,YAmCA,OACA,wBACA,wBACA,wBACA,sBAEA,EA8JA,IAZA,GAaA,EA7JA,gBACA,YA+IA,EA9IA,QA8IA,EA7IA,WA6IA,EA5IA,aA8GA,OAEA,wBACA,sBAKA,EAmCA,IAbA,GAyCA,WACA,CAAO,IAIP,UACA,UACA,CAAG,EAEH,eAEA,wBACA,wCAEA,OAGA,2CAMA,UAEA,cACA,uBACA,CAAG,EAED,EAAE,qBACJ,yBACA,0BACA,oBACA,CAEA,eAGA,SADA,KADA,OAGA,sCACA,CAEA,cAEA,SADA,oCACA,YAA6B,WAAgB,CAC7C,CChTA,eACA,IAhBA,EAgBA,IACA,KACA,uBAoBA,OAjBA,EAFA,KAEA,YAFA,KAEA,cAdA,qBAYA,KAZA,YACA,KAWA,CAXA,oCAiBA,SANA,KAMA,kBANA,KAOA,mBACA,OAlFA,gBACA,kBAEA,8CAEA,QADA,IACgB,WAAiB,KAIjC,QAHA,IACA,cACA,WACkB,WAAmB,IACrC,eACA,SACA,KACA,KAGA,uBACA,CACA,0BACA,CACA,EAkEA,EAhHA,kBACA,wBACA,oBAEA,QAAc,WAAmB,IAIjC,QAHA,cAEA,KADA,eAAyC,QACzC,SACgB,WAAsB,IAGtC,QADA,GADA,QACA,UACkB,WAAsB,IAIxC,GAFA,EADA,YACA,EACA,uBACA,WACA,iCACA,uCACA,KACA,CAIA,QACA,EAwFA,EADA,WA/IA,KACA,kBACA,oBACA,KAEA,QAAc,4BAAkC,KAOhD,QAHA,cAFA,IADA,6BACA,EACA,wBACA,WACA,GAAW,KAD4C,CAC5C,WAEK,IAAa,IAC7B,aACA,eACA,+BACA,KACA,QACA,oBACA,UACA,gCACA,UACO,EAEP,SACA,CACA,QACA,EAoHA,EAXA,MAYA,EAZA,MAcA,EAdA,MAeA,WA/DA,KACA,kBACA,uBAEA,QAAc,WAAiB,IAG/B,QAFA,cACA,WACgB,WAAmB,IACnC,aAEA,EADA,uCACA,uBAEA,2BAOA,MAJA,EADA,OACA,qBAEA,iCAGA,MAEA,wBAGA,QACA,EAqCA,EAfA,MAnBA,uBAmBA,KAlBA,cACA,kDAkCA,CAlCA,SAiBA,KAkBA,OACA,CACA,CC9LA,OACA,mBAAqB,kBAAkB,gBAAgB,kBAAkB,uSASlE,iBACP,YACA,0CAAyD,GACzD,UAMA,GAJA,4BACA,oDACA,iCAEA,gDACA,gBACA,mCACM,mBACN,QACA,oCAEA,oCAEA,+BACA,qCAEA,+BACA,OAEA,wBAGA,QACA,CAmBA,eACA,OAA0B,EAAjB,GAAM,EAAD,CAAY,iBAC1B,CAKA,eACA,gBACA,WACA,QAOA,IALE,EAAE,kDAEJ,WACA,KAEA,IAAc,WAAmB,KACjC,OACA,OACA,eACA,iBAEA,SACA,GACA,GACA,kBAA0B,EAE1B,SAFqC,IAAI,kBAEzC,EAAkB,IAAe,GAAG,EAFK,EAIzC,YACA,GACA,+BAAuC,EAAU,mBAEjD,gDACA,eApDA,WACA,UACA,QAEA,QAAc,gBAAsB,IAEpC,oCADA,aACA,aACA,cACA,mBAGA,iCADA,EACA,MAFA,QAEA,OAGA,aAsCA,WACA,YACA,qBACA,CAEA,sBAAmC,cAAmB,EACtD,kBAAsC,MAAoB,GAAG,EAC7D,IACA,mBAAuB,EAAE,GAAY,EAAE,GAAe,EAEtD,MAAe,EAAE,4CACjB,2BACA,oDACA,CCnEA,2BACA,IAjBA,EAiBA,EACA,KAEA,EADA,KACA,gBADA,CACA,cAEA,CAFgD,EAEhD,cACA,IAJA,CAIA,UACA,MACA,CAEA,GACA,iBACA,gBAEA,WAZA,CAYA,yBAGA,WACA,QAAoB,gBAAqB,EAEzC,WA9DA,KACA,YAEA,QAAc,WAA2B,IAGzC,QAFA,OAEgB,WAAsB,IACtC,qBACA,GACA,OACA,QACA,eACA,CACA,6BACA,6BACA,qCACA,oBACA,KACA,CAGA,QACA,EAwCA,KArCA,4BACA,gBACA,gBAEA,gBACA,gBAEA,oBACA,oBAWA,KAqBA,WAAoB,KA9BpB,EA8BoB,UAEpB,UAvBA,CAuBA,qBAvBA,CAuBA,WACA,EAGA,IA3BA,CA2BA,cA3BA,KAyBA,SAzBA,KA8BA,0BACA,CA2PA,0BA5BA,MACA,EA5LA,EAiCA,EACA,EApEA,EAuEA,EAmMA,GAfA,KAEA,4BAFA,KAGA,6BAGA,GACI,EAAE,WAPN,KAOM,6BAGN,yBACA,IAXA,CAWA,6BAXA,KAWA,0BAEA,WAbA,KAaA,QAA+B,GAb/B,MAeA,EAF0C,QAE1C,SAfA,KAgBA,gBACA,MACA,CAhDA,EAkDA,EAlDA,EAkDA,EAlDA,EA8BA,MA3BA,SArBA,KACA,QAEA,wCAEA,QADA,IACgB,WAAmB,IACnC,sBAEA,OACA,aACA,0LAKA,CACA,EAKA,KAEA,2CAhMA,EAkMA,gBAEA,EAnMS,EAAE,WAmMX,EAnMW,yBACX,QACA,wBACA,iBACA,gBACK,EACL,QA+LA,eAnKA,EAvCA,CAAU,gBA1BV,YAJA,EAoEA,6BAhEA,SACA,iBAyBU,SAtBV,qBACA,iBAqBU,OAbV,MAFA,EAEA,KAFA,EAGA,KAHA,EAGA,IAHA,EAGA,YAHA,EAEA,OAFA,EAIA,IAJA,EAIA,aAJA,EAIA,KAYA,UATA,gBACA,OADA,UAEA,QAOA,KALA,IAKA,MAHA,GAGA,EAsDA,CAdA,gBACA,sBAA6B,eAAgB,EAC7C,sBACA,6BACA,wCACA,wCACA,iBACA,0BAEA,iCACA,CACA,CAAK,EACL,wBAA+B,eAAgB,GAG/C,mBACA,yCACK,EACL,6BAAyC,2BAAgC,EACzE,yBAAgC,iCAAqC,EACrE,yBAAqC,kBAAsB,EAC3D,kBACA,0BACA,gBACA,WACA,8BACA,kCACA,qBACA,iBACA,0BAGA,OACA,GAAa,EAAG,GAAG,IAAgB,EACnC,GAAa,EAAG,GAAG,IAAgB,EACnC,GAAa,EAAG,GAAG,EAAE,EACrB,GAAa,EAAG,GAAG,EAAE,EACrB,CAEA,OADA,WAEA,CACA,sBACA,kBACA,OACA,GAAe,EAAG,GAAG,EAAE,EACvB,GAAe,EAAG,GAAG,EAAE,EACvB,GAAe,EAAG,GAAG,WAAa,EAClC,GAAe,EAAG,GAAG,WAAa,EAClC,MACU,iBACV,wBACA,GACA,GAAe,EAAG,GAAG,WAAa,EAClC,GAAe,EAAG,GAAG,WAAa,EAClC,GAAe,EAAG,GAAG,EAAE,EACvB,GAAe,EAAG,GAAG,EAAE,EACvB,CAGA,OADA,WAEA,CACA,CAAK,EAEL,EACA,mBACA,0CACK,EACL,eACA,qBAA4B,gBA/F5B,KACA,kCAKI,sBACJ,gBACI,yBACJ,mBACI,oBACJ,mBACI,qBACJ,oBAEA,sBAbA,cACA,kBAEA,YA0F4B,KAAkC,EAC9D,6BA6FA,EA7FyC,yBAAgC,EACzE,yBA4FA,EA5FgC,+BAAqC,EACrE,yBAAqC,kBAAsB,GA4FvD,cACJ,SAvFA,KACA,oBACA,sBAA6B,YAAa,EAC1C,sBACA,0BACA,QACA,oBAUA,OARA,sBACA,YACA,aAEA,UACA,WAIA,wBACA,cAEA,CAAK,EACL,wBAA+B,eAAgB,EAC/C,6BAAyC,2BAAgC,EACzE,yBAAgC,iCAAqC,CACrE,EA+DA,KACI,gBACA,SFjGJ,KACA,MEgGwB,EF/FxB,IAAkB,CAClB,oBAGA,SADA,gCAEA,UAGA,oBAEA,sBACA,8BAlCA,MAOA,EA4BA,OAjCA,EAiCA,EAjCA,GAiCA,EAjCA,KACA,EAgCA,EAhCA,qBAgCA,EAhCA,KAEA,EA8BA,IA9BA,OAIA,GAFA,aAGA,MAIA,MAqBA,EArBA,IACA,MAoBA,EApBA,IACA,YACA,OAmBA,CAAK,EACL,wBAA+B,eAAgB,CAC/C,EEgFwB,KACpB,YA7DJ,cACA,cACA,sBAA6B,eAAgB,EAC7C,sBACA,kBACA,0BACA,kCACA,YACA,WACA,kCASA,MAPA,GACW,GAAG,EAAG,OACN,GAAG,EAAG,EADgB,KAEtB,GAAG,EAAG,EADgB,GAEtB,GAAG,EAAG,EAAE,CACnB,CAGK,EACL,wBAA+B,eAAgB,EAC/C,6BAAyC,2BAAgC,EACzE,yBAAgC,iCAAqC,EACrE,yBAAqC,kBAAsB,CAC3D,EAsCA,KAYA,KAqBA,0BArBA,CAqBA,sBACA,CCjWO,mBACP,qBACA,+BACA,aACA,sBACA,WACA,EAAmB,EAAE,0CACrB,kBAA4B,gBAAgC,EAE5D,wCACA,CAAK,EACL,0BACA,WACM,EAAE,0CACR,kBAA4B,gBAAgC,EAC5D,mBACA,CAAK,EACL,yBACM,EAAE,0CACR,mBACA,CAAK,CACL,CAEO,YACP,aAEA,QAEA,6BACA,4BAEA,oBACA,cACA,qBACA,oBACA,oBACA,kBAEA,gBACA,uBACA,CAqBO,wBAOP,GAHA,OACA,OAEA,wBACA,sBACA,wBACA,iCACA,mCAEA,iCACA,iCAEA,CAEA,IAjBA,IACA,IAgBA,yDACA,eACA,eACA,yDAEA,eACA,eAyBA,OAvBA,SACA,mCAGA,OACA,SAIA,IACA,MAIA,IACA,KAGA,2CACA,yCACA,2CACA,yCAEA,MGbA,eACA,IFxCA,EAbA,ECeA,EAbA,ECuCA,EAaA,uBAEA,EADA,KACA,OAKA,GANA,KAIA,kBAGA,iBACA,+BAEA,4BFpDA,4BAvCA,oBACA,gBAEA,QAAc,WAA4B,IAC1C,OAEA,MAAe,GAAiB,KAc5B,GANJ,EAAqB,GAAmB,CARR,CAGhC,cAKwC,CALxC,EAW+B,GAX/B,kBAEA,gCAGwC,GAGxC,GADA,qBACA,GACA,QAE+B,CAFN,CAEM,KAC/B,EApCA,eACA,8BACA,UAkCA,GAjCA,UAiCA,GAhCA,UAgCA,EAhCA,SACA,UA+BA,EA/BA,SA+BA,EA7BA,eACA,8BACA,UA2BA,GA1BA,UA0BA,GAzBA,oBACA,mBA0BA,EEqEiC,EFnDnB,EAAE,QEwChB,KFxCgB,UAChB,2BACA,wBEsCA,MFvDA,uBEuDA,KFtDA,cACA,+CAmBmB,CAnBnB,YCaA,4BAME,SA/C2B,WAC7B,gBAEA,QAAc,KA4CQ,KA5CR,CAA4B,GAHb,CAI7B,OAEA,MAAe,GAAiB,KFiBzB,SACP,aAEA,QAEA,OERyC,KFQzC,iBACA,4BAEA,oBACA,cACA,wBACA,yBACA,yBACA,uBAEA,gBACA,uBACA,EE1BA,EAAqB,GAAmB,EALxC,cAKwC,CALxC,uBAEA,gCAGwC,GAGxC,EADA,sBACA,GACA,QAGA,CAHyB,CAGzB,KAE4B,EAtC5B,eACA,8BACA,UAoC4B,EApC5B,YACA,UAmC4B,EAnC5B,YACA,UAkC4B,GAjC5B,UAiC4B,KA/B5B,eACA,8BACA,uBACA,uBACA,UA2B4B,GA1B5B,UA0B4B,EAE5B,ECqE2C,EDnD7B,EAAE,YCsChB,CDtCgB,UAChB,2BACA,wBCoCA,MDrDA,uBACA,ICoDA,CDpDA,cACA,+CAmBmB,CAnBnB,YCUA,SAAS,CAAoB,QAC7B,UA+DsB,EA/DtB,OAD6B,CAC7B,EAEA,QAAc,WAA4B,IAC1C,OAEA,MAAe,GAAiB,OAQhC,EAAqB,GAAmB,EARR,EAGhC,YAKwC,CALxC,yBAEA,gCAGwC,GAExC,oBAII,GAA2B,EAH/B,sBAG+B,gBAH/B,IACA,4CAE+B,OAC3B,SA3EK,CAAwB,YAEjC,OAEA,GAuE4B,KAvE5B,0BACA,+BAEA,UACA,YAEA,KACA,MAGA,iBACA,8BACA,aACA,aACA,qBACA,qBACA,kBACA,wBAEA,iBACA,8BACA,aACA,aACA,oBACA,oBACA,kBACA,uBACA,EA4C4B,aAC5B,SA3CA,aACA,uCACA,eACA,iBACA,gBACA,sBACA,aACA,MACA,+DACI,EAAE,kCACN,CACA,YACA,iBACA,gBACA,aACA,eACA,sBACA,YAEA,EAwBA,YAEA,EAwCsB,EANR,EAAE,YAjBhB,CAiBgB,UAChB,2BACA,wBAnBA,KAqBA,oBArBA,MAdA,uBACA,IAaA,CAbA,cACA,+CAqCmB,CArCnB,QAsCA,CC1HA,cACA,KACA,0BADA,CACA,4BACE,EAAE,WAFJ,KAEI,6BACJ,IAHA,CAGA,eAHA,CAGA,qBAHA,CAGA,WACA,CAgCA,eACA,UAEA,EADA,KACA,iBAkBA,OAnBA,KAGA,+BAEA,EArCA,cACA,gBACA,EAKA,QAHA,KAGc,WAAwB,KAGtC,QAFA,OACA,KACgB,kBAA0B,IAE1C,GADA,sBACA,EADwC,CACxC,GACA,gBACA,kBACA,WAGA,QAAkC,mBAAyC,CAC3E,CAEA,QACA,EAgBA,KACA,GAAe,SAPf,CAOe,yBAEf,kBATA,CASA,iBACI,GAVJ,MAaA,MAbA,CAaA,oBAEE,EAAE,eAfJ,CAeI,6BACJ,IAhBA,CAgBA,wBACA,IAjBA,CAiBA,cAEA,CACA,CA4BA,eACA,cAOA,CAJA,UAIA,UACA,qBACA,8BAMA,EA1CA,cACA,kBACA,KAIA,QAFA,IAEc,WAAwB,KAGtC,QAFA,OACA,KACgB,kBAA0B,IAE1C,IADA,sBACA,KACA,KACA,QAEA,gBACA,UAEA,QAAyB,mBAAmC,CAC5D,CAIA,OAFA,mBAEA,CACA,EAiBA,SAbA,MAgBA,mCACA,GAAe,iBACf,IAlBA,CAkBA,oCAlBA,CAkBA,qBARA,CAWA,CC9GA,QACA,QACA,cACA,oBACA,0BACA,gCACA,sCACA,4CACA,kDACA,wDACA,8DACA,CAmHA,iBACA,mBACA,CAmIA,mBACA,MA9BA,EACA,EACA,EAuCA,OARA,SACA,WAEA,eApEA,OACA,YACA,KACA,KAGA,QADA,KACc,WAAsB,KAIpC,GAHA,OAGA,SAFA,yCAEA,CAhBA,aACA,+CAAiE,EACjE,0CAgBA,QACA,CAEA,IACA,QAAiB,oBAAiC,EAElD,0CACA,MAvFA,iBACA,OACA,YAGA,MACA,6BACA,sCAEA,QAAc,kBAA+B,KAI7C,QAHA,cACA,KAEgB,WAAiB,IACjC,aAEA,sBAEA,0BACA,iCAEA,EADA,yBACA,eAGA,wBAEA,YACA,aACA,oBACA,UAAqB,SRnKrB,KAEA,CQiKoC,GRlKpC,MACA,mBACA,KACA,YAAkB,4BAAkC,KACpD,gCACA,oBACA,CAOA,OALA,UACA,oBAEA,GAKA,gBACA,IACA,UACA,IAFA,mCAIA,QAAc,WAAuB,IACrC,aAKA,WADA,aAFA,EADA,QACA,OAGA,MACA,iCAEyB,GAAkB,MAC3C,MAEA,GAH2C,WAG3C,OAGA,QACA,EA3BA,8BACA,MAEA,CACA,EQoJoC,MAGpC,qCACA,mCACA,wCACA,qBAEA,MA7DA,4BApEA,IACA,EAwBA,IACA,EAwBA,EAmCA,OAfA,2BAtEA,EAuEA,EAvEA,EAuEA,4BApEA,WAoEA,CApEA,IACA,KAmEA,EAnEA,aACA,OACA,CAiEA,EAjEA,eAEA,SACA,kBAEA,YACA,wBAEA,yBAGA,EAsDA,EAtDA,aAsDA,KApDA,GAqDI,0CACJ,OAhDA,EAiDA,EAjDA,EAiDA,EAhDA,0BAgDA,EA9CA,gBACA,0BA6CA,EA5CA,YA4CA,EA5CA,oBA4CA,EAzCA,WAyCA,EAzCA,oBAyCA,EAxCA,gBACA,qBAuCA,GArCA,iBAqCA,EArCA,CAIA,EAiCA,EAjCA,aAiCA,GA/BA,QAOA,EAgCA,IA/BA,YACA,CA8BA,EA9BA,cAEA,SACA,CA2BA,EA3BA,MA2BA,EA3BA,yBA2BA,EAzBA,OACA,qBAwBA,EAtBA,WACA,2BAEA,EAmBA,EAnBA,aAmBA,KAjBA,GAoBA,OA6CA,cACA,CAEA,KAYA,IAXA,qBACA,YAAyB,GAAa,eACtC,wBAEA,4BAIA,mCAGA,IAAgB,qBAA6B,IAC7C,6BAIA,aA8BA,UACA,KAEA,MbxIA,iBACA,OACA,kBACA,6BAEA,QAAc,kBAA+B,KAM7C,QALA,cAGA,CAFA,MAEA,UAEgB,CAFO,CAEP,EAAO,IACvB,aAGA,QAAgB,WAAiB,IACjC,EAAc,GAAoB,QAClC,iBAGA,mBAEA,YACA,aACA,qCACA,uBACA,iCAEA,SACA,CAIA,OAFA,UAEA,OawGyB,UACzB,IAEA,CACA,WACA,EAuCA,IALA,MAMA,EA3PA,cACA,gBAKA,QAHA,IACA,KACA,qBACc,WAAiB,IAE/B,QADA,YACgB,WAA4B,IAC5C,SACA,SACA,UAKA,QACA,EA0OA,EANA,MA9BA,EA8BA,KA9BA,yBACA,MA6BA,CA7BA,sBAEA,0BACA,cACA,oEACA,EADA,sEAMA,eA2BA,GA3BA,SAEA,aACA,iFACA,EADA,kBA0BA,CACA,CChRO,SAOP,iBACA,cACA,WACA,CAMA,eACA,UAKA,OAJA,OACA,YACA,cAEA,wBACA,kCACA,iBACA,gBACA,+BACA,CAAS,CACT,CAAK,CACL,CAOA,oBACA,SAEA,gCACA,MACA,iBACA,iDAEA,+BACA,mCAEA,kBAGA,QADA,8BACsB,WAAqB,IAC3C,6BACA,cAEA,GADA,eACA,EACA,aAEA,IACA,CAAS,CACT,CAAO,CACP,CACA,CADM,KACN,8DAEA,CAKA,2BACA,cACA,uBAEA,WACA,kCAEA,mCACA,iCAGA,KADA,kBACA,YAKA,GAHA,aACA,UAEA,CAMA,2BACA,cACA,KACA,qBAGA,QADA,6CACgB,WAAiB,IACjC,QAAmB,mBAAyB,EAG5C,QAAgB,WAAqB,IACrC,OACA,sCACA,8BAOA,MAFA,CAAiB,KADjB,iCADA,mBAEiB,SAGjB,CAEA,CCvHA,cAEA,WACA,KAEA,qBACA,qBACA,yCAEA,WACA,mBACA,8BACA,OACA,CACK,CACL,CAAG,EAKH,OAHA,CACA,uEACA,CACA,0BAKA,EACA,iBAAqB,mCAJrB,oCACA,kCAKA,8BACA,YACA,WACA,aACA,CAAG,EAEH,8BACA,0CACA,yBACA,kCAGA,wDACA,sCAAyC,GACzC,6BAEA,kBACA,CC+CA,cACA,IAjBA,EADA,EAmBA,EADA,KACA,QAhBA,CAHA,MAkBA,CAlBA,QAGA,mBACA,gCACA,eAEA,gCACA,SAEA,IAQA,C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CA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,YAOA,eACA,cAAyB,6BAAiC,CAC1D,CAEA,cAEA,GADA,+CAGA,2DACA,YAAgC,WAAe,EAE/C,qDACA,CCtOO,SAEP,eACA,cACA,0BACA,CAEA,6BACA,QACA,UAEA,SAEA,CAEA,WACA,mBAGA,cACA,QACA,CACA,CAEO,oBAEP,eACA,SACA,iCACA,CAEA,WACA,qBAEA,YAA4C,CAA5C,iBACA,oBAsBA,MApBA,UAEA,wBACA,SACA,IACA,QACA,OACA,OACA,CAAS,CACT,IACA,QACA,8CACS,CACT,MACA,QACA,wBAEA,CAAO,EAGP,WACA,CAEA,cACA,eACA,CAEA,CChEO,SAEP,eAEA,eACA,iBAAuB,GAAM,aAC7B,CAEA,0BACA,uBACA,0BACM,uBACN,kCAEA,IAEA,CAEA,sBACA,mBACA,kDACA,WACA,EACM,2BACN,EAEA,MAEA,CAEA,eACA,mBACA,gCACA,2BACA,mBACA,CAAc,qBAEd,CAEA,CAEA,6BACA,+BACA,oBAEA,MACA,gCACA,iCAIA,CCrDO,SAeP,eACA,aACA,mBACA,iBACA,iCAGA,kBACA,sBAEM,4CACN,kBAEA,cAJA,iBAMA,CAEA,oBACA,gCACA,oBAEA,iBAIA,CCpCO,SAEP,mBACA,gBACA,qCACA,eACA,aACA,gBAAsB,GAAK,cAC3B,uBACA,CAKA,0BACA,4CACA,oBACA,cACM,oBACN,cAEA,aAEA,CAEA,0BACA,EACA,+BAEA,CAEA,CAEA,0BACA,EACA,+BAEA,CAEA,CAKA,kBAEA,YACA,MA2CA,EACA,GA1CA,OAEA,gBACA,sBACA,iBACA,oDAIA,6BACA,6BAGA,4BAGA,KACA,0BACA,0BAEA,MACA,KACA,uBAEA,iCACA,mCAGA,8BACA,GACA,WAEM,GAEN,OACA,iBACM,iCAEN,QAIA,gCACA,8BACA,QACA,eA6BA,OAzBA,cACA,kCACA,kBACA,QACA,QACA,eACA,eACA,wBACA,yBACA,uBACA,QAEA,CAAO,EACP,4BACA,qCACA,CAAO,EACP,gCACA,uCACA,CAAO,EACP,qBACA,cACO,2BACP,eACO,EAEP,CACA,CAEA,uBAEA,WAEA,6BAIA,2CACA,kBACA,CAAK,kBACL,WAAiB,GAAK,EACtB,CAAK,EAEL,0CAEA,OACA,UAEA,0BACA,QACA,QACA,eACA,sBACA,qBACA,wCACA,CAAO,cACP,yBACA,yCACA,CAAO,uCACP,yBACA,oBACA,CAAO,EACP,CAKA,gBAEA,YAGA,QAAgB,2BAA8B,IAC9C,uCACA,uBACA,KACA,CAaA,OATA,6BACA,+BAQA,CACA,KACA,kBACA,KACA,wBACA,8CAEA,CAEA,gBACA,2BACA,kBAEA,sDAKA,CACA,SACA,KACA,eACA,EADA,OAEA,mCAFA,KAGA,YAHA,MAIA,0BACA,EAGA,EACA,SACA,KACA,eACA,MADA,OAEA,cAFA,KAGA,YAHA,MAIA,0BACA,CAAO,EACP,aACA,KACA,aACA,mCADA,KAEA,UAFA,KAGA,cAHA,KAIA,UACA,CAAO,CAEP,CAEA,gBACA,2BACA,WACA,kBAEA,sDACA,CACA,SACA,KACA,aACA,EADA,OAEA,mCAFA,KAGA,UAHA,KAIA,+BACA,EAGA,EACA,KACA,aACA,EADA,OAEA,mCAFA,KAGA,UAHA,KAIA,MACA,CAAO,EACP,aACA,KACA,YACA,mCADA,KAEA,UACA,kBACA,cACA,CAAO,CAEP,CAEA,gBACA,OACA,mBACA,kEAEA,CAKA,wBAEA,UAEA,OACA,cACA,KAEA,kDACA,gCAGA,4BACA,QACA,QACA,eACA,sBACA,8CACA,CAAO,EACP,yBACA,iCACO,EACP,qBACA,MAKA,WAHA,0BAGA,QAFA,8BAEA,UAEA,mBAFA,OAGA,QACA,CAAO,EACP,eACA,CAMA,oBACA,2CACA,oBACA,CAAK,EAIL,OAFA,6BAEA,WAEA,CAEO,oBAEP,mBACA,aACA,mCACA,CACA,CAEO,oBAEP,mBAEA,aACA,qCACA,kBACA,CAEA,iBACA,qCACA,CAEA,gBAOA,2BAGA,OAFA,qBAEA,EACA,aACA,wBACA,gBADA,OAEA,4BAFA,KAGA,oBACA,CAAK,EACL,eACA,4BACA,aADA,OAEA,qBAFA,KAGA,qBACA,cACA,CAAK,EAGL,gBAOA,2BACA,WACA,qBAEA,OACA,SACA,KACA,oBACA,EADA,OAEA,mCAFA,KAGA,gBACA,CACA,CACA,CAEO,oBAEP,mBAEA,aACA,qCACA,kBACA,CAEA,gBAQA,2BACA,WACA,mBAEA,OACA,SACA,KAEA,oBACA,MADA,OAEA,cAFA,KAGA,YAHA,MAIA,0BACA,CACA,CAEA,iBACA,qCACA,CAEA,gBAOA,2BAGA,OAFA,qBAEA,EACA,aACA,yBACA,gBADA,OAEA,4BAFA,KAGA,oBACA,CAAK,EACL,eACA,6BACA,aADA,OAEA,qBAFA,KAGA,qBACA,cACA,CAAK,EAEL,CCtcA,qBAEA,cAEA,EAAS,EAAE,+BAEX,EAAY,GAAY,eAGxB,0BAGA,IACA,YACA,gBACA,4CACA,wCAGA,EAAU,GAAU,gCACpB,cAEE,EAAE,sDAEJ,qBACA,2CACA,kBACA,QACA,QACA,eACA,qBAA4B,cAAe,EAC3C,yBAAgC,eAAgB,EAGhD,WACI,EAAE,8CAEN,CAKA,eACA,cACA,EAqBA,GAnBA,aAEA,4CAEA,4CAEE,EAAE,4BAIJ,KAFA,EAAc,EAAE,YAEhB,gBAEA,GAAgB,EAAE,uBAClB,YACA,+BACA,oBACA,mCAIA,qBACA,wBACA,8BACA,CACA,6BACA,MACA,CAOA,IALA,IACA,sBACA,yCAGA,IAAyB,IAA6B,IACtD,2BAEA,CAMA,eACA,QAEA,mBAIA,oBAEA,uCAEA,EADA,uCACA,SAEA,2BACA,CAEA,cACA,cACA,IAGA,MADA,CACA,OAEA,EAAY,EAAE,sCACd,EAAkB,EAAE,4CACpB,EAAmB,EAAE,6CAIrB,EADA,IADA,aAEA,EAEA,OAGA,OACA,0BACA,wCAIA,4BACA,+BACA,2BAEA,EAxBA,KAyBA,eACA,2BAKA,qCAIA,wBACA,gBApCA,KAoCA,yBAEA,MAIA,CAJmB,CAInB,eA1CA,KA0CA,0BAEA,EACA,0BACA,6BACA,6BAEA,8BAjDA,KAmDA,kBACI,SAAS,CLyOb,EAIA;MACM;;;;;;;WAON,CAGA,mCACA,oCAxGA,gCACA,6BACA,sCACA,2BACA,mBACA,WA8DA,iDACA,MACA,QACA,cACA,sBACA,MAEA,CAAK,EACL,eACA,KACA,IAEA,EAEA,OACA,uCACA,EAEA,oCACA,MA/EA,uBACA,KAEA,CAAK,EAEL,SA9DA,GACA,oDAEA,cACA,MAVA,oDACA,qBAWA,6BA8EA,EA3EA,MACA,uBAEA,yBACA,GAyEA,aAzEA,GAyEA,YAKA,GAEA,iDAGA;AACA;AACA;AACA,wCALA,uBAKoD;AACpD;AACA,KAfA,IACA,UA1EA,GA0EA,cAkBA;AACA;AACA,uBAEA;;QAEQ,aAAa,CAAY,UAAO,EAAE,EAAE,YAAY;;WAExD,GA1BA,EACA,SAzEA,mBACA,oCA9CA,eA+CA,KA3CA,kCACA,kBACA,OACA,6CAGA,SAFA,wBAEA,aACA,mBACA,IAmCA,IAjCA,GAiCA,GAhCA,WAEA,CAAK,EAgCL,iBACA,0CACA,iCzFJA,EAIA,EAGA,EACA,EA2BA,EAKA,EAIA,EACA,EAEA,EACA,EACA,EyF5CA,KzFLA,qCAGA,mCACA,gCACA,wCACA,uBACA,2BAEA,CADA,mBACA,cACA,0BACA,6BAwBA,6BAGA,WACA,YAEA,CADA,sBACA,0BACA,2BAEA,2CACA,uCAEA,YACA,gBAAkC,oBAAqB,eAAe,EACtE,uBAEA,wBArCA,EACA,EAMA,EA+BA,mBACA,qBAvCA,EAyCA,EACA,uBACA,0CA1CA,0BACA,YACA,WACA,aACA,CAAK,EAGL,CADA,+BACA,wCACA,yBACA,kCAGA,uDACA,sCAA2C,GAC3C,6BAEA,mBACA,UA4BA,EAEA,OyFvDA,CAAa,EAEb,2CACA,6BAGA,WADA,cADA,kCACA,WACA,4BACA,KACA,wBAEA,CAAa,IAGb,iEAEA,CAAK,CACL,CAAG,EAGH,gDACA,gCAAiD,KAAc,CAC/D,CAAG,CAEH,EA6GA,GAEA,SA3FA,GACA,yCACA,kCACA,mCAEA,uDACA,mCAEA,0BACA,wBAEA,CAAG,EAEH,sDACA,EA6EA,EACA,EKlTA,OAsDA,CCpFA,eA9CA,YACA,gBAEE,EAAE,0CACJ,8BACA,yBACA,0CACA,qDACA,6CACA,uBACA,0CACA,CAAK,EACL,oDACA,oBAjCA,kBAEA,IAxBA,EAwBA,GAtBA,EADA,KAuBA,EAvBA,kBACA,CAsBA,EAtBA,MAsBA,EApBA,mDAIA,kBACA,qBACA,6BAGA,EADA,sBACA,OAEA,QAIA,GAQE,EAAE,8BACJ,QACA,QACA,gBACA,wBACA,kBACA,CAAK,EACL,qDACA,2BACA,oCACA,6BACA,CAAK,EACL,YACA,EAgBA,WACA,CAAK,CACL,EA+BA,MAEA,SA/BA,GACA,gBAEE,EAAE,0CACJ,mBACM,EAAE,uCACR,eACA,yBACA,qDACA,uBACA,uCACA,CAAS,EACT,uBACA,uCACA,CAAS,EACT,mBACA,iCACA,CAAS,EACT,4BACA,CAAK,CACL,EASA,KAGA,CA2EA,yBACA,EA1EA,EACA,MAyBA,EACA,MACA,EAPA,EA4BA,EACA,MACA,GA0BA,KAzEA,UAJA,EA+EA,IA1EA,uBACA,qBAEA,2BACA,KACA,mBAEA,KACA,MACA,GAAa,SACb,MAgEA,EA7DA,CAAU,4BA+DV,yBAvDA,EAwDA,EAtDA,MA+CA,CA/CA,OAPA,EASA,EARA,CAQA,EARA,8CAQA,EAPA,EASA,KACA,uBACA,8BAGA,gBACA,+BAEA,MAEA,6BACA,6BACA,mBACA,cACA,cAGA,EAmCA,EA/BA,IAFA,MAwBA,CAxBA,QAEA,WACA,yCAEA,sBACA,wCAIA,EADA,GADA,cACA,QACA,UAEA,6BACA,2CACA,mBACA,YACA,SAiBA,EAjBA,GAmBA,CCvLe,eACf,WACA,cAGA,qCACA,sBACA,+BACA,CAEA,QACA,CCTA,eACA,MAAmB,GAAS,WAC5B,2CACA,CAEA,eACA,MAAmB,GAAS,eAC5B,+CACA,CAEA,eAEA,kCACA,SAGA,MAAmB,GAAS,cAC5B,8CACA,CCpBO,IAAI,GAAG,SACH,GAAG,SACH,GAAK,WCFD,cACf,qCAEA,2CACA,yBACA,6BACK,YAGL,oBCRe,cACf,6CAAgD,KAChD,CCCe,KDF4C,ICE5C,UACf,YACA,OAGA,YACA,OAGA,gCACA,IACA,IAEA,GAAsB,GAAa,KACnC,KADmC,UACnC,IAAuC,GAAK,0BAC5C,oBAAwC,GAAK,6BAG7C,IACA,GADa,GAAS,GAAY,GAAZ,GAAqB,QAC3C,eAEA,GAA0B,MAAgB,EAC1C,QAD0C,CAC1C,0BACA,iCACA,YACA,aACA,OACA,QACA,SACA,MACA,UACA,WACA,OACA,IACA,GACA,CACA,CCvCe,eACf,MAAY,GAAS,GAGrB,GAHqB,GAGrB,CACA,WAHA,cAIA,UAHA,cAKA,CGTe,eACf,4CACA,CCDe,eAEf,QAAW,GAAS,mBACpB,8CCDe,eAQf,OAAS,GAAsB,GAAkB,SAAkB,GAAe,GAApD,SAAoD,CAClF,CCXe,eACf,OAAS,GAAS,sBAClB,CCFe,eAEf,MAA0B,GAAgB,GAC1C,UAD0C,EAC1C,CACA,cACA,cAEA,8CACA,CENe,eACf,MAAmB,GAAqB,GAGxC,OAHmD,QAGnD,CACA,iBAUA,OARA,wBACA,YAGA,yBACA,aAGA,CACA,eACA,cACA,QACA,QACA,CACA,CCrBe,qBACT,WAAW,IACjB,EAMA,gBACA,eACI,GAAY,iBAEZ,GAAkB,EAGtB,CEPe,YFIO,CEJP,IAGf,YACA,OAGA,IANA,EAMA,EDde,eCcqB,KDbpC,oCAA4C,GAAW,OAEvD,CAFuD,CAEvD,mBAGM,GAAa,IAAU,GAAc,GAAxB,EAInB,EAAyB,GAAa,CAJK,EAK3C,ECGoC,GACpC,EDLsC,ICKtC,0CACA,EAAY,GAAS,GACrB,GADqB,CACrB,gCAA+D,GAAc,aAC7E,YACA,WACA,YAAuC,GAAa,IACpD,CEjBA,KFgBoD,IEhBpD,aACA,GAAoB,IACF,MADE,IAClB,GAAgB,YAIlB,CAJkB,CAIlB,aAHA,IAIA,CAwCe,CAxCb,QAwCa,MAIf,IAHA,MAAe,GAAS,GACxB,GADwB,EACxB,GAEA,GDzDA,aCyDyB,CDzDzB,cAAuC,GCyDA,KDzDW,cCyDO,GAAgB,eACzE,aAGA,IAAkC,SAAX,GAAW,IAAwC,IAAxC,KAA6B,GAAW,IAA6C,IAA7C,OAA6B,GAAgB,eAIvH,GAhDA,YACA,sBAAkC,MAGlC,GAFA,EAD6C,SAC7C,KAA6B,OAEf,GAAa,CAFa,GAMxC,MAJ2B,IAI3B,GAFqC,GAErC,SACA,CAHqC,MAGrC,KAIA,MAAoB,GAAa,GAMjC,IAJM,GAF2B,IAGjC,KADkB,IAClB,EAGS,GAAa,8BAA0C,GAAW,MAC3E,EAD2E,EAC3E,EAAc,GAAgB,GAI9B,UAJ8B,CAAe,CAI7C,6KACA,SAEA,eAIA,WACA,EAgBA,KACA,CCnEO,gBACA,WACA,UACA,UACA,IALO,MAKkB,UACzB,WAGA,cACA,YAEA,2BACP,oCACA,CAAC,KACU,GAAU,wCACrB,sCACA,CAAC,KAaM,CAbC,EAaD,CAXA,aACA,OACA,YAEA,CAF6B,YAG7B,OACA,YAEA,CAF6B,aAG7B,QACA,aACA,CIrBP,IACA,mBACA,aACA,mBACA,EAEA,cACA,0CAAsE,IAAa,IACnF,kBAGA,0BACA,sDACA,CAAG,CACH,CCrBA,QACA,UACA,ECHe,eACf,uBCFe,eACf,uBCDe,eACf,4CACA,CCEe,eACf,IAOA,EAPA,cACA,YACA,cACA,IAAkC,GAAgB,QAClD,IAA8B,CADoB,EACR,QAC1C,CAD0C,CAC1C,wBACA,4BAGA,UACA,ITfc,CSeL,KACT,GACA,CAFY,CAEZ,EACA,gBAEA,KAEA,MAAS,GACT,GADe,EAEf,EACA,gBAEA,KAEA,MAAS,GACT,EADc,CAEd,cACA,GACA,EACA,KAEA,MAAS,GACT,CADa,CACb,CACA,cACA,GACA,EACA,KAEA,SACA,GACA,MACA,MAEA,CAEA,QAAiC,GAAwB,QAEzD,YACA,CAHyD,GAGzD,2BAEA,UACA,KAAW,GACX,EADgB,EAChB,sBACA,KAEA,KTrDO,GSqDO,GACd,yBAIA,CACA,CAEA,QACA,CE5DA,QACA,WACA,aACA,cACA,WACA,EAcO,CAdJ,QAcI,MAGP,IAbA,IACA,EACA,EACA,EAQA,EAmFA,EAjFA,WACA,eACA,cACA,cACA,YACA,aACA,oBACA,aACA,iBACA,YACA,MACA,iBACA,MACA,iBAEA,0BACA,IACA,GACA,CAAG,GACH,IACA,GACA,EAEA,MACA,MACA,4BACA,wBACA,EAAc,GACd,CADkB,CX1DJ,MW2DA,EACd,OADiB,GAGjB,GACA,MAAuB,GAAe,GACtC,SADsC,QAEtC,gBAEA,IAAyB,GAAS,IAGR,EAHQ,SAGxB,GAFV,EAAqB,GAAkB,IAEb,WAFa,YAEb,IAC1B,iBACA,iBAOA,YAAyB,EAAH,GAAsB,IAAI,EAAvB,EAAyC,GAAK,WAAmB,CAAG,GAC7F,EAAc,GAGd,GAHoB,CADsE,GAE1F,gDACA,MACA,SACA,WAGA,KAAsB,IAAI,YAAsB,GAAH,CAAqB,GAAM,EXhFjE,GWgFyC,KAAwB,CAAmB,CAAG,GAC9F,EAAc,GAGd,EAHmB,CACnB,CAF2F,GAE3F,+CACA,MACA,QACA,UAEA,CAEA,qBACA,UACA,CAAG,QAEH,UAlFA,EAkFA,CACA,IACA,GACA,CAAG,CArFH,EAqFK,GAAS,GApFd,GAoFc,CApFd,EACA,MAEA,CACA,EAAO,GAAK,GAFZ,IAEY,gBAFZ,MAEY,KACZ,EAAO,GAAK,SACZ,GA8Ec,CACd,IACA,GACA,QAKA,CAHA,MACA,MAEA,GAGA,gBAA2B,UAAoC,uIAG/D,gBAAyB,UAAqC,mDAC9D,CC1CA,OAAe,CACf,mBACA,WACA,cACA,GA5EA,YACA,cACA,4CACA,sBACA,sBACA,gBAES,CAF+B,EAElB,IAAc,GAAW,GAAzB,EAOtB,GAP+C,IAO/C,kBACA,mCACA,YAEA,MACA,qBAEA,6BAEA,CAAK,EACL,CAAG,CACH,EAoDA,OAlDA,CAkDU,QAlDK,GACf,OAiDgB,CAjDhB,MACA,CAFe,CAEf,CACA,QACA,4BACA,SACA,QACA,UACA,CAAK,CACL,OACA,mBACA,CAAK,CACL,YACA,EAQA,OAPA,gDACA,WAEA,kBACA,8CAGA,WACA,4CACA,oBACA,sBAGA,SAFA,kDAEA,CAFuH,KAEvH,eAEA,OADA,QACA,CACA,CAAO,GAAI,EAEA,CAFG,EAEU,IAAc,GAAW,GAAzB,EAIxB,GAJiD,IAIjD,kBACA,mCACA,oBACA,CAAO,EACP,CAAK,CACL,CACA,EAAE,SASF,kBACC,CEnFD,QACA,aACA,aACA,aACA,YACA,EACe,eACf,sDACA,YACA,CAAG,CACH,CCVA,IAAI,GAAI,CACR,YACA,WACA,EACe,KAJP,IAIO,MACf,0CACA,OAAW,EAAI,IACZ,CACH,CGPe,iBACf,qCAEA,CAF2D,EAE3D,cACA,SAEA,MAAuB,GAAY,IACnC,KADmC,CACnC,EAEA,GACA,sBACA,SAIA,wBACQ,QAIR,CAHM,KAGN,EACA,CCtBe,eACf,uBAAyB,IACzB,SACA,QACA,kBACA,oBACG,CACH,CCqBA,uBAZA,EHTe,EACf,EAEA,EACA,EACA,EACA,EACA,EACA,EACA,EGaA,WAA4B,GAAW,GJzBxB,EIyBqB,OJzBrB,IIyBwC,CJxBvD,CIwBuE,GJxBvE,EAAY,GAAS,GACrB,EAAa,CADQ,EACU,GAC/B,YAD+B,MAC/B,CACA,gBACA,iBACA,IACA,IAEA,MACA,UACA,WACA,MAAyB,KAEzB,WAFyC,OAEzC,KACA,eACA,cAEA,CAEA,OACA,QACA,SACA,IAAW,GAAmB,GAC9B,GACA,CACA,EIDuE,MAAuB,CJFhE,EIEyE,IAZvG,CADA,CAauG,CAb1F,GAa0F,EAbrE,aAaqE,GAbrE,CAClC,UAYuG,EAZvG,UACA,2BACA,8BACA,6BACA,sBACA,wBACA,WACA,UACA,GAIiL,IHtBlK,EGsBmM,GAAkB,GHnBpO,EAAa,EGmBoL,CHnBlK,GAC/B,EAAkB,EGkBkN,CHlBnM,GACjC,IAF+B,IAE/B,kCACA,EAAc,GAAG,iEACjB,EAAe,GAAG,qEAClB,gBAAkC,GAAmB,GACrD,aADqD,CACrD,CAEsB,QAAhB,GAAgB,iBACtB,IAAS,GAAG,oCAGZ,CACA,QACA,SACA,IACA,GACA,GGGA,CC9Be,CD8Bb,QC9Ba,KACf,OACA,MACA,QACA,SACA,MACA,CACA,CCNe,eACf,uBAAyB,CAAE,KAAkB,EAC7C,CCHe,UDE8B,ECF9B,KACf,8BAEA,OADA,OACA,CACA,CAAG,GAAI,CACP,CCKe,iBACf,YACA,OAGA,IJqCe,MAhBf,EAEA,EAgBA,EACA,EACA,EIzCA,IACA,cACA,2BACA,aACA,0BACA,aAEA,iBAEA,mBACA,aAA0D,GAAM,EAChE,CADgE,CAChE,cAEA,YACA,iBACA,EAAsB,GAAkB,qBAAyC,GAAe,EAAU,KAE1G,KAFgG,IAAwB,CAExH,OACA,aANA,cAIA,IAAsC,GxBpB/B,GwBoBqC,GAAG,MAAY,GAAH,EAExD,CAFiE,GJqBlD,EIlB4B,GAAS,aAAzB,QAAyB,EAAgD,GAAkB,EAA5E,QAA4E,SJkBvG,EI/Bf,WxBbO,awBawD,OJ+BhD,EI7Bf,WAAwD,GAAQ,EJgChE,GADA,YADA,uBAjBA,EAAwB,GAAkB,GAiB1C,IAbO,GAFP,GAFuD,CAAd,EAIzB,QAHhB,iBAAwD,GAgBxD,GAhBwE,cAC5B,GAe5C,GAfqE,GAerE,IAfyD,EAOzD,MAPoF,EAOpF,aACA,OAAW,GAAS,IAAoB,EAApB,CAA4B,MAA+C,SAAX,GAAW,EAC/F,CAAG,EANH,GAK+F,CAO/F,aACA,KACA,IASA,CARA,yBACA,aIvBsH,GJ4BtH,OAJA,MAAkB,GAAG,aACrB,QAAoB,GAAG,iBACvB,SAAqB,GAAG,mBACxB,OAAmB,GAAG,eACtB,CACA,CAAG,QI7BmH,KJ8BtH,qBACA,wBACA,WACA,UACA,GIjCA,EAA4B,GAAqB,sBACjD,EAAsB,GAAc,CACpC,YACA,UACA,oBACA,WACA,CAAG,EACH,EAAyB,GAAgB,gBAAiB,OAC1D,MAA6C,GAAM,IAGnD,GACA,sBACA,kCACA,0BACA,+BAEA,yBAEA,CAF+C,EAE/C,IAAyB,IAAM,GAC/B,WACA,mCACA,OAAsB,GAAO,EAAF,CAAQ,oBACnC,GxB1Dc,MwB0DS,GAAF,CAAQ,qBAC7B,aACA,CAAK,CACL,CAEA,QACA,CI/DO,mBACP,OAAS,GAAO,EAAM,GAAO,MGC7B,mBAQA,OAPA,YACA,IACA,IACA,GACA,GAGA,CACA,uBACA,0BACA,6BACA,wBAEA,CAEA,eACA,O/BpBc,M+BoBC,GAAF,EAAO,CAAU,GAAF,CAAM,iBAClC,cACA,CAAG,CACH,CCZA,IAAI,GAA4B,S5BczB,GACP,G4Bf+C,CAA/B,C5BehB,OACA,OAGA,QACA,qBACA,kBACA,mBACA,kBACA,uBACA,YACA,MAGA,IFxCe,EACf,EEuCA,GACA,mBACA,oBACA,wBAA+B,OAC/B,gBAAuB,CACvB,UACA,YACA,QACA,CAAO,CACP,aAAoB,CACpB,SACA,EACA,KACA,KACA,GACA,QACA,uBACA,IDxDA,EFCA,EACA,EACA,EACA,EGoDA,sCACA,IACA,0BAAwC,gBACxC,iBACA,UAAqB,GAAS,GAAc,GAAiB,oBAAyC,GAAiB,qBACvH,OAAkB,GAAiB,EACnC,EAGA,CAHW,GAGX,GHhEA,EEQA,CCoDmC,MDpDnC,KATA,ICiEyD,aAAX,MAAW,YDjEzD,GCiEkH,GDjElH,eACA,gBAKA,OAJA,4BAAsD,MACtD,wBAA+B,sBAC/B,qBAA4B,eAC5B,CAAK,IACL,CACA,CAAG,GAAI,GAAG,GAEV,aACA,YACG,EFTH,UACA,UACA,KACA,sBACA,eACA,CAAG,EAiBH,CAjBM,CAiBN,oBACA,eAEA,SAlBA,KACA,cACA,iDACA,oBACA,cACA,eAEA,GACA,IAEA,CACA,CAAK,EACL,SACA,EAKA,EAEA,CAAG,EAQM,GAAc,qBACvB,gBARA,EAQA,mBACA,kBACA,CAAK,EACL,CAAG,MG8BH,OAJA,wCACA,iBACS,EA+FT,uCACA,aACA,YAEA,WAEA,yBACA,SACA,QACA,OACA,WACA,QARA,cAAmD,CASnD,CAAW,EAIX,UAFA,aAGA,CACA,CAAO,EA/GP,UACA,CAAO,CAMP,uBACA,OAIA,IjBhFe,EMcA,IAKf,EAbA,EACA,EACA,EAYA,EACA,EACA,EACA,EAIA,EWqDA,aACA,cACA,WAGA,CAH6C,EAG7C,SAKA,SACA,WX7Ee,EW6EkC,GAAe,GX7EjD,EW6EiD,MAA3B,CAA2B,sBXxEhE,EAAgC,GAAa,GAC7C,EAA6B,GAAa,EADG,GAZ7C,EAAe,GAa2B,CAd1C,EAc0C,EAd1C,EACoB,mBADpB,IACoB,OAasB,EAbtB,eACpB,EAAe,GAAK,4BACpB,cAYA,EAAwB,GAAkB,GAC1C,EAAa,GWqEwB,EXrEH,KADQ,EAE1C,CACA,QAFkC,GAElC,EACA,WACA,EACA,GACA,IACA,GACA,EAEA,eACmB,SAAX,GAAW,IACf,GAAc,CADC,CACD,GAClB,GNlCA,CADe,EMmCa,IAAb,CNlCA,GAAS,IAAW,EAAX,CAAwB,EMkCpB,CPtC5B,CACA,MCGgD,KDHhD,aACA,UCK+B,EDL/B,SACA,ECEW,GAAe,EMiCE,EAGpB,GAAa,IACrB,CNrC0B,CMqCV,GAAqB,CADhB,CACgB,IACrC,YADqC,KACrC,CACA,kBACM,GACN,KAAkB,GAAmB,KAIrC,CACA,UALqC,CAKrC,eACA,wBACA,cACA,eACA,GWwCA,OAAkB,GAAa,EAC/B,EAMA,CANW,CAMX,IAP+B,CAO/B,IACA,gCAKA,CALmD,CAKnD,qCACA,+CAAsE,QACtE,CAAS,EAET,YAA4B,4BAAuC,KACnE,iBACA,WACA,KACA,QACA,CAEA,4BACA,OACA,YACA,gBAAgE,EAChE,SAEA,sBACA,MACA,QACA,UACA,OACA,UACA,CAAa,KAEb,GACA,CAAO,CAGP,QF1Ie,EE0IO,WACtB,+BACA,gBACA,IACA,CAAS,CACT,CAAO,CF7IP,WAUA,OATA,GACA,2BACA,kCACA,SACA,MACA,CAAS,CACT,EAAO,EAGP,CACA,GEmIA,mBACA,IACA,IACA,CACA,EAEA,YACA,SAmCA,aACA,sBACA,UACA,CAAO,EACP,KAGA,OAvCA,iCACA,qBACA,kBAEA,CAAK,EAmCL,CAnCQ,CAqCR,E4BxL+C,CAC/C,iBAFA,C3B+Be,CACf,a2BhCsC,EAAE,O3BiCxC,WACA,K2BlCqD,C3BkCrD,C2BlCuD,O3BmCvD,eAAsB,CACtB,OAxCA,YACA,cACA,aACA,YACA,WACA,gBACA,WACA,gBACA,EAAe,GAAS,mBACxB,8DAYA,OAVA,GACA,sBACA,wCACA,CAAK,EAGL,GACA,yCAGA,WACA,GACA,sBACA,2CACA,CAAO,EAGP,GACA,2CAEA,CACA,EAAE,KASF,EACA,CAAC,CK9Bc,CACf,qBACA,WACA,aACA,GApBA,YACA,cACA,SAKA,mBAA8B,GAAc,CAC5C,UAD4C,EAC5C,gBACA,uBACA,oBACA,sBACG,CACH,EAAE,KAQF,EACA,CAAC,CC0Ic,CACf,qBACA,WACA,oBACA,GA9CA,YACA,cACA,YACA,oBAEA,aAEA,iBACA,gBACA,GACA,UAAe,GAAgB,uBAChB,GAAY,aAC3B,yBACA,0BACA,gBAVA,cAWA,qCAGA,sCACA,iCAA0C,oCAAmD,IAC7F,sCACA,4BACA,SAhBA,cAiBA,cACA,CAAK,KAGL,6BACA,gCAAyC,mCAAkD,IAC3F,8BACA,oBACA,YACA,cACA,CAAK,KAGL,oCAA4C,sBAC5C,oCACG,CACH,EAQA,OACA,CAAC,CqB9JqE,GnBqCvD,CACf,cACA,GmBvCiF,EAAE,GnBuCnF,GACA,UmBxCyF,EAAE,CnByC3F,amBzC+F,EAAE,WnByCjG,CACA,GA5BA,YACA,cACA,CmBhBuH,CnBgBvH,CmBhByH,CnBgBzH,QACA,KmBjB6H,GnBiB7H,CACA,WACA,qBACA,EAAa,GAAU,yBA3BhB,EACP,EACA,EAEA,EAGA,EACA,EAqBA,OADA,MA5BO,EA4BP,QA1BA,GAAwB,GbLV,CaKc,EAAE,GAAG,SADjC,EAAsB,GA2BtB,KA1BiC,OAKjC,CANsC,CAMtC,CAHA,qBAwBA,EAxBA,kBAAmE,IACnE,UAuBA,CAtBA,CAAG,GAsBH,EArBA,IACA,OAEA,OACA,WACA,CAAU,GAAM,CAAF,EAAO,gBACrB,IACA,GACA,EAAI,CACJ,IACA,GACA,GAWA,CACA,CAAG,GAAI,EACP,iBACA,MACA,KAEA,uCACA,mCACA,oCAGA,oBACA,CASA,CAAC,CaoFc,CACf,YACA,WACA,aACA,GA5HA,YACA,cACA,YACA,SAEA,8BAoCA,QAhCA,aACA,gBACA,YACA,gBACA,uBACA,YACA,aACA,iBACA,gBACA,mBACA,gBACA,0BACA,sBAEA,KADsC,KACtC,EACA,MAFsC,GAEtC,IAAiG,GAAoB,aAjCrH,GACA,CAgCqH,EAhC/G,GAAgB,KAAgB,GACtC,CAD0C,IAApB,CACtB,GAGA,MAA0B,GAAoB,GAC9C,OAAU,GAA6B,IADO,CACyB,GAA6B,KA2BiB,IACrH,SA5BuC,GA4BvC,KA5BoG,KA4BpG,mBDtCe,EAMf,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAGA,EASA,ECaA,gBAAsB,GAAgB,KAAgB,IAAI,EDjC1D,CCiC6D,CAAvB,CAA2C,CACjF,YACA,KAFiF,IAEjF,EACA,eACA,UACA,iBACA,uBACA,CAAK,EDxCL,UACA,EAFA,EAEA,SACA,EAHA,EAGA,aACA,EAJA,EAIA,QACA,EALA,EAKA,eAEA,YADA,2BACiE,GAAa,EAS9E,KAJA,GAHA,GAF8E,EAC5D,GAAY,IAC9B,EAAgD,GAAsB,GAAmB,aAAtB,GAAsB,GACzF,OAAW,GAAY,MACvB,CAAG,EAAI,IACP,UADqB,MACrB,GACA,sBACA,CAAG,GAEH,QACA,MAaA,YATA,yBAOA,OANA,KAAqB,GCY4D,EDZ9C,CACnC,QADmC,EACnC,EACA,WACA,eACA,SACA,CAAK,EAAE,GAAgB,IACvB,CACA,CAAG,GAAI,GACP,CAHuB,GAGvB,eACA,iBACG,GCSE,EACL,CAAG,KACH,oBACA,iBACA,UACA,KACA,OAEA,IAAkB,WAAuB,KACzC,WAEA,EAAyB,GAAgB,GAEzC,EAA2B,GAAY,KAFE,GAGzC,CADuC,CAAqB,C1B/D9C,M0BgEa,GAAF,CAAQ,cACjC,qBACA,EAAmB,GAAc,GACjC,QADiC,EACjC,EACA,WACA,eACA,cACA,SACA,CAAK,EACL,MAA4D,GAAQ,EAAH,CAAO,EAAsB,G1BzEhF,G0ByEsF,EAEpG,CAFuG,CAEvG,UACA,GAA0B,GAAoB,IAG9C,MAA2B,GAAoB,GAC/C,CAJ8C,CAI9C,GAUA,GARA,GACA,GAJ+C,GAI/C,UAGA,GACA,wBAGA,oBACA,QACA,CAAK,GACL,IACA,KACA,KACA,CAEA,UACA,CAEA,KAqBA,QAnBA,QAEA,cACA,yBACA,eAEA,KACA,sCACA,QACA,CAAW,CAEX,CAAO,EAEP,KAEA,OADA,IACA,OAEA,EAEA,IAAkC,KAGlC,UAFA,KAD0C,KAO1C,kBACA,4BACA,cACA,YAEA,EAAE,iBAQF,WACA,MACA,QACA,CACA,CAAC,CGXc,CACf,uBACA,WACA,aACA,GA/HA,YACA,cACA,YACA,SACA,aAEA,YAEA,aACA,iBACA,gBACA,YACA,WACA,gBACA,iBACA,iBACA,EAAiB,GAAc,GAC/B,QAD+B,CAC/B,EACA,eACA,UACA,aACA,CAAG,EACH,EAAsB,GAAgB,aACtC,EAAkB,GAAY,aAC9B,KACA,EAAiB,GAAwB,GACzC,EFrCA,MEqC0B,EAAV,IFrChB,IEoCyC,EACf,EAC1B,4BACA,oBACA,iBACA,yCAA4F,UAC5F,sBACG,KACH,sBACA,WACA,SACA,EAAI,eACJ,WACA,SACA,CAAG,IACH,kEACA,GACA,IACA,GACA,EAEA,MAIA,GA7CA,cA6CA,CAGA,IAFA,EAEA,U7BjEc,M6BiE8B,CAAH,EACzC,CADgD,CAChD,QAAqC,GAAS,GAAH,EAAQ,MACnD,mBACA,OACA,SACA,SACA,cACA,MAA+B,GAAK,UACpC,MAA+B,GAAK,YAGpC,CAH+E,CAG/E,iBACA,OAA6C,GAAa,IAC1D,MAD0D,EAE1D,QACA,EACA,kFAAyH,KACzH,OACA,MAF2I,CAQ3I,CANuD,CAMpC,GAAM,aACzB,6CACA,8CACA,oBAAoD,GAAe,kBACnE,6CACA,oCAGA,EAA0B,GAAM,EAAU,CAAV,EAAiB,EAFjD,GAEiD,CAFjD,KAEiD,MAAyC,GAAO,EADjG,GACiG,CADjG,GACiG,EACjG,QACA,QACA,CAEA,GAnFA,cAmFA,CAGA,IDpGA,ECkGA,EAEA,QAAuC,E7BzGzB,M6ByG+B,CAAH,EAE1C,CAFiD,CAEjD,QAAsC,GAAS,GAAH,EAAQ,CAEpD,KAEA,4BAEA,WAEA,WAEA,S7BrHc,M6BqHe,GAAF,CAAM,WAEjC,qCAEA,qCAEA,qCAEA,SDvHA,CADA,KCwHkE,MAAd,KAAc,MDvHlE,ECuHsG,CAApC,EAA0C,mBAE5G,SACA,UACA,CAEA,qBACA,EAAE,iBAQF,WACC,CC5Dc,CACf,aACA,WACA,aACA,GApEA,YAGA,IAVA,EAQA,EAEA,UACA,SACA,YACA,mBACA,gCACA,EAAsB,GAAgB,eACzB,GAAwB,GAErC,EADA,CAAoB,GAAM,CAAF,EAAO,eAC/B,iBAEA,SAIA,MApBS,GAAkB,gBAH3B,sBADA,EAwBA,WAvBA,kBAAoE,CAuBpE,EAvBoE,OACpE,UAsBA,EAtBA,UACG,MACwB,EAAyC,GAAe,EAAU,KAqB7F,EAAkB,GArBiE,GAsBnF,CAtB2G,CAsB3G,KAD+B,CAC/B,E9BpCc,M8BoCuB,CAAH,EAClC,CADyC,CACzC,QAA+B,GAAS,GAAH,EAAQ,EAC7C,+DACA,4BACA,EAA0B,GAAe,GACzC,SADyC,CACzC,uCAIA,OACA,cACA,aALA,UAMA,CANuD,CAMxC,GAAM,MAGrB,IAHyC,YAGzC,KAAyD,CAAzD,KAAyD,CADzD,EACyD,yBACzD,EAkCA,OAhCA,CAgCU,QAhCD,CAAM,EACf,CA+BgB,GA/BhB,KADe,IACf,CAEA,EADA,UACA,QACA,oCAEA,UAKA,qBACA,sCADA,GAQO,GAAQ,sBAIf,oBACA,EAAE,SASF,kBACA,qCACC,CCnCc,CACf,YACA,WACA,aACA,qCACA,GAlCA,YACA,cACA,SACA,oBACA,iBACA,kCACA,EAA0B,GAAc,GACxC,QADwC,OACxC,WACA,CAAG,EACH,EAA0B,GAAc,GACxC,QADwC,IACxC,EACA,CAAG,EACH,UACA,YACA,QACA,OACA,qBACA,2BACA,sBACA,oBACA,kBACA,EACA,oCAA4C,sBAC5C,iCACA,uBACA,CAAG,CACH,CASA,CATE,CCtCF,CAAC,ECJD,CDII,ECJJ,gBAEA,iBACA,qBACA,IACA,WACA,UACA,EACA,cACA,sBAMA,mBACA,qBACA,WACA,wCACA,CAEA,QACA,CACA,SAAS,GAAM,KACf,QADe,CACf,CAAc,kBACd,oDACA,CACA,iBACA,8CACA,CACA,SAAS,GAAQ,SAMjB,MANiB,GAEjB,MACA,EAIA,YACA,gBACA,wBACA,IACA,CAAK,GACL,CACA,CAWA,eACA,kBACA,CACA,iBACA,mBACA,SAEA,CASA,eACA,sBACA,CACA,eACA,2CAKA,OAJA,eACA,YAGA,CACA,CAAG,GAAI,CACP,CAEA,cACA,oCACA,CACA,SAAS,GAAS,GAClB,aADkB,IAClB,6BACA,OAAW,GAAM,IACjB,CAAG,CACH,CAyBA,MA3BiB,GA2BjB,QACA,sBACA,GACA,mCAEA,CAAG,CACH,CACA,iBACA,sBACA,GACA,8BAEA,CAAG,CACH,CAoCA,mBACA,wBAGA,CAHyC,gBAGzC,2CACA,SACA,CAAG,CACH,CAMA,iBAGA,IAFA,IAGA,EAHA,IAEA,IAGA,iBACA,SAGA,qEAGA,QACA,CAEA,QACA,UACA,EACA,KAQA,eACA,aAIA,cAEA,oBACA,0CAEA,CAOA,cACA,wBAEA,UACA,cACA,8CAGA,IACA,CAQA,cACA,6BAEA,MA/IA,+BA+IA,GACA,eAEA,4BACA,QAEA,CACA,CAOA,SADA,4DAEA,kBA0EA,kBACA,YACA,MACA,eACA,eACA,CAAG,CACH,QACA,mBACA,4BACA,eACA,oBACA,eACA,oBACA,sBACA,kBACA,cACA,0BAA4C,CAC5C,2BAA8C,CAC9C,qBAAkC,CAClC,sBAAoC,CACpC,qBAAkC,CAClC,mBAA8B,CAC9B,oBAAgC,CAChC,mBAA8B,CAC9B,oBAAgC,CAChC,sBAAoC,CACpC,wBAAwC,CACxC,2BAA8C,CAC9C,gBACA,WACA,gBAAmB,CACnB,YACA,gBACA,SACA,2BACA,kBACA,CAAC,CArDD,CACA,eACA,gBACA,qBACA,SACA,EACA,CACA,aACA,iBACA,SACA,WACA,WACA,aAC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CA,MAGA,CAEA,aACA,IACA,CAEA,aACA,IACA,CAEA,aACA,UACA,qCACA,oCACA,sCACA,oCACA,CAEA,aACA,UACA,wCACA,uCACA,yCACA,uCACA,CAcA,gBACA,SA/KA,GA+KA,IAEA,cACA,eACA,iBACA,IAEA,CAIA,CAJM,EAIN,MACA,WAGA,iBACA,cACA,GACA,CAEA,kBACA,YACA,OAGA,6BACA,oBACA,0BACA,QACA,OACA,YACA,UACA,SACA,CAAO,CACP,CAAK,CACL,CAEA,aACA,MACA,kBACA,UACA,CAAO,EACP,gBACA,UACA,CAAO,GAv3BP,EA03BA,cA13BA,6BA03BA,oBACA,gBAMA,OAFA,OAEA,GACA,iBACA,kBACA,KAEA,aACA,0BACA,KAEA,eACA,eAEA,CACA,CAAK,CACL,CAEA,aACA,sBACA,aACA,cACA,YACA,YACA,4BACA,CAAK,EACL,KAGA,cAGA,IAFA,EAEA,KAEA,oCAIA,4CACA,IACA,kBACA,IAEA,oBA/3BS,GA+3BT,EA/3Be,eAo4Bf,uBACA,WACA,CAAO,EAIP,4GACA,KAEA,KAGA,kBACA,OAGA,OACA,MAEA,CAEA,cACA,IA/2BA,EACA,EACA,EA62BA,WACA,EAnTA,OAmTA,2BAEA,6BAl3BA,EAs3BA,8BAIA,IAHA,EAGA,WADA,SACA,sCAEA,EACA,CACA,qCACA,cACA,OACA,EAGA,IACA,CAAK,kBAp4BL,YACA,EAq4BA,EAr4BA,QACA,oBACA,mBACA,gBAEA,IADA,MACA,kBACA,EA9EA,EA8EwC,UA9ExC,EA8EwB,GA9ExB,SA+EA,cADwC,GACxC,QAEA,MACA,SAGA,6BACA,yBACA,yBACA,yBACA,cACA,iBACA,eACA,gBACA,iBACA,CAAG,IAg3BH,IACA,OAEA,CAEA,cAGA,IAFA,gDAMA,wBACA,2BACA,MACA,CAEA,MACA,CAEA,cACA,iDAhWA,QAqWA,mEAIA,KACA,CAEA,cACA,oDACA,CAEA,aACA,IACA,cACA,kBACA,cACA,WACA,2BACA,mBACA,uBACA,KACA,wBACA,iCA3XA,IA4XA,EAAM,EA4BN,IACA,cACA,SAC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B,IAAI,aAAa;oBAC/D,IAAI,gBAAgB,IAAI;2BACjB,OAAO;;KAElC,CACG,EASH,SAIA,OAFA,aAEA,CACA,CAUA,yBACA,wBATO,cACP,iBAEA,8CACA,iCACA,CAAI,CACJ,EC3ZO,4CAEP,YACA,YAEA,IACA,YACA,QACA,UACA,WACA,EAEA,IACA,mBACA,eACA,mBACA,kBACA,EAEA,IACA,mBACA,eACA,kBACA,EAEA,IACA,0BACA,YACA,2BACA,eACA,EAEA,GACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,uBAAuB;AACvB;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA,IAAI,QAAQ;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAEA,+DAGA,cACA,0DACA,CAGA,eACA,WAEA,IADA,qBACA,gCACA,oBAA4B,OAAO,EAAkB,EAIrD,yBACA,gBAGA,CADA,kDACA,uBAEA,OADA,MAA2B,GAAM,0BACjC,IACA,2DACA,eACA,wBAPA,OAQA,MACA,2BACA,MACE,GAAS,EACX,CAGO,eAEP,GANW,IAKX,kCAEA,CAGA,uBACA,IAEA,wDACA,KAKI,CACJ,uBAEA,GADA,gBACA,IACA,EACA,IACM,KACN,QAEA,yBAdA,CACA,oDACA,kBACA,CAD2B,CAC3B,gDACA,GACA,CAWA,CAXI,GAWJ,QAKA,OAHA,mDAGA,GA2CA,eACA,gBACA,yDACA,aAEA,kDACA,wBAAoD,EACpD,wCACA,CACA,CAoCA,iBACA,gBAGA,UACA,sBA4BA,OA1BA,kBACA,gBACA,aAEA,YACA,WACA,gBAGA,GAEA,QACA,OAIA,oBACA,WAIA,OACA,SAEA,CAAG,EAEH,CACA,CAIA,iBACA,8BACA,CA4EA,cACA,4BACA,8BAAiD,EAAI,GACrD,iCACA,CAIA,mBAkBA,EAcA,EA/BA,4DAIA,QAFA,8CACA,iCAGA,WAnDA,SAOA,EANA,gBACA,sBAMA,MACA,cACA,qBACA,EAAI,IAGJ,QADA,kBADA,iBAGA,oBACA,CAaA,OAXA,kBACA,yBACA,aACA,GAvCA,kBACA,gBACA,YACA,YACA,YACA,OACA,GACA,WACA,QAGA,EA1BA,kBACA,uBACA,oBACA,UACA,UACA,WACA,WACA,OACA,GACA,WACA,QAGA,CAyCA,EAEA,WAEA,gBACA,kBAEA,CAAG,EACH,CACA,EAqBA,KAEA,uBACA,CADqC,GACrC,wBACA,6BAA6C,EAAI,GACjD,OAEA,oBACA,mBACA,MACA,CAEA,kBACA,yBACA,KAEA,CAAG,EAEH,OAAmB,sCACnB,iCACA,iCAGA,6BACA,6BASA,GAPA,UACA,SACI,WACJ,YAKA,YAtLA,gBACA,iBACA,OACA,UACA,kBAEA,EAiLA,OACA,CACA,oBACA,mBACA,MACA,CAEA,KACA,eACA,YAGA,cACA,CAD4B,CAC5B,iBACA,UACA,qBACA,SACA,KACA,gBACA,EAAI,kBACJ,CADoC,CACpC,iBACA,iBACA,MACA,qBACA,SACA,KACA,gBACA,CACA,oBACA,kBACA,CAEA,cACA,iEACA,CAEA,iBACA,KACA,YACE,GAAS,EACX,CAEA,iBACA,CAJW,CAOX,kCACA,KAEA,8CAEA,UACA,qCACA,qCACA,6BAAwD,MAIxD,GADA,QAA4B,IAAI,EAAE,MAAM,2DAAI,UAAoB,EAAR,CAAoB,CAC5E,GACA,KAF4E,CAE5E,KACA,yBACA,CAAG,EAGH,oCACA,iDACA,8BACA,WACA,4BACA,CAAG,CACH,CAqBA,eAEA,gDACA,sBAEA,EAFqC,CAErC,WAEA,6DAEA,qCACA,yCACA,uBACA,wBACA,MAGA,4CACA,oCACA,YAKA,+BACA,CAAK,EADwC,SAG7C,aAEA,CADA,8CACA,sBAEA,CAAG,EACH,oCACA,gCAEA,EAF2C,OAE3C,aAEA,CADA,8CACA,kBAIA,KA1DA,YAEA,MADA,4CACA,wBACA,YACA,YAGA,OADA,0CAmDA,IAUA,SAIA,wBACA,0CACA,CAAG,EAEH,0BACA,2BAEA,cACA,OACA,CAAG,EACH,CAUA,SAAS,GAAc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CA,UACA,GACA,yCAIA,SACA,KACA,QACA,EA/BA,WAgCA,KACA,OACA,KACA,QA3BA,EA4BA,EA3BA,CADA,EA4BA,QA3BA,GACA,MAEA,WAyBA,KACA,KAEA,SAA+B,MAAY,EAAE,MAAY,EAAE,KAAW,EAiBtE,GAbA,+BAGA,iCAEA,oDAA4D,EAAc,GAC1E,2BACA,GACA,QAGA,yBAEA,IAIA,OADA,iBAAyB,MAAM,oCAAI,GAAc,EACjD,EAEA,CAGA,MANiD,EAMjD,CAA6B,SAAS,CD5D/B,EAGP,WAIA,sBAIA,uBACA,OAnEA,OACA,OAkEA,CACI,qBACJ,OAvBA,UACA,UAsBA,CACI,GACJ,eACA,4BAEA,cACI,GACJ,cAEA,OAxCA,UACA,UAuCA,CACI,GACJ,0BAEA,OAzCA,UACA,UAwCA,CACI,GACJ,2BAEA,OAlCA,OACA,OAiCA,MACI,GACJ,kCAEA,OAxCA,OACA,OAuCA,MACI,2BAEJ,OAtEA,UACA,UAqEA,MACI,iBACJ,mBACI,uBACJ,mBAIA,GACA,8BACA,gCACA,kBACA,kBACA,mBACA,mBACA,yCACA,6BACA,qCACA,mBACA,6BACA,gCACA,2BACA,oCAEA,oCACA,wCAEA,mBACA,sCACA,cACA,iBACA,sBACA,8CACA,mBAEA,mBACI,GAEJ,2BACA,kCACA,gCACA,+BACA,iCACA,oBACA,+BACA,oCACA,oCACA,iEAEA,6BACA,4BACA,4DACA,yBAEA,mBACI,GAEJ,iCACA,oCACA,mDACA,sCACA,sBACA,0BACA,sCACA,0CACA,mBACA,0BACA,yBACA,2BACA,YACA,wCACA,oCACA,0BACA,mBACA,uBACA,kBACA,kBACA,+BACA,kCACA,2BACA,kBACA,+BACA,sBACA,oDACA,oBACA,YACA,4BACA,mBAEA,mBACI,GACJ,8BACA,qCACA,gCACA,gBACA,0BACA,2CACA,mBACA,gDACA,mCACA,sCACA,iCACA,4BAEA,OA9MA,OACA,OA6MA,MACI,GACJ,uCACA,uBACA,kBACA,2BACA,gCACA,qBACA,mBACA,mCAEA,mBACI,GAEJ,4BACA,sBACA,4BACA,kDACA,6BACA,kCACA,mBACA,kCACA,oCACA,uBAEA,mCACA,sBAEA,oCACA,aACA,8CACA,sBACA,2BACA,kCACA,iCACA,iBACA,oBACA,yCACA,2BACA,2BACA,8BACA,mBACA,mBACA,8BACA,wBACA,oBACA,oDACA,6BACA,uCACA,2BACA,uBACA,mCACA,0BACA,yBACA,uCACA,oBACA,6BACA,gBAEA,mBACI,GACJ,oDACA,mCACA,0BACA,yBACA,uCACA,8CACA,oBACA,0CACA,iBACA,+CACA,kBACA,uBACA,mCACA,mDACA,mBACA,mBACA,yBACA,wBACA,kCACA,mBACA,mCACA,oDACA,4BACA,6BAEA,mBACI,GAEJ,4BACA,2BACA,mBACA,kDACA,0BACA,+BACA,2BACA,uBACA,wBACA,wDACA,kBACA,kBACA,+BACA,kBACA,gBACA,oBACA,mCACA,8BAEA,uEADA,GAEA,mBACA,qCACA,oBACA,qBACA,yBACA,4BACA,kCACA,8BACA,2BACA,+DACA,sCACA,mBACA,kBAEA,mBACI,GACJ,kBACA,+BACA,0BACA,+BACA,mBACA,uBACA,6CACA,gCACA,qDACA,sBACA,0CACA,uCACA,uBACA,mBACA,6BACA,8BACA,2BACA,kBACA,gBACA,oBADuD,MACvD,qBACA,wCACA,6CACA,qDACA,4BACA,gCACA,2BACA,kBAEA,mBACI,GACJ,oBACA,uCACA,mCACA,mDACA,yDACA,wBACA,0BACA,mBACA,2BACA,yBACA,2BACA,+BACA,sDACA,6BACA,qBAEA,mBACI,GACJ,kBACA,0BACA,0BACA,8BACA,4BACA,sCACA,mCACA,mCACA,6CACA,qBACA,0BACA,0BACA,yBACA,sBACA,sCACA,kCACA,iCACA,oBACA,qCACA,wBACA,mCACA,gDACA,kCACA,yBACA,0BACA,sCACA,0BACA,mBACA,6CACA,oDACA,kBACA,sCACA,kBACA,iCACA,4CACA,kCACA,qCACA,uDACA,qBACA,iCACA,oBACA,mBACA,sCACA,0BACA,kBACA,mBACA,kCAEA,mBACI,GAEJ,kCACA,wDACA,yBACA,8BACA,4CACA,yBACA,2CACA,mBACA,wBACA,2BACA,0BACA,gCACA,+BACA,2BACA,iCACA,WACA,gCACA,iCACA,iCACA,gCACA,gCACA,8BACA,0BACA,kBACA,iBACA,qBAF2E,QAG3E,mBACA,+CACA,mBACA,qBACA,2DACA,6DACA,mBACA,uCACA,4BACA,0BACA,2BACA,kCAEA,mBACI,GACJ,sBACA,6BACA,wBACA,gCACA,wCACA,sBACA,mCACA,+BACA,8CACA,kDACA,iDACA,yCACA,+CACA,6BACA,+BACA,gDACA,0BACA,iDACA,mBACA,0BACA,uBACA,wBACA,yBACA,2BACA,qBACA,mCACA,oBACA,oBACA,yBACA,4BACA,sBAEA,mBACI,GACJ,6BACA,sBACA,kBACA,qCACA,kCACA,0BACA,+BACA,iCACA,kBACA,kBACA,6BACA,mBACA,gCACA,iBACA,oBACA,sCACA,uBACA,oCACA,6BACA,wBACA,mBACA,mBACA,iCACA,4CACA,8BACA,wBACA,gDACA,mCAEA,mBACI,GACJ,4BACA,qBACA,6BACA,qCACA,mCACA,oBACA,6BACA,kCACA,wBACA,mBACA,8CACA,qBAEA,mBACI,GACJ,mCACA,4BACA,sBACA,gCACA,wBACA,wBACA,6DACA,wCACA,4BACA,yCACA,oBACA,+BACA,2BAEA,OA/hBA,UACA,UA8hBA,MASA,GACA,yCACA,uBACA,0BACA,+DACA,2BACA,oCACA,oBACA,sBACA,kBACA,wCACA,kBACA,oBACA,yBAEA,OAxhBA,OACA,OAuhBA,MAGA,GAEA,iBACA,4BACA,qBACA,kBACA,mCACA,+BACA,+BACA,kBACA,gBACA,+CACA,wCACA,4BACA,sBACA,qBACA,mCACA,uBACA,gCACA,8BACA,2BACA,kBACA,0BACA,8CACA,yBACA,gCACA,aACA,2BACA,uBAEA,mBACI,GACJ,uBACA,8BACA,4BACA,6BACA,oBACA,0BACA,4BACA,2BACA,oBACA,mCACA,kBACA,iDACA,0DACA,kBACA,kBACA,8BACA,cACA,+BACA,oBACA,2BACA,yBACA,sDAEA,oBACA,0BACA,2BACA,kBACA,gCACA,iBACA,mDACA,yBACA,sBACA,oBACA,oBACA,iCACA,qCAEA,mBACI,GACJ,yBACA,kCACA,kCACA,iCACA,mBACA,uBAEA,OAznBA,UACA,UAwnBA,MACI,GAEJ,oCACA,qCACA,qCACA,mBACA,+BACA,uBACA,0BACA,qCACA,kBACA,mBACA,oBACA,+CACA,oDACA,kBACA,iCACA,yBACA,uBACA,0BACA,gCACA,6BACA,oCACA,sDACA,wBACA,qBACA,qBACA,wCACA,iBACA,oDACA,iCAEA,mBACI,GAEJ,oBACA,6BACA,oBACA,6BACA,oCACA,0BACA,2BACA,uCACA,wBACA,mCACA,qBACA,sBACA,0BACA,oBACA,mBACA,qCACA,qBAEA,OA/tBA,OACA,OA8tBA,MACI,GACJ,gCACA,0CACA,gCAEA,OA3uBA,OACA,OA0uBA,MACI,GACJ,iDACA,mBACA,uBACA,0CACA,iCACA,4BACA,oBACA,oBACA,8BAGA,yBACA,kBACA,2BAEA,wBACA,YACA,kCAEA,sBAGA,iCACA,qCACA,6CACA,kCACA,oCAEA,uBAEA,OA9sBA,UACA,UA6sBA,MACI,GACJ,sBACA,qCACA,iDACA,4BACA,2CACA,2BACA,kCACA,yCACA,uCACA,0CAEA,mBACI,GACJ,uBACA,uBACA,oBACA,8BACA,kCACA,kCACA,kCACA,gCACA,2BACA,uCACA,4BACA,mBACA,mBACA,oCACA,kCAEA,mBACI,GACJ,yBACA,2BACA,0BAEA,mBACI,GACJ,yCACA,yCACA,2BACA,kDACA,qBACA,mBACA,kBACA,mBACA,sCACA,8CACA,+CACA,2CACA,iCACA,4BACA,2CACA,mBACA,qBACA,sBAEA,mBACI,GACJ,kDACA,qBACA,wBACA,6BACA,6BACA,kBACA,2CACA,sDAEA,mBACI,GACJ,mCACA,mBACA,yBACA,+BACA,yCACA,sBACA,yBACA,kBACA,2BACA,qBACA,oBACA,mBACA,mCACA,uCACA,mBACA,4BACA,6CACA,wCACA,mBACA,wBAEA,mBACI,GACJ,kBACA,2CACA,2C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NA,OACA,sBACA,SAKA,CALe,EAKf,cACA,cAEA,GACA,eACA,iBACA,EAEA,EACA,YACA,wBAAoB,sBAGpB,KAUA,OARA,WADA,4CACA,YACA,MA1HA,cACA,WAEA,sBAAS,sBAAwC,EAEjD,KACA,IACA,KACA,OACA,OA4CA,OA1CA,mCACA,+BAEA,MADA,EACA,yBACA,aAEA,gBACA,KACA,UAEA,eACA,OATA,EAYA,4BACA,MAbA,EAaA,0BACA,eACA,WACA,UAEA,IACA,eACU,SAEV,CACA,CAEA,CAAG,EAEH,UACA,sBACA,qBAEA,gCAEA,GACA,cAFA,qCAGA,SACA,SACA,GAGA,CACA,EAoEA,IACA,YACA,aACA,UAEA,CAAG,EAEH,CACA,EAnPA,IADA,KAGA,OACA,CAAG,EACH,CACA,EAzEA,SAEA,UAEA,eACA,OACA,aACA,eAAsB,CACtB,YACA,wBAA+B,CAC/B,qBACA,mBACA,EAMA,EAHA,CAFA,EA5GA,YACA,SACA,eAEA,QAYA,OAVA,gCACA,eAAW,gBAAwB,SAxCnC,KACA,SACA,KAEA,kCAAiC,gBAEjC,iCAUA,OATA,cACA,8BACA,OACA,OAEA,OACA,MAEA,CAAG,EACH,YAAU,eACV,EAwBA,KACA,MACA,OAEA,mBACA,CAAG,EACH,WAEA,CACA,EA2FA,IAEA,OACA,aAOA,CAFA,WAxFA,GAEA,SAEA,KACA,CADwB,CACxB,GACA,CADyB,MACzB,uBACA,aACA,YACA,CAAG,EAEH,gBACA,gBAEA,eACA,QAEA,EADA,cACA,IA8BA,OA5BA,gCACA,SACA,eACA,iCAEA,EADA,cACA,IACA,cACA,8BAEA,IADA,YACA,GACA,yBACA,OACA,OAEA,OACA,MAEA,CAAO,CACP,CACA,4BAEA,CAAG,EAEH,oBACA,QACA,gBAGA,CACA,EAwCA,IAEA,gBACA,YAEA,gBAGA,CAwBA,QACA,EQ0gD2B,aAC3B,WAEA,eACA,sBAFA,iBAEA,GAEA,CAEA,QACA,EA0DA,IAnBA,KAmBA,EAGA,MACA,+BAA6C,cAAoB,KACjE,SACA,mBAAiC,gBAAgB,EAEjD,IACA,eACA,2DACA,kBA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","sources":["webpack://_N_E/./node_modules/ideogram/src/js/version.js","webpack://_N_E/./node_modules/d3-selection/src/selectAll.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-fetch/src/blob.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-fetch/src/buffer.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-dsv/src/dsv.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-dsv/src/csv.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-dsv/src/tsv.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-fetch/src/text.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-fetch/src/dsv.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-fetch/src/image.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-fetch/src/json.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-fetch/src/xml.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-fetch/src/index.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-dispatch/src/dispatch.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-dispatch/src/index.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/formatDecimal.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/exponent.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/formatGroup.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/formatNumerals.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/formatSpecifier.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/formatTrim.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/formatPrefixAuto.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/formatRounded.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/formatTypes.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/identity.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/locale.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/defaultLocale.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/precisionFixed.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/precisionPrefix.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/precisionRound.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-format/src/index.js","webpack://_N_E/./node_modules/ideogram/node_modules/d3-array/src/max.js","webpack://_N_E/./node_modules/ideogram/src/js/init/organism-metadata.js","webpack://_N_E/./node_modules/ideogram/src/js/lib.js","webpack://_N_E/./node_modules/ideogram/src/js/bands/styles.js","webpack://_N_E/./node_modules/ideogram/src/js/init/configure.js","webpack://_N_E/./node_modules/ideogram/src/js/collinear-vertical.js","webpack://_N_E/./node_modules/ideogram/src/js/collinear.js","webpack://_N_E/./node_modules/fflate/esm/browser.js","webpack://_N_E/./node_modules/workbox-core/models/messages/messages.js","webpack://_N_E/./node_modules/workbox-core/models/messages/messageGenerator.js","webpack://_N_E/./node_modules/workbox-core/_private/WorkboxError.js","webpack://_N_E/./node_modules/workbox-core/_private/assert.js","webpack://_N_E/./node_modules/workbox-core/_private/logger.js","webpack://_N_E/./node_modules/workbox-range-requests/utils/calculateEffectiveBoundaries.js","webpack://_N_E/./node_modules/workbox-range-requests/utils/parseRangeHeader.js","webpack://_N_E/./node_modules/workbox-range-requests/createPartialResponse.js","webpack://_N_E/./node_modules/workbox-range-requests/RangeRequestsPlugin.js","webpack://_N_E/./node_modules/workbox-range-requests/index.js","webpack://_N_E/./node_modules/workbox-range-requests/index.mjs","webpack://_N_E/./node_modules/ideogram/src/js/init/caches/cache-lib.js","webpack://_N_E/./node_modules/ideogram/src/js/init/caches/gene-cache-worker.js","webpack://_N_E/./node_modules/ideogram/src/js/init/caches/paralog-cache-worker.js","webpack://_N_E/./node_modules/ideogram/src/js/init/caches/interaction-cache-worker.js","webpack://_N_E/./node_modules/ideogram/src/js/init/caches/gene-structure-cache-worker.js","webpack://_N_E/./node_modules/ideogram/src/js/init/caches/protein-cache-worker.js","webpack://_N_E/./node_modules/ideogram/src/js/init/caches/synonym-cache-worker.js","webpack://_N_E/./node_modules/ideogram/src/js/init/caches/tissue-cache-worker.js","webpack://_N_E/./node_modules/ideogram/src/js/init/caches/variant-cache-worker.js","webpack://_N_E/./node_modules/ideogram/src/js/init/caches/cache.js","webpack://_N_E/./node_modules/ideogram/src/js/init/finish-init.js","webpack://_N_E/./node_modules/ideogram/src/js/ploidy.js","webpack://_N_E/./node_modules/ideogram/src/js/views/chromosome-util.js","webpack://_N_E/./node_modules/ideogram/src/js/layouts/layout.js","webpack://_N_E/./node_modules/ideogram/src/js/layouts/vertical-layout.js","webpack://_N_E/./node_modules/ideogram/src/js/layouts/horizontal-layout.js","webpack://_N_E/./node_modules/ideogram/src/js/layouts/paired-layout.js","webpack://_N_E/./node_modules/ideogram/src/js/layouts/small-layout.js","webpack://_N_E/./node_modules/ideogram/src/js/layouts/layout-adapter.js","webpack://_N_E/./node_modules/ideogram/src/js/init/write-container.js","webpack://_N_E/./node_modules/ideogram/src/js/bands/fetch.js","webpack://_N_E/./node_modules/ideogram/src/js/init/init.js","webpack://_N_E/./node_modules/ideogram/src/js/parsers/bed-parser.js","webpack://_N_E/./node_modules/ideogram/src/js/parsers/tsv-parser.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/heatmap-lib.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/track-labels-collinear.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/heatmap-collinear.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/heatmap-2d.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/track-labels.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/heatmap.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/events.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/labels.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/histogram.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/legend.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/draw.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/synteny-lib.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/synteny-collinear.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/synteny-collinear-horizontal.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/synteny.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/filter.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/process.js","webpack://_N_E/./node_modules/ideogram/src/js/parsers/expression-matrix-parser.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/download.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/annotations.js","webpack://_N_E/./node_modules/ideogram/src/js/annotations/highlight.js","webpack://_N_E/./node_modules/ideogram/src/js/services/eutils-config.js","webpack://_N_E/./node_modules/ideogram/src/js/services/organisms.js","webpack://_N_E/./node_modules/ideogram/src/js/services/services.js","webpack://_N_E/./node_modules/ideogram/src/js/bands/show.js","webpack://_N_E/./node_modules/ideogram/src/js/bands/draw.js","webpack://_N_E/./node_modules/ideogram/src/js/bands/parse.js","webpack://_N_E/./node_modules/ideogram/src/js/bands/bands.js","webpack://_N_E/./node_modules/ideogram/src/js/brush.js","webpack://_N_E/./node_modules/ideogram/src/js/cursor.js","webpack://_N_E/./node_modules/ideogram/src/js/sex-chromosomes.js","webpack://_N_E/./node_modules/ideogram/src/js/coordinate-converters.js","webpack://_N_E/./node_modules/crossfilter2/src/array.js","webpack://_N_E/./node_modules/crossfilter2/src/filter.js","webpack://_N_E/./node_modules/crossfilter2/src/identity.js","webpack://_N_E/./node_modules/crossfilter2/src/null.js","webpack://_N_E/./node_modules/crossfilter2/src/zero.js","webpack://_N_E/./node_modules/crossfilter2/src/heap.js","webpack://_N_E/./node_modules/crossfilter2/src/heapselect.js","webpack://_N_E/./node_modules/crossfilter2/src/bisect.js","webpack://_N_E/./node_modules/crossfilter2/src/permute.js","webpack://_N_E/./node_modules/crossfilter2/src/reduce.js","webpack://_N_E/./node_modules/@ranfdev/deepobj/dist/deepobj.m.js","webpack://_N_E/./node_modules/crossfilter2/src/result.js","webpack://_N_E/./node_modules/crossfilter2/src/index.js","webpack://_N_E/./node_modules/crossfilter2/main.js","webpack://_N_E/./node_modules/ideogram/src/js/filter.js","webpack://_N_E/./node_modules/ideogram/src/js/views/chromosome-model.js","webpack://_N_E/./node_modules/ideogram/src/js/tools/tools.js","webpack://_N_E/./node_modules/ideogram/src/js/model-adapter.js","webpack://_N_E/./node_modules/ideogram/src/js/color.js","webpack://_N_E/./node_modules/ideogram/src/js/range.js","webpack://_N_E/./node_modules/ideogram/src/js/views/chromosome.js","webpack://_N_E/./node_modules/ideogram/src/js/views/draw-chromosomes.js","webpack://_N_E/./node_modules/ideogram/src/js/views/chromosome-labels.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getWindow.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/math.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/userAgent.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js","webpack://_N_E/./node_modules/@popperjs/core/lib/enums.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/orderModifiers.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/debounce.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/mergeByName.js","webpack://_N_E/./node_modules/@popperjs/core/lib/createPopper.js","webpack://_N_E/./node_modules/@popperjs/core/lib/modifiers/eventListeners.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/getBasePlacement.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/getVariation.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/computeOffsets.js","webpack://_N_E/./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js","webpack://_N_E/./node_modules/@popperjs/core/lib/modifiers/computeStyles.js","webpack://_N_E/./node_modules/@popperjs/core/lib/modifiers/applyStyles.js","webpack://_N_E/./node_modules/@popperjs/core/lib/modifiers/offset.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/contains.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/rectToClientRect.js","webpack://_N_E/./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/expandToHashMap.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/detectOverflow.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js","webpack://_N_E/./node_modules/@popperjs/core/lib/modifiers/flip.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/getAltAxis.js","webpack://_N_E/./node_modules/@popperjs/core/lib/utils/within.js","webpack://_N_E/./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js","webpack://_N_E/./node_modules/@popperjs/core/lib/modifiers/arrow.js","webpack://_N_E/./node_modules/@popperjs/core/lib/modifiers/hide.js","webpack://_N_E/./node_modules/@popperjs/core/lib/popper.js","webpack://_N_E/./node_modules/tippy.js/dist/tippy.esm.js","webpack://_N_E/./node_modules/ideogram/src/js/kit/tippy-styles.js","webpack://_N_E/./node_modules/snarkdown/dist/snarkdown.es.js","webpack://_N_E/./node_modules/ideogram/src/js/kit/pathway-viewer.js","webpack://_N_E/./node_modules/ideogram/src/js/kit/analyze-related-genes.js","webpack://_N_E/./node_modules/ideogram/src/js/kit/protein-color.js","webpack://_N_E/./node_modules/ideogram/src/js/kit/protein.js","webpack://_N_E/./node_modules/ideogram/src/js/kit/variant.js","webpack://_N_E/./node_modules/ideogram/src/js/kit/gene-structure.js","webpack://_N_E/./node_modules/ideogram/src/js/kit/wikipathways.js","webpack://_N_E/./node_modules/fast-kde/src/accessor.js","webpack://_N_E/./node_modules/fast-kde/src/bin1d.js","webpack://_N_E/./node_modules/fast-kde/src/deriche.js","webpack://_N_E/./node_modules/fast-kde/src/extent.js","webpack://_N_E/./node_modules/fast-kde/src/nrd.js","webpack://_N_E/./node_modules/fast-kde/src/density1d.js","webpack://_N_E/./node_modules/ideogram/src/js/kit/tissue.js","webpack://_N_E/./node_modules/ideogram/src/js/kit/related-genes.js","webpack://_N_E/./node_modules/ideogram/src/js/ideogram.js","webpack://_N_E/./node_modules/ideogram/src/js/index.js","webpack://_N_E/./node_modules/workbox-core/_version.js","webpack://_N_E/./node_modules/workbox-range-requests/_version.js"],"sourcesContent":["var version = '1.53.0';\nexport default version;\n","import array from \"./array.js\";\nimport {Selection, root} from \"./selection/index.js\";\n\nexport default function(selector) {\n  return typeof selector === \"string\"\n      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])\n      : new Selection([array(selector)], root);\n}\n","function responseBlob(response) {\n  if (!response.ok) throw new Error(response.status + \" \" + response.statusText);\n  return response.blob();\n}\n\nexport default function(input, init) {\n  return fetch(input, init).then(responseBlob);\n}\n","function responseArrayBuffer(response) {\n  if (!response.ok) throw new Error(response.status + \" \" + response.statusText);\n  return response.arrayBuffer();\n}\n\nexport default function(input, init) {\n  return fetch(input, init).then(responseArrayBuffer);\n}\n","var EOL = {},\n    EOF = {},\n    QUOTE = 34,\n    NEWLINE = 10,\n    RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"] || \\\"\\\"\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nfunction pad(value, width) {\n  var s = value + \"\", length = s.length;\n  return length < width ? new Array(width - length + 1).join(0) + s : s;\n}\n\nfunction formatYear(year) {\n  return year < 0 ? \"-\" + pad(-year, 6)\n    : year > 9999 ? \"+\" + pad(year, 6)\n    : pad(year, 4);\n}\n\nfunction formatDate(date) {\n  var hours = date.getUTCHours(),\n      minutes = date.getUTCMinutes(),\n      seconds = date.getUTCSeconds(),\n      milliseconds = date.getUTCMilliseconds();\n  return isNaN(date) ? \"Invalid Date\"\n      : formatYear(date.getUTCFullYear(), 4) + \"-\" + pad(date.getUTCMonth() + 1, 2) + \"-\" + pad(date.getUTCDate(), 2)\n      + (milliseconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \".\" + pad(milliseconds, 3) + \"Z\"\n      : seconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \"Z\"\n      : minutes || hours ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \"Z\"\n      : \"\");\n}\n\nexport default function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // current line number\n        t, // current token\n        eof = N <= 0, // current token followed by EOF?\n        eol = false; // current token followed by EOL?\n\n    // Strip the trailing newline.\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL;\n\n      // Unescape quotes.\n      var i, j = I, c;\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);\n        if ((i = I) >= N) eof = true;\n        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // Find next delimiter or newline.\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      }\n\n      // Return last token before EOF.\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF) row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function preformatBody(rows, columns) {\n    return rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    });\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join(\"\\n\");\n  }\n\n  function formatBody(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return preformatBody(rows, columns).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(value) {\n    return value == null ? \"\"\n        : value instanceof Date ? formatDate(value)\n        : reFormat.test(value += \"\") ? \"\\\"\" + value.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : value;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatBody: formatBody,\n    formatRows: formatRows,\n    formatRow: formatRow,\n    formatValue: formatValue\n  };\n}\n","import dsv from \"./dsv.js\";\n\nvar csv = dsv(\",\");\n\nexport var csvParse = csv.parse;\nexport var csvParseRows = csv.parseRows;\nexport var csvFormat = csv.format;\nexport var csvFormatBody = csv.formatBody;\nexport var csvFormatRows = csv.formatRows;\nexport var csvFormatRow = csv.formatRow;\nexport var csvFormatValue = csv.formatValue;\n","import dsv from \"./dsv.js\";\n\nvar tsv = dsv(\"\\t\");\n\nexport var tsvParse = tsv.parse;\nexport var tsvParseRows = tsv.parseRows;\nexport var tsvFormat = tsv.format;\nexport var tsvFormatBody = tsv.formatBody;\nexport var tsvFormatRows = tsv.formatRows;\nexport var tsvFormatRow = tsv.formatRow;\nexport var tsvFormatValue = tsv.formatValue;\n","function responseText(response) {\n  if (!response.ok) throw new Error(response.status + \" \" + response.statusText);\n  return response.text();\n}\n\nexport default function(input, init) {\n  return fetch(input, init).then(responseText);\n}\n","import {csvParse, dsvFormat, tsvParse} from \"d3-dsv\";\nimport text from \"./text.js\";\n\nfunction dsvParse(parse) {\n  return function(input, init, row) {\n    if (arguments.length === 2 && typeof init === \"function\") row = init, init = undefined;\n    return text(input, init).then(function(response) {\n      return parse(response, row);\n    });\n  };\n}\n\nexport default function dsv(delimiter, input, init, row) {\n  if (arguments.length === 3 && typeof init === \"function\") row = init, init = undefined;\n  var format = dsvFormat(delimiter);\n  return text(input, init).then(function(response) {\n    return format.parse(response, row);\n  });\n}\n\nexport var csv = dsvParse(csvParse);\nexport var tsv = dsvParse(tsvParse);\n","export default function(input, init) {\n  return new Promise(function(resolve, reject) {\n    var image = new Image;\n    for (var key in init) image[key] = init[key];\n    image.onerror = reject;\n    image.onload = function() { resolve(image); };\n    image.src = input;\n  });\n}\n","function responseJson(response) {\n  if (!response.ok) throw new Error(response.status + \" \" + response.statusText);\n  if (response.status === 204 || response.status === 205) return;\n  return response.json();\n}\n\nexport default function(input, init) {\n  return fetch(input, init).then(responseJson);\n}\n","import text from \"./text.js\";\n\nfunction parser(type) {\n  return (input, init) => text(input, init)\n    .then(text => (new DOMParser).parseFromString(text, type));\n}\n\nexport default parser(\"application/xml\");\n\nexport var html = parser(\"text/html\");\n\nexport var svg = parser(\"image/svg+xml\");\n","export {default as blob} from \"./blob.js\";\nexport {default as buffer} from \"./buffer.js\";\nexport {default as dsv, csv, tsv} from \"./dsv.js\";\nexport {default as image} from \"./image.js\";\nexport {default as json} from \"./json.js\";\nexport {default as text} from \"./text.js\";\nexport {default as xml, html, svg} from \"./xml.js\";\n","var noop = {value: () => {}};\n\nfunction dispatch() {\n  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n    if (!(t = arguments[i] + \"\") || (t in _) || /[\\s.]/.test(t)) throw new Error(\"illegal type: \" + t);\n    _[t] = [];\n  }\n  return new Dispatch(_);\n}\n\nfunction Dispatch(_) {\n  this._ = _;\n}\n\nfunction parseTypenames(typenames, types) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t);\n    return {type: t, name: name};\n  });\n}\n\nDispatch.prototype = dispatch.prototype = {\n  constructor: Dispatch,\n  on: function(typename, callback) {\n    var _ = this._,\n        T = parseTypenames(typename + \"\", _),\n        t,\n        i = -1,\n        n = T.length;\n\n    // If no callback was specified, return the callback of the given type and name.\n    if (arguments.length < 2) {\n      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\n      return;\n    }\n\n    // If a type was specified, set the callback for the given type and name.\n    // Otherwise, if a null callback was specified, remove callbacks of the given name.\n    if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n    while (++i < n) {\n      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);\n      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);\n    }\n\n    return this;\n  },\n  copy: function() {\n    var copy = {}, _ = this._;\n    for (var t in _) copy[t] = _[t].slice();\n    return new Dispatch(copy);\n  },\n  call: function(type, that) {\n    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  },\n  apply: function(type, that, args) {\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  }\n};\n\nfunction get(type, name) {\n  for (var i = 0, n = type.length, c; i < n; ++i) {\n    if ((c = type[i]).name === name) {\n      return c.value;\n    }\n  }\n}\n\nfunction set(type, name, callback) {\n  for (var i = 0, n = type.length; i < n; ++i) {\n    if (type[i].name === name) {\n      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));\n      break;\n    }\n  }\n  if (callback != null) type.push({name: name, value: callback});\n  return type;\n}\n\nexport default dispatch;\n","export {default as dispatch} from \"./dispatch.js\";\n","export default function(x) {\n  return Math.abs(x = Math.round(x)) >= 1e21\n      ? x.toLocaleString(\"en\").replace(/,/g, \"\")\n      : x.toString(10);\n}\n\n// Computes the decimal coefficient and exponent of the specified number x with\n// significant digits p, where x is positive and p is in [1, 21] or undefined.\n// For example, formatDecimalParts(1.23) returns [\"123\", 0].\nexport function formatDecimalParts(x, p) {\n  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, Infinity\n  var i, coefficient = x.slice(0, i);\n\n  // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n  // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n  return [\n    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n    +x.slice(i + 1)\n  ];\n}\n","import {formatDecimalParts} from \"./formatDecimal.js\";\n\nexport default function(x) {\n  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;\n}\n","export default function(grouping, thousands) {\n  return function(value, width) {\n    var i = value.length,\n        t = [],\n        j = 0,\n        g = grouping[0],\n        length = 0;\n\n    while (i > 0 && g > 0) {\n      if (length + g + 1 > width) g = Math.max(1, width - length);\n      t.push(value.substring(i -= g, i + g));\n      if ((length += g + 1) > width) break;\n      g = grouping[j = (j + 1) % grouping.length];\n    }\n\n    return t.reverse().join(thousands);\n  };\n}\n","export default function(numerals) {\n  return function(value) {\n    return value.replace(/[0-9]/g, function(i) {\n      return numerals[+i];\n    });\n  };\n}\n","// [[fill]align][sign][symbol][0][width][,][.precision][~][type]\nvar re = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;\n\nexport default function formatSpecifier(specifier) {\n  if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n  var match;\n  return new FormatSpecifier({\n    fill: match[1],\n    align: match[2],\n    sign: match[3],\n    symbol: match[4],\n    zero: match[5],\n    width: match[6],\n    comma: match[7],\n    precision: match[8] && match[8].slice(1),\n    trim: match[9],\n    type: match[10]\n  });\n}\n\nformatSpecifier.prototype = FormatSpecifier.prototype; // instanceof\n\nexport function FormatSpecifier(specifier) {\n  this.fill = specifier.fill === undefined ? \" \" : specifier.fill + \"\";\n  this.align = specifier.align === undefined ? \">\" : specifier.align + \"\";\n  this.sign = specifier.sign === undefined ? \"-\" : specifier.sign + \"\";\n  this.symbol = specifier.symbol === undefined ? \"\" : specifier.symbol + \"\";\n  this.zero = !!specifier.zero;\n  this.width = specifier.width === undefined ? undefined : +specifier.width;\n  this.comma = !!specifier.comma;\n  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;\n  this.trim = !!specifier.trim;\n  this.type = specifier.type === undefined ? \"\" : specifier.type + \"\";\n}\n\nFormatSpecifier.prototype.toString = function() {\n  return this.fill\n      + this.align\n      + this.sign\n      + this.symbol\n      + (this.zero ? \"0\" : \"\")\n      + (this.width === undefined ? \"\" : Math.max(1, this.width | 0))\n      + (this.comma ? \",\" : \"\")\n      + (this.precision === undefined ? \"\" : \".\" + Math.max(0, this.precision | 0))\n      + (this.trim ? \"~\" : \"\")\n      + this.type;\n};\n","// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.\nexport default function(s) {\n  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {\n    switch (s[i]) {\n      case \".\": i0 = i1 = i; break;\n      case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;\n    }\n  }\n  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;\n}\n","import {formatDecimalParts} from \"./formatDecimal.js\";\n\nexport var prefixExponent;\n\nexport default function(x, p) {\n  var d = formatDecimalParts(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1],\n      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n      n = coefficient.length;\n  return i === n ? coefficient\n      : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n      : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n      : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!\n}\n","import {formatDecimalParts} from \"./formatDecimal.js\";\n\nexport default function(x, p) {\n  var d = formatDecimalParts(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1];\n  return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n      : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n}\n","import formatDecimal from \"./formatDecimal.js\";\nimport formatPrefixAuto from \"./formatPrefixAuto.js\";\nimport formatRounded from \"./formatRounded.js\";\n\nexport default {\n  \"%\": (x, p) => (x * 100).toFixed(p),\n  \"b\": (x) => Math.round(x).toString(2),\n  \"c\": (x) => x + \"\",\n  \"d\": formatDecimal,\n  \"e\": (x, p) => x.toExponential(p),\n  \"f\": (x, p) => x.toFixed(p),\n  \"g\": (x, p) => x.toPrecision(p),\n  \"o\": (x) => Math.round(x).toString(8),\n  \"p\": (x, p) => formatRounded(x * 100, p),\n  \"r\": formatRounded,\n  \"s\": formatPrefixAuto,\n  \"X\": (x) => Math.round(x).toString(16).toUpperCase(),\n  \"x\": (x) => Math.round(x).toString(16)\n};\n","export default function(x) {\n  return x;\n}\n","import exponent from \"./exponent.js\";\nimport formatGroup from \"./formatGroup.js\";\nimport formatNumerals from \"./formatNumerals.js\";\nimport formatSpecifier from \"./formatSpecifier.js\";\nimport formatTrim from \"./formatTrim.js\";\nimport formatTypes from \"./formatTypes.js\";\nimport {prefixExponent} from \"./formatPrefixAuto.js\";\nimport identity from \"./identity.js\";\n\nvar map = Array.prototype.map,\n    prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\nexport default function(locale) {\n  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + \"\"),\n      currencyPrefix = locale.currency === undefined ? \"\" : locale.currency[0] + \"\",\n      currencySuffix = locale.currency === undefined ? \"\" : locale.currency[1] + \"\",\n      decimal = locale.decimal === undefined ? \".\" : locale.decimal + \"\",\n      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),\n      percent = locale.percent === undefined ? \"%\" : locale.percent + \"\",\n      minus = locale.minus === undefined ? \"\" : locale.minus + \"\",\n      nan = locale.nan === undefined ? \"NaN\" : locale.nan + \"\";\n\n  function newFormat(specifier) {\n    specifier = formatSpecifier(specifier);\n\n    var fill = specifier.fill,\n        align = specifier.align,\n        sign = specifier.sign,\n        symbol = specifier.symbol,\n        zero = specifier.zero,\n        width = specifier.width,\n        comma = specifier.comma,\n        precision = specifier.precision,\n        trim = specifier.trim,\n        type = specifier.type;\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // The \"\" type, and any invalid type, is an alias for \".12~g\".\n    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = \"g\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    // Compute the prefix and suffix.\n    // For SI-prefix, the suffix is lazily computed.\n    var prefix = symbol === \"$\" ? currencyPrefix : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n        suffix = symbol === \"$\" ? currencySuffix : /[%p]/.test(type) ? percent : \"\";\n\n    // What format function should we use?\n    // Is this an integer type?\n    // Can this type generate exponential notation?\n    var formatType = formatTypes[type],\n        maybeSuffix = /[defgprs%]/.test(type);\n\n    // Set the default precision if not specified,\n    // or clamp the specified precision to the supported range.\n    // For significant precision, it must be in [1, 21].\n    // For fixed precision, it must be in [0, 20].\n    precision = precision === undefined ? 6\n        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n        : Math.max(0, Math.min(20, precision));\n\n    function format(value) {\n      var valuePrefix = prefix,\n          valueSuffix = suffix,\n          i, n, c;\n\n      if (type === \"c\") {\n        valueSuffix = formatType(value) + valueSuffix;\n        value = \"\";\n      } else {\n        value = +value;\n\n        // Determine the sign. -0 is not less than 0, but 1 / -0 is!\n        var valueNegative = value < 0 || 1 / value < 0;\n\n        // Perform the initial formatting.\n        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);\n\n        // Trim insignificant zeros.\n        if (trim) value = formatTrim(value);\n\n        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.\n        if (valueNegative && +value === 0 && sign !== \"+\") valueNegative = false;\n\n        // Compute the prefix and suffix.\n        valuePrefix = (valueNegative ? (sign === \"(\" ? sign : minus) : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n        valueSuffix = (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + valueSuffix + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n        // Break the formatted value into the integer value part that can be\n        // grouped, and fractional or exponential suffix part that is not.\n        if (maybeSuffix) {\n          i = -1, n = value.length;\n          while (++i < n) {\n            if (c = value.charCodeAt(i), 48 > c || c > 57) {\n              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      }\n\n      // If the fill character is not \"0\", grouping is applied before padding.\n      if (comma && !zero) value = group(value, Infinity);\n\n      // Compute the padding.\n      var length = valuePrefix.length + value.length + valueSuffix.length,\n          padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n      // If the fill character is \"0\", grouping is applied after padding.\n      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n      // Reconstruct the final output based on the desired alignment.\n      switch (align) {\n        case \"<\": value = valuePrefix + value + valueSuffix + padding; break;\n        case \"=\": value = valuePrefix + padding + value + valueSuffix; break;\n        case \"^\": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;\n        default: value = padding + valuePrefix + value + valueSuffix; break;\n      }\n\n      return numerals(value);\n    }\n\n    format.toString = function() {\n      return specifier + \"\";\n    };\n\n    return format;\n  }\n\n  function formatPrefix(specifier, value) {\n    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n        k = Math.pow(10, -e),\n        prefix = prefixes[8 + e / 3];\n    return function(value) {\n      return f(k * value) + prefix;\n    };\n  }\n\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix\n  };\n}\n","import formatLocale from \"./locale.js\";\n\nvar locale;\nexport var format;\nexport var formatPrefix;\n\ndefaultLocale({\n  thousands: \",\",\n  grouping: [3],\n  currency: [\"$\", \"\"]\n});\n\nexport default function defaultLocale(definition) {\n  locale = formatLocale(definition);\n  format = locale.format;\n  formatPrefix = locale.formatPrefix;\n  return locale;\n}\n","import exponent from \"./exponent.js\";\n\nexport default function(step) {\n  return Math.max(0, -exponent(Math.abs(step)));\n}\n","import exponent from \"./exponent.js\";\n\nexport default function(step, value) {\n  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n}\n","import exponent from \"./exponent.js\";\n\nexport default function(step, max) {\n  step = Math.abs(step), max = Math.abs(max) - step;\n  return Math.max(0, exponent(max) - exponent(step)) + 1;\n}\n","export {default as formatDefaultLocale, format, formatPrefix} from \"./defaultLocale.js\";\nexport {default as formatLocale} from \"./locale.js\";\nexport {default as formatSpecifier, FormatSpecifier} from \"./formatSpecifier.js\";\nexport {default as precisionFixed} from \"./precisionFixed.js\";\nexport {default as precisionPrefix} from \"./precisionPrefix.js\";\nexport {default as precisionRound} from \"./precisionRound.js\";\n","export default function max(values, valueof) {\n  let max;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value;\n      }\n    }\n  }\n  return max;\n}\n","var organismMetadata = {\n  9606: {\n    commonName: 'Human',\n    scientificName: 'Homo sapiens',\n    assemblies: {\n      default: 'GCF_000001405.26', // GRCh38\n      GRCh38: 'GCF_000001405.26',\n      GRCh37: 'GCF_000001405.13',\n      NCBI36: 'GCF_000001405.12'\n    },\n    hasGeneCache: true,\n    hasParalogCache: true,\n    hasInteractionCache: true,\n    hasGeneStructureCache: true,\n    hasProteinCache: true,\n    hasSynonymCache: true,\n    hasTissueCache: true,\n    hasVariantCache: true\n  },\n  10090: {\n    commonName: 'Mouse',\n    scientificName: 'Mus musculus',\n    assemblies: {\n      default: 'GCF_000001635.27', // GRCm39\n      GRCm39: 'GCF_000001635.27',\n      GRCm38: 'GCF_000001635.20',\n      MGSCv37: 'GCF_000001635.18'\n    },\n    hasGeneCache: true,\n    hasParalogCache: true,\n    hasInteractionCache: true,\n    hasGeneStructureCache: true,\n    hasProteinCache: true,\n    hasSynonymCache: true\n  },\n  9598: {\n    commonName: 'Chimpanzee',\n    scientificName: 'Pan troglodytes',\n    assemblies: {\n      'default': 'GCF_028858775.1',\n      'NHGRI_mPanTro3-v1.1-hic.freeze_pri': 'GCF_028858775.1',\n      'Pan_tro 3.0': 'GCF_000001515.7'\n    },\n    hasGeneCache: true,\n    hasSynonymCache: true\n  },\n  10116: {\n    commonName: 'Rat',\n    scientificName: 'Rattus norvegicus',\n    assemblies: {\n      'default': 'GCF_000001895.5',\n      'Rnor_6.0': 'GCF_000001895.5'\n    },\n    hasGeneCache: true,\n    hasParalogCache: true,\n    hasSynonymCache: true\n  },\n  3702: {\n    commonName: 'Thale cress',\n    scientificName: 'Arabidopsis thaliana',\n    assemblies: {\n      default: 'GCF_000001735.3', // TAIR10\n      TAIR10: 'GCF_000001735.3'\n    }\n  },\n  4530: {\n    commonName: 'Rice',\n    scientificName: 'Oryza sativa',\n    assemblies: {\n      'default': 'GCA_001433935.1',\n      'IRGSP-1.0': 'GCA_001433935.1'\n    }\n  },\n  4577: {\n    commonName: 'Maize',\n    scientificName: 'Zea mays',\n    assemblies: {\n      'default': 'GCA_000005005.5',\n      'IRGSP-1.0': 'GCA_001433935.1'\n    }\n  },\n  4641: {\n    commonName: 'Banana',\n    scientificName: 'Musa acuminata',\n    assemblies: {\n      default: 'mock'\n    }\n  },\n  7227: {\n    commonName: 'Fly',\n    scientificName: 'Drosophila melanogaster',\n    assemblies: {\n      'default': 'GCA_000001215.4',\n      'Release 6 plus ISO1 MT': 'GCA_000001215.4'\n    },\n    hasSynonymCache: true\n  },\n  7165: {\n    commonName: 'Mosquito',\n    scientificName: 'Anopheles gambiae',\n    assemblies: {\n      default: 'GCF_000005575.2'\n    }\n  },\n  746128: {\n    commonName: 'Aspergillis fumigatus',\n    scientificName: 'Aspergillis fumigatus',\n    assemblies: {\n      default: 'GCF_000002655.1'\n    }\n  },\n  227321: {\n    scientificName: 'Aspergillus nidulans',\n    assemblies: {\n      default: 'GCF_000149205.2'\n    }\n  },\n  5061: {\n    commonName: 'black mold',\n    scientificName: 'Aspergillus niger',\n    assemblies: {\n      default: 'GCF_003184595.1'\n    }\n  },\n  5062: {\n    commonName: 'koji',\n    scientificName: 'Aspergillus oryzae',\n    assemblies: {\n      default: 'GCF_000184455.2'\n    }\n  },\n  15368: {\n    commonName: 'stiff brome',\n    scientificName: 'Brachypodium distachyon',\n    assemblies: {\n      default: 'GCF_000005505.3'\n    }\n  },\n  60711: {\n    commonName: 'green monkey',\n    scientificName: 'Chlorocebus sabaeus',\n    assemblies: {\n      default: 'GCF_015252025.1'\n    }\n  },\n  7719: {\n    commonName: 'Vase tunicate',\n    scientificName: 'Ciona intestinalis',\n    assemblies: {\n      default: 'GCF_000224145.3'\n    }\n  },\n  9685: {\n    commonName: 'Cat',\n    scientificName: 'Felis catus',\n    assemblies: {\n      default: 'GCF_000181335.3'\n    },\n    hasGeneCache: true\n  },\n  9031: {\n    commonName: 'Chicken',\n    scientificName: 'Gallus gallus',\n    assemblies: {\n      default: 'GCF_000002315.6'\n    },\n    hasGeneCache: true,\n    hasParalogCache: true\n  },\n  9593: {\n    commonName: 'Gorilla',\n    scientificName: 'Gorilla gorilla',\n    assemblies: {\n      default: 'GCF_008122165.1'\n    }\n  },\n  4513: {\n    commonName: 'Barley',\n    scientificName: 'Hordeum vulgare',\n    assemblies: {\n      default: 'GCA_901482405.1'\n    }\n  },\n  9541: {\n    commonName: 'Crab-eating macaque',\n    scientificName: 'Macaca fascicularis',\n    assemblies: {\n      default: 'GCF_000364345.1'\n    },\n    hasGeneCache: true,\n    hasParalogCache: true,\n    hasSynonymCache: true\n  },\n  9544: {\n    commonName: 'Rhesus macaque',\n    scientificName: 'Macaca mulatta',\n    assemblies: {\n      default: 'GCF_003339765.1'\n    },\n    hasGeneCache: true,\n    hasParalogCache: true,\n    hasSynonymCache: true\n  },\n  9597: {\n    commonName: 'Bonobo',\n    scientificName: 'Pan paniscus',\n    assemblies: {\n      default: 'GCF_013052645.1'\n    }\n  },\n  9615: {\n    commonName: 'Dog',\n    scientificName: 'Canis lupus familiaris',\n    assemblies: {\n      default: 'GCF_014441545.1'\n    },\n    hasGeneCache: true,\n    hasParalogCache: true,\n    hasSynonymCache: true\n  },\n  9823: {\n    commonName: 'Pig',\n    scientificName: 'Sus scrofa',\n    assemblies: {\n      default: 'GCF_000003025.6'\n    },\n    hasGeneCache: true,\n    hasParalogCache: true,\n    hasSynonymCache: true\n  },\n  4932: {\n    commonName: 'Yeast',\n    scientificName: 'Saccharomyces cerevisiae',\n    assemblies: {\n      default: 'GCA_000146045.2',\n      R64: 'GCA_000146045.2'\n    }\n  },\n  5833: {\n    commonName: 'malaria parasite',\n    scientificName: 'Plasmodium falciparum',\n    assemblies: {\n      default: 'GCA_000002765.3',\n      GCA_000002765: 'GCA_000002765.3'\n    }\n  },\n  6239: {\n    commonName: 'worm',\n    scientificName: 'Caenorhabditis elegans',\n    assemblies: {\n      default: 'GCF_000002985.6'\n    },\n    hasGeneCache: true,\n    hasParalogCache: true,\n    hasSynonymCache: true\n  },\n  4081: {\n    commonName: 'tomato',\n    scientificName: 'Solanum lycopersicum',\n    assemblies: {\n      default: 'GCF_000188115.4'\n    }\n  },\n  4072: {\n    commonName: 'pepper',\n    scientificName: 'Capsicum annuum',\n    assemblies: {\n      default: 'GCF_000710875.1'\n    }\n  },\n  3694: {\n    commonName: 'black cottonwood',\n    scientificName: 'Populus trichocarpa',\n    assemblies: {\n      default: 'GCF_000002775.5'\n    }\n  }\n};\n\nexport {organismMetadata};\n","/**\n * @fileoverview A collection of Ideogram methods that don't fit elsewhere.\n */\n\nimport {select, selectAll} from 'd3-selection';\nimport * as d3fetch from 'd3-fetch';\nimport * as d3brush from 'd3-brush';\nimport * as d3dispatch from 'd3-dispatch';\nimport * as d3format from 'd3-format';\nimport {scaleLinear} from 'd3-scale';\nimport {max} from 'd3-array';\n\nimport {organismMetadata} from './init/organism-metadata';\n\nvar d3 = Object.assign(\n  {}, d3fetch, d3brush, d3dispatch, d3format\n);\n\nd3.select = select;\nd3.selectAll = selectAll;\nd3.scaleLinear = scaleLinear;\nd3.max = max;\n\n/**\n * Is the assembly in this.config an NCBI Assembly accession?\n *\n * @returns {boolean}\n */\nfunction assemblyIsAccession() {\n  return (\n    'assembly' in this.config &&\n    /(GCF_|GCA_)/.test(this.config.assembly)\n  );\n}\n\n/**\n * Is the assembly in this.config not from GenBank?\n *\n * @returns {boolean}\n */\nfunction hasNonGenBankAssembly(ideo) {\n  return (\n    'assembly' in ideo.config &&\n    /(GCA_)/.test(ideo.config.assembly) === false\n  );\n}\n\n/**\n * Is the assembly in this.config from GenBank?\n *\n * @returns {boolean}\n */\nfunction hasGenBankAssembly(ideo) {\n  return (\n    'assembly' in ideo.config &&\n    /(GCA_)/.test(ideo.config.assembly)\n  );\n}\n\nfunction getDir(dir) {\n  var script, tmp, protocol, dataDir, ideogramInLeaf,\n    scripts = document.scripts,\n    version = Ideogram.version;\n\n  if (location.pathname.includes('/examples/vanilla/') === false) {\n    return (\n      `https://cdn.jsdelivr.net/npm/ideogram@${version}/dist/data/${dir}`\n    );\n  }\n\n  for (var i = 0; i < scripts.length; i++) {\n    script = scripts[i];\n    ideogramInLeaf = /ideogram/.test(script.src.split('/').slice(-1));\n    if ('src' in script && ideogramInLeaf) {\n      tmp = script.src.split('//');\n      protocol = tmp[0];\n      tmp = '/' + tmp[1].split('/').slice(0, -2).join('/');\n      dataDir = protocol + '//' + tmp + '/data/' + dir;\n      return dataDir;\n    }\n  }\n\n  return '../data/' + dir;\n}\n\n/** Try request, and if failed then retry with URL lacking extension */\nfunction fetchWithRetry(url, isRetry=false) {\n  return fetch(url)\n    .then((response) => {\n      if (response.ok) {\n        return response;\n      } else {\n        if (isRetry === false) {\n          var urlWithoutExtension = url.replace('.json', '');\n          return fetchWithRetry(urlWithoutExtension, true);\n        } else {\n          throw Error('Fetch failed for ' + url);\n        }\n      }\n    });\n}\n\n/**\n * Returns directory used to fetch data for bands and annotations\n *\n * This simplifies ideogram configuration.  By default, the dataDir is\n * set to an external CDN unless we're serving from the local Ideogram\n * working directory\n *\n * @returns {String}\n */\nfunction getDataDir() {\n  return getDir('bands/native/');\n}\n\n/**\n * Rounds a float (e.g. SVG coordinate) to two decimal places\n *\n * @param coord Floating-point number, e.g. 42.1234567890\n * @returns {number} Rounded value, e.g. 42.12\n */\nfunction round(coord) {\n  // Per http://stackoverflow.com/a/9453447, below method is fastest\n  return Math.round(coord * 100) / 100;\n}\n\n/**\n * Convert e.g. 1000 to 1 k, 1500000 to 1.5 M, etc.\n * Used to format 1500000 base pairs to e.g. 1.5 Mbp\n *\n * Adapted from https://stackoverflow.com/a/9462382/10564415\n */\nfunction formatSiPrefix(num, digits) {\n  const lookup = [\n    {value: 1, symbol: ''},\n    {value: 1e3, symbol: 'k'},\n    {value: 1e6, symbol: 'M'},\n    {value: 1e9, symbol: 'G'},\n    {value: 1e12, symbol: 'T'},\n    {value: 1e15, symbol: 'P'},\n    {value: 1e18, symbol: 'E'}\n  ];\n  const rx = /\\.0+$|(\\.[0-9]*[1-9])0+$/;\n  var item = lookup.slice().reverse().find(function(item) {\n    return num >= item.value;\n  });\n  // eslint-disable-next-line max-len\n  return item ? (num / item.value).toFixed(digits).replace(rx, '$1') + ' ' + item.symbol : '0';\n}\n\nfunction onDidRotate(chrModel) {\n  call(this.onDidRotateCallback, chrModel);\n}\n\n/**\n * Get ideogram SVG container\n */\nfunction getSvg() {\n  return d3.select(this.selector).node();\n}\n\n/** Request data with Ideogram's authorization bearer token */\nfunction fetchWithAuth(url, contentType) {\n  var ideo = this,\n    config = ideo.config,\n    headers = new Headers();\n\n  if (config.accessToken) {\n    headers = new Headers({Authorization: 'Bearer ' + config.accessToken});\n  }\n\n  if (contentType === 'text') {\n    return d3.text(url, {headers: headers});\n  } else {\n    return d3.json(url, {headers: headers});\n  }\n}\n\n/** getTaxid(), but without need to initialize ideogram  */\nfunction getEarlyTaxid(name) {\n  name = slug(name);\n  for (const taxid in organismMetadata) {\n    const organism = organismMetadata[taxid];\n    const commonName = slug(organism.commonName);\n    const scientificName = slug(organism.scientificName);\n    if (commonName === name || scientificName === name) {\n      return taxid;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get organism's taxid (NCBI Taxonomy ID) given its common or scientific name\n */\nfunction getTaxid(name) {\n  var organism, taxid, commonName, scientificName,\n    ideo = this,\n    organisms = ideo.organisms;\n\n  name = slug(name);\n\n  for (taxid in organisms) {\n    organism = organisms[taxid];\n    commonName = slug(organism.commonName);\n    scientificName = slug(organism.scientificName);\n    if (commonName === name || scientificName === name) {\n      return taxid;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get organism's common name given its taxid\n */\nfunction getCommonName(taxid) {\n  var ideo = this;\n  if (taxid in ideo.organisms) {\n    return ideo.organisms[taxid].commonName;\n  }\n  return null;\n}\n\n/**\n * Get organism's scientific name given its taxid\n */\nfunction getScientificName(taxid) {\n  var ideo = this;\n  if (taxid in ideo.organisms) {\n    return ideo.organisms[taxid].scientificName;\n  }\n  return null;\n}\n\n/** Convert string to camelcase */\nexport function camel(str) {\n  const camelCaseString = str\n    .split(/[ _-]/g)\n    .map((token, i) => {\n      if (i > 0) {\n        return token[0].toUpperCase() + token.slice(1);\n      } else {\n        return token;\n      }\n    })\n    .join('');\n\n  return camelCaseString;\n}\n\n/**\n* Examples:\n* \"Homo sapiens\" -> \"homo-sapiens\"\n* \"Canis lupus familiaris\" -> \"canis-lupus-familiaris\"\n*/\nfunction slug(value) {\n  if (typeof value === 'undefined') return '';\n  return value.toLowerCase().replace(/ /g, '-');\n}\n\n// Determine if a string is a Roman numeral\n// From https://stackoverflow.com/a/48601418\nfunction isRoman(s) {\n  // http://stackoverflow.com/a/267405/1447675\n  return /^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/i.test(s);\n}\n\n// Convert Roman numeral to integer\n// From https://stackoverflow.com/a/48601418\nfunction parseRoman(s) {\n  var val = {M: 1000, D: 500, C: 100, L: 50, X: 10, V: 5, I: 1};\n  return s.toUpperCase().split('').reduce(function(r, a, i, aa) {\n    return val[a] < val[aa[i + 1]] ? r - val[a] : r + val[a];\n  }, 0);\n}\n\n/**\n* Download a PNG image of the ideogram\n*\n* Includes any annotations, but not legend.\n*/\nfunction downloadPng(ideo) {\n  var ideoSvg = document.querySelector(ideo.selector);\n\n  // Create a hidden canvas.  This will contain the raster image to download.\n  var canvas = document.createElement('canvas');\n  var canvasId = '_ideo-undisplayed-dl-canvas';\n  canvas.setAttribute('style', 'display: none');\n  canvas.setAttribute('id', canvasId);\n  var width = ideoSvg.width.baseVal.value + 30;\n  var ideoSvgClone = ideoSvg.cloneNode(true);\n  ideoSvgClone.style.left = '';\n  canvas.setAttribute('width', width);\n  document.body.appendChild(canvas);\n\n  // Called after PNG image is created from data URL\n  function triggerDownload(imgUrl) {\n    var evt = new MouseEvent('click', {\n      view: window,\n      bubbles: false,\n      cancelable: true\n    });\n\n    var a = document.createElement('a');\n    a.setAttribute('download', 'ideogram.png');\n    a.setAttribute('href', imgUrl);\n    a.setAttribute('target', '_blank');\n\n    // Enables easy testing\n    a.setAttribute('id', '_ideo-undisplayed-dl-image-link');\n    a.setAttribute('style', 'display: none;');\n    document.body.appendChild(a);\n\n    a.dispatchEvent(evt);\n    canvas.remove();\n  }\n\n  var canvas = document.getElementById(canvasId);\n\n  // Enlarge canvas and disable smoothing, for higher resolution PNG\n  canvas.width *= 2;\n  canvas.height *= 2;\n  var ctx = canvas.getContext('2d');\n  ctx.setTransform(2, 0, 0, 2, 0, 0);\n  ctx.imageSmoothingEnabled = false;\n\n  var data = (new XMLSerializer()).serializeToString(ideoSvgClone);\n  var domUrl = window.URL || window.webkitURL || window;\n\n  var img = new Image();\n  var svgBlob = new Blob([data], {type: 'image/svg+xml;charset=utf-8'});\n  var url = domUrl.createObjectURL(svgBlob);\n\n  img.onload = function() {\n    ctx.drawImage(img, 0, 0);\n    domUrl.revokeObjectURL(url);\n\n    var imgUrl = canvas\n      .toDataURL('image/png')\n      .replace('image/png', 'image/octet-stream');\n\n    triggerDownload(imgUrl);\n  };\n\n  img.src = url;\n}\n\nfunction getFont(ideo) {\n  const config = ideo.config;\n\n  let family = 'sans-serif';\n  if (config.fontFamily) {\n    family = config.fontFamily;\n  }\n  let weight = 600;\n  if (config.fontWeight) {\n    weight = config.fontWeight;\n  }\n\n  const labelSize = config.annotLabelSize ? config.annotLabelSize : 13;\n  const font = weight + ' ' + labelSize + 'px ' + family;\n\n  return font;\n}\n\n/**\n * Get width and height of given text in pixels.\n *\n * Background: https://erikonarheim.com/posts/canvas-text-metrics/\n */\nfunction getTextSize(text, ideo) {\n  var font = getFont(ideo);\n\n  // re-use canvas object for better performance\n  var canvas =\n    getTextSize.canvas ||\n    (getTextSize.canvas = document.createElement('canvas'));\n  var context = canvas.getContext('2d');\n  context.font = font;\n  var metrics = context.measureText(text);\n\n  // metrics.width is less precise than technique below\n  var right = metrics.actualBoundingBoxRight;\n  var left = metrics.actualBoundingBoxLeft;\n  var width = Math.abs(left) + Math.abs(right);\n\n  const height =\n    Math.abs(metrics.actualBoundingBoxAscent) +\n    Math.abs(metrics.actualBoundingBoxDescent);\n\n  return {width, height};\n}\n\n/** Clone a nested array */\nfunction deepCopy(array) {\n  return JSON.parse(JSON.stringify(array));\n}\n\n/** Naively pluralizes a word, if count is > 1 */\nexport function pluralize(word, count) {\n  return word + (count > 1 ? 's' : '');\n}\n\n/**\n * Convert hexadecimal color to RGB color\n * Source: https://stackoverflow.com/a/5624139/10564415\n */\nexport function hexToRgb(hex) {\n  // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n  var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n  hex = hex.replace(shorthandRegex, function(m, r, g, b) {\n    return r + r + g + g + b + b;\n  });\n\n  var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16)\n  } : null;\n}\n\n// http://stackoverflow.com/a/5624139\nfunction componentToHex(c) {\n  var hex = parseInt(c, 10).toString(16);\n  return hex.length === 1 ? '0' + hex : hex;\n}\n\nfunction rgbToHex(r, g, b) {\n  return (\n    '#' +\n    componentToHex(r) +\n    componentToHex(g) +\n    componentToHex(b)\n  );\n}\n\nfunction rgbColorToHex(color) {\n  const rgb = color.split('rgb(')[1].trim(')').split(', ');\n  const hex = rgbToHex(rgb[0], rgb[1], rgb[2]);\n  return hex;\n}\n\n/**\n * If hex color is low contrast with white, then darken it.\n *\n * @param {String} color Initial color that fills the shape, in hex\n */\nexport function ensureContrast(color, bgColor='#FFF') {\n  if (color.slice(0, 3) === 'rgb') color = rgbColorToHex(color);\n  if (color[0] !== '#') return color; // preserve non-hex color, e.g. \"purple\"\n  const rgb = hexToRgb(color);\n\n  if (bgColor === '#FFF') {\n    // If low contrast, darken\n    if (rgb.r > 150 && rgb.g > 150 && rgb.b > 150) {\n      color = `rgb(${rgb.r - 30}, ${rgb.g - 30}, ${rgb.b - 30})`;\n    }\n\n    // If lower contrast, darken more\n    if (rgb.r > 200 && rgb.g > 200 && rgb.b > 200) {\n      color = `rgb(${rgb.r - 50}, ${rgb.g - 50}, ${rgb.b - 50})`;\n    }\n  } else {\n    const bgRgb = hexToRgb(bgColor);\n    const contrast = getContrast(\n      [rgb.r, rgb.g, rgb.b],\n      [bgRgb.r, bgRgb.g, bgRgb.b]\n    );\n    if (contrast < 3) {\n      color = `rgb(230, 230, 230)`;\n    }\n  }\n\n  return color;\n}\n\n/** https://stackoverflow.com/a/9733420 */\nconst RED = 0.2126;\nconst GREEN = 0.7152;\nconst BLUE = 0.0722;\n\nconst GAMMA = 2.4;\n\n/** https://stackoverflow.com/a/9733420 */\nfunction luminance(r, g, b) {\n  var a = [r, g, b].map((v) => {\n    v /= 255;\n    return (\n      v <= 0.03928\n        ? v / 12.92\n        : Math.pow((v + 0.055) / 1.055, GAMMA)\n    );\n  });\n  return a[0] * RED + a[1] * GREEN + a[2] * BLUE;\n}\n\n/** https://stackoverflow.com/a/9733420 */\nfunction getContrast(rgb1, rgb2) {\n  var lum1 = luminance(...rgb1);\n  var lum2 = luminance(...rgb2);\n  var brightest = Math.max(lum1, lum2);\n  var darkest = Math.min(lum1, lum2);\n  return (brightest + 0.05) / (darkest + 0.05);\n}\n\n\nexport function adjustBrightness(color, brightness) {\n  if (color[0] !== '#') return color; // preserve non-hex color, e.g. \"purple\"\n  const rgb = hexToRgb(color);\n  const br = brightness;\n  const newRgb = {r: rgb.r * br, g: rgb.g * br, b: rgb.b * br};\n  const newColor = `rgb(${newRgb.r}, ${newRgb.g}, ${newRgb.b})`;\n\n  return newColor;\n}\n\nexport function getTippyConfig() {\n  return {\n    theme: 'light-border',\n    allowHTML: true,\n    popperOptions: { // Docs: https://atomiks.github.io/tippyjs/v6/all-props/#popperoptions\n      modifiers: [ // Docs: https://popper.js.org/docs/v2/modifiers\n        {\n          name: 'flip'\n        }\n      ]\n    },\n    onShow: function() {\n      // Ensure only 1 tippy tooltip is displayed at a time\n      document.querySelectorAll('[data-tippy-root]')\n        .forEach(tippyNode => tippyNode.remove());\n    }\n  };\n}\n\nexport {\n  assemblyIsAccession, hasNonGenBankAssembly, hasGenBankAssembly, getDataDir,\n  getDir, round, formatSiPrefix, onDidRotate, getSvg, d3, getEarlyTaxid,\n  getTaxid, getCommonName, getScientificName, slug, isRoman, parseRoman,\n  downloadPng, fetchWithRetry, getTextSize, getFont, deepCopy,\n  fetchWithAuth as fetch\n};\n","var staticColors, staticCss, staticGradients;\n\n// Gradient colors for each class, for polished rendering\nstaticColors = [\n  ['gneg', '#FFF', '#FFF', '#DDD'],\n  ['gpos25', '#C8C8C8', '#DDD', '#BBB'],\n  ['gpos33', '#BBB', '#BBB', '#AAA'],\n  ['gpos50', '#999', '#AAA', '#888'],\n  ['gpos66', '#888', '#888', '#666'],\n  ['gpos75', '#777', '#777', '#444'],\n  ['gpos100', '#444', '#666', '#000'],\n  ['acen', '#FEE', '#FEE', '#FDD'],\n  ['noBands', '#BBB', '#BBB', '#AAA']\n];\n\nstaticCss =\n  '#_ideogram {padding-left: 5px;} ' +\n  '#_ideogram .labeled {padding-left: 15px;} ' +\n  '#_ideogram.labeledLeft {padding-left: 15px; padding-top: 15px;} ' +\n  // Tahoma has great readability and space utilization at small sizes\n  // More: http://ux.stackexchange.com/a/3334\n  '#_ideogram text {font: 9px Tahoma; fill: #000;} ' +\n  '#_ideogram .italic {font-style: italic;} ' +\n  '#_ideogram .chromosome {cursor: pointer; fill: #AAA;}' +\n  '#_ideogram.no-rotate .chromosome {cursor: default;} ' +\n  '#_ideogram .chrLabel, #_ideogram .annot {cursor: pointer;}' +\n  '#_ideogram .chrSetLabel {font-weight: bolder;}' +\n  '#_ideogram .ghost {opacity: 0.2;}' +\n  '#_ideogram .hidden {display: none;}' +\n  '#_ideogram .bandLabelStalk line {stroke: #AAA; stroke-width: 1;}' +\n  '#_ideogram .syntenyBorder {stroke:#AAA;stroke-width:1;}' +\n  '#_ideogram rect.cursor {' +\n  '  fill: #F00;' +\n  '  stroke: #F00;' +\n  '  fill-opacity: .3;' +\n  '  shape-rendering: crispEdges;' +\n  '}' +\n  '#_ideogram .brush .selection {' +\n  '  fill: #F00;' +\n  '  stroke: #F00;' +\n  '  fill-opacity: .3;' +\n  '  shape-rendering: crispEdges;' +\n  '}' +\n  '#_ideogram .noBands {fill: #AAA;}' +\n  // NCBI stain density colors\n  '#_ideogram .gneg {fill: #FFF}' +\n  '#_ideogram .gpos25 {fill: #BBB}' +\n  '#_ideogram .gpos33 {fill: #AAA}' +\n  '#_ideogram .gpos50 {fill: #888}' +\n  '#_ideogram .gpos66 {fill: #666}' +\n  '#_ideogram .gpos75 {fill: #444}' +\n  '#_ideogram .gpos100 {fill: #000}' +\n  '#_ideogram .gpos {fill: #000}' +\n  '#_ideogram .acen {fill: #FDD}' +\n  '#_ideogram .stalk {fill: #CCE;}' +\n  '#_ideogram .gvar {fill: #DDF}' +\n  // Used when overlaid with annotations\n  '#_ideogram.faint .gneg {fill: #FFF}' +\n  '#_ideogram.faint .gpos25 {fill: #EEE}' +\n  '#_ideogram.faint .gpos33 {fill: #EEE}' +\n  '#_ideogram.faint .gpos50 {fill: #EEE}' +\n  '#_ideogram.faint .gpos66 {fill: #EEE}' +\n  '#_ideogram.faint .gpos75 {fill: #EEE}' +\n  '#_ideogram.faint .gpos100 {fill: #DDD}' +\n  '#_ideogram.faint .gpos {fill: #DDD}' +\n  '#_ideogram.faint .acen {fill: #FEE}' +\n  '#_ideogram.faint .stalk {fill: #EEF;}' +\n  '#_ideogram.faint .gvar {fill: #EEF}' +\n  // For sheen, i.e. the soft shine in chromosomes\n  '#_ideogram .gneg {fill: url(\"#gneg\")} ' +\n  '#_ideogram .gpos25 {fill: url(\"#gpos25\")} ' +\n  '#_ideogram .gpos33 {fill: url(\"#gpos33\")} ' +\n  '#_ideogram .gpos50 {fill: url(\"#gpos50\")} ' +\n  '#_ideogram .gpos66 {fill: url(\"#gpos66\")} ' +\n  '#_ideogram .gpos75 {fill: url(\"#gpos75\")} ' +\n  '#_ideogram .gpos100 {fill: url(\"#gpos100\")} ' +\n  '#_ideogram .gpos {fill: url(\"#gpos100\")} ' +\n  '#_ideogram .acen {fill: url(\"#acen\")} ' +\n  '#_ideogram .stalk {fill: url(\"#stalk\")} ' +\n  '#_ideogram .gvar {fill: url(\"#gvar\")} ' +\n  '#_ideogram .noBands {fill: url(\"#noBands\")} ' +\n  '#_ideogram .chromosome {fill: url(\"#noBands\")} ';\n\nstaticGradients =\n  '<pattern id=\"stalk\" width=\"2\" height=\"1\" patternUnits=\"userSpaceOnUse\" ' +\n  'patternTransform=\"rotate(30 0 0)\">' +\n  '<rect x=\"0\" y=\"0\" width=\"10\" height=\"2\" fill=\"#CCE\" /> ' +\n  '<line x1=\"0\" y1=\"0\" x2=\"0\" y2=\"100%\" style=\"stroke:#88B; ' +\n  'stroke-width:0.7;\" />' +\n  '</pattern>' +\n  '<pattern id=\"gvar\" width=\"2\" height=\"1\" patternUnits=\"userSpaceOnUse\" ' +\n  'patternTransform=\"rotate(-30 0 0)\">' +\n  '<rect x=\"0\" y=\"0\" width=\"10\" height=\"2\" fill=\"#DDF\" /> ' +\n  '<line x1=\"0\" y1=\"0\" x2=\"0\" y2=\"100%\" style=\"stroke:#99C; ' +\n  'stroke-width:0.7;\" />' +\n  '</pattern>';\n\nexport {staticColors, staticCss, staticGradients};\n","import {organismMetadata} from './organism-metadata';\nimport {staticCss} from './../bands/styles';\n\nfunction configurePloidy(ideo) {\n  if (!ideo.config.ploidy) ideo.config.ploidy = 1;\n\n  if (ideo.config.ploidy > 1) {\n    ideo.sexChromosomes = {};\n    if (!ideo.config.sex) {\n      // Default to 'male' per human, mouse reference genomes.\n      // TODO: The default sex value should probably be the heterogametic sex,\n      // i.e. whichever sex has allosomes that differ in morphology.\n      // In mammals and most insects that is the male.\n      // However, in birds and reptiles, that is female.\n      ideo.config.sex = 'male';\n    }\n    if (ideo.config.ploidy === 2 && !ideo.config.ancestors) {\n      ideo.config.ancestors = {M: '#ffb6c1', P: '#add8e6'};\n      ideo.config.ploidyDesc = 'MP';\n    }\n  }\n}\n\nfunction configureHeight(ideo) {\n  var container, rect, chrHeight;\n\n  if (!ideo.config.chrHeight) {\n    container = ideo.config.container;\n    rect = document.querySelector(container).getBoundingClientRect();\n\n    if (ideo.config.orientation === 'vertical') {\n      chrHeight = rect.height;\n    } else {\n      chrHeight = rect.width;\n    }\n\n    if (container === 'body' || chrHeight === 0) chrHeight = 400;\n    ideo.config.chrHeight = chrHeight;\n  }\n}\n\nfunction configureWidth(ideo) {\n  var chrWidth, chrHeight;\n\n  if (!ideo.config.chrWidth) {\n    chrWidth = 10;\n    chrHeight = ideo.config.chrHeight;\n\n    if (chrHeight < 900 && chrHeight > 500) {\n      chrWidth = Math.round(chrHeight / 40);\n    } else if (chrHeight >= 900) {\n      chrWidth = Math.round(chrHeight / 45);\n    }\n    ideo.config.chrWidth = chrWidth;\n  }\n}\n\nfunction configureMargin(ideo) {\n  if (ideo.config.geometry && ideo.config.geometry === 'collinear') {\n    if ('chrMargin' in ideo.config === false) {\n      ideo.config.chrMargin = 0;\n    }\n    return;\n  }\n  if (!ideo.config.chrMargin) {\n    if (ideo.config.ploidy === 1) {\n      ideo.config.chrMargin = 10;\n    } else {\n      // Defaults polyploid chromosomes to relatively small interchromatid gap\n      ideo.config.chrMargin = Math.round(ideo.config.chrWidth / 4);\n    }\n  }\n  if (ideo.config.showBandLabels) ideo.config.chrMargin += 20;\n}\n\nfunction configureBump(ideo) {\n  ideo.bump = Math.round(ideo.config.chrHeight / 125);\n  ideo.adjustedBump = false;\n  if (ideo.config.chrHeight < 200) {\n    ideo.adjustedBump = true;\n    ideo.bump = 4;\n  }\n}\n\nfunction configureSingleChromosome(config, ideo) {\n  if (config.chromosome) {\n    ideo.config.chromosomes = [config.chromosome];\n    if ('showBandLabels' in config === false) {\n      ideo.config.showBandLabels = true;\n    }\n    if ('rotatable' in config === false) ideo.config.rotatable = false;\n  }\n}\n\nfunction configureOrganisms(config, ideo) {\n  ideo.organisms = Object.assign({}, organismMetadata);\n  if (config.taxid && config.organismMetadata) ideo.organisms[config.taxid] = config.organismMetadata\n  ideo.organismsWithBands = Object.assign({}, ideo.organisms);\n}\n\nfunction configureCallbacks(config, ideo) {\n  if (config.onLoad) ideo.onLoadCallback = config.onLoad;\n  if (config.onLoadAnnots) ideo.onLoadAnnotsCallback = config.onLoadAnnots;\n  if (config.onBeforeDrawAnnots) {\n    ideo.onBeforeDrawAnnotsCallback = config.onBeforeDrawAnnots;\n  }\n  if (config.onDrawAnnots) ideo.onDrawAnnotsCallback = config.onDrawAnnots;\n  if (config.onBrushMove) ideo.onBrushMoveCallback = config.onBrushMove;\n  if (config.onBrushEnd) ideo.onBrushEndCallback = config.onBrushEnd;\n  if (config.onCursorMove) ideo.onCursorMoveCallback = config.onCursorMove;\n  if (config.onDidRotate) ideo.onDidRotateCallback = config.onDidRotate;\n  if (config.onWillShowAnnotTooltip) {\n    ideo.onWillShowAnnotTooltipCallback = config.onWillShowAnnotTooltip;\n  }\n  if (config.onDidShowAnnotTooltip) {\n    ideo.onDidShowAnnotTooltipCallback = config.onDidShowAnnotTooltip;\n  }\n  if (config.onClickAnnot) {\n    ideo.onClickAnnotCallback = config.onClickAnnot;\n  }\n}\n\nfunction configureMiscellaneous(ideo) {\n  ideo.chromosomesArray = [];\n  ideo.coordinateSystem = 'iscn';\n  ideo.maxLength = {bp: 0, iscn: 0};\n  ideo.chromosomes = {};\n  ideo.numChromosomes = 0;\n  if (!ideo.config.debug) ideo.config.debug = false;\n  if (!ideo.config.dataDir) ideo.config.dataDir = ideo.getDataDir();\n  if (!ideo.config.container) ideo.config.container = 'body';\n  ideo.selector = ideo.config.container + ' #_ideogram';\n  if (!ideo.config.resolution) ideo.config.resolution = '';\n  if (!ideo.config.orientation) ideo.config.orientation = 'vertical';\n  if (!ideo.config.brush) ideo.config.brush = null;\n  if (!ideo.config.rows) ideo.config.rows = 1;\n  if ('showChromosomeLabels' in ideo.config === false) {\n    ideo.config.showChromosomeLabels = true;\n  }\n  if (!ideo.config.showNonNuclearChromosomes) {\n    ideo.config.showNonNuclearChromosomes = false;\n  }\n  if (!ideo.config.chromosomeScale) {\n    ideo.config.chromosomeScale = 'absolute';\n  }\n  if (!ideo.config.showTools) ideo.config.showTools = false;\n}\n\nfunction configureBands(ideo) {\n  if (!ideo.config.showBandLabels) ideo.config.showBandLabels = false;\n\n  if ('showFullyBanded' in ideo.config === false) {\n    ideo.config.showFullyBanded = true;\n  }\n\n  ideo.bandsToShow = [];\n  ideo.bandData = {};\n}\n\nlet configuredCss = staticCss;\nfunction configureTextStyle(ideo) {\n  const config = ideo.config;\n  if (!config.chrLabelSize) ideo.config.chrLabelSize = 9;\n  if (!config.chrLabelColor) ideo.config.chrLabelColor = '#000';\n  if (!config.fontFamily) ideo.config.fontFamily = '';\n\n  const size = `font-size: ${config.chrLabelSize}px`;\n  const color = `fill: ${config.chrLabelColor}`;\n  const fontFamily = `font-family: ${config.fontFamily}`;\n  configuredCss += `#_ideogram text {${fontFamily}; ${size}; ${color};}`;\n  configuredCss += `#_ideogramLabel text {${fontFamily};}`;\n}\n\n/**\n * High-level helper method for Ideogram constructor.\n *\n * @param config Configuration object.  Enables setting Ideogram properties.\n *\n * Docs: https://github.com/eweitz/ideogram/blob/master/api.md\n */\nfunction configure(config) {\n  // Clone the config object, to allow multiple instantiations\n  // without picking up prior ideogram's settings\n  this.config = JSON.parse(JSON.stringify(config));\n\n  configureMiscellaneous(this);\n  configurePloidy(this);\n  configureBands(this);\n  configureHeight(this);\n  configureWidth(this);\n  configureMargin(this);\n  configureCallbacks(config, this);\n  configureOrganisms(config, this);\n  configureBump(this);\n  configureSingleChromosome(config, this);\n  configureTextStyle(this);\n  this.initAnnotSettings();\n  if (!this.config.geometry || this.config.geometry === 'parallel') {\n    this.config.chrMargin += this.config.chrWidth;\n    if (this.config.annotationsLayout === 'heatmap') {\n      this.config.chrMargin += this.config.annotTracksHeight;\n    } else {\n      this.config.chrMargin += this.config.annotTracksHeight * 2;\n    }\n  }\n  this.init();\n}\n\nexport {configure, configuredCss};\n","/**\n * @fileoverview Functions for collinear chromosomes.\n * Collinear chromosomes form a line together, unlike the default parallel\n * geometry.\n */\n\nimport {d3} from './lib';\n\nfunction labelGenomes(ideo) {\n\n  ideo.config.taxids.forEach((taxid, i) => {\n    var org = ideo.organisms[taxid];\n    // var commonName = slug(org.commonName);\n    var scientificName = org.scientificName;\n    d3.select(ideo.selector)\n      .append('text')\n      .attr('class', 'genomeLabel italic')\n      .attr('x', 55 + 200 * i)\n      .attr('y', 10)\n      .text(scientificName)\n      .attr('text-anchor', 'middle');\n  });\n}\n\n/**\n* Rearrange chromosomes from parallel vertical to collinear vertical\n*\n* Parallel vertical (as in https://eweitz.github.io/ideogram/human)\n* | | |\n*\n* Collinear vertical (as in https://eweitz.github.io/ideogram/orthologs?loci=2:150000000,5:20000000;3:100000000,10:80000000&org=homo-sapiens&org2=mus-musculus)\n* |\n* |\n* |\n*/\nfunction rearrangeChromosomes(chrSets, yOffsets, x, ideo) {\n  var i, chrSet, y, chrLabelX, adjustedX, chr, taxid, orgIndex,\n    config = ideo.config,\n    chrLabelSize = config.chrLabelSize;\n\n  for (i = 0; i < chrSets.length; i++) {\n    chrSet = chrSets[i];\n    y = yOffsets[i] + 23 - chrLabelSize;\n\n    chr = ideo.chromosomesArray[i];\n    taxid = chr.id.split('-')[1];\n    orgIndex = ideo.config.taxids.indexOf(taxid);\n    adjustedX = x - orgIndex * 200 - 30 - 5;\n    if (orgIndex === 0) {\n      chrLabelX = -34;\n      adjustedX += ideo.config.chrWidth * 2 - 16;\n    } else {\n      chrLabelX = ideo.config.chrWidth * 2 - 24;\n    }\n\n    if (config.showChromosomeLabels) {\n      const labelSpan = chrSet.querySelector('.chrLabel > tspan');\n      labelSpan.setAttribute('x', chrLabelX);\n      labelSpan.setAttribute('dy', chrLabelSize - 8);\n      chrSet.querySelector('.chrLabel').setAttribute('text-anchor', 'start');\n    }\n    chrSet.setAttribute(\n      'transform', 'rotate(90) translate(' + y + ',' + adjustedX + ')'\n    );\n    chrSet.querySelector('.chromosome').setAttribute(\n      'transform', 'translate(-13, 10)'\n    );\n  }\n\n  labelGenomes(ideo);\n}\n\n/**\n* Get pixel coordinates to use for rearrangement\n*/\nfunction getYOffsets(chrSets, ideo) {\n  var yOffsets, i, index, chr, prevChr, y, prevWidth, prevY, yBump, taxid,\n    seenTaxids = {};\n\n  yOffsets = [];\n  for (i = 0; i < chrSets.length; i++) {\n    chr = ideo.chromosomesArray[i];\n    taxid = chr.id.split('-')[1];\n    index = (i === 0) ? i : i - 1;\n    prevChr = ideo.chromosomesArray[index];\n    if (i === 0 || taxid in seenTaxids === false) {\n      y = 20;\n      seenTaxids[taxid] = 1;\n    } else {\n      prevWidth = prevChr.width;\n      prevY = yOffsets[index];\n      yBump = (ideo.config.showChromosomeLabels ? 0 : 2);\n      y = prevY + prevWidth + yBump + ideo.config.chrMargin;\n    }\n    yOffsets.push(y);\n  }\n\n  return yOffsets;\n}\n\nfunction collinearizeVerticalChromosomes(ideo) {\n  var chrSets, yOffsets, x, height, width,\n    config = ideo.config;\n\n  ideo.config.annotLabelHeight = 12;\n  // var annotLabelHeight = ideo.config.annotLabelHeight;\n\n  if ('demarcateCollinearChromosomes' in ideo.config === false) {\n    ideo.config.demarcateCollinearChromosomes = true;\n  }\n\n  chrSets = document.querySelectorAll('.chromosome-set');\n\n  x = -40;\n\n  yOffsets = getYOffsets(chrSets, ideo);\n  rearrangeChromosomes(chrSets, yOffsets, x, ideo);\n\n  width = Math.round(yOffsets.slice(-1)[0] + 70);\n\n  if (config.multiorganism) {\n    height *= 8;\n    var maxHeight = 0;\n    yOffsets.forEach(d => {\n      if (d > maxHeight) maxHeight = d;\n    });\n    height = maxHeight + 30;\n  } else {\n    height = xOffsets.slice(-1)[0] + 30;\n  }\n\n  d3.select(ideo.selector)\n    .attr('height', height)\n    .attr('width', width);\n\n  d3.select('#_ideogramTrackLabelContainer').remove();\n  d3.select('#_ideogramInnerWrap')\n    .insert('div', ':first-child')\n    .attr('id', '_ideogramTrackLabelContainer')\n    .style('position', 'absolute');\n}\n\nexport default collinearizeVerticalChromosomes;\n","/**\n * @fileoverview Functions for collinear chromosomes.\n * Collinear chromosomes form a line together, unlike the default parallel\n * geometry.\n */\n\nimport {d3} from './lib';\nimport collinearizeVerticalChromosomes from './collinear-vertical';\n\nfunction labelGenomes(ideo) {\n\n  ideo.config.taxids.forEach((taxid, i) => {\n    var org = ideo.organisms[taxid];\n    var config = ideo.config;\n    // var commonName = slug(org.commonName);\n    var scientificName = org.scientificName;\n    d3.select(ideo.selector)\n      .append('text')\n      .attr('class', 'genomeLabel italic')\n      .attr('x', 5)\n      .attr('y', config.chrLabelSize + (200 + (3 * config.chrWidth)) * i)\n      .text(scientificName);\n  });\n}\n\n/**\n* Rearrange chromosomes from parallel horizontal to collinear horizontal\n*\n* Parallel horizontal (as in https://eweitz.github.io/ideogram/mouse)\n*     ---\n*     ---\n*     ---\n*\n* Collinear horizontal (as in https://eweitz.github.io/ideogram/geometry-collinear):\n*     --- --- ---\n*/\nfunction rearrangeChromosomes(chrSets, xOffsets, y, ideo) {\n  var i, chr, chrSet, taxid, x, adjustedY, orgIndex, chrLabelY,\n    config = ideo.config,\n    chrWidth = config.chrWidth,\n    chrLabelSize = config.chrLabelSize;\n\n  for (i = 0; i < chrSets.length; i++) {\n    chrSet = chrSets[i];\n    x = xOffsets[i];\n\n    chr = ideo.chromosomesArray[i];\n    taxid = chr.id.split('-')[1];\n    orgIndex = config.taxids.indexOf(taxid);\n    adjustedY = y + orgIndex * 200;\n    if (orgIndex === 0 && ideo.config.multiorganism) {\n      chrLabelY = chrLabelSize - 4;\n      adjustedY += chrWidth * 2 + chrLabelSize;\n    } else {\n      chrLabelY = chrWidth * 2 + chrLabelSize + 2;\n    }\n\n    if (ideo.config.showChromosomeLabels) {\n      chrSet.querySelector('.chrLabel').setAttribute('y', chrLabelY);\n      chrSet.querySelector('.chrLabel').setAttribute('text-anchor', 'middle');\n    }\n    chrSet.setAttribute('transform', 'translate(' + x + ',' + adjustedY + ')');\n    chrSet.querySelector('.chromosome').setAttribute(\n      'transform', 'translate(-13, 10)'\n    );\n  }\n\n  if (config.multiorganism) {\n    labelGenomes(ideo);\n  }\n}\n\n/**\n* Get pixel coordinates to use for rearrangement\n*/\nfunction getXOffsets(chrSets, ideo) {\n  var xOffsets, i, index, chr, prevChr, x, prevWidth, prevX, xBump, taxid,\n    seenTaxids = {};\n\n  xOffsets = [];\n  for (i = 0; i < chrSets.length; i++) {\n    chr = ideo.chromosomesArray[i];\n    taxid = chr.id.split('-')[1];\n    index = (i === 0) ? i : i - 1;\n    prevChr = ideo.chromosomesArray[index];\n    if (i === 0 || taxid in seenTaxids === false) {\n      x = 20;\n      seenTaxids[taxid] = 1;\n    } else {\n      prevWidth = prevChr.width;\n      prevX = xOffsets[index];\n      xBump = (ideo.config.showChromosomeLabels ? 0 : 2);\n      x = prevX + prevWidth + xBump + ideo.config.chrMargin;\n    }\n    xOffsets.push(x);\n  }\n\n  return xOffsets;\n}\n\n// /**\n//  * Track number of chromosomes in preceding organisms.\n//  * Adds an instance variable to the ideogram object to offset\n//  * chromosome indices.  Needed for multiorganism collinear ideograms.\n//  */\n// function setTaxidChrOffsets(ideo) {\n//   var taxidChrOffsets, taxidChrOffset;\n\n//   taxidChrOffsets = {};\n\n//   taxidChrOffset = 0;\n//   ideo.config.organism.forEach((org) => {\n//     var taxid, numChrs;\n//     taxid = ideo.getTaxid(org);\n//     taxidChrOffsets[taxid] = taxidChrOffset;\n//     numChrs = Object.keys(ideo.chromosomes[taxid]).length;\n//     taxidChrOffset += numChrs;\n//   });\n\n//   ideo.taxidChrOffsets = taxidChrOffsets;\n// }\n\n// /**\n//  * Change chromosome indices for multiorganism collinear ideograms\n//  * This is needed to account for x-offsets.\n//  */\n// function adjustChrIndex(ideo) {\n//   setTaxidChrOffsets(ideo);\n\n//   ideo.chromosomesArray.map((chr) => {\n//     var taxid = chr.id.split('-')[1];\n//     var taxidChrOffset = ideo.taxidChrOffsets[taxid];\n//     chr.chrIndex -= taxidChrOffset;\n//     ideo.chromosomes[taxid][chr.name].chrIndex = chr.chrIndex;\n//   });\n// }\n\nfunction collinearizeChromosomes(ideo) {\n  var chrSets, xOffsets, y, height, width,\n    config = ideo.config,\n    annotHeight = config.annotationHeight || 0;\n\n  if (config.orientation === 'vertical') {\n    collinearizeVerticalChromosomes(ideo);\n    return;\n  }\n\n  // if (config.multiorganism) adjustChrIndex(ideo);\n\n  ideo.config.annotLabelHeight = 12;\n  var annotLabelHeight = ideo.config.annotLabelHeight;\n\n  if ('demarcateCollinearChromosomes' in ideo.config === false) {\n    ideo.config.demarcateCollinearChromosomes = true;\n  }\n\n  chrSets = document.querySelectorAll('.chromosome-set');\n\n  y = (\n    (config.numAnnotTracks * (annotHeight + annotLabelHeight + 4)) -\n    config.chrWidth + 1\n  );\n\n  xOffsets = getXOffsets(chrSets, ideo);\n  rearrangeChromosomes(chrSets, xOffsets, y, ideo);\n\n  height = y + config.chrWidth * 2 + 20;\n\n  if (config.multiorganism) {\n    height *= 8;\n    var maxWidth = 0;\n    xOffsets.forEach(d => {\n      if (d > maxWidth) maxWidth = d;\n    });\n    width = maxWidth + 20;\n  } else {\n    width = xOffsets.slice(-1)[0] + 20;\n  }\n\n  d3.select(ideo.selector)\n    .attr('width', width)\n    .attr('height', height);\n\n  d3.select('#_ideogramTrackLabelContainer').remove();\n  d3.select('#_ideogramInnerWrap')\n    .insert('div', ':first-child')\n    .attr('id', '_ideogramTrackLabelContainer')\n    .style('position', 'absolute');\n}\n\nexport default collinearizeChromosomes;\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && st.f && !st.l))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[pos >> 3] = lst;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if (d[1] & 32)\n        err(6, 'invalid zlib data: preset dictionaries not supported');\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                err(6, 'invalid gzip data');\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            err(8);\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this_1.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this_1.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this_1.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this_1.ondata(err, dat, final);\n                    _this_1.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_3 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    if (sc < 320000) {\n                        try {\n                            cbl(null, inflateSync(infl, new u8(su)));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../../_version.js';\nexport const messages = {\n    'invalid-value': ({ paramName, validValueDescription, value }) => {\n        if (!paramName || !validValueDescription) {\n            throw new Error(`Unexpected input to 'invalid-value' error.`);\n        }\n        return (`The '${paramName}' parameter was given a value with an ` +\n            `unexpected value. ${validValueDescription} Received a value of ` +\n            `${JSON.stringify(value)}.`);\n    },\n    'not-an-array': ({ moduleName, className, funcName, paramName }) => {\n        if (!moduleName || !className || !funcName || !paramName) {\n            throw new Error(`Unexpected input to 'not-an-array' error.`);\n        }\n        return (`The parameter '${paramName}' passed into ` +\n            `'${moduleName}.${className}.${funcName}()' must be an array.`);\n    },\n    'incorrect-type': ({ expectedType, paramName, moduleName, className, funcName, }) => {\n        if (!expectedType || !paramName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'incorrect-type' error.`);\n        }\n        const classNameStr = className ? `${className}.` : '';\n        return (`The parameter '${paramName}' passed into ` +\n            `'${moduleName}.${classNameStr}` +\n            `${funcName}()' must be of type ${expectedType}.`);\n    },\n    'incorrect-class': ({ expectedClassName, paramName, moduleName, className, funcName, isReturnValueProblem, }) => {\n        if (!expectedClassName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'incorrect-class' error.`);\n        }\n        const classNameStr = className ? `${className}.` : '';\n        if (isReturnValueProblem) {\n            return (`The return value from ` +\n                `'${moduleName}.${classNameStr}${funcName}()' ` +\n                `must be an instance of class ${expectedClassName}.`);\n        }\n        return (`The parameter '${paramName}' passed into ` +\n            `'${moduleName}.${classNameStr}${funcName}()' ` +\n            `must be an instance of class ${expectedClassName}.`);\n    },\n    'missing-a-method': ({ expectedMethod, paramName, moduleName, className, funcName, }) => {\n        if (!expectedMethod ||\n            !paramName ||\n            !moduleName ||\n            !className ||\n            !funcName) {\n            throw new Error(`Unexpected input to 'missing-a-method' error.`);\n        }\n        return (`${moduleName}.${className}.${funcName}() expected the ` +\n            `'${paramName}' parameter to expose a '${expectedMethod}' method.`);\n    },\n    'add-to-cache-list-unexpected-type': ({ entry }) => {\n        return (`An unexpected entry was passed to ` +\n            `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` +\n            `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` +\n            `strings with one or more characters, objects with a url property or ` +\n            `Request objects.`);\n    },\n    'add-to-cache-list-conflicting-entries': ({ firstEntry, secondEntry }) => {\n        if (!firstEntry || !secondEntry) {\n            throw new Error(`Unexpected input to ` + `'add-to-cache-list-duplicate-entries' error.`);\n        }\n        return (`Two of the entries passed to ` +\n            `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +\n            `${firstEntry} but different revision details. Workbox is ` +\n            `unable to cache and version the asset correctly. Please remove one ` +\n            `of the entries.`);\n    },\n    'plugin-error-request-will-fetch': ({ thrownErrorMessage }) => {\n        if (!thrownErrorMessage) {\n            throw new Error(`Unexpected input to ` + `'plugin-error-request-will-fetch', error.`);\n        }\n        return (`An error was thrown by a plugins 'requestWillFetch()' method. ` +\n            `The thrown error message was: '${thrownErrorMessage}'.`);\n    },\n    'invalid-cache-name': ({ cacheNameId, value }) => {\n        if (!cacheNameId) {\n            throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n        }\n        return (`You must provide a name containing at least one character for ` +\n            `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` +\n            `'${JSON.stringify(value)}'`);\n    },\n    'unregister-route-but-not-found-with-method': ({ method }) => {\n        if (!method) {\n            throw new Error(`Unexpected input to ` +\n                `'unregister-route-but-not-found-with-method' error.`);\n        }\n        return (`The route you're trying to unregister was not  previously ` +\n            `registered for the method type '${method}'.`);\n    },\n    'unregister-route-route-not-registered': () => {\n        return (`The route you're trying to unregister was not previously ` +\n            `registered.`);\n    },\n    'queue-replay-failed': ({ name }) => {\n        return `Replaying the background sync queue '${name}' failed.`;\n    },\n    'duplicate-queue-name': ({ name }) => {\n        return (`The Queue name '${name}' is already being used. ` +\n            `All instances of backgroundSync.Queue must be given unique names.`);\n    },\n    'expired-test-without-max-age': ({ methodName, paramName }) => {\n        return (`The '${methodName}()' method can only be used when the ` +\n            `'${paramName}' is used in the constructor.`);\n    },\n    'unsupported-route-type': ({ moduleName, className, funcName, paramName }) => {\n        return (`The supplied '${paramName}' parameter was an unsupported type. ` +\n            `Please check the docs for ${moduleName}.${className}.${funcName} for ` +\n            `valid input types.`);\n    },\n    'not-array-of-class': ({ value, expectedClass, moduleName, className, funcName, paramName, }) => {\n        return (`The supplied '${paramName}' parameter must be an array of ` +\n            `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` +\n            `Please check the call to ${moduleName}.${className}.${funcName}() ` +\n            `to fix the issue.`);\n    },\n    'max-entries-or-age-required': ({ moduleName, className, funcName }) => {\n        return (`You must define either config.maxEntries or config.maxAgeSeconds` +\n            `in ${moduleName}.${className}.${funcName}`);\n    },\n    'statuses-or-headers-required': ({ moduleName, className, funcName }) => {\n        return (`You must define either config.statuses or config.headers` +\n            `in ${moduleName}.${className}.${funcName}`);\n    },\n    'invalid-string': ({ moduleName, funcName, paramName }) => {\n        if (!paramName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'invalid-string' error.`);\n        }\n        return (`When using strings, the '${paramName}' parameter must start with ` +\n            `'http' (for cross-origin matches) or '/' (for same-origin matches). ` +\n            `Please see the docs for ${moduleName}.${funcName}() for ` +\n            `more info.`);\n    },\n    'channel-name-required': () => {\n        return (`You must provide a channelName to construct a ` +\n            `BroadcastCacheUpdate instance.`);\n    },\n    'invalid-responses-are-same-args': () => {\n        return (`The arguments passed into responsesAreSame() appear to be ` +\n            `invalid. Please ensure valid Responses are used.`);\n    },\n    'expire-custom-caches-only': () => {\n        return (`You must provide a 'cacheName' property when using the ` +\n            `expiration plugin with a runtime caching strategy.`);\n    },\n    'unit-must-be-bytes': ({ normalizedRangeHeader }) => {\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n        }\n        return (`The 'unit' portion of the Range header must be set to 'bytes'. ` +\n            `The Range header provided was \"${normalizedRangeHeader}\"`);\n    },\n    'single-range-only': ({ normalizedRangeHeader }) => {\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'single-range-only' error.`);\n        }\n        return (`Multiple ranges are not supported. Please use a  single start ` +\n            `value, and optional end value. The Range header provided was ` +\n            `\"${normalizedRangeHeader}\"`);\n    },\n    'invalid-range-values': ({ normalizedRangeHeader }) => {\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n        }\n        return (`The Range header is missing both start and end values. At least ` +\n            `one of those values is needed. The Range header provided was ` +\n            `\"${normalizedRangeHeader}\"`);\n    },\n    'no-range-header': () => {\n        return `No Range header was found in the Request provided.`;\n    },\n    'range-not-satisfiable': ({ size, start, end }) => {\n        return (`The start (${start}) and end (${end}) values in the Range are ` +\n            `not satisfiable by the cached response, which is ${size} bytes.`);\n    },\n    'attempt-to-cache-non-get-request': ({ url, method }) => {\n        return (`Unable to cache '${url}' because it is a '${method}' request and ` +\n            `only 'GET' requests can be cached.`);\n    },\n    'cache-put-with-no-response': ({ url }) => {\n        return (`There was an attempt to cache '${url}' but the response was not ` +\n            `defined.`);\n    },\n    'no-response': ({ url, error }) => {\n        let message = `The strategy could not generate a response for '${url}'.`;\n        if (error) {\n            message += ` The underlying error is ${error}.`;\n        }\n        return message;\n    },\n    'bad-precaching-response': ({ url, status }) => {\n        return (`The precaching request for '${url}' failed` +\n            (status ? ` with an HTTP status of ${status}.` : `.`));\n    },\n    'non-precached-url': ({ url }) => {\n        return (`createHandlerBoundToURL('${url}') was called, but that URL is ` +\n            `not precached. Please pass in a URL that is precached instead.`);\n    },\n    'add-to-cache-list-conflicting-integrities': ({ url }) => {\n        return (`Two of the entries passed to ` +\n            `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +\n            `${url} with different integrity values. Please remove one of them.`);\n    },\n    'missing-precache-entry': ({ cacheName, url }) => {\n        return `Unable to find a precached response in ${cacheName} for ${url}.`;\n    },\n    'cross-origin-copy-response': ({ origin }) => {\n        return (`workbox-core.copyResponse() can only be used with same-origin ` +\n            `responses. It was passed a response with origin ${origin}.`);\n    },\n    'opaque-streams-source': ({ type }) => {\n        const message = `One of the workbox-streams sources resulted in an ` +\n            `'${type}' response.`;\n        if (type === 'opaqueredirect') {\n            return (`${message} Please do not use a navigation request that results ` +\n                `in a redirect as a source.`);\n        }\n        return `${message} Please ensure your sources are CORS-enabled.`;\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { messages } from './messages.js';\nimport '../../_version.js';\nconst fallback = (code, ...args) => {\n    let msg = code;\n    if (args.length > 0) {\n        msg += ` :: ${JSON.stringify(args)}`;\n    }\n    return msg;\n};\nconst generatorFunction = (code, details = {}) => {\n    const message = messages[code];\n    if (!message) {\n        throw new Error(`Unable to find message for code '${code}'.`);\n    }\n    return message(details);\n};\nexport const messageGenerator = process.env.NODE_ENV === 'production' ? fallback : generatorFunction;\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { messageGenerator } from '../models/messages/messageGenerator.js';\nimport '../_version.js';\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\nclass WorkboxError extends Error {\n    /**\n     *\n     * @param {string} errorCode The error code that\n     * identifies this particular error.\n     * @param {Object=} details Any relevant arguments\n     * that will help developers identify issues should\n     * be added as a key on the context object.\n     */\n    constructor(errorCode, details) {\n        const message = messageGenerator(errorCode, details);\n        super(message);\n        this.name = errorCode;\n        this.details = details;\n    }\n}\nexport { WorkboxError };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from '../_private/WorkboxError.js';\nimport '../_version.js';\n/*\n * This method throws if the supplied value is not an array.\n * The destructed values are required to produce a meaningful error for users.\n * The destructed and restructured object is so it's clear what is\n * needed.\n */\nconst isArray = (value, details) => {\n    if (!Array.isArray(value)) {\n        throw new WorkboxError('not-an-array', details);\n    }\n};\nconst hasMethod = (object, expectedMethod, details) => {\n    const type = typeof object[expectedMethod];\n    if (type !== 'function') {\n        details['expectedMethod'] = expectedMethod;\n        throw new WorkboxError('missing-a-method', details);\n    }\n};\nconst isType = (object, expectedType, details) => {\n    if (typeof object !== expectedType) {\n        details['expectedType'] = expectedType;\n        throw new WorkboxError('incorrect-type', details);\n    }\n};\nconst isInstance = (object, \n// Need the general type to do the check later.\n// eslint-disable-next-line @typescript-eslint/ban-types\nexpectedClass, details) => {\n    if (!(object instanceof expectedClass)) {\n        details['expectedClassName'] = expectedClass.name;\n        throw new WorkboxError('incorrect-class', details);\n    }\n};\nconst isOneOf = (value, validValues, details) => {\n    if (!validValues.includes(value)) {\n        details['validValueDescription'] = `Valid values are ${JSON.stringify(validValues)}.`;\n        throw new WorkboxError('invalid-value', details);\n    }\n};\nconst isArrayOfClass = (value, \n// Need general type to do check later.\nexpectedClass, // eslint-disable-line\ndetails) => {\n    const error = new WorkboxError('not-array-of-class', details);\n    if (!Array.isArray(value)) {\n        throw error;\n    }\n    for (const item of value) {\n        if (!(item instanceof expectedClass)) {\n            throw error;\n        }\n    }\n};\nconst finalAssertExports = process.env.NODE_ENV === 'production'\n    ? null\n    : {\n        hasMethod,\n        isArray,\n        isInstance,\n        isOneOf,\n        isType,\n        isArrayOfClass,\n    };\nexport { finalAssertExports as assert };\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nconst logger = (process.env.NODE_ENV === 'production'\n    ? null\n    : (() => {\n        // Don't overwrite this value if it's already set.\n        // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923\n        if (!('__WB_DISABLE_DEV_LOGS' in globalThis)) {\n            self.__WB_DISABLE_DEV_LOGS = false;\n        }\n        let inGroup = false;\n        const methodToColorMap = {\n            debug: `#7f8c8d`,\n            log: `#2ecc71`,\n            warn: `#f39c12`,\n            error: `#c0392b`,\n            groupCollapsed: `#3498db`,\n            groupEnd: null, // No colored prefix on groupEnd\n        };\n        const print = function (method, args) {\n            if (self.__WB_DISABLE_DEV_LOGS) {\n                return;\n            }\n            if (method === 'groupCollapsed') {\n                // Safari doesn't print all console.groupCollapsed() arguments:\n                // https://bugs.webkit.org/show_bug.cgi?id=182754\n                if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n                    console[method](...args);\n                    return;\n                }\n            }\n            const styles = [\n                `background: ${methodToColorMap[method]}`,\n                `border-radius: 0.5em`,\n                `color: white`,\n                `font-weight: bold`,\n                `padding: 2px 0.5em`,\n            ];\n            // When in a group, the workbox prefix is not displayed.\n            const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n            console[method](...logPrefix, ...args);\n            if (method === 'groupCollapsed') {\n                inGroup = true;\n            }\n            if (method === 'groupEnd') {\n                inGroup = false;\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        const api = {};\n        const loggerMethods = Object.keys(methodToColorMap);\n        for (const key of loggerMethods) {\n            const method = key;\n            api[method] = (...args) => {\n                print(method, args);\n            };\n        }\n        return api;\n    })());\nexport { logger };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { assert } from 'workbox-core/_private/assert.js';\nimport '../_version.js';\n/**\n * @param {Blob} blob A source blob.\n * @param {number} [start] The offset to use as the start of the\n * slice.\n * @param {number} [end] The offset to use as the end of the slice.\n * @return {Object} An object with `start` and `end` properties, reflecting\n * the effective boundaries to use given the size of the blob.\n *\n * @private\n */\nfunction calculateEffectiveBoundaries(blob, start, end) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isInstance(blob, Blob, {\n            moduleName: 'workbox-range-requests',\n            funcName: 'calculateEffectiveBoundaries',\n            paramName: 'blob',\n        });\n    }\n    const blobSize = blob.size;\n    if ((end && end > blobSize) || (start && start < 0)) {\n        throw new WorkboxError('range-not-satisfiable', {\n            size: blobSize,\n            end,\n            start,\n        });\n    }\n    let effectiveStart;\n    let effectiveEnd;\n    if (start !== undefined && end !== undefined) {\n        effectiveStart = start;\n        // Range values are inclusive, so add 1 to the value.\n        effectiveEnd = end + 1;\n    }\n    else if (start !== undefined && end === undefined) {\n        effectiveStart = start;\n        effectiveEnd = blobSize;\n    }\n    else if (end !== undefined && start === undefined) {\n        effectiveStart = blobSize - end;\n        effectiveEnd = blobSize;\n    }\n    return {\n        start: effectiveStart,\n        end: effectiveEnd,\n    };\n}\nexport { calculateEffectiveBoundaries };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { assert } from 'workbox-core/_private/assert.js';\nimport '../_version.js';\n/**\n * @param {string} rangeHeader A Range: header value.\n * @return {Object} An object with `start` and `end` properties, reflecting\n * the parsed value of the Range: header. If either the `start` or `end` are\n * omitted, then `null` will be returned.\n *\n * @private\n */\nfunction parseRangeHeader(rangeHeader) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isType(rangeHeader, 'string', {\n            moduleName: 'workbox-range-requests',\n            funcName: 'parseRangeHeader',\n            paramName: 'rangeHeader',\n        });\n    }\n    const normalizedRangeHeader = rangeHeader.trim().toLowerCase();\n    if (!normalizedRangeHeader.startsWith('bytes=')) {\n        throw new WorkboxError('unit-must-be-bytes', { normalizedRangeHeader });\n    }\n    // Specifying multiple ranges separate by commas is valid syntax, but this\n    // library only attempts to handle a single, contiguous sequence of bytes.\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range#Syntax\n    if (normalizedRangeHeader.includes(',')) {\n        throw new WorkboxError('single-range-only', { normalizedRangeHeader });\n    }\n    const rangeParts = /(\\d*)-(\\d*)/.exec(normalizedRangeHeader);\n    // We need either at least one of the start or end values.\n    if (!rangeParts || !(rangeParts[1] || rangeParts[2])) {\n        throw new WorkboxError('invalid-range-values', { normalizedRangeHeader });\n    }\n    return {\n        start: rangeParts[1] === '' ? undefined : Number(rangeParts[1]),\n        end: rangeParts[2] === '' ? undefined : Number(rangeParts[2]),\n    };\n}\nexport { parseRangeHeader };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { calculateEffectiveBoundaries } from './utils/calculateEffectiveBoundaries.js';\nimport { parseRangeHeader } from './utils/parseRangeHeader.js';\nimport './_version.js';\n/**\n * Given a `Request` and `Response` objects as input, this will return a\n * promise for a new `Response`.\n *\n * If the original `Response` already contains partial content (i.e. it has\n * a status of 206), then this assumes it already fulfills the `Range:`\n * requirements, and will return it as-is.\n *\n * @param {Request} request A request, which should contain a Range:\n * header.\n * @param {Response} originalResponse A response.\n * @return {Promise<Response>} Either a `206 Partial Content` response, with\n * the response body set to the slice of content specified by the request's\n * `Range:` header, or a `416 Range Not Satisfiable` response if the\n * conditions of the `Range:` header can't be met.\n *\n * @memberof workbox-range-requests\n */\nasync function createPartialResponse(request, originalResponse) {\n    try {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-range-requests',\n                funcName: 'createPartialResponse',\n                paramName: 'request',\n            });\n            assert.isInstance(originalResponse, Response, {\n                moduleName: 'workbox-range-requests',\n                funcName: 'createPartialResponse',\n                paramName: 'originalResponse',\n            });\n        }\n        if (originalResponse.status === 206) {\n            // If we already have a 206, then just pass it through as-is;\n            // see https://github.com/GoogleChrome/workbox/issues/1720\n            return originalResponse;\n        }\n        const rangeHeader = request.headers.get('range');\n        if (!rangeHeader) {\n            throw new WorkboxError('no-range-header');\n        }\n        const boundaries = parseRangeHeader(rangeHeader);\n        const originalBlob = await originalResponse.blob();\n        const effectiveBoundaries = calculateEffectiveBoundaries(originalBlob, boundaries.start, boundaries.end);\n        const slicedBlob = originalBlob.slice(effectiveBoundaries.start, effectiveBoundaries.end);\n        const slicedBlobSize = slicedBlob.size;\n        const slicedResponse = new Response(slicedBlob, {\n            // Status code 206 is for a Partial Content response.\n            // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206\n            status: 206,\n            statusText: 'Partial Content',\n            headers: originalResponse.headers,\n        });\n        slicedResponse.headers.set('Content-Length', String(slicedBlobSize));\n        slicedResponse.headers.set('Content-Range', `bytes ${effectiveBoundaries.start}-${effectiveBoundaries.end - 1}/` +\n            `${originalBlob.size}`);\n        return slicedResponse;\n    }\n    catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.warn(`Unable to construct a partial response; returning a ` +\n                `416 Range Not Satisfiable response instead.`);\n            logger.groupCollapsed(`View details here.`);\n            logger.log(error);\n            logger.log(request);\n            logger.log(originalResponse);\n            logger.groupEnd();\n        }\n        return new Response('', {\n            status: 416,\n            statusText: 'Range Not Satisfiable',\n        });\n    }\n}\nexport { createPartialResponse };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { createPartialResponse } from './createPartialResponse.js';\nimport './_version.js';\n/**\n * The range request plugin makes it easy for a request with a 'Range' header to\n * be fulfilled by a cached response.\n *\n * It does this by intercepting the `cachedResponseWillBeUsed` plugin callback\n * and returning the appropriate subset of the cached response body.\n *\n * @memberof workbox-range-requests\n */\nclass RangeRequestsPlugin {\n    constructor() {\n        /**\n         * @param {Object} options\n         * @param {Request} options.request The original request, which may or may not\n         * contain a Range: header.\n         * @param {Response} options.cachedResponse The complete cached response.\n         * @return {Promise<Response>} If request contains a 'Range' header, then a\n         * new response with status 206 whose body is a subset of `cachedResponse` is\n         * returned. Otherwise, `cachedResponse` is returned as-is.\n         *\n         * @private\n         */\n        this.cachedResponseWillBeUsed = async ({ request, cachedResponse, }) => {\n            // Only return a sliced response if there's something valid in the cache,\n            // and there's a Range: header in the request.\n            if (cachedResponse && request.headers.has('range')) {\n                return await createPartialResponse(request, cachedResponse);\n            }\n            // If there was no Range: header, or if cachedResponse wasn't valid, just\n            // pass it through as-is.\n            return cachedResponse;\n        };\n    }\n}\nexport { RangeRequestsPlugin };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { createPartialResponse } from './createPartialResponse.js';\nimport { RangeRequestsPlugin } from './RangeRequestsPlugin.js';\nimport './_version.js';\n/**\n * @module workbox-range-requests\n */\nexport { createPartialResponse, RangeRequestsPlugin };\n","export * from './index.js';","/** @fileoverview Functions used by multiple content-specific cache modules */\n\nimport {decompressSync, strFromU8} from 'fflate';\nimport {createPartialResponse} from 'workbox-range-requests';\n\nimport version from '../../version';\nimport {getEarlyTaxid, slug, getDir} from '../../lib';\nimport {organismMetadata} from '../organism-metadata';\n\nasync function fetchByteRangesByName(url) {\n  const byteRangesByName = {};\n\n  const path = `${url.replace('.tsv.gz', '')}.tsv.li.gz`;\n\n  const response = await cacheFetch(path);\n  const text = await response.text();\n  const lines = text.split('\\n');\n  for (let i = 0; i < lines.length - 1; i++) {\n    const [gene, rawOffset] = lines[i].split('\\t');\n    if (gene[0] === '#') continue;\n    const offset = parseInt(rawOffset);\n    const offsetEnd = parseInt(lines[i + 1].split('\\t')[1]);\n    byteRangesByName[gene] = [offset, offsetEnd];\n  }\n\n  return byteRangesByName;\n}\n\nasync function fetchVariantByteRangesByName(text) {\n  const byteRangesByName = {};\n\n  const lines = text.split('\\n');\n  for (let i = 0; i < lines.length - 1; i++) {\n    const [gene, rawOffset, rawLength] = lines[i].split('\\t');\n    if (gene[0] === '#') continue;\n    const offset = parseInt(rawOffset);\n    const offsetEnd = offset + parseInt(rawLength);\n    byteRangesByName[gene] = [offset, offsetEnd];\n  }\n\n  return byteRangesByName;\n}\n\n/** Reports if current organism has a gene structure cache */\nexport function supportsCache(orgName, cacheName) {\n  const metadata = parseOrgMetadata(orgName);\n  const cacheProp = 'has' + cacheName + 'Cache';\n  return metadata[cacheProp] && metadata[cacheProp] === true;\n}\n\n/** Get URL for given type of cache file (e.g. gene, tissue, variant) */\nexport function getCacheUrl(orgName, cacheDir, cacheType, fileType='tsv') {\n  const organism = slug(orgName);\n  if (!cacheDir) {\n    cacheDir = getDir('cache/' + cacheType + '/');\n  } else {\n    cacheDir += cacheType + '/';\n  }\n\n  const cacheUrl =\n    cacheDir + organism + '-' + cacheType + '.' + fileType + '.gz';\n\n  return cacheUrl;\n}\n\n/**\n * Build full ID from prefix (e.g. ENSG or IPR) and slim ID (e.g. 223972)\n *\n * Example output ID: ENSG00000223972\n * */\nexport function getFullId(prefix, slimId, fullNumLength=11) {\n\n  // C. elegans (prefix: WBGene) has special IDs, e.g. WBGene00197333\n  if (prefix === 'WBGene') fullNumLength = 8;\n\n  // Zero-pad the slim ID, e.g. 223972 -> 00000223972\n  const zeroPaddedId = slimId.padStart(fullNumLength, '0');\n\n  return prefix + zeroPaddedId;\n}\n\n\nasync function getServiceWorkerCache() {\n  const currentIdeogram = `ideogram-${version}`;\n\n  // Delete other versions of Ideogram cache; there should be 1 per dodmain\n  const cacheNames = await caches.keys();\n  cacheNames.forEach(name => {\n    if (name.startsWith('ideogram-') && name !== currentIdeogram) {\n      caches.delete(name);\n    }\n  });\n\n  const cache = await caches.open(currentIdeogram);\n\n  return cache;\n}\n\nexport async function cacheFetch(url) {\n\n  const cache = await getServiceWorkerCache();\n  window.ideoCache = cache;\n  window.createPartialResponse = createPartialResponse;\n\n  const decompressedUrl = url.replace('.gz', '');\n  const response = await cache.match(decompressedUrl);\n  if (typeof response === 'undefined') {\n    // If cache miss, then fetch, decompress, and put response in cache\n    const rawResponse = await fetch(url);\n    const blob = await rawResponse.blob();\n    const uint8Array = new Uint8Array(await blob.arrayBuffer());\n    const data = strFromU8(decompressSync(uint8Array));\n    const contentLength = data.length;\n    const decompressedResponse = new Response(\n      new Blob([data], {type: 'text/tab-separated-values'}),\n      {headers: new Headers({'Content-Length': contentLength})}\n    );\n    await cache.put(decompressedUrl, decompressedResponse);\n    return await cache.match(decompressedUrl);\n  }\n  return await cache.match(decompressedUrl);\n}\n\nexport async function cacheRangeFetch(url, byteRange) {\n  // console.log('url', url)\n  url = url.replace('.gz', '');\n\n  // +/- 1 to trim newlines\n  const rangeStart = byteRange[0] + 1;\n  const rangeEnd = byteRange[1] - 1;\n\n  const headers = new Headers({\n    'content-type': 'multipart/byteranges',\n    'range': `bytes=${rangeStart}-${rangeEnd}`\n  });\n\n  const request = new Request(url, {headers});\n\n  const cache = await getServiceWorkerCache();\n\n  const fullResponse = await cache.match(request);\n  const partialResponse = await createPartialResponse(request, fullResponse);\n\n  const text = await partialResponse.text();\n\n  return text;\n}\n\nwindow.cacheRangeFetch = cacheRangeFetch;\n\n/** Get organism's metadata fields */\nexport function parseOrgMetadata(orgName) {\n  const taxid = getEarlyTaxid(orgName);\n  return organismMetadata[taxid] || {};\n}\n\n/** Fetch URL from service worker cache, call given parsing function */\nexport async function fetchAndParse(\n  cacheUrl, perfTimes, parseFn, orgName=null\n) {\n  const fetchStartTime = performance.now();\n  const response = await cacheFetch(cacheUrl);\n  let data;\n  if (cacheUrl.includes('.json')) {\n    data = await response.json();\n  } else {\n    data = await response.text();\n  }\n  const fetchEndTime = performance.now();\n  perfTimes.fetch = Math.round(fetchEndTime - fetchStartTime);\n\n  let parsedCache;\n  if (cacheUrl.includes('tissue')) {\n    const byteRangesByName = await fetchByteRangesByName(cacheUrl);\n    parsedCache = parseFn(data, perfTimes, byteRangesByName);\n  } else if (cacheUrl.includes('variant')) {\n    const variantsTsvPath = cacheUrl.replace('.li', '');\n    await cacheFetch(variantsTsvPath);\n    const byteRangesByName = await fetchVariantByteRangesByName(data);\n    parsedCache = parseFn(data, perfTimes, byteRangesByName);\n  } else {\n    parsedCache = parseFn(data, perfTimes, orgName);\n  }\n\n  perfTimes.parseCache = Math.round(performance.now() - fetchEndTime);\n\n  return [parsedCache, perfTimes];\n}\n\n/** Print size and time of given parsed cache */\nexport function inspectWorker(cacheName, json) {\n  const size = new TextEncoder().encode(JSON.stringify(json)).length;\n  const kiloBytes = size / 1024;\n  const megaBytes = kiloBytes / 1024;\n  console.log(`Parsed ${cacheName}Cache size: ${megaBytes} MiB`);\n  console.timeEnd(`${cacheName}CacheWorker`);\n}\n","import {fetchAndParse, getFullId, inspectWorker} from './cache-lib';\n\n/**\n * Convert pre-annotation arrays to annotation objects\n * sorted by genomic position.\n */\nfunction parseAnnots(preAnnots) {\n  const chromosomes = {};\n\n  for (let i = 0; i < preAnnots.length; i++) {\n    const [chromosome, start, stop, ensemblId, gene] = preAnnots[i];\n\n    if (!(chromosome in chromosomes)) {\n      chromosomes[chromosome] = {chr: chromosome, annots: []};\n    } else {\n      const annot = {name: gene, start, stop, ensemblId};\n      chromosomes[chromosome].annots.push(annot);\n    }\n  }\n\n  const annotsSortedByPosition = {};\n\n  Object.entries(chromosomes).forEach(([chr, annotsByChr]) => {\n    annotsSortedByPosition[chr] = {\n      chr,\n      annots: annotsByChr.annots.sort((a, b) => a.start - b.start)\n    };\n  });\n\n  return annotsSortedByPosition;\n}\n\n/** Parse a gene cache TSV file, return array of useful transforms */\nexport function parseGeneCache(rawTsv, perfTimes) {\n  const names = [];\n  const nameCaseMap = {};\n  const namesById = {};\n  const fullNamesById = {};\n  const idsByName = {};\n  const lociByName = {};\n  const lociById = {};\n  const preAnnots = [];\n\n  // If the gene has among top 2% expression in a tissue (per GTEx), that's\n  // tracked here.\n  const tissueIdsByName = {};\n\n  let ensemblPrefix;\n\n  let t0 = performance.now();\n  const lines = rawTsv.split(/\\r\\n|\\n/);\n  perfTimes.rawTsvSplit = Math.round(performance.now() - t0);\n\n  t0 = performance.now();\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (line === '') continue; // Skip empty lines\n    if (line[0] === '#') {\n      if (line.slice(0, 9) === '## prefix') {\n        ensemblPrefix = line.split('prefix: ')[1];\n      }\n      continue;\n    }\n    const [\n      chromosome, rawStart, rawLength, slimEnsemblId, gene,\n      rawFullName, tissueIds\n    ] = line.trim().split(/\\t/);\n    const fullName = decodeURIComponent(rawFullName);\n    const start = parseInt(rawStart);\n    const stop = start + parseInt(rawLength);\n    const ensemblId = getFullId(ensemblPrefix, slimEnsemblId);\n    preAnnots.push([chromosome, start, stop, ensemblId, gene, fullName]);\n    const locus = [chromosome, start, stop];\n\n    names.push(gene);\n    nameCaseMap[gene.toLowerCase()] = gene;\n    namesById[ensemblId] = gene;\n    fullNamesById[ensemblId] = fullName;\n    idsByName[gene] = ensemblId;\n    lociByName[gene] = locus;\n    lociById[ensemblId] = locus;\n\n    if (tissueIds !== undefined) {\n      const processedTissueIds = [];\n      const splitTissueIds = tissueIds.split(',');\n      for (let i = 0; i < splitTissueIds.length; i++) {\n        processedTissueIds.push(parseInt(splitTissueIds[i], 10));\n      }\n      tissueIdsByName[gene] = processedTissueIds;\n    }\n  };\n  const t1 = performance.now();\n  perfTimes.parseCacheLoop = Math.round(t1 - t0);\n\n  // const sortedAnnots = parseAnnots(preAnnots);\n  perfTimes.parseAnnots = Math.round(performance.now() - t1);\n\n  return [\n    names, nameCaseMap, namesById,\n    fullNamesById,\n    idsByName, lociByName, lociById\n    // , sortedAnnots\n  ];\n}\n\n// Uncomment when workers work outside localhost\n// addEventListener('message', async event => {\n//   console.time('geneCacheWorker');\n//   // console.log('in gene cache worker message handler');\n//   const [cacheUrl, perfTimes, debug] = event.data;\n//   const result = await fetchAndParse(cacheUrl, perfTimes, parseCache);\n//   postMessage(result);\n//   if (debug) inspectWorker('gene', result[0]);\n// });\n","import {fetchAndParse, getFullId, inspectWorker} from './cache-lib';\n\n/** Parse a paralog cache TSV file, return array of useful transforms */\nexport function parseParalogCache(rawTsv, perfTimes) {\n  const paralogsByName = {};\n  let ensemblPrefix;\n\n  let t0 = performance.now();\n  const lines = rawTsv.split(/\\r\\n|\\n/);\n  perfTimes.rawTsvSplit = Math.round(performance.now() - t0);\n\n  t0 = performance.now();\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (line === '') continue; // Skip empty lines\n    if (line[0] === '#') {\n      if (line.slice(0, 9) === '## prefix') {\n        ensemblPrefix = line.split('prefix: ')[1];\n      }\n      continue;\n    }\n    const columns = line.trim().split(/\\t/);\n    const gene = columns[0];\n    const geneSlimId = columns[1];\n\n    const paralogs = [];\n    if (columns[2][0] === '_') {\n      const pointer = columns[2].slice(1).toUpperCase();\n      const paralogSuperList = paralogsByName[pointer];\n      const geneId = getFullId(ensemblPrefix, geneSlimId);\n      for (let j = 0; j < paralogSuperList.length; j++) {\n        const id = paralogSuperList[j];\n        if (id !== geneId) {\n          paralogs.push(id);\n        }\n      }\n      paralogs.unshift(getFullId(ensemblPrefix, columns[3]));\n    } else {\n      const slimEnsemblIds = columns.slice(2);\n      for (let j = 0; j < slimEnsemblIds.length; j++) {\n        const slimId = slimEnsemblIds[j];\n        if (slimId !== geneSlimId) {\n          paralogs.push(getFullId(ensemblPrefix, slimId));\n        }\n      }\n    }\n\n    paralogsByName[gene.toUpperCase()] = paralogs;\n  };\n  const t1 = performance.now();\n  perfTimes.parseCacheLoop = Math.round(t1 - t0);\n\n  return paralogsByName;\n}\n\n// Uncomment when workers work outside localhost\n// addEventListener('message', async event => {\n//   console.time('paralogCacheWorker');\n//   const [cacheUrl, perfTimes, debug] = event.data;\n//   const result = await fetchAndParse(cacheUrl, perfTimes, parseCache);\n//   postMessage(result);\n//   if (debug) inspectWorker('paralog', result[0]);\n// });\n","import {fetchAndParse, inspectWorker} from './cache-lib';\n\n/** Parse an interaction cache JSON file, return array of useful transforms */\nexport function parseInteractionCache(rawJson, perfTimes, orgName) {\n  let t0 = performance.now();\n  const interactionsByName = {};\n  const tmp = orgName.replace('-', ' ');\n  const desluggedOrg = tmp[0].toUpperCase() + tmp.slice(1);\n\n  t0 = performance.now();\n  for (const gene in rawJson['interactions']) {\n    const ixnLists = rawJson['interactions'][gene];\n    interactionsByName[gene] = {result: []};\n    for (let i = 0; i < ixnLists.length; i++) {\n      const compressedIxn = ixnLists[i];\n      const slimPwId = compressedIxn[0];\n      interactionsByName[gene].result.push({\n        fields: {\n          left: {values: compressedIxn[1]},\n          right: {values: compressedIxn[2]}\n        },\n        id: 'WP' + slimPwId,\n        name: rawJson['pathwayNamesById'][slimPwId],\n        species: desluggedOrg\n      });\n    }\n  }\n  const t1 = performance.now();\n  perfTimes.parseCacheLoop = Math.round(t1 - t0);\n\n  return interactionsByName;\n}\n\n// Uncomment when workers work outside localhost\n// addEventListener('message', async event => {\n//   console.time('interactionCacheWorker');\n//   const [cacheUrl, perfTimes, debug, orgName] = event.data;\n//   const result = await fetchAndParse(cacheUrl, perfTimes, parseCache, orgName);\n//   postMessage(result);\n//   if (debug) inspectWorker('interaction', result[0]);\n// });\n","import {fetchAndParse, inspectWorker} from './cache-lib';\n\n/** Parse compressed feature subparts to more easily computable format */\nfunction deserializeSubparts(rawSubparts, subpartKeys) {\n  const subparts = [];\n  for (let i = 0; i < rawSubparts.length; i++) {\n    const rawSubpart = rawSubparts[i].split(';');\n    const subpartType = subpartKeys[parseInt(rawSubpart[0])];\n    const start = parseInt(rawSubpart[1]);\n    const length = parseInt(rawSubpart[2]);\n    const subpart = [subpartType, start, length];\n    subparts.push(subpart);\n  }\n  return subparts;\n}\n\n/** Parse metainformation header lines, i.e. those beginning  \"## \"\" */\nfunction parseMetainformationHeader(line) {\n  const splitHead = line.split(' keys: ');\n  if (splitHead.length < 2) return [null];\n  const metaHeader = splitHead[0].split('## ')[1];\n  const keys = {};\n  splitHead[1].split(', ').forEach(entry => {\n    const splitEntry = entry.split(' = ');\n    keys[splitEntry[0]] = splitEntry[1];\n  });\n  return [metaHeader, keys];\n}\n\n/** Parse a gene structure cache TSV file, return array of useful transforms */\nexport function parseGeneStructureCache(rawTsv, perfTimes) {\n  const featuresByGene = {};\n\n  let t0 = performance.now();\n  const lines = rawTsv.split(/\\r\\n|\\n/);\n  perfTimes.rawTsvSplit = Math.round(performance.now() - t0);\n\n  let biotypeKeys, subpartKeys;\n\n  t0 = performance.now();\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (line === '') continue; // Skip empty lines\n\n    // Parse header\n    if (line[0] === '#') {\n\n      // Parse metainformation headers\n      if (line[1] === '#') {\n        const [metaHeader, keys] = parseMetainformationHeader(line);\n        if (metaHeader === 'biotype') {\n          biotypeKeys = keys;\n        } else if (metaHeader === 'subpart') {\n          subpartKeys = keys;\n        }\n      }\n      continue;\n    }\n    const splitLine = line.trim().split(/\\t/);\n\n    const [\n      name, rawStartOffset, biotypeCompressed, strand\n    ] = splitLine.slice(0, 4);\n\n    const startOffset = parseInt(rawStartOffset);\n    const gene = name.split('-').slice(0, -1).join('-');\n\n    const rawSubparts = splitLine.slice(4);\n    const subparts = deserializeSubparts(rawSubparts, subpartKeys);\n\n    const biotype = biotypeKeys[biotypeCompressed];\n\n    // E.g. ACE2-201, protein_coding, -, <array of exon or UTR arrays>\n    const feature = {\n      name,\n      startOffset,\n      biotype,\n      strand,\n      subparts\n    };\n\n    if (gene in featuresByGene) {\n      featuresByGene[gene].push(feature);\n    } else {\n      featuresByGene[gene] = [feature];\n    }\n\n  };\n  const t1 = performance.now();\n  perfTimes.parseCacheLoop = Math.round(t1 - t0);\n\n  return featuresByGene;\n}\n\n// Uncomment when workers work outside localhost\n// addEventListener('message', async event => {\n//   console.time('geneStructureCacheWorker');\n//   const [cacheUrl, perfTimes, debug] = event.data;\n//   const result = await fetchAndParse(cacheUrl, perfTimes, parseCache);\n//   postMessage(result);\n//   if (debug) inspectWorker('geneStructure', result[0]);\n// });\n","import {fetchAndParse, inspectWorker, getFullId} from './cache-lib';\n\n/** Parse compressed protein to more easily computable format */\nfunction deserializeProtein(rawProtein, domainKeys) {\n  const domains = [];\n  for (let i = 0; i < rawProtein.length; i++) {\n    const rawDomain = rawProtein[i].split(';');\n    // const domainID = getFullId('IPR', rawDomain[0], 6);\n    const domainName = domainKeys[rawDomain[0]];\n    const start = parseInt(rawDomain[1]);\n    const length = parseInt(rawDomain[2]);\n    const domain = [domainName, start, length];\n    domains.push(domain);\n  }\n  return domains;\n}\n\n/** Parse metainformation header lines, i.e. those beginning  \"## \"\" */\nfunction parseMetainformationHeader(line) {\n  const splitHead = line.split(' keys: ');\n  if (splitHead.length < 2) return [null];\n  const metaHeader = splitHead[0].split('## ')[1];\n  const keys = {};\n  splitHead[1].split('; ').forEach(entry => {\n    const splitEntry = entry.split(' = ');\n    keys[splitEntry[0]] = splitEntry[1];\n  });\n  return [metaHeader, keys];\n}\n\n/** Parse a protein cache TSV file, return array of useful transforms */\nexport function parseProteinCache(rawTsv, perfTimes) {\n  const featuresByGene = {};\n\n  let t0 = performance.now();\n  const lines = rawTsv.split(/\\r\\n|\\n/);\n  perfTimes.rawTsvSplit = Math.round(performance.now() - t0);\n\n  let domainKeys;\n\n  t0 = performance.now();\n\n  let gene = null;\n  let refTxBaseNum;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (line === '') continue; // Skip empty lines\n\n    // Parse header\n    if (line[0] === '#') {\n\n      // Parse metainformation headers\n      if (line[1] === '#') {\n        const [metaHeader, keys] = parseMetainformationHeader(line);\n        if (metaHeader === 'domain') {\n          domainKeys = keys;\n        }\n      }\n      continue;\n    }\n    const splitLine = line.trim().split(/\\t/);\n\n    let transcriptName = splitLine[0];\n    if (isNaN(transcriptName)) {\n      const splitTxName = transcriptName.split('-');\n      const txNum = splitTxName.slice(-1)[0]; // e.g. 208 in ACE2-208\n      const highestDigit = parseInt(txNum[0]); // e.g. 2 in 208\n      const numDigits = txNum.length;\n      refTxBaseNum = highestDigit * (10 ** (numDigits - 1));\n      gene = splitTxName.slice(0, -1).join('-');\n    } else {\n      transcriptName = refTxBaseNum + parseInt(transcriptName);\n      transcriptName = gene + '-' + transcriptName;\n    }\n\n    const rawProtein = splitLine.slice(1);\n    const protein = deserializeProtein(rawProtein, domainKeys);\n\n    // E.g. ACE2-201, <array of proteins <protein name, protein ID, start, length>>\n    const feature = {\n      transcriptName,\n      protein\n    };\n\n    if (gene in featuresByGene) {\n      featuresByGene[gene].push(feature);\n    } else {\n      featuresByGene[gene] = [feature];\n    }\n\n  };\n  const t1 = performance.now();\n  perfTimes.parseCacheLoop = Math.round(t1 - t0);\n\n  return featuresByGene;\n}\n\n// Uncomment when workers work outside localhost\n// addEventListener('message', async event => {\n//   console.time('proteinCacheWorker');\n//   const [cacheUrl, perfTimes, debug] = event.data;\n//   const result = await fetchAndParse(cacheUrl, perfTimes, parseCache);\n//   postMessage(result);\n//   if (debug) inspectWorker('proteinStructure', result[0]);\n// });\n","import {fetchAndParse, inspectWorker} from './cache-lib';\n\n/** Parse synonym cache TSV data, return array of useful transforms */\nexport function parseSynonymCache(rawTsv, perfTimes) {\n  const byGene = {};\n  // const nameCaseMap = {};\n\n  let t0 = performance.now();\n  const lines = rawTsv.split(/\\r\\n|\\n/);\n  perfTimes.rawTsvSplit = Math.round(performance.now() - t0);\n\n  t0 = performance.now();\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (line === '' || line[0] === '#') continue; // Skip empty lines, headers\n\n    const splitLine = line.trim().split(/\\t/);\n\n    const gene = splitLine[0];\n    const synonyms = splitLine.slice(1);\n\n    byGene[gene] = synonyms;\n\n    // For now, initialization is JITed in related-genes.js, as use is rare.\n    // nameCaseMap[gene.toLowerCase()] = synonyms.map(s => s.toLowerCase());\n  };\n  const t1 = performance.now();\n  perfTimes.parseCacheLoop = Math.round(t1 - t0);\n\n  return {byGene};\n}\n\n// Uncomment when workers work outside localhost\n// addEventListener('message', async event => {\n//   console.time('geneSynonymCacheWorker');\n//   const [cacheUrl, perfTimes, debug] = event.data;\n//   const result = await fetchAndParse(cacheUrl, perfTimes, parseCache);\n//   postMessage(result);\n//   if (debug) inspectWorker('geneStructure', result[0]);\n// });\n","import {\n  fetchAndParse, getFullId, inspectWorker,\n  cacheFetch, cacheRangeFetch, getCacheUrl\n} from './cache-lib';\n\n\nfunction parseTissueKeys(rawTissuesString) {\n  const tissueNames = [];\n  const tissueColors = [];\n  const tissueSamples = [];\n  rawTissuesString.split(';').forEach(entry => {\n    const splitEntry = entry.split(',');\n    tissueNames.push(splitEntry[0]);\n    tissueColors.push(splitEntry[1]);\n    tissueSamples.push(splitEntry[2]);\n  });\n  return [tissueNames, tissueColors, tissueSamples];\n}\n\n/** Transform a stringified list of integers into an actual list of integers */\nfunction processIds(ids) {\n  const processedIds = [];\n  const splitIds = ids.split(',');\n  for (let i = 0; i < splitIds.length; i++) {\n    processedIds.push(parseInt(splitIds[i], 10));\n  }\n  return processedIds;\n}\n\nasync function getTissueExpressions(gene, config) {\n  const cache = Ideogram.tissueCache;\n  const byteRange = cache.byteRangesByName[gene];\n\n  // Easier debuggability\n  if (!Ideogram.cacheRangeFetch) Ideogram.cacheRangeFetch = cacheRangeFetch;\n\n  if (!byteRange) return null;\n\n  let cacheDir = null;\n  if (config.cacheDir) cacheDir = config.cacheDir;\n  const cacheType = 'tissues';\n  const extension = 'tsv';\n\n  const orgName = 'homo-sapiens';\n  const cacheUrl = getCacheUrl(orgName, cacheDir, cacheType, extension);\n\n  const geneDataLine = await cacheRangeFetch(cacheUrl, byteRange);\n\n  const tissueExpressions = [];\n  const rawExpressions = geneDataLine.split('\\t').slice(1);\n  for (let i = 0; i < rawExpressions.length; i++) {\n    const rawValues = rawExpressions[i].split(';').map(\n      v => v === '' ? 0 : v // inflate empty string to 0-integer\n    );\n    const numValues = rawValues.length;\n    if (numValues === 15) {\n      rawValues.splice(1, 0, 0); // Insert number 0 at position 1\n    } else if (numValues === 14) {\n      // Min. and Q1 are 0\n      rawValues.splice(1, 0, 0);\n      rawValues.splice(1, 0, 0);\n    } else if (numValues === 13) {\n      // Min., Q1, and median are 0\n      rawValues.splice(1, 0, 0);\n      rawValues.splice(1, 0, 0);\n      rawValues.splice(1, 0, 0);\n    }\n    const tissueId = rawValues[0];\n    const boxMetrics = rawValues.slice(1, 6);\n    const min = parseFloat(boxMetrics[0]);\n    const q1 = parseFloat(boxMetrics[1]);\n    const median = parseFloat(boxMetrics[2]);\n    const q3 = parseFloat(boxMetrics[3]);\n    const max = parseFloat(boxMetrics[4]);\n    const quantiles = rawValues.slice(6).map(v => parseInt(v));\n    const expression = {\n      min, q1, median, q3, max,\n      quantiles\n    };\n    const tissue = cache.tissueNames[tissueId];\n    const color = cache.tissueColors[tissueId];\n    const samples = parseInt(cache.tissueSamples[tissueId]);\n    tissueExpressions.push({tissue, expression, color, samples});\n  }\n\n  return tissueExpressions;\n}\n\n/** Parse a tissue cache TSV file */\nexport function parseTissueCache(rawTsv, perfTimes, byteRangesByName) {\n  let tissueNames;\n  let tissueColors;\n  let tissueSamples;\n\n  let t0 = performance.now();\n  const lines = rawTsv.split(/\\r\\n|\\n/);\n  perfTimes.rawTsvSplit = Math.round(performance.now() - t0);\n\n  t0 = performance.now();\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (line === '') continue; // Skip empty lines\n    if (line[0] === '#') {\n      if (line.slice(0, 10) === '## tissues') {\n        const parsedTissueKeys = parseTissueKeys(line.split('tissues: ')[1]);\n        [tissueNames, tissueColors, tissueSamples] = parsedTissueKeys;\n      }\n      continue;\n    }\n\n  };\n  const t1 = performance.now();\n  perfTimes.parseCacheLoop = Math.round(t1 - t0);\n\n  return {\n    getTissueExpressions,\n    byteRangesByName,\n    tissueNames,\n    tissueColors,\n    tissueSamples\n  };\n}\n\n// Uncomment when workers work outside localhost\n// addEventListener('message', async event => {\n//   console.time('tissueCacheWorker');\n//   const [cacheUrl, perfTimes, debug] = event.data;\n//   const result = await fetchAndParse(cacheUrl, perfTimes, parseCache);\n//   postMessage(result);\n//   if (debug) inspectWorker('paralog', result[0]);\n// });\n","import {\n  fetchAndParse, getFullId, inspectWorker,\n  cacheFetch, cacheRangeFetch, getCacheUrl\n} from './cache-lib';\n\nconst variantOriginMap = {\n  '0': 'unknown',\n  '1': 'germline',\n  '2': 'somatic',\n  '4': 'inherited',\n  '8': 'paternal',\n  '16': 'maternal',\n  '32': 'de-novo',\n  '64': 'biparental',\n  '128': 'uniparental',\n  '256': 'not-tested',\n  '512': 'tested-inconclusive',\n  '1073741824': 'other'\n};\n\nfunction parseDiseaseElement(diseaseArray, i) {\n  const [rawId, rawName] = diseaseArray[i].split('|');\n  const id = 'MONDO:' + rawId;\n  const name = rawName.replaceAll('_', ' ');\n  return [id, name];\n}\n\n/** Transform custom-compressed array into disease name-by-id map */\nfunction parseDiseaseKey(line) {\n  const diseaseNamesById = {};\n\n  // E.g. [\"0012345|Disease_name_1\", \"0000042|Particular_condition\", ...]\n  const diseaseArray = getArray(line);\n\n  for (let i = 0; i < diseaseArray.length; i++) {\n    const [id, name] = parseDiseaseElement(diseaseArray, i);\n    diseaseNamesById[id] = name;\n  }\n\n  return [diseaseArray, diseaseNamesById];\n}\n\n/** Transform custom-compressed molecular consequence array */\nfunction parseMolecularConsequenceKey(line) {\n  const molecularConsequenceById = {};\n\n  // E.g. ['SO:0001574|splice_acceptor_variant', 'SO:0001234|foo', ...]\n  const molecularConsequenceArray = getArray(line);\n\n  for (let i = 0; i < molecularConsequenceArray.length; i++) {\n    const [id, rawName] = molecularConsequenceArray[i].split('|');\n    const name = rawName.replaceAll('_', ' ');\n    molecularConsequenceById[id] = name;\n  }\n\n  return [molecularConsequenceArray, molecularConsequenceById];\n}\n\n/** Get disease names and IDs for this variant, given raw compressed values */\nfunction parseDiseases(rawDiseases, diseaseArray) {\n  const diseases = [];\n\n  if (rawDiseases === '') {\n    return [{id: '', disease: 'Not provided'}];\n  }\n\n  // The raw \"diseases\" value in variants.tsv is a list of integer index values,\n  // which map to the id-name values in disease_mondo_ids_and_names from the\n  // variants.tsv.li file.\n  const diseaseIndexValues = rawDiseases.split(',');\n\n  for (let i = 0; i < diseaseIndexValues.length; i++) {\n    const diseaseIndexValue = parseInt(diseaseIndexValues[i]);\n    const [id, name] = parseDiseaseElement(diseaseArray, diseaseIndexValue);\n    const disease = {id, name};\n    diseases.push(disease);\n  }\n\n  return diseases;\n}\n\n/** Like parseDiseases, but for molecular consequences */\nfunction parseMolecularConsequences(rawMolecularConsequences, mcArray) {\n  const molecularConsequences = [];\n\n  const mcIndexValues = rawMolecularConsequences.split(',');\n\n  for (let i = 0; i < mcIndexValues.length; i++) {\n    const mcIndexValue = parseInt(mcIndexValues[i]);\n    const [id, name] = mcArray[mcIndexValue].split('|');\n    const mc = {id, name};\n    molecularConsequences.push(mc);\n  }\n\n  return molecularConsequences;\n}\n\nfunction parseKey(index, key) {\n  return key[index].replaceAll('_', ' ');\n}\n\n/**\n * Parse a line in variants.tsv, return a useful variant object\n *\n * The line has the format:\n * #CHROM\tPOS\tID\tREF\tALT\tDISEASE_IDS\tCLNREVSTAT\tCLNSIG\tCLNVC\tMC\tORIGIN\tRS\n */\nfunction parseVariant(line, variantCache) {\n\n  const [\n    chromosome,\n    rawPosition,\n    rawClinvarId,\n    refAllele, // Allele in the reference genome\n    altAllele, // Allele that makes this a \"variant\"\n    rawDiseases,\n    rawAfExac,\n    rawReviewStatus,\n    rawClinicalSignificance,\n    rawVariantType,\n    rawMolecularConsequences,\n    rawOrigin,\n    rsNumber\n  ] = line.split('\\t')\n\n  const position = parseInt(rawPosition);\n  const afExac = rawAfExac === '' ? null : parseFloat(rawAfExac);\n\n  const keys = variantCache.keys;\n\n  // const zeros = '0'.repeat(9 - rawClinvarId.length);\n  // const clinvarVariantId = 'VCV' + zeros + rawClinvarId;\n  const clinvarVariantId = rawClinvarId;\n  const diseases = parseDiseases(rawDiseases, keys.diseaseArray);\n  const reviewStatus = parseKey(rawReviewStatus, keys.reviewStatuses);\n  const clinicalSignificance = parseKey(\n    rawClinicalSignificance, keys.clinicalSignificances\n  );\n  const variantType = parseKey(rawVariantType, keys.variantTypes);\n  let molecularConsequences = null;\n  if (rawMolecularConsequences !== '') {\n    molecularConsequences = parseMolecularConsequences(\n      rawMolecularConsequences, keys.molecularConsequenceArray\n    );\n  }\n  const dbSnpId = rsNumber ? 'rs' + rsNumber : null;\n\n  const origin = variantOriginMap[rawOrigin];\n\n  const variant = {\n    chromosome, position,\n    afExac,\n    clinvarVariantId,\n    refAllele,\n    altAllele,\n    diseases,\n    reviewStatus,\n    rawReviewStatus: parseInt(rawReviewStatus),\n    clinicalSignificance,\n    rawClinicalSignificance: parseInt(rawClinicalSignificance),\n    variantType,\n    molecularConsequences,\n    dbSnpId,\n    origin,\n    rawOrigin: parseInt(rawOrigin)\n  };\n\n  return variant;\n}\n\nasync function getVariants(gene, ideo) {\n  const variants = [];\n\n  const cache = Ideogram.variantCache;\n  const byteRange = cache.byteRangesByName[gene];\n\n  // Easier debuggability\n  if (!Ideogram.cacheRangeFetch) Ideogram.cacheRangeFetch = cacheRangeFetch;\n\n  if (!byteRange) return [];\n\n  const config = ideo.config;\n  let cacheDir = null;\n  if (config.cacheDir) cacheDir = config.cacheDir;\n  const cacheType = 'variants';\n  const extension = 'tsv';\n\n  const orgName = 'homo-sapiens';\n  const cacheUrl = getCacheUrl(orgName, cacheDir, cacheType, extension);\n\n  const geneLocus = Ideogram.geneCache.lociByName[gene];\n\n  // Get variant data only for the requested gene\n  const data = await cacheRangeFetch(cacheUrl, byteRange);\n  const lines = data.split('\\n');\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const variant = parseVariant(line, cache);\n    variant.positionRelative = variant.position - geneLocus[1];\n    variants.push(variant);\n  }\n\n  return variants;\n}\n\nfunction getArray(line) {\n  // console.log('line', line)\n  const value = line.split('= ')[1];\n  return JSON.parse(value);\n}\n\n/** Parse a tissue cache TSV file */\nexport function parseVariantCacheIndex(rawTsv, perfTimes, byteRangesByName) {\n  let diseaseArray;\n  let diseaseNamesById; // Per MONDO ontology\n  let variantTypes; // e.g. \"single_nucleotide_variant\", \"Indel\"\n  let clinicalSignificances;\n  let reviewStatuses;\n  let molecularConsequenceArray;\n  let molecularConsequenceById;\n\n  let t0 = performance.now();\n  const lines = rawTsv.split(/\\r\\n|\\n/);\n  perfTimes.rawTsvSplit = Math.round(performance.now() - t0);\n\n  t0 = performance.now();\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (line === '') continue; // Skip empty lines\n    if (line[0] === '#') {\n      // Parse keys\n      const firstChars = line.slice(0, 50);\n      if (firstChars.includes('disease_mondo_ids_and_names')) {\n        [diseaseArray, diseaseNamesById] = parseDiseaseKey(line);\n      } else if (firstChars.includes('variant_types')) {\n        variantTypes = getArray(line);\n      } else if (firstChars.includes('clinical_significances')) {\n        clinicalSignificances = getArray(line);\n      } else if (firstChars.includes('clinical_review_statuses')) {\n        reviewStatuses = getArray(line);\n      } else if (firstChars.includes('molecular_consequences')) {\n        [molecularConsequenceArray, molecularConsequenceById] =\n          parseMolecularConsequenceKey(line);\n      }\n      continue;\n    }\n\n    // Only process comments, because\n    // other variant index lines (byteRangesByName) are processed upstream\n    break;\n  };\n  const t1 = performance.now();\n  perfTimes.parseCacheLoop = Math.round(t1 - t0);\n\n  return {\n    getVariants,\n    byteRangesByName,\n    keys: {\n      diseaseArray,\n      diseaseNamesById,\n      variantTypes,\n      clinicalSignificances,\n      reviewStatuses,\n      molecularConsequenceArray,\n      molecularConsequenceById\n    }\n  };\n}\n\n// Uncomment when workers work outside localhost\n// addEventListener('message', async event => {\n//   console.time('tissueCacheWorker');\n//   const [cacheUrl, perfTimes, debug] = event.data;\n//   const result = await fetchAndParse(cacheUrl, perfTimes, parseCache);\n//   postMessage(result);\n//   if (debug) inspectWorker('paralog', result[0]);\n// });\n","import {\n  supportsCache, getCacheUrl, fetchAndParse,\n  cacheFetch\n} from './cache-lib';\n\n// Uncomment when workers work outside localhost\n// const geneCacheWorker = new Worker(\n//   new URL('./gene-cache-worker.js', import.meta.url), {type: 'module'}\n// );\n// const paralogCacheWorker = new Worker(\n//   new URL('./paralog-cache-worker.js', import.meta.url), {type: 'module'}\n// );\n// const interactionCacheWorker = new Worker(\n//   new URL('./interaction-cache-worker.js', import.meta.url), {type: 'module'}\n// );\n// const geneStructureCacheWorker = new Worker(\n//   new URL('./gene-structure-cache-worker.js', import.meta.url), {type: 'module'}\n// );\n\nimport {parseGeneCache} from './gene-cache-worker';\nimport {parseParalogCache} from './paralog-cache-worker';\nimport {parseInteractionCache} from './interaction-cache-worker';\nimport {parseGeneStructureCache} from './gene-structure-cache-worker';\nimport {parseProteinCache} from './protein-cache-worker';\nimport {parseSynonymCache} from './synonym-cache-worker';\nimport {parseTissueCache} from './tissue-cache-worker';\nimport {parseVariantCacheIndex} from './variant-cache-worker';\n\n/**\n * Populates in-memory content caches from on-disk service worker (SW) caches.\n *\n * This warms the following content caches:\n * - Gene cache: gene symbol -> full name, Ensembl ID, genomic coordinates\n * - Paralog cache: gene symbol -> paralogs (evolutionarily related genes)\n * - Interaction cache: gene symbol -> adjacent genes in biochemical pathways\n *\n * And, optionally:\n * - Gene structure cache: gene symbol -> canonical transcript, exons, UTRs\n * - Protein cache: gene symbol -> protein domains & families, per transcript\n * - Synonym cache: gene symbol -> list of synonyms, a.k.a. aliases\n *\n * Used for related genes kit now, likely worth generalizing in the future.\n *\n * This approach makes navigating related genes ideogram instant and\n * possible completely offline (i.e. a progressive web component) -- but only\n * once caches are populated.\n */\nexport async function initCaches(config) {\n\n  if (!config.useCache) return;\n\n  const organism = config.organism;\n\n  let cacheDir = null;\n  if (config.cacheDir) cacheDir = config.cacheDir;\n\n  if (config.awaitCache) {\n    // Start all these in parallel.  Only initGeneCache blocks; it internally\n    // resolves a Promise, whereas the others return upon completing their\n    // respective initializations.\n    const cachePromise = Promise.all([\n      cacheFactory('gene', organism, config, cacheDir),\n      cacheFactory('paralog', organism, config, cacheDir),\n      cacheFactory('interaction', organism, config, cacheDir),\n      cacheFactory('synonym', organism, config, cacheDir),\n    ]);\n\n    if (config.showGeneStructureInTooltip) {\n      cacheFactory('geneStructure', organism, config, cacheDir);\n      cacheFactory('protein', organism, config, cacheDir);\n      cacheFactory('tissue', organism, config, cacheDir);\n      if (config.showVariantInTooltip) {\n        cacheFactory('variant', organism, config, cacheDir);\n      }\n    }\n\n    return cachePromise;\n\n  } else {\n    cacheFactory('gene', organism, config, cacheDir);\n    cacheFactory('paralog', organism, config, cacheDir);\n    cacheFactory('interaction', organism, config, cacheDir);\n    if (config.showGeneStructureInTooltip) {\n      cacheFactory('geneStructure', organism, config, cacheDir);\n      cacheFactory('protein', organism, config, cacheDir);\n      cacheFactory('synonym', organism, config, cacheDir);\n      cacheFactory('tissue', organism, config, cacheDir);\n      if (config.showVariantInTooltip) {\n        cacheFactory('variant', organism, config, cacheDir);\n      }\n    }\n  }\n}\n\nconst allCacheProps = {\n  gene: {\n    metadata: 'Gene', dir: 'genes',\n    fn: setGeneCache,\n    // worker: geneCacheWorker // Uncomment when workers work\n    parseFn: parseGeneCache // Remove when workers work\n  },\n  paralog: {\n    metadata: 'Paralog', dir: 'paralogs',\n    fn: setParalogCache,\n    // worker: paralogCacheWorker // Uncomment when workers work\n    parseFn: parseParalogCache // Remove when workers work\n  },\n  interaction: {\n    metadata: 'Interaction', dir: 'interactions',\n    fn: setInteractionCache, extension: 'json',\n    // worker: interactionCacheWorker, // Uncomment when workers work\n    parseFn: parseInteractionCache // Remove when workers work\n  },\n  geneStructure: {\n    metadata: 'GeneStructure', dir: 'gene-structures',\n    fn: setGeneStructureCache,\n    // worker: geneStructureCacheWorker // Uncomment when workers work\n    parseFn: parseGeneStructureCache // Remove when workers work\n  },\n  protein: {\n    metadata: 'Protein', dir: 'proteins',\n    fn: setProteinCache,\n    // worker: proteinCacheWorker // Uncomment when workers work\n    parseFn: parseProteinCache // Remove when workers work\n  },\n  synonym: {\n    metadata: 'Synonym', dir: 'synonyms',\n    fn: setSynonymCache,\n    // worker: synonymCacheWorker // Uncomment when workers work\n    parseFn: parseSynonymCache // Remove when workers work\n  },\n  tissue: {\n    metadata: 'Tissue', dir: 'tissues',\n    fn: setTissueCache,\n    // worker: tissueCacheWorker // Uncomment when workers work\n    parseFn: parseTissueCache // Remove when workers work\n  },\n  variant: {\n    metadata: 'Variant', dir: 'variants',\n    fn: setVariantCache, extension: 'tsv.li',\n    // worker: variantCacheWorker // Uncomment when workers work\n    parseFn: parseVariantCacheIndex // Remove when workers work\n  }\n};\n\nfunction setGeneCache(parsedCache) {\n  const [\n    interestingNames, nameCaseMap, namesById, fullNamesById,\n    idsByName, lociByName, lociById\n    //, sortedAnnots\n  ] = parsedCache;\n\n  Ideogram.geneCache = {\n    interestingNames, // Array ordered by general or scholarly interest\n    nameCaseMap, // Maps of lowercase gene names to proper gene names\n    namesById,\n    fullNamesById,\n    idsByName,\n    lociByName, // Object of gene positions, keyed by gene name\n    lociById\n    //, sortedAnnots // Ideogram annotations sorted by genomic position\n  };\n}\n\nfunction setParalogCache(parsedCache) {\n  const paralogsByName = parsedCache;\n  // Array of paralog Ensembl IDs by (uppercase) gene name\n  Ideogram.paralogCache = {paralogsByName};\n}\n\nfunction setInteractionCache(parsedCache) {\n  const interactionsByName = parsedCache;\n  Ideogram.interactionCache = interactionsByName;\n}\n\nfunction setGeneStructureCache(parsedCache) {\n  const featuresByGene = parsedCache;\n  Ideogram.geneStructureCache = featuresByGene;\n}\n\nfunction setProteinCache(parsedCache) {\n  Ideogram.proteinCache = parsedCache;\n}\n\nfunction setSynonymCache(parsedCache) {\n  Ideogram.synonymCache = parsedCache;\n}\n\nfunction setTissueCache(parsedCache) {\n  Ideogram.tissueCache = parsedCache;\n}\n\nfunction setVariantCache(parsedCache) {\n  Ideogram.variantCache = parsedCache;\n}\n\nasync function cacheFactory(cacheName, orgName, config, cacheDir=null) {\n\n  const cacheProps = allCacheProps[cacheName];\n  const debug = config.debug;\n\n  /**\n   * Fetch cached gene data, transform it usefully, and set it as Ideogram prop\n   */\n  const startTime = performance.now();\n  let perfTimes = {};\n\n  let parsedCache;\n\n  // Skip initialization if files needed to make cache don't exist\n  if (!supportsCache(orgName, cacheProps.metadata)) return;\n\n  const staticProp = cacheName + 'Cache';\n  // Skip initialization if cache is already populated\n  if (Ideogram[staticProp] && Ideogram[staticProp][orgName]) {\n    // Simplify chief use case, i.e. for single organism\n    return;\n  }\n\n  if (!Ideogram[staticProp]) {\n    Ideogram[staticProp] = {};\n  }\n\n  const extension = cacheProps?.extension ?? 'tsv';\n  const cacheUrl = getCacheUrl(orgName, cacheDir, cacheProps.dir, extension);\n\n  [parsedCache, perfTimes] =\n    await fetchAndParse(cacheUrl, perfTimes, cacheProps.parseFn, orgName);\n\n  // const cacheWorker = cacheProps.worker;\n  if (debug) console.time(`${cacheName}Cache total`);\n  return new Promise(resolve => {\n  //   const message = [cacheUrl, perfTimes, debug];\n  //   if (cacheName === 'interaction') message.push(orgName);\n  //   cacheWorker.postMessage(message);\n  //   cacheWorker.addEventListener('message', event => {\n  //     [parsedCache, perfTimes] = event.data;\n      cacheProps.fn(parsedCache, orgName);\n      Ideogram[staticProp][orgName] = Ideogram[staticProp];\n\n      if (debug) {\n        console.timeEnd(`${cacheName}Cache total`);\n        perfTimes.total = Math.round(performance.now() - startTime);\n        const preamble = 'perfTimes in init' + cacheProps.metadata + 'Cache:';\n        console.log(preamble, perfTimes);\n      }\n\n      resolve();\n    // });\n  });\n}\n","import {d3} from '../lib';\nimport collinearizeChromosomes from '../collinear';\nimport {initCaches} from './caches/cache';\n\nfunction processLabels(config, ideo) {\n  var i, chrID, t0C, t1C;\n\n  if (config.showBandLabels === true) {\n    t0C = new Date().getTime();\n    ideo.hideUnshownBandLabels();\n    t1C = new Date().getTime();\n    if (config.debug) {\n      console.log('Time in showing bands: ' + (t1C - t0C) + ' ms');\n    }\n\n    if (config.orientation === 'vertical') {\n      for (i = 0; i < ideo.chromosomesArray.length; i++) {\n        chrID = '#' + ideo.chromosomesArray[i].id;\n        ideo.rotateChromosomeLabels(d3.select(chrID), i);\n      }\n    }\n  }\n\n  if (config.showChromosomeLabels === true) {\n    ideo.drawChromosomeLabels(ideo.chromosomes);\n  }\n}\n\nfunction processAnnots(ideo) {\n  if (typeof ideo.timeout !== 'undefined') window.clearTimeout(ideo.timeout);\n\n  ideo.rawAnnots = ideo.setOriginalTrackIndexes(ideo.rawAnnots);\n\n  if (ideo.config.annotationsDisplayedTracks) {\n    ideo.annots =\n      ideo.updateDisplayedTracks(ideo.config.annotationsDisplayedTracks);\n  } else {\n    ideo.annots = ideo.processAnnotData(ideo.rawAnnots);\n    if (ideo.config.filterable) ideo.initCrossFilter();\n    ideo.drawProcessedAnnots(ideo.annots);\n  }\n}\n\n/**\n * Load (potentially large) annotation dataset, then process it.\n */\nfunction waitForAndProcessAnnots(ideo) {\n  if (ideo.rawAnnots) {\n    processAnnots(ideo);\n  } else {\n    (function checkAnnotData() {\n      ideo.timeout = setTimeout(function() {\n        if (\n          !ideo.rawAnnots ||\n          (ideo.rawAnnots && typeof ideo.rawAnnots.then !== 'undefined')\n        ) {\n          // Ensure rawAnnots is defined and not a Promise (not \"then\"-able)\n          checkAnnotData();\n        } else {\n          processAnnots(ideo);\n        }\n      }, 50);\n    })();\n  }\n}\n\nfunction reportDebugTimings(config, t0, t0A) {\n\n  var t1A = new Date().getTime();\n  if (config.debug) {\n    console.log('Time in drawChromosome: ' + (t1A - t0A) + ' ms');\n  }\n\n  var t1 = new Date().getTime();\n  if (config.debug) {\n    console.log('Time constructing ideogram: ' + (t1 - t0) + ' ms');\n  }\n}\n\n/**\n * Completes high-level initialization.\n * Draws chromosomes and band labels, rotating as needed;\n * processes and draws annotations;\n * creates brush, emits notification of load completion, etc.\n */\nfunction finishInit(t0) {\n  var t0A = new Date().getTime(),\n    ideo = this,\n    config = ideo.config,\n    confAnnots = config.annotations;\n\n  ideo.initDrawChromosomes();\n\n  if (config.annotationsPath) waitForAndProcessAnnots(ideo);\n\n  processLabels(config, ideo);\n\n  // Create a brush or a click cursor if specified\n  if (config.brush) ideo.createBrush(config.brush);\n  else if (config.cursorPosition) ideo.createClickCursor(config.cursorPosition);\n\n  if (confAnnots) {\n    if (Array.isArray(confAnnots)) {\n      ideo.drawAnnots(confAnnots);\n    } else {\n      // Enable client-side-defined annotations to be formatted\n      // like the wider variety of server-side-defined annotations.\n      // Supports https://github.com/eweitz/ideogram/issues/137\n      ideo.rawAnnots = confAnnots;\n      ideo.afterRawAnnots();\n      processAnnots(ideo);\n    }\n  }\n\n  reportDebugTimings(config, t0, t0A);\n\n  ideo.setOverflowScroll();\n\n  if (config.geometry === 'collinear') collinearizeChromosomes(ideo);\n\n  if (ideo.config.debug) console.time('initCache: Ideogram');\n  initCaches(ideo.config).then(() => {\n    if (ideo.config.debug) console.timeEnd('initCache: Ideogram');\n    if (ideo.onLoadCallback) ideo.onLoadCallback();\n  });\n}\n\nexport {finishInit};\n","export class Ploidy {\n\n  constructor(config) {\n    this._config = config;\n    this._description = this._normalize(this._config.ploidyDesc);\n  }\n\n  // Get number of chromosomes in a chromosome set\n  getChromosomesNumber(setIndex) {\n    if (this._config.ploidyDesc) {\n      var chrSetCode = this._config.ploidyDesc[setIndex];\n      if (chrSetCode instanceof Object) {\n        return Object.keys(chrSetCode)[0].length;\n      } else {\n        return chrSetCode.length;\n      }\n    } else {\n      return this._config.ploidy || 1;\n    }\n  }\n\n  // Normalize use defined description\n  _normalize(description) {\n    var key, descValue,\n      normalized = [];\n\n    if (!description) return description;\n\n    // Loop through description and normalize\n    for (key in description) {\n      descValue = description[key];\n      if (typeof descValue === 'string') {\n        if (this._config.orientation === 'vertical') {\n          descValue = descValue.split('').reverse();\n        }\n        normalized.push({\n          ancestors: descValue,\n          existence: this._getexistenceArray(descValue.length)\n        });\n      } else {\n        normalized.push({\n          ancestors: Object.keys(descValue)[0],\n          existence: descValue[Object.keys(descValue)[0]]\n        });\n      }\n    }\n\n    return normalized;\n  }\n\n  // Get array filled by '11' elements\n  _getexistenceArray(length) {\n    var array = [];\n\n    for (var i = 0; i < length; i++) {\n      array.push('11');\n    }\n\n    return array;\n  }\n\n  getSetSize(chrSetIndex) {\n    if (this._description) {\n      return this._description[chrSetIndex].ancestors.length;\n    } else {\n      return 1;\n    }\n  }\n\n  // Get ancestor letter\n  getAncestor(chrSetIndex, chrIndex) {\n    if (this._description) {\n      return this._description[chrSetIndex].ancestors[chrIndex];\n    } else {\n      return '';\n    }\n  }\n\n  // Check if chromosome's arm should be rendered.\n  // If no description was provided, method returns true and\n  // something another depending on user provided description.\n  exists(chrSetIndex, chrIndex, armIndex) {\n    if (this._description) {\n      var desc =\n        this._description[chrSetIndex].existence[chrIndex][armIndex];\n      return Number(desc) > 0;\n    } else {\n      return true;\n    }\n  }\n\n}\n","import {d3} from '../lib';\n\n/**\n * Chromosome's view utility class\n */\nexport class ChromosomeUtil {\n\n  constructor(node) {\n    this._node = node;\n  }\n\n  getLabel() {\n    var label =\n      d3\n        .select(this._node.parentNode)\n        .select('text.chrLabel')\n        .text();\n    return label;\n  }\n\n  /**\n   * Get chromosome set label\n   */\n  getSetLabel() {\n    var setLabel =\n      d3\n        .select(this._node.parentNode)\n        .select('text.chrSetLabel')\n        .text();\n    return setLabel;\n  }\n}\n","import {d3} from '../lib';\nimport {ChromosomeUtil} from './../views/chromosome-util';\n\nclass Layout {\n\n  constructor(config, ideo) {\n    this._config = config;\n    this._ideo = ideo;\n    this._ploidy = this._ideo._ploidy;\n    this._translate = undefined;\n\n    if ('chrSetMargin' in config) {\n      this.chrSetMargin = config.chrSetMargin;\n    } else {\n      var chrMargin = this._config.chrMargin;\n      this.chrSetMargin = (this._config.ploidy > 1 ? chrMargin : 0);\n    }\n\n    // Chromosome band's size.\n    this._tickSize = 8;\n\n    // Chromosome rotation state.\n    this._isRotated = false;\n  }\n\n  // Get chart left margin\n  _getLeftMargin() {\n    return this.margin.left;\n  }\n\n  // Get rotated chromosome y scale\n  _getYScale() {\n    // 20 is width of rotated chromosome.\n    return 20 / this._config.chrWidth;\n  }\n\n  // Get chromosome labels\n  getChromosomeLabels(chrElement) {\n    var util = new ChromosomeUtil(chrElement),\n      labels = [];\n\n    if (this._ideo.config.ploidy > 1) {\n      labels.push(util.getSetLabel());\n    }\n    labels.push(util.getLabel());\n\n    return labels.filter(function(d) {\n      return d.length > 0;\n    });\n  }\n\n  getChromosomeBandLabelTranslate(band) {\n    var x, y, translate,\n      ideo = this._ideo,\n      tickSize = this._tickSize,\n      orientation = ideo.config.orientation;\n\n    if (orientation === 'vertical') {\n      x = tickSize;\n      y = ideo.round(2 + band.px.start + band.px.width / 2);\n      translate = 'rotate(-90)translate(' + x + ',' + y + ')';\n    } else if (orientation === 'horizontal') {\n      x = ideo.round(-tickSize + band.px.start + band.px.width / 2);\n      y = -10;\n      translate = 'translate(' + x + ',' + y + ')';\n    }\n\n    return {\n      x: x,\n      y: y,\n      translate: translate\n    };\n  }\n\n  didRotate(chrIndex, chrElement) {\n    var ideo, taxid, chrName, bands, chrModel, oldWidth,\n      chrSetElement, transform, scale, scaleRE;\n\n    ideo = this._ideo;\n    taxid = ideo.config.taxid;\n    chrName = chrElement.id.split('-')[0].replace('chr', '');\n    chrModel = ideo.chromosomes[taxid][chrName];\n    bands = chrModel.bands;\n\n    chrSetElement = d3.select(chrElement.parentNode);\n    transform = chrSetElement.attr('transform');\n    scaleRE = /scale\\(.*\\)/;\n    scale = scaleRE.exec(transform);\n    transform = transform.replace(scale, '');\n    chrSetElement.attr('transform', transform);\n\n    oldWidth = chrModel.width;\n\n    chrModel = ideo.getChromosomeModel(bands, chrName, taxid, chrIndex);\n\n    chrModel.oldWidth = oldWidth;\n\n    ideo.chromosomes[taxid][chrName] = chrModel;\n    ideo.drawChromosome(chrModel);\n\n    ideo.handleRotateOnClick();\n\n    if (ideo.rawAnnots) {\n      if (ideo.displayedTrackIndexes) {\n        ideo.updateDisplayedTracks(ideo.displayedTrackIndexes);\n      } else {\n        ideo.annots = ideo.processAnnotData(ideo.rawAnnots);\n        ideo.drawProcessedAnnots(ideo.annots);\n\n        if (ideo.config.filterable) {\n          ideo.initCrossFilter();\n        }\n      }\n    }\n\n    if (ideo.config.showBandLabels === true) {\n      ideo.drawBandLabels(ideo.chromosomes);\n      ideo.hideUnshownBandLabels();\n    }\n\n    if (ideo.onDidRotateCallback) {\n      ideo.onDidRotateCallback(chrModel);\n    }\n  }\n\n  rotate(chrSetIndex, chrIndex, chrElement) {\n    var ideo, otherChrs, ideoBounds, labelSelectors;\n    ideo = this._ideo;\n\n    labelSelectors = (\n      ideo.selector + ' .chrSetLabel, ' + ideo.selector + ' .chrLabel'\n    );\n\n    ideoBounds = document.querySelector(ideo.selector).getBoundingClientRect();\n\n    // Find chromosomes which should be hidden\n    otherChrs = d3.selectAll(ideo.selector + ' g.chromosome')\n      .filter(function() {return this !== chrElement;});\n\n    if (this._isRotated) {\n\n      this._isRotated = false;\n\n      ideo.config.chrHeight = ideo.config.chrHeightOriginal;\n      ideo.config.chrWidth = ideo.config.chrWidthOriginal;\n      ideo.config.annotationHeight = ideo.config.annotationHeightOriginal;\n\n      // Rotate chromosome back\n      this.rotateBack(chrSetIndex, chrIndex, chrElement, function() {\n        // Show all other chromosomes and chromosome labels\n        otherChrs.style('display', null);\n        d3.selectAll(labelSelectors).style('display', null);\n        ideo._layout.didRotate(chrIndex, chrElement);\n      });\n\n    } else {\n\n      this._isRotated = true;\n\n      // Hide all other chromosomes and chromosome labels\n      otherChrs.style('display', 'none');\n      d3.selectAll(labelSelectors).style('display', 'none');\n\n      // Rotate chromosome\n      this.rotateForward(chrSetIndex, chrIndex, chrElement, function() {\n\n        var chrHeight, elementLength, windowLength;\n\n        ideo.config.chrHeightOriginal = ideo.config.chrHeight;\n        ideo.config.chrWidthOriginal = ideo.config.chrWidth;\n        ideo.config.annotationHeightOriginal = ideo.config.annotationHeight;\n\n        const settingsGearWidth = 20;\n\n        if (ideo._layout._class === 'VerticalLayout') {\n          elementLength = ideoBounds.width - settingsGearWidth;\n          windowLength = window.innerWidth - settingsGearWidth;\n        } else {\n          elementLength = ideoBounds.height - 10;\n          windowLength = window.innerHeight - 10;\n        }\n\n        // Set chromosome height to window length or ideogram element length,\n        // whichever is smaller.  This keeps whole chromosome viewable, while\n        // also ensuring the height doesn't exceed what the user specified.\n        if (windowLength < elementLength) {\n          chrHeight = windowLength;\n        } else {\n          chrHeight = elementLength;\n        }\n        chrHeight -= ideo.config.chrMargin * 2;\n        ideo.config.chrHeight = chrHeight;\n\n        // Account for chromosome label\n        // TODO: Make this dynamic, not hard-coded\n        ideo.config.chrWidth *= 2.3;\n\n        ideo.config.annotationHeight *= 1.7;\n\n        ideo._layout.didRotate(chrIndex, chrElement);\n      });\n    }\n  }\n\n  getChromosomeLabelClass() {\n    if (this._config.ploidy === 1) {\n      return 'chrLabel';\n    } else {\n      return 'chrSetLabel';\n    }\n  }\n\n  _getAdditionalOffset() {\n    var config = this._config;\n    var numTracks = config.annotationsNumTracks || config.numAnnotTracks || 1;\n    return (config.annotationHeight || 0) * numTracks;\n  }\n\n  _getChromosomeSetSize(chrSetIndex) {\n    // Get last chromosome set size.\n    var setSize = this._ploidy.getSetSize(chrSetIndex);\n\n    // Increase offset by last chromosome set size\n    return (\n      setSize * this._config.chrWidth * 2 + (this.chrSetMargin)\n    );\n  }\n\n  // Get chromosome set label anchor property\n  getChromosomeSetLabelAnchor() {\n    return 'middle';\n  }\n\n  // Get chromosome label y position.\n  getChromosomeLabelYPosition() {\n    return -5.5;\n  }\n\n  getChromosomeSetLabelYPosition(chrIndex) {\n    if (this._config.ploidy === 1) {\n      return this.getChromosomeLabelYPosition(chrIndex);\n    } else {\n      return -2 * this._config.chrWidth;\n    }\n  }\n\n}\n\nexport default Layout;\n","/**\n* @fileoverview Vertical layout class\n* Ideogram instances with vertical layout are oriented with each chromosome\n* starting at top and ending at bottom, and aligned as columns.\n*/\n\nimport {d3} from '../lib';\nimport Layout from './layout';\n\nclass VerticalLayout extends Layout {\n\n  constructor(config, ideo) {\n    super(config, ideo);\n    this._class = 'VerticalLayout';\n    // Layout margins\n    this.margin = {\n      top: 30,\n      left: 15\n    };\n  }\n\n  rotateForward(chrSetIndex, chrIndex, chrElement, callback) {\n    // TODO: Integrate chrSetIndex and chrIndex to support polyploid rotation.\n\n    var self = this;\n\n    var xOffset = 20;\n\n    var scale = this.getChromosomeScale(chrElement);\n\n    var transform =\n      'translate(' + xOffset + ', 25) ' + scale;\n\n    d3.select(chrElement.parentNode)\n      .transition()\n      .attr('transform', transform)\n      .on('end', callback);\n\n    // Append new chromosome labels\n    var labels = this.getChromosomeLabels(chrElement);\n    var y = (xOffset + self._config.chrWidth) * 1.3;\n    d3.select(this._ideo.getSvg())\n      .append('g')\n      .attr('class', 'tmp')\n      .selectAll('text')\n      .data(labels)\n      .enter()\n      .append('text')\n      .attr('class', function(d, i) {\n        return i === 0 && labels.length === 2 ? 'chrSetLabel' : null;\n      })\n      .attr('x', 0)\n      .attr('y', y).style('opacity', 0)\n      .text(String)\n      .transition()\n      .style('opacity', 1);\n\n    this._ideo.config.orientation = 'horizontal';\n  }\n\n  rotateBack(setIndex, chrIndex, chrElement, callback) {\n\n    var scale = this.getChromosomeScaleBack(chrElement);\n    var translate = this.getChromosomeSetTranslate(setIndex);\n\n    d3.select(chrElement.parentNode)\n      .transition()\n      .attr('transform', translate + ' ' + scale)\n      .on('end', callback);\n\n    d3.selectAll(this._ideo.selector + ' g.tmp')\n      .style('opacity', 0)\n      .remove();\n\n    this._ideo.config.orientation = 'vertical';\n  }\n\n  getHeight() {\n    return this._config.chrHeight + this.margin.top * 1.5;\n  }\n\n  getWidth() {\n    return '97%';\n  }\n\n  getChromosomeBandTickY1() {\n    return 2;\n  }\n\n  getChromosomeBandTickY2() {\n    return 10;\n  }\n\n  getChromosomeSetLabelTranslate() {\n    return 'rotate(-90)';\n  }\n\n  getChromosomeBandLabelAnchor() {\n    return null;\n  }\n\n  getChromosomeScale(chrElement) {\n    var ideoBox, chrBox, scaleX, scaleY;\n\n    ideoBox = d3.select(this._ideo.selector).node().getBoundingClientRect();\n    chrBox = chrElement.getBoundingClientRect();\n\n    scaleX = (ideoBox.width / chrBox.height) * 0.97;\n    scaleY = this._getYScale();\n\n    return 'scale(' + scaleX + ', ' + scaleY + ')';\n  }\n\n  getChromosomeScaleBack(chrElement) {\n    var scale, scaleX, scaleY, chrName, chrModel, taxid, ideo, config;\n\n    ideo = this._ideo;\n    config = ideo.config;\n    taxid = config.taxid;\n\n    chrName = chrElement.id.split('-')[0].replace('chr', '');\n    chrModel = this._ideo.chromosomes[taxid][chrName];\n    scaleX = (chrModel.oldWidth / (config.chrHeight * 3)) * 0.97;\n    scaleY = 1 / this._getYScale();\n    scale = 'scale(' + scaleX + ', ' + scaleY + ')';\n    return scale;\n  }\n\n  getChromosomeSetTranslate(setIndex) {\n    var marginTop = this.margin.top;\n    var chromosomeSetYTranslate = this.getChromosomeSetYTranslate(setIndex);\n    return (\n      'rotate(90) ' +\n      'translate(' + marginTop + ', -' + chromosomeSetYTranslate + ')'\n    );\n  }\n\n  getChromosomeSetYTranslate(setIndex) {\n    // Get additional padding caused by annotation/histogram tracks\n    var pad = this._getAdditionalOffset(),\n      config = this._config,\n      margin = config.chrMargin,\n      width = config.chrWidth,\n      translate;\n\n    // If no detailed description provided just use one formula for all cases\n    if (!config.ploidyDesc) {\n      // TODO:\n      // This part of code contains a lot magic numbers and if\n      // statements for exactly corresponing to original ideogram examples.\n      // But all this stuff should be removed. Calculation of translate\n      // should be a simple formula applied for all cases listed below.\n      // Now they are diffirent because of Layout:_getAdditionalOffset do\n      // not meet for cases when no annotation, when annotation exists and\n      // when histogram used\n\n      if (config.annotationsLayout === 'histogram') {\n        var barWidth = config.barWidth;\n        return margin + setIndex * (margin + width + 3) + barWidth * 2;\n      } else {\n        const decorPad =\n          'legendPad' in config ? config.legendPad : 0;\n        translate = width + setIndex * (margin + width) + pad * 2 + decorPad;\n        if (pad > 0) {\n          return translate;\n        } else {\n          return translate + 4 + (2 * setIndex);\n        }\n      }\n    }\n\n    // If detailed description provided start to calculate offsets\n    // for each chromosome set separately. This should be done only once\n    if (!this._translate) {\n      // First offset equals to zero\n      this._translate = [this._ploidy.getSetSize(0) * width * 2];\n      var prevTranslate;\n      // Loop through description set\n      for (var i = 1; i < this._config.ploidyDesc.length; i++) {\n        prevTranslate = this._translate[i - 1];\n        this._translate[i] = prevTranslate + this._getChromosomeSetSize(i - 1);\n      }\n    }\n\n    return this._translate[setIndex];\n  }\n\n  getChromosomeSetLabelXPosition() {\n    return (this._config.chrWidth * this._config.ploidy) / -2;\n  }\n\n  getChromosomeLabelXPosition() {\n    return this._config.chrWidth / -2;\n  }\n}\n\nexport default VerticalLayout;\n","/**\n* @fileoverview Horizontal layout class\n* Ideogram instances with horizontal layout are oriented with each chromosome\n* starting at left and ending at right, and aligned as rows.\n*/\n\nimport {d3} from '../lib';\nimport Layout from './layout';\n\nclass HorizontalLayout extends Layout {\n\n  constructor(config, ideo) {\n    super(config, ideo);\n    this._class = 'HorizontalLayout';\n    this.margin = {\n      left: 20,\n      top: 30\n    };\n  }\n\n  _getLeftMargin() {\n    var margin = Layout.prototype._getLeftMargin.call(this);\n    if (this._config.ploidy > 1) {\n      margin *= 1.8;\n    }\n\n    return margin;\n  }\n\n  rotateForward(setIndex, chrIndex, chrElement, callback) {\n\n    var xOffset, yOffset, transform, labels;\n\n    xOffset = 30;\n\n    yOffset = xOffset + 7.5;\n\n    transform = (\n      'rotate(90) ' +\n      'translate(' + xOffset + ', -' + yOffset + ') '\n    );\n\n    d3.select(chrElement.parentNode)\n      .transition()\n      .attr('transform', transform)\n      .on('end', callback);\n\n    // Append new chromosome labels\n    labels = this.getChromosomeLabels(chrElement);\n    d3.select(this._ideo.getSvg())\n      .append('g')\n      .attr('class', 'tmp')\n      .selectAll('text')\n      .data(labels)\n      .enter()\n      .append('text')\n      .attr('class', function(d, i) {\n        return i === 0 && labels.length === 2 ? 'chrSetLabel' : null;\n      })\n      .attr('x', xOffset - 4)\n      .attr('y', function(d, i) {\n        return (i + 1 + labels.length % 2) * 12;\n      })\n      .style('text-anchor', 'middle')\n      .style('opacity', 0)\n      .text(String)\n      .transition()\n      .style('opacity', 1);\n\n    this._ideo.config.orientation = 'vertical';\n  }\n\n  rotateBack(setIndex, chrIndex, chrElement, callback) {\n    var translate = this.getChromosomeSetTranslate(setIndex);\n\n    d3.select(chrElement.parentNode)\n      .transition()\n      .attr('transform', translate)\n      .on('end', callback);\n\n    d3.selectAll(this._ideo.selector + ' g.tmp')\n      .style('opacity', 0)\n      .remove();\n\n    this._ideo.config.orientation = 'horizontal';\n  }\n\n  getHeight(taxid) {\n    if (typeof taxid === 'undefined') taxid = this._config.taxids[0];\n    // Get last chromosome set offset.\n    var numChromosomes = this._config.chromosomes[taxid].length;\n    var lastSetOffset = this.getChromosomeSetYTranslate(numChromosomes - 1);\n\n    // Get last chromosome set size.\n    var lastSetSize = this._getChromosomeSetSize(numChromosomes - 1);\n\n    // Increase offset by last chromosome set size\n    lastSetOffset += lastSetSize;\n\n    return lastSetOffset + this._getAdditionalOffset() * 2;\n  }\n\n  getWidth() {\n    return this._config.chrHeight + this.margin.top * 1.5;\n  }\n\n  getChromosomeSetLabelAnchor() {\n    return 'end';\n  }\n\n  getChromosomeBandLabelAnchor() {\n    return null;\n  }\n\n  getChromosomeBandTickY1() {\n    return 2;\n  }\n\n  getChromosomeBandTickY2() {\n    return 10;\n  }\n\n  getChromosomeSetLabelTranslate() {\n    return null;\n  }\n\n  getChromosomeSetTranslate(setIndex) {\n    var leftMargin = this._getLeftMargin();\n    var yTranslate = this.getChromosomeSetYTranslate(setIndex);\n    return 'translate(' + leftMargin + ', ' + yTranslate + ')';\n  }\n\n  getChromosomeSetYTranslate(setIndex) {\n    // If no detailed description provided just use one formula for all cases.\n    if (!this._config.ploidyDesc) {\n      return this._config.chrMargin * (setIndex + 1);\n    }\n\n    // Id detailed description provided start to calculate offsets\n    //  for each chromosome set separately. This should be done only once.\n    if (!this._translate) {\n      // First offset equals to zero.\n      this._translate = [1];\n\n      // Loop through description set\n      for (var i = 1; i < this._config.ploidyDesc.length; i++) {\n        this._translate[i] =\n          this._translate[i - 1] + this._getChromosomeSetSize(i - 1);\n      }\n    }\n\n    return this._translate[setIndex];\n  }\n\n  getChromosomeSetLabelXPosition(i) {\n    if (this._config.ploidy === 1) {\n      return this.getChromosomeLabelXPosition(i);\n    } else {\n      return -20;\n    }\n  }\n\n  getChromosomeSetLabelYPosition(i) {\n    var setSize = this._ploidy.getSetSize(i),\n      config = this._config,\n      chrMargin = config.chrMargin,\n      chrWidth = config.chrWidth,\n      y;\n\n    if (config.ploidy === 1) {\n      y = chrWidth / 2 + 3;\n    } else {\n      y = (setSize * chrMargin) / 2;\n    }\n\n    return y;\n  }\n\n  getChromosomeLabelXPosition() {\n    return -8;\n  }\n\n  getChromosomeLabelYPosition() {\n    return this._config.chrWidth;\n  }\n\n}\n\nexport default HorizontalLayout;\n","/**\n* @fileoverview Paired layout class\n* Ideograms with paired layout group each chromosome in a chromosome set.\n* This enables ploidy support beyond the default haploid; e.g. diploid genomes.\n*/\n\nimport Layout from './layout';\n\nclass PairedLayout extends Layout {\n\n  constructor(config, ideo) {\n    super(config, ideo);\n\n    this._class = 'PairedLayout';\n\n    this.margin = {\n      left: 30\n    };\n  }\n\n  getHeight() {\n    return this._config.chrHeight + this.margin.left * 1.5;\n  }\n\n  getWidth() {\n    return '97%';\n  }\n\n  getChromosomeBandTickY1(chrIndex) {\n    return chrIndex % 2 ? this._config.chrWidth : this._config.chrWidth * 2;\n  }\n\n  getChromosomeBandTickY2(chrIndex) {\n    var width = this._config.chrWidth;\n    return chrIndex % 2 ? width - this._tickSize : width * 2 + this._tickSize;\n  }\n\n  getChromosomeBandLabelAnchor(chrIndex) {\n    return chrIndex % 2 ? null : 'end';\n  }\n\n  getChromosomeBandLabelTranslate(band, chrIndex) {\n    var x = chrIndex % 2 ? 10 : -this._config.chrWidth - 10;\n    var y = this._ideo.round(band.px.start + band.px.width / 2) + 3;\n\n    return {\n      x: y,\n      y: y,\n      translate: 'rotate(-90) translate(' + x + ', ' + y + ')'\n    };\n  }\n\n  getChromosomeLabelXPosition() {\n    return -this._tickSize;\n  }\n\n  getChromosomeSetLabelXPosition() {\n    return this._config.chrWidth / -2;\n  }\n\n  getChromosomeSetLabelTranslate() {\n    return 'rotate(-90)';\n  }\n\n  getChromosomeSetTranslate(setIndex) {\n    var chromosomeSetYTranslate = this.getChromosomeSetYTranslate(setIndex);\n    return (\n      'rotate(90) ' +\n      'translate(' + this.margin.left + ', -' + chromosomeSetYTranslate + ')'\n    );\n  }\n\n  getChromosomeSetYTranslate(setIndex) {\n    return 200 * (setIndex + 1);\n  }\n\n}\n\nexport default PairedLayout;\n","import Layout from './layout';\n\nclass SmallLayout extends Layout {\n\n  constructor(config, ideo) {\n    super(config, ideo);\n\n    this._class = 'SmallLayout';\n\n    this.margin = {\n      left: 36.5,\n      top: 10\n    };\n\n    var taxid = this._ideo.getTaxid(this._ideo.config.organism);\n\n    this.chrs = config.chromosomes[taxid];\n    var numChrs = this.chrs.length;\n\n    // Number of chromosomes per row\n    this.chrsPerRow = Math.ceil(numChrs / config.rows);\n  }\n\n  // rotateForward(setIndex, chrIndex, chrElement, callback) {\n  //   var ideoBox =\n  //      d3.select(this._ideo.selector).node().getBoundingClientRect();\n  //   var chrBox = chrElement.getBoundingClientRect();\n  //\n  //   var scaleX = (ideoBox.width / chrBox.height) * 0.97;\n  //   var scaleY = this._getYScale();\n  //\n  //   transform = 'translate(5, 25) scale(' + scaleX + ', ' + scaleY + ')';\n  //\n  //   d3.select(chrElement.parentNode)\n  //     .transition()\n  //     .attr('transform', transform)\n  //     .on('end', callback);\n  // }\n  //\n  // rotateBack(setIndex, chrIndex, chrElement, callback) {\n  //   var translate = this.getChromosomeSetTranslate(setIndex);\n  //\n  //   d3.select(chrElement.parentNode)\n  //     .transition()\n  //     .attr('transform', translate)\n  //     .on('end', callback);\n  // }\n\n  /**\n   * eweitz 2020-04-13:\n   * This height metric is crude because it is calculated before\n   * the height (\"width\") of each chromosome is calculated.\n   *\n   * It calculates height by multiplying the max height of all chromosomes\n   * (specified in the Ideogram configuration object) by the number of rows.\n   * This ensures the ideogram height doesn't truncate in cases like dog\n   * (where chrX on the second row is longer than chr1 on the first), but it\n   * often leaves too much space on the second row, e.g. for human.\n   *\n   * Ideally, ideogram height would be cumulative height per row, plus top\n   * margin.  This would require calling getHeight _after_ all chromosomes\n   * have had their height (technically, chr.width) assigned.  See draft new\n   * getHeight method below this getHeight method.\n  */\n  getHeight() {\n    var config = this._config;\n    var chrHeight = config.chrHeight * 1.25;\n    return this._config.rows * (chrHeight + this.margin.top);\n  }\n\n  /**\n   * eweitz 2020-04-13:\n   * Draft refinement of getHeight.  See note in classic version above.\n   *\n   * Total height is cumulative height per row, plus top margin\n   */\n  // getHeight() {\n  //   let height = 0;\n  //   const rows = this._config.rows;\n  //   const chrEntries = Object.entries(this.chrs);\n\n  //   for (let i = 0; i < rows; i++) {\n  //     let rowHeight = 0;\n  //     // Starting and ending indexes of chromosomes of this row\n  //     const startIndex = this.chrsPerRow * i;\n  //     const endIndex = this.chrsPerRow * (i + 1) - 1;\n\n  //     for (let j = startIndex; j < endIndex; j++) {\n  //       const thisChrHeight = chrEntries[j][1].width;\n  //       if (thisChrHeight > rowHeight) {\n  //         rowHeight = thisChrHeight;\n  //       }\n  //     }\n  //     height += rowHeight + this.margin.top;\n  //   }\n\n  //   return height;\n  // }\n\n  getWidth() {\n    return '97%';\n  }\n\n  getChromosomeBandLabelTranslate() {\n\n  }\n\n  getChromosomeSetLabelTranslate() {\n    return 'rotate(-90)';\n  }\n\n  getChromosomeSetTranslate(setIndex) {\n    var xOffset, yOffset;\n\n    if (setIndex > this.chrsPerRow - 1) {\n      xOffset = this.margin.left + this._config.chrHeight * 1.3;\n      yOffset = this.getChromosomeSetYTranslate(setIndex - this.chrsPerRow);\n    } else {\n      xOffset = this.margin.left;\n      yOffset = this.getChromosomeSetYTranslate(setIndex);\n    }\n\n    return 'rotate(90) translate(' + xOffset + ', -' + yOffset + ')';\n  }\n\n  getChromosomeSetYTranslate(setIndex) {\n    // Get additional padding caused by annotation tracks\n    var additionalPadding = this._getAdditionalOffset() * 0.3;\n    // If no detailed description provided just use one formula for all cases\n    return (\n      this.margin.left * (setIndex) + this._config.chrWidth +\n      additionalPadding * 2 + additionalPadding * setIndex\n    );\n  }\n\n  getChromosomeSetLabelXPosition(setIndex) {\n    return (\n      ((this._ploidy.getSetSize(setIndex) * this._config.chrWidth + 20) / -2) +\n      (this._config.ploidy > 1 ? 0 : this._config.chrWidth)\n    );\n  }\n\n  getChromosomeLabelXPosition() {\n    return this._config.chrWidth / -2;\n  }\n\n}\n\nexport default SmallLayout;\n","import VerticalLayout from './vertical-layout';\nimport HorizontalLayout from './horizontal-layout';\nimport PairedLayout from './paired-layout';\nimport SmallLayout from './small-layout';\n\nfunction getLayout(ideo) {\n  var config = ideo.config;\n\n  if ('perspective' in config && config.perspective === 'comparative') {\n    return new PairedLayout(config, ideo);\n  } else if ('rows' in config && config.rows > 1) {\n    return new SmallLayout(config, ideo);\n  } else if (config.orientation === 'vertical') {\n    return new VerticalLayout(config, ideo);\n  } else if (config.orientation === 'horizontal') {\n    return new HorizontalLayout(config, ideo);\n  } else {\n    return new VerticalLayout(config, ideo);\n  }\n}\n\nexport {getLayout};\n","import {d3} from '../lib';\nimport {Ploidy} from '../ploidy';\nimport {getLayout} from '../layouts/layout-adapter';\n\n/**\n * If ploidy description is a string, then convert it to the canonical\n * array format.  String ploidyDesc is used when depicting e.g. parental\n * origin each member of chromosome pair in a human genome.\n * See ploidy-basic.html for usage example.\n */\nfunction setPloidy(ideo) {\n  if (\n    'ploidyDesc' in ideo.config &&\n    typeof ideo.config.ploidyDesc === 'string'\n  ) {\n    var tmp = [];\n    for (var i = 0; i < ideo.numChromosomes; i++) {\n      tmp.push(ideo.config.ploidyDesc);\n    }\n    ideo.config.ploidyDesc = tmp;\n  }\n  // Organism ploidy description\n  ideo._ploidy = new Ploidy(ideo.config);\n}\n\nfunction getContainerSvgClass(ideo) {\n  var svgClass = '';\n  if (ideo.config.showChromosomeLabels) {\n    if (ideo.config.orientation === 'horizontal') {\n      svgClass += 'labeledLeft ';\n    } else {\n      svgClass += 'labeled ';\n    }\n  }\n\n  if (ideo.config.rotatable === false) {\n    svgClass += 'no-rotate ';\n  }\n\n  if (\n    ideo.config.annotationsLayout &&\n    ideo.config.annotationsLayout === 'overlay'\n  ) {\n    svgClass += 'faint';\n  }\n\n  return svgClass;\n}\n\n/** Hide tooltip upon pressing \"esc\" on keyboard */\nfunction handleEscape(event) {\n  if (event.keyCode === 27) { // \"Escape\" key pressed\n    const tooltip = document.querySelector('._ideogramTooltip');\n    if (tooltip) {\n      tooltip.style.opacity = 0;\n    }\n    const pathwayContainer = document.querySelector('#ideo-pathway-container');\n    if (pathwayContainer) {\n      pathwayContainer.remove();\n    }\n  }\n}\n\n/**\n * Write tooltip div setup with default styling.\n */\nfunction writeTooltipContainer(ideo) {\n  d3.select(ideo.config.container + ' #_ideogramOuterWrap').append('div')\n    .attr('class', '_ideogramTooltip')\n    .attr('id', `${ideo.config.container.replace('#', '')}_ideogramTooltip`)\n    .style('opacity', 0)\n    .style('position', 'fixed')\n    .style('text-align', 'center')\n    .style('padding', '4px')\n    .style('font', '12px sans-serif')\n    .style('background', 'white')\n    .style('border', '1px solid black')\n    .style('border-radius', '5px')\n    .style('z-index', '1000')\n    .style('margin-left', '-2px'); // Mitigate crowding, e.g. BRCA1 for RAD51\n\n  document.removeEventListener('keydown', handleEscape);\n  document.addEventListener('keydown', handleEscape);\n}\n\nfunction writeContainerDom(ideo) {\n\n  // Remove any previous container content\n  d3.selectAll(ideo.config.container + ' #_ideogramOuterWrap').remove();\n\n  d3.select(ideo.config.container)\n    .append('div')\n    .attr('id', '_ideogramOuterWrap')\n    .append('div')\n    .attr('id', '_ideogramTrackLabelContainer')\n    .style('position', 'absolute');\n\n  d3.select(ideo.config.container + ' #_ideogramOuterWrap').append('div')\n    .attr('id', '_ideogramMiddleWrap') // needed for overflow and scrolling\n    .style('position', 'relative')\n    .style('overflow-x', 'auto')\n    .style('transform', 'translateZ(0)') // add compositing layer for ideogram\n    .append('div')\n    .attr('id', '_ideogramInnerWrap') // needed for overflow and scrolling\n    .append('svg')\n    .attr('id', '_ideogram')\n    .attr('class', getContainerSvgClass(ideo))\n    .attr('width', ideo._layout.getWidth())\n    .attr('height', ideo._layout.getHeight())\n    .html(ideo.getBandColorGradients());\n}\n\n/**\n * Writes the HTML elements that contain this ideogram instance.\n */\nfunction writeContainer(t0) {\n  var ideo = this;\n\n  if (ideo.config.annotationsPath) {\n    ideo.fetchAnnots(ideo.config.annotationsPath);\n  }\n\n  setPloidy(ideo);\n\n  ideo._layout = getLayout(ideo);\n\n  writeContainerDom(ideo);\n\n  ideo.isOnlyIdeogram = document.querySelectorAll('#_ideogram').length === 1;\n  writeTooltipContainer(ideo);\n  ideo.finishInit(t0);\n}\n\nexport {writeContainer};\n","import {hasNonGenBankAssembly, fetchWithRetry} from '../lib';\n\nvar lastBandDataUrl = '';\n\nfunction getBandUrl(bandDataFileNames, taxid, ideo) {\n  return ideo.config.dataDir + bandDataFileNames[taxid];\n}\n\nfunction shouldFetchBands(bandDataFileNames, taxid, ideo) {\n  var bandDataUrl = getBandUrl(bandDataFileNames, taxid, ideo);\n  return (\n    !(typeof window.chrBands !== 'undefined' && lastBandDataUrl === '') ||\n    lastBandDataUrl !== bandDataUrl\n  ) &&\n  hasNonGenBankAssembly(ideo) &&\n  taxid in bandDataFileNames;\n}\n\nfunction setBandData(url, fileNames, chrBands, ideo) {\n  var taxid, fetchedTaxid, fileName;\n\n  // Ensures correct taxid is processed in response callback;\n  // using simply upstream 'taxid' variable gives the last\n  // *requested* taxid, which fails when dealing with multiple taxa.\n  for (taxid in fileNames) {\n    fileName = fileNames[taxid];\n    if (url.includes(fileName) && fileName !== '') {\n      fetchedTaxid = taxid;\n    }\n  }\n\n  ideo.bandData[fetchedTaxid] = chrBands;\n}\n\nfunction fetchBands(bandDataFileNames, taxid, t0, ideo) {\n  var bandDataUrl = getBandUrl(bandDataFileNames, taxid, ideo);\n\n  if (!ideo.numBandDataResponses) ideo.numBandDataResponses = 0;\n\n  return fetchWithRetry(bandDataUrl)\n    .then(function(response) {\n      return response.json().then(function(rawBands) {\n        lastBandDataUrl = bandDataUrl;\n\n        delete window.chrBands; // Remove any previous chrBands variable\n        window.chrBands = rawBands.chrBands;\n\n        setBandData(response.url, bandDataFileNames, chrBands, ideo);\n      });\n    });\n}\n\nexport {shouldFetchBands, fetchBands};\n","/**\n * @fileoveriew Methods for initialization\n */\n\nimport {d3, slug} from '../lib';\nimport {configure} from './configure';\nimport {finishInit} from './finish-init';\nimport {writeContainer} from './write-container';\nimport {shouldFetchBands, fetchBands} from '../bands/fetch';\nimport {organismMetadata} from './organism-metadata';\n\nfunction isHeterogameticChromosome(chrModel, chrIndex, ideo) {\n  var ploidy = ideo.config.ploidy;\n  return (\n    'sex' in ideo.config &&\n      (\n        ploidy === 2 && ideo.sexChromosomes.index + 1 === chrIndex ||\n        ideo.config.sex === 'female' && chrModel.name === 'Y'\n      )\n  );\n}\n\nfunction prepareChromosomes(bandsArray, chrs, taxid, ideo) {\n  var j, bands, chromosome, chrModel, chrIndex;\n\n  for (j = 0; j < chrs.length; j++) {\n    chromosome = chrs[j];\n    if (typeof bandsArray !== 'undefined') bands = bandsArray[j];\n\n    chrIndex = j + ideo.config.taxids.indexOf(taxid);\n    chrModel = ideo.getChromosomeModel(bands, chromosome, taxid, chrIndex);\n\n    if (typeof chromosome !== 'string') {\n      chromosome = chromosome.name.split(' ').slice(-1)[0].replace('chr', '');\n    }\n\n    ideo.chromosomes[taxid][chromosome] = chrModel;\n    ideo.chromosomesArray.push(chrModel);\n\n    if (isHeterogameticChromosome(chrModel, j, ideo)) continue;\n\n    ideo.drawChromosome(chrModel);\n  }\n}\n\nfunction setCoordinateSystem(chrs, ideo) {\n  if (\n    typeof chrBands !== 'undefined' &&\n    chrs.length >= chrBands.length / 2\n  ) {\n    ideo.coordinateSystem = 'bp';\n  }\n}\n\n/**\n * Configures chromosome data and calls downstream chromosome drawing functions\n */\nfunction initDrawChromosomes() {\n  var taxid, i, chrs, bandsArray,\n    ideo = this,\n    taxids = ideo.config.taxids;\n\n  for (i = 0; i < taxids.length; i++) {\n    taxid = taxids[i];\n    chrs = ideo.config.chromosomes[taxid];\n\n    bandsArray = ideo.bandsArray[taxid];\n\n    if (!ideo.config.showNonNuclearChromosomes) {\n      // Remove MT\n      // TODO: Handle other non-nuclear chromosomes, e.g. CP, AP\n      chrs = chrs.filter(chr => chr !== 'MT');\n      if (typeof bandsArray !== 'undefined') {\n        bandsArray = bandsArray.filter(bands => {\n          return bands[0].chr !== 'MT';\n        });\n      }\n    }\n\n    setCoordinateSystem(chrs, ideo);\n\n    ideo.chromosomes[taxid] = {};\n    ideo.setSexChromosomes(chrs);\n\n    prepareChromosomes(bandsArray, chrs, taxid, ideo);\n\n    if (ideo.config.showBandLabels) ideo.drawBandLabels(ideo.chromosomes);\n    ideo.handleRotateOnClick();\n    ideo._gotChrModels = true; // Prevent issue with errant rat centromeres\n  }\n}\n\n/**\n * Attach any click handlers to rotate and toggle chromosomes\n */\nfunction handleRotateOnClick() {\n  var ideo = this;\n\n  if (!('rotatable' in ideo.config && ideo.config.rotatable === false)) {\n    d3.selectAll(ideo.selector + ' .chromosome-set').on('click', function() {\n      // Handles click on chromosome graphic or label.\n      // Label click needed to toggle e.g. human MT\n      const element = this.children[1];\n\n      ideo.rotateAndToggleDisplay(element);\n    });\n  } else {\n    d3.selectAll(ideo.selector).style('cursor', 'default');\n  }\n}\n\n/**\n * Called when Ideogram has finished initializing.\n * Accounts for certain ideogram properties not being set until\n * asynchronous requests succeed, etc.\n */\nfunction onLoad() {\n  call(this.onLoadCallback);\n}\n\nfunction getBandFileName(taxid, accession, ideo) {\n  var organism = ideo.organisms[taxid];\n  var bandFileName = [slug(organism.scientificName)];\n  var assemblies = organism.assemblies;\n  var resolution = ideo.config.resolution;\n\n  if (accession !== assemblies.default) {\n    bandFileName.push(accession);\n  }\n  if (\n    taxid === '9606' &&\n    (accession in assemblies === 'false' &&\n      Object.values(assemblies).includes(config.assembly) ||\n      (resolution !== '' && resolution !== 850))\n  ) {\n    bandFileName.push(resolution);\n  }\n\n  bandFileName = bandFileName.join('-');\n\n  var fullyBandedTaxids = ['9606', '10090', '10116'];\n  if (fullyBandedTaxids.includes(taxid) && !ideo.config.showFullyBanded) {\n    bandFileName += '-no-bands';\n  }\n\n  bandFileName += '.json';\n\n  return bandFileName;\n}\n\nfunction getBandFileNames(taxid, bandFileNames, ideo) {\n  var organism, assemblies, accession, bandFileName,\n    config = ideo.config;\n\n  organism = ideo.organisms[taxid];\n\n  if (!config.assembly) ideo.config.assembly = 'default';\n\n  assemblies = organism.assemblies;\n\n  if (ideo.assemblyIsAccession()) {\n    accession = config.assembly;\n  } else {\n    accession = assemblies[config.assembly];\n  }\n\n  bandFileName = getBandFileName(taxid, accession, ideo);\n  var isCustomOrganism = taxid === '-1';\n\n  if (taxid in ideo.organismsWithBands || isCustomOrganism) {\n    bandFileNames[taxid] = bandFileName;\n  }\n  return bandFileNames;\n}\n\nfunction prepareContainer(taxid, bandFileNames, t0, ideo) {\n\n  if (shouldFetchBands(bandFileNames, taxid, ideo)) {\n    return fetchBands(bandFileNames, taxid, t0, ideo).then(function() {\n      return ideo.processBandData(taxid);\n    });\n  } else {\n    return new Promise(function(resolve) {\n      ideo.processBandData(taxid);\n      resolve([taxid, undefined]);\n    });\n  }\n}\n\nfunction initializeTaxids(ideo) {\n  return new Promise(function(resolve) {\n    var organism = ideo.config.organism;\n    if (typeof organism === 'number') {\n      // 'organism' is a taxid, e.g. 9606\n      ideo.getOrganismFromEutils(organism, function() {\n        ideo.getTaxids(resolve);\n      });\n    } else {\n      ideo.getTaxids(resolve);\n    }\n\n  });\n}\n\nfunction getBandsAndPrepareContainer(taxids, t0, ideo) {\n  var bandFileNames, i, taxid,\n    promises = [];\n\n  bandFileNames = {};\n  for (taxid in organismMetadata) {\n    bandFileNames[taxid] = '';\n  }\n\n  for (i = 0; i < taxids.length; i++) {\n    taxid = String(taxids[i]);\n    bandFileNames = getBandFileNames(taxid, bandFileNames, ideo);\n    promises.push(prepareContainer(taxid, bandFileNames, t0, ideo));\n  }\n\n  Promise.all(promises).then(function(taxidsAndBandsArrays) {\n    var taxidAndBandsArray, taxid, bandsArray;\n\n    for (i = 0; i < taxidsAndBandsArrays.length; i++) {\n      taxidAndBandsArray = taxidsAndBandsArrays[i];\n      taxid = taxidAndBandsArray[0];\n      bandsArray = taxidAndBandsArray[1];\n\n      if ('bandsArray' in ideo === false) {\n        ideo.bandsArray = {};\n      }\n\n      ideo.bandsArray[taxid] = bandsArray;\n    }\n    ideo.writeContainer(t0);\n  });\n}\n\n/**\n * Initializes an ideogram.\n * Sets some high-level properties based on instance configuration,\n * fetches band and annotation data if needed, and\n * writes an SVG element to the document to contain the ideogram\n */\n// Prevents race condition when init is called multiple times in\n// quick succession.\n// See https://github.com/eweitz/ideogram/pull/154.\nvar ideoNext = {};\nvar ideoQueued = {};\nvar ideoWait = {};\n\nfunction init(ideo) {\n  ideo = ideo || this;\n  var containerId = ideo.config.container;\n\n  if (ideoWait[containerId]) {\n    ideoQueued[containerId] = true;\n    ideoNext[containerId] = ideo;\n  } else {\n    ideoWait[containerId] = true;\n    initializeTaxids(ideo)\n      .then(function(taxids) {\n\n        var taxid = taxids[0];\n        ideo.config.taxid = taxid;\n        ideo.config.taxids = taxids;\n\n        ideo.organismScientificName =\n          ideo.getScientificName(ideo.config.taxid);\n\n        var t0 = new Date().getTime();\n        getBandsAndPrepareContainer(taxids, t0, ideo);\n\n        ideoWait[containerId] = false;\n        if (ideoQueued[containerId]) {\n          ideoQueued[containerId] = false;\n          init(ideoNext[containerId]);\n        }\n      });\n  }\n}\n\nexport {\n  configure, initDrawChromosomes, handleRotateOnClick,\n  onLoad, init, finishInit, writeContainer\n};\n","/**\n * @fileoverview Parse raw Ideogram.js annotations from a BED file\n * BED documentation: https://genome.ucsc.edu/FAQ/FAQformat#format1\n */\n\nexport class BedParser {\n\n  constructor(bed, ideo) {\n    this.rawAnnots = this.parseBed(bed, ideo);\n  }\n\n  // http://stackoverflow.com/a/5624139\n  static componentToHex(c) {\n    var hex = parseInt(c, 10).toString(16);\n    return hex.length === 1 ? '0' + hex : hex;\n  }\n\n  static rgbToHex(r, g, b) {\n    return (\n      '#' +\n      BedParser.componentToHex(r) +\n      BedParser.componentToHex(g) +\n      BedParser.componentToHex(b)\n    );\n  }\n\n  parseGenomicCoordinates(columns, ucscStyle) {\n    var chr, start, stop, length;\n\n    // These three columns (i.e. fields) are required\n    chr = columns[0];\n    start = parseInt(columns[1], 10);\n    stop = parseInt(columns[2], 10);\n\n    length = stop - start;\n\n    if (ucscStyle) {\n      chr = chr.slice(3);\n    }\n\n    return [chr, start, stop, length];\n  }\n\n  /**\n   * Parses an annotation from a tab-separated line of a BED file\n   */\n  parseAnnotFromTsvLine(tsvLine, chrs, ucscStyle) {\n    var annot, chrIndex, chr, start, rgb, color, label,\n      columns = tsvLine.split(/\\s/g);\n\n    [chr, start, stop, length] =\n      this.parseGenomicCoordinates(columns, ucscStyle);\n\n    chrIndex = chrs.indexOf(chr);\n    if (chrIndex === -1) return [null, null];\n\n    annot = ['', start, length, 0];\n\n    if (columns.length >= 4) {\n      label = columns[3];\n      annot[0] = label;\n    }\n\n    if (columns.length >= 8) {\n      rgb = columns[8].split(',');\n      color = BedParser.rgbToHex(rgb[0], rgb[1], rgb[2]);\n      annot.push(color);\n    }\n\n    return [chrIndex, annot];\n  }\n\n  parseRawAnnots(annots, bedStartIndex, tsvLines, chrs) {\n    var i, line, chrIndex, annot, keys, rawAnnots, ucscStyle;\n\n    ucscStyle = true;\n    if (isNaN(parseInt(tsvLines[bedStartIndex], 10)) === false) {\n      ucscStyle = false;\n    }\n\n    for (i = bedStartIndex; i < tsvLines.length; i++) {\n      line = tsvLines[i];\n      [chrIndex, annot] = this.parseAnnotFromTsvLine(line, chrs, ucscStyle);\n      if (chrIndex !== null) annots[chrIndex].annots.push(annot);\n    }\n\n    keys = ['name', 'start', 'length', 'trackIndex'];\n    if (tsvLines[bedStartIndex].length >= 8) keys.push('color');\n\n    rawAnnots = {keys: keys, annots: annots};\n\n    return rawAnnots;\n  }\n\n  /**\n  * Parses a BED file, returns raw annotations\n  */\n  parseBed(bed, ideo) {\n    var i, chrs, chr, bedStartIndex, rawAnnots,\n      annots = [],\n      tsvLines = bed.split(/\\r\\n|\\n/);\n\n    chrs = Object.keys(ideo.chromosomes[ideo.config.taxid]);\n\n    for (i = 0; i < chrs.length; i++) {\n      chr = chrs[i];\n      annots.push({chr: chr, annots: []});\n    }\n\n    bedStartIndex = 0; // 1 if BED has header (i.e. track line), 0 otherwise\n    if (tsvLines[0].slice(0, 3) === 'chr' || isNaN(parseInt(tsvLines[0], 10))) {\n      bedStartIndex = 1;\n    }\n\n    rawAnnots = this.parseRawAnnots(annots, bedStartIndex, tsvLines, chrs);\n    return rawAnnots;\n  }\n\n}\n","/**\n * @fileoverview Parse raw Ideogram.js annotations from a TSV file\n */\n\nimport {camel} from './../lib';\n\nexport class TsvParser {\n\n  constructor(tsv, ideo) {\n    this.rawAnnots = this.parseTsv(tsv, ideo);\n  }\n\n  parseGenomicCoordinates(columns) {\n    // These three columns (i.e. fields) are required\n    const chr = columns[1];\n    const start = parseInt(columns[2], 10);\n    const length = parseInt(columns[3], 10);\n\n    return [chr, start, length];\n  }\n\n  /**\n  * Parses a TSV file, returns raw annotations\n  */\n  parseTsv(tsv, ideo) {\n    const lines = tsv.split(/\\r\\n|\\n/);\n\n    const chrs = Object.keys(ideo.chromosomes[ideo.config.taxid]);\n\n    const annots = [];\n\n    for (let i = 0; i < chrs.length; i++) {\n      const chr = chrs[i];\n      annots.push({chr, annots: []});\n    }\n\n    let headers;\n    const innerKeysByField = {};\n    const customHeaders = [];\n\n    const numRequired = 4;\n    // let numColumns;\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      if (line === '') continue; // Skip empty lines\n\n      // Parse headers\n      if (line[0] === '#') {\n        if (line[1] === '#') {\n          // Parse inner field keys in metainformation lines\n          // E.g. ## differential_expression keys: gene;log2fc;pval_adj\n          const keySplit = line.split(' keys: ');\n          if (keySplit.length > 1) {\n            const field = keySplit[0].slice(3);\n            const keys = keySplit[1].split(';');\n            innerKeysByField[camel(field)] = keys;\n          }\n        } else {\n          // Slice/trim off \"# \", take columns 5 and onward, e.g.:\n          // full_name\\tmentions\\tdifferential_expression\\tinterest_rank\n          headers = line.slice(1).trim().split(/\\t/).map(h => camel(h));\n          // numColumns = headers.length;\n          const customs = headers.slice(numRequired);\n          customs.forEach((custom, i) => customHeaders.push(camel(custom)));\n        }\n        continue;\n      }\n\n      const columns = line.trim().split(/\\t/);\n      const name = columns[0];\n\n      const [chr, start, length] = this.parseGenomicCoordinates(columns);\n      const chrIndex = chrs.indexOf(chr);\n      if (chrIndex === -1) continue;\n\n      const customValues = columns.slice(numRequired);\n      for (let j = 0; j < numRequired; j++) {\n        const customHeader = customHeaders[j];\n        if (customHeader in innerKeysByField) {\n          const innerKeys = innerKeysByField[customHeader]\n          const block = columns[numRequired + j];\n          const group = block.split(';');\n          const customValue = [];\n          if (group[0] !== '') {\n            for (let k = 0; k < group.length; k++) {\n              const innerObj = {};\n              const innerValues = group[k].split('!');\n              for (let m = 0; m < innerValues.length; m++) {\n                const innerKey = innerKeys[m];\n                const innerValue = innerValues[m];\n                innerObj[camel(innerKey)] = innerValue;\n              }\n              customValue.push(innerObj);\n            }\n          }\n          customValues[j] = customValue;\n        }\n      }\n\n      const annot = [name, chr, start, length].concat(customValues);\n      annot.push(i); // Rank in initial file\n\n      annots[chrIndex].annots.push(annot);\n    };\n\n    headers.push('initRank');\n    const rawAnnots = {keys: headers, annots, innerKeysByField};\n    return rawAnnots;\n  }\n}\n","/**\n * @fileoverview Functions used by parallel and collinear heatmaps.\n */\n\nvar reservedTrackKeys = [\n  'name', 'start', 'length', 'trackIndex', 'trackIndexOriginal', 'color'\n];\n\nvar defaultHeatmapColors = {\n  3: ['00B', 'DDD', 'F00'],\n  5: ['00D', '66D', 'DDD', 'F88', 'F00'],\n  17: [\n    '00D', '00D', '00D', '00D', '00D', '44D', '44D', 'DDD', 'DDD',\n    'DDD', 'DDD', 'F88', 'F66', 'F22', 'F22', 'F00', 'F00', 'F00'\n  ]\n};\n\n/**\n * Get label text for displayed tracks from annotation container metadata,\n * heatmap keys, or annotation container keys\n */\nfunction getLabels(ideo) {\n  var annotKeys, labels, heatmaps, i;\n\n  if (ideo.rawAnnots.metadata && ideo.rawAnnots.metadata.trackLabels) {\n    labels = ideo.rawAnnots.metadata.trackLabels;\n  } else if (ideo.config.heatmaps) {\n    labels = [];\n    heatmaps = ideo.config.heatmaps;\n    for (i = 0; i < heatmaps.length; i++) {\n      labels.push(heatmaps[i].key);\n    }\n  } else {\n    annotKeys = ideo.rawAnnots.keys.slice(0);\n    labels = annotKeys.filter(d => !reservedTrackKeys.includes(d));\n  }\n\n  if (ideo.displayedTrackIndexes) {\n    labels = labels.filter(function(d, i) {\n      return ideo.displayedTrackIndexes.includes(i + 1);\n    });\n  }\n\n  return labels;\n}\n\n/**\n * Apply heatmap thresholds that are passed in as annotation metadata\n */\nfunction inflateThresholds(ideo) {\n  var thresholds, colors,\n    rawAnnots = ideo.rawAnnots;\n\n  if (\n    rawAnnots.metadata && !rawAnnots.metadata.heatmapThresholds &&\n    !ideo.config.heatmapThresholds\n  ) {\n    return;\n  }\n\n  if (ideo.config.heatmapThresholds) {\n    thresholds = ideo.config.heatmapThresholds;\n  } else {\n    thresholds = ideo.rawAnnots.metadata.heatmapThresholds;\n  }\n\n  colors = defaultHeatmapColors[thresholds.length + 1];\n  thresholds = thresholds.map((d, i) => {\n    return [d, '#' + colors[i]];\n  });\n\n  thresholds.push(['+', '#' + colors.slice(-1)[0]]);\n\n  return thresholds;\n}\n\n/**\n * Set needed configuration options from raw annotation data.\n * Simplifies heatmap API by inferring reasonable defaults.\n */\nfunction inflateHeatmaps(ideo) {\n  var i, labels, heatmaps, annotationTracks, rawAnnots, displayedTracks,\n    thresholds = ideo.config.heatmapThresholds;\n\n  heatmaps = [];\n  rawAnnots = ideo.rawAnnots;\n  labels = rawAnnots.keys.slice(3);\n\n  annotationTracks = [];\n  displayedTracks = [];\n  if (rawAnnots.metadata || !isNaN(thresholds[0])) {\n    thresholds = inflateThresholds(ideo);\n  }\n\n  for (i = 0; i < labels.length; i++) {\n    heatmaps.push({key: labels[i], thresholds: thresholds});\n    annotationTracks.push({id: labels[i]});\n    displayedTracks.push(i + 1);\n  }\n  ideo.config.annotationsNumTracks = labels.length;\n  ideo.config.annotationsDisplayedTracks = displayedTracks;\n  ideo.config.heatmaps = heatmaps;\n  ideo.config.annotationTracks = annotationTracks;\n}\n\n/**\n * Given annotation value (m), should it use the color in this threshold?\n */\nfunction shouldUseThreshold(m, numThresholds, value, prevThreshold,\n  threshold) {\n\n  return (\n    // If this is the last threshold, and\n    // its value is \"+\" and the value is above the previous threshold...\n    m === numThresholds && (\n      threshold === '+' && value > prevThreshold\n    ) ||\n\n    // ... or if the value matches the threshold...\n    value === threshold ||\n\n    // ... or if this isn't the first or last threshold, and\n    // the value is between this threshold and the previous one...\n    m !== 0 && m !== numThresholds && (\n      value <= threshold &&\n      value > prevThreshold\n    ) ||\n\n    // ... or if this is the first threshold and the value is\n    // at or below the threshold\n    m === 0 && value <= threshold\n  );\n}\n\n/**\n * Determine the color of the heatmap annotation.\n */\nfunction getHeatmapAnnotColor(thresholds, value) {\n  var m, numThresholds, thresholdList, threshold, tvNum, thresholdColor,\n    prevThreshold, useThresholdColor, color;\n\n  for (m = 0; m < thresholds.length; m++) {\n    numThresholds = thresholds.length - 1;\n    thresholdList = thresholds[m];\n    threshold = thresholdList[0];\n\n    // The threshold value is usually a number,\n    // but can also be a \"+\" character indicating that\n    // this threshold is anything greater than the previous threshold.\n    tvNum = parseFloat(threshold);\n    if (isNaN(tvNum) === false) threshold = tvNum;\n    if (m !== 0) prevThreshold = parseFloat(thresholds[m - 1][0]);\n    thresholdColor = thresholdList[1];\n\n    useThresholdColor = shouldUseThreshold(m, numThresholds, value,\n      prevThreshold, threshold);\n\n    if (useThresholdColor) color = thresholdColor;\n  }\n\n  return color;\n}\n\nexport {\n  getLabels, inflateHeatmaps, inflateThresholds, defaultHeatmapColors,\n  getHeatmapAnnotColor, shouldUseThreshold\n};\n","/**\n * @fileoverview Functions for labeling collinear tracks of genome annotations.\n * See track-labels.js for more.\n */\n\nimport {d3} from '../lib';\nimport {getLabels} from './heatmap-lib';\n\nfunction renderTrackLabels(labels, ideo) {\n  var i, x, y, labelContainer, markBump,\n    annotLabelHeight = ideo.config.annotLabelHeight,\n    demarcateChrs = ideo.config.demarcateCollinearChromosomes;\n\n  x = 11; // Close to chrLeft in heatmap-collinear.js.  For tabs.\n  markBump = (demarcateChrs ? 2 : 0); // Make labels flush with demarcations\n\n  labelContainer =\n    d3.select(ideo.config.container + ' #_ideogramTrackLabelContainer');\n  labelContainer.html('');\n\n  y = ideo.config.annotationHeight + annotLabelHeight + 4;\n\n  for (i = 0; i < labels.length; i++) {\n    labelContainer\n      .style('position', 'absolute')\n      .append('div')\n      .attr('class', '_ideogramTrackLabel')\n      .style('opacity', 1)\n      .style('position', 'absolute')\n      .style('text-align', 'center')\n      .style('padding', '1px')\n      .style('font', '11px sans-serif')\n      .style('background', 'white')\n      .style('line-height', '10px')\n      .style('z-index', '5')\n      .style('left', (x + markBump) + 'px')\n      .style('top', (y * i + markBump) + 'px')\n      .style('width', 'max-content')\n      .style('transform-origin', 'bottom left')\n      .style('text-align', 'left')\n      .html(labels[i]);\n  }\n\n}\n\n/**\n * Show the label for this track\n */\nfunction writeTrackLabels(ideo) {\n  var labels = getLabels(ideo);\n  renderTrackLabels(labels, ideo);\n}\n\nexport {writeTrackLabels};\n","/**\n * @fileoverview Functions for collinear heatmaps of genome annotations.\n * See heatmap.js for more.\n */\n\nimport {d3} from '../lib';\nimport {writeTrackLabels} from './track-labels-collinear';\nimport {inflateHeatmaps} from './heatmap-lib';\n\n/**\n * Add canvases that will contain annotations.  One canvas per track.\n */\nfunction writeCanvases(chr, chrLeft, ideo) {\n  var j, trackLeft, trackWidth, canvas, context, id,\n    chrWidth = chr.width,\n    contextArray = [],\n    annotLabelHeight = ideo.config.annotLabelHeight,\n    numAnnotTracks = ideo.config.numAnnotTracks;\n\n  // Create a canvas for each annotation track on this chromosome\n  for (j = 0; j < numAnnotTracks; j++) {\n    trackWidth = ideo.config.annotationHeight + annotLabelHeight + 4;\n    id = chr.id + '-canvas-' + j; // e.g. chr1-9606-canvas-0\n    trackLeft = chrLeft;\n    if (chr.chrIndex > 0) {\n      trackLeft += (ideo.config.chrMargin * chr.chrIndex) - 1;\n    }\n    canvas = d3.select(ideo.config.container + ' #_ideogramInnerWrap')\n      .append('canvas')\n      .attr('id', id)\n      .attr('width', chrWidth + 1)\n      .attr('height', trackWidth)\n      .style('position', 'absolute')\n      .style('left', trackLeft + 'px')\n      .style('top', (trackWidth * j + 1) + 'px');\n    context = canvas.nodes()[0].getContext('2d');\n    contextArray.push([context, chr]);\n  }\n\n  return contextArray;\n}\n\n/**\n * Render annotations on the canvas\n */\nfunction fillCanvasAnnots(annots, contextArray, ideo) {\n  var j, annot, context, chr,\n    annotLabelHeight = ideo.config.annotLabelHeight,\n    annotHeight = ideo.config.annotationHeight,\n    demarcateChrs = ideo.config.demarcateCollinearChromosomes;\n\n  var trackWidth = annotHeight + annotLabelHeight + 4;\n\n  // Fill in the canvas(es) with annotation colors to draw a heatmap\n  for (j = 0; j < annots.length; j++) {\n    annot = annots[j];\n    context = contextArray[annot.trackIndex][0];\n    chr = contextArray[annot.trackIndex][1];\n    context.fillStyle = annot.color;\n    if (demarcateChrs) {\n      if (annot.startPx < 1 || annot.startPx > chr.width - 1) continue;\n      context.fillRect(annot.startPx, 1, 0.5, trackWidth);\n    } else {\n      context.fillRect(annot.startPx, annotLabelHeight + 1, 0.5, annotHeight);\n    }\n  }\n\n  if (demarcateChrs) {\n    for (j = 0; j < contextArray.length; j++) {\n      context = contextArray[j][0];\n      chr = contextArray[j][1];\n      context.fillStyle = '#555';\n      if (chr.chrIndex === 0) context.fillRect(0, 0, 1, trackWidth);\n      context.fillRect(chr.width - 1, 0, 1.1, trackWidth);\n      context.fillRect(0, 0, chr.width + 1, 1);\n      if (ideo.config.chrMargin) context.fillRect(0, 0, 1.1, trackWidth);\n    }\n  }\n}\n\n/**\n * Draw a 1D heatmap of annotations along each chromosome.\n * Ideal for representing very dense annotation sets in a granular manner\n * without subsampling.\n *\n * TODO:\n * - Support in 'vertical' orientation\n * - Support after rotating chromosome on click\n */\nfunction drawHeatmapsCollinear(annotContainers, ideo) {\n  var annots, chrLeft, contextArray, i, chr,\n    prevX = 0,\n    xBump = (ideo.config.showChromosomesLabels) ? 2 : -0.1;\n\n  d3.select(ideo.selector).classed('labeledLeft', false);\n  d3.selectAll(ideo.config.container + ' canvas').remove();\n\n  // Each \"annotationContainer\" represents annotations for a chromosome\n  for (i = 0; i < annotContainers.length; i++) {\n    annots = annotContainers[i].annots;\n    chr = ideo.chromosomesArray[i];\n    if (i === 0) {\n      chrLeft = 12;\n    } else {\n      chrLeft = prevX + ideo.chromosomesArray[i - 1].width + 14;\n      prevX += ideo.chromosomesArray[i - 1].width + xBump;\n    }\n    contextArray = writeCanvases(chr, chrLeft, ideo);\n    fillCanvasAnnots(annots, contextArray, ideo);\n  }\n\n  writeTrackLabels(ideo);\n\n  if (ideo.onDrawAnnotsCallback) ideo.onDrawAnnotsCallback();\n}\n\nexport {drawHeatmapsCollinear, inflateHeatmaps};\n","/**\n * @fileoverview Functions for 2D heatmaps of genome annotations.\n * 2D heatmaps enable showing many (100+) tracks of data in one dimension,\n * for features (e.g. genes) along a dimension of genomic coordinates in\n * chromosome context.\n *\n * TO DO:\n * - Horizontal orientation\n * - Multiple chromosomes\n * - Non-human organisms\n */\n\nimport {d3} from '../lib';\nimport {getHeatmapAnnotColor} from './heatmap-lib';\n\n/**\n * Add one canvas that will contain all annotations.  One canvas per chromosome.\n */\nfunction writeCanvas(chr, ideoHeight, width, ideo) {\n  var left, canvas, context, id;\n\n  id = chr.id + '-canvas'; // e.g. chr1-9606-canvas\n  left = (ideo.config.chrWidth * 2) + ideo.config.annotationHeight - 0.5;\n  canvas = d3.select(ideo.config.container + ' #_ideogramInnerWrap')\n    .append('canvas')\n    .attr('id', id)\n    .attr('width', width)\n    .attr('height', ideoHeight)\n    .style('position', 'absolute')\n    .style('left', left + 'px')\n    .style('top', '0px');\n  context = canvas.nodes()[0].getContext('2d');\n\n  return context;\n}\n\n/**\n * Render annotations on the canvas.\n *\n * These annotations are 2D; each annotation has many values, each on a track.\n */\nfunction fillCanvasAnnotValues(annot, context, ideo) {\n  var i, x, values,\n    annotHeight = ideo.config.annotationHeight,\n    ideoMarginTop = ideo._layout.margin.top;\n\n  values = annot.values;\n\n  // Fill canvas with annotation colors to draw the heatmap\n  for (i = 0; i < values.length; i++) {\n    context.fillStyle = values[i];\n    x = (i - 1) * annotHeight;\n    context.fillRect(x, annot.startPx + ideoMarginTop, annotHeight, 2);\n  }\n}\n\n/**\n * Draw a 2D heatmap of annotations along one chromosome.\n *\n * TODO:\n * - Support in 'horizontal' orientation\n * - Support after rotating chromosome on click\n */\nfunction drawHeatmaps2d(annotContainers, ideo) {\n  var annot, context, i, chr,\n    container = ideo.config.container,\n    ideoMarginTop = ideo._layout.margin.top,\n    ideoHeight = ideo.config.chrHeight + ideoMarginTop,\n    width = ideo.config.annotationHeight * annotContainers[0].values.length;\n\n  d3.selectAll(container + ' canvas').remove();\n\n  d3.select(container + ' #_ideogramInnerWrap')\n    .style('max-width', width + 'px');\n  d3.select(container + ' #_ideogram').attr('width', width);\n\n  chr = ideo.chromosomesArray[0];\n\n  context = writeCanvas(chr, ideoHeight, width, ideo);\n\n  // Each \"annotationContainer\" represents annotations for a chromosome\n  for (i = 0; i < annotContainers.length; i++) {\n    annot = annotContainers[i];\n    fillCanvasAnnotValues(annot, context, ideo);\n  }\n\n  if (ideo.onDrawAnnotsCallback) {\n    ideo.onDrawAnnotsCallback();\n  }\n}\n\nfunction add2dAnnotsForChr(annots, omittedAnnots, annotsByChr, chrModel,\n  m, keys, ideo) {\n  var j, k, annot, ra, stop, stopPx, color,\n    thresholds = ideo.config.heatmapThresholds;\n\n  for (j = 0; j < annotsByChr.annots.length; j++) {\n    ra = annotsByChr.annots[j];\n    annot = {};\n\n    annot.values = []; // one value per track\n\n    for (k = 0; k < 3; k++) {\n      annot[keys[k]] = ra[k];\n    }\n\n    for (k = 3; k < keys.length; k++) {\n      color = getHeatmapAnnotColor(thresholds, ra[k]);\n      annot.values.push(color);\n    }\n\n    stop = annot.start + annot.length;\n\n    annot.chr = annotsByChr.chr;\n    annot.chrIndex = m;\n    annot.startPx = ideo.convertBpToPx(chrModel, annot.start);\n    stopPx = ideo.convertBpToPx(chrModel, stop);\n    annot.px = Math.round((annot.startPx + stopPx) / 2);\n\n    annots.push(annot);\n  }\n\n  annots.shift();\n\n  return [annots, omittedAnnots];\n}\n\nexport {drawHeatmaps2d, add2dAnnotsForChr};\n","/**\n * @fileoverview Functions for labeling tracks of genome annotations.\n * Tracks are columns of annotations that run beside a chromosome.\n * Labeling tracks with descriptive names makes them easier to understand.\n */\n\nimport {d3} from '../lib';\nimport {getLabels} from './heatmap-lib';\n\n/**\n * Start a timer that, upon expiring, hides the track label.\n *\n * To enable users to copy label content to their clipboard, a timer is\n * used to control when the label disappears.  It starts when the user's\n * cursor leaves the track or the label.  If the user moves the cursor\n * back over the annot or label after the timer starts and before it expires,\n * then the timer is cleared.\n */\nfunction startHideTrackLabelTimeout(ideo) {\n  if (ideo.config.showTrackLabel === false) return;\n\n  ideo.hideTrackLabelTimeout = window.setTimeout(function() {\n    d3.select(ideo.config.container + ' #_ideogramTrackLabel').transition()\n      .duration(500)\n      .style('opacity', 0);\n  }, 250);\n}\n\n/**\n * Write label div setup with default styling.\n */\nfunction writeTrackLabelContainer(ideo) {\n  d3.select(ideo.config.container + ' #_ideogramTrackLabelContainer')\n    .append('div')\n    .attr('id', '_ideogramTrackLabel')\n    .style('opacity', 0)\n    .style('position', 'absolute')\n    .style('text-align', 'center')\n    .style('padding', '1px')\n    .style('font', '11px sans-serif')\n    .style('background', 'white')\n    .style('line-height', '10px')\n    .style('z-index', '9000');\n}\n\n/**\n * Display track labels on the page\n */\nfunction renderTrackLabels(top, left, ideo) {\n  d3.select(ideo.config.container + ' #_ideogramTrackLabel')\n    .style('opacity', 1) // Make label visible\n    .style('left', left + 'px')\n    .style('top', top + 'px')\n    .style('width', 'max-content')\n    .style('transform-origin', 'bottom left')\n    .style('text-align', 'left')\n    .on('mouseover', function() {\n      clearTimeout(ideo.hideTrackLabelTimeout);\n    })\n    .on('mouseout', function() {\n      startHideTrackLabelTimeout(ideo);\n    });\n}\n\n/**\n * Get left and top (x and y) offset for track label text\n */\nfunction getTrackLabelOffsets(labels, trackCanvas, ideo) {\n  var firstTrackId, firstTrack, trackBox, labelBox, ideoBox, left, top,\n    marginHack = 7; // TODO: Make this dynamic\n\n  firstTrackId = trackCanvas.id.split('-').slice(0, -1).join('-') + '-0';\n  firstTrack = d3.select(ideo.config.container + ' #' + firstTrackId)\n    .nodes()[0];\n  trackBox = firstTrack.getBoundingClientRect();\n\n  labelBox = d3.select(ideo.config.container + ' #_ideogramTrackLabel')\n    .nodes()[0].getBoundingClientRect();\n  ideoBox = d3.select(ideo.config.container).nodes()[0]\n    .getBoundingClientRect();\n\n  left = Math.round(trackBox.left + labelBox.width) - trackBox.width - 1;\n  left -= ideoBox.left - marginHack;\n  top = -(labels.split('<br>').length - 2) * trackBox.width + 2;\n\n  return [left, top];\n}\n\n/**\n * Show the label for this track\n */\nfunction showTrackLabel(trackCanvas, ideo) {\n  var labels, left, top;\n\n  clearTimeout(ideo.hideTrackLabelTimeout);\n\n  labels = getLabels(ideo);\n  labels = labels.join('<br>');\n\n  // Clear any previous positioning, write track label text to DOM\n  d3.select(ideo.config.container + ' #_ideogramTrackLabel')\n    .interrupt() // Stop any in-progress disapperance\n    .style('top', '')\n    .style('left', '')\n    .style('transform', null)\n    .style('transform', 'rotate(-90deg)')\n    .html(labels);\n\n  [left, top] = getTrackLabelOffsets(labels, trackCanvas, ideo);\n\n  renderTrackLabels(top, left, ideo);\n}\n\nexport {\n  startHideTrackLabelTimeout, writeTrackLabelContainer, showTrackLabel\n};\n","/**\n * @fileoverview Functions for 2D heatmaps of genome annotations.\n * Heatmaps provide an easy way to visualize very dense annotation data.\n * Unlike the rest of Ideogram's graphics, which use SVG, heatmaps are\n * rendered using the Canvas element.\n */\n\nimport {d3} from '../lib';\nimport {drawHeatmapsCollinear} from './heatmap-collinear';\nimport {drawHeatmaps2d} from './heatmap-2d';\nimport {getHeatmapAnnotColor} from './heatmap-lib';\n\nimport {\n  startHideTrackLabelTimeout, writeTrackLabelContainer, showTrackLabel\n} from './track-labels';\n\n/**\n * Add canvases that will contain annotations.  One canvas per track.\n */\nfunction writeCanvases(chr, chrLeft, ideoHeight, ideo) {\n  var j, trackLeft, trackWidth, canvas, context, id,\n    contextArray = [],\n    numAnnotTracks = ideo.config.numAnnotTracks;\n\n  var marginHack = 7; // TODO: Make this dynamic\n\n  // Create a canvas for each annotation track on this chromosome\n  for (j = 0; j < numAnnotTracks; j++) {\n    trackWidth = ideo.config.annotationHeight;\n    id = chr.id + '-canvas-' + j; // e.g. chr1-9606-canvas-0\n    trackLeft = chrLeft - trackWidth * (numAnnotTracks - j) - marginHack;\n    canvas = d3.select(ideo.config.container + ' #_ideogramInnerWrap')\n      .append('canvas')\n      .attr('id', id)\n      .attr('width', trackWidth)\n      .attr('height', ideoHeight)\n      .style('position', 'absolute')\n      .style('left', trackLeft + 'px');\n    context = canvas.nodes()[0].getContext('2d');\n    contextArray.push(context);\n  }\n\n  return contextArray;\n}\n\n/**\n * Render annotations on the canvas\n */\nfunction fillCanvasAnnots(annots, contextArray, chrWidth, ideoMarginTop) {\n  var j, annot, context, x;\n\n  // Fill in the canvas(es) with annotation colors to draw a heatmap\n  for (j = 0; j < annots.length; j++) {\n    annot = annots[j];\n    context = contextArray[annot.trackIndex];\n    context.fillStyle = annot.color;\n    x = annot.trackIndex - 1;\n    context.fillRect(x, annot.startPx + ideoMarginTop, chrWidth, 0.5);\n  }\n}\n\n/**\n * Draw a 1D heatmap of annotations along each chromosome.\n * Ideal for representing very dense annotation sets in a granular manner\n * without subsampling.\n *\n * TODO:\n * - Support in 'horizontal' orientation\n * - Support after rotating chromosome on click\n */\nfunction drawHeatmaps(annotContainers) {\n  var annots, chrLeft, contextArray, chrWidth, i, chr,\n    ideo = this,\n    config = ideo.config,\n    ideoMarginTop = ideo._layout.margin.top,\n    ideoHeight = config.chrHeight + ideoMarginTop;\n\n  if (config.geometry === 'collinear') {\n    return drawHeatmapsCollinear(annotContainers, ideo);\n  } else if (config.annotationsLayout === 'heatmap-2d') {\n    return drawHeatmaps2d(annotContainers, ideo);\n  }\n\n  d3.selectAll(ideo.config.container + ' canvas').remove();\n\n  writeTrackLabelContainer(ideo);\n\n  // Each \"annotationContainer\" represents annotations for a chromosome\n  for (i = 0; i < annotContainers.length; i++) {\n\n    annots = annotContainers[i].annots;\n    chr = ideo.chromosomesArray[i];\n    chrWidth = ideo.config.chrWidth;\n    chrLeft = ideo._layout.getChromosomeSetYTranslate(i);\n\n    contextArray = writeCanvases(chr, chrLeft, ideoHeight, ideo);\n    fillCanvasAnnots(annots, contextArray, chrWidth, ideoMarginTop);\n  }\n\n  d3.selectAll(ideo.config.container + ' canvas')\n    .on('mouseover', function() {showTrackLabel(this, ideo);})\n    .on('mouseout', function() {startHideTrackLabelTimeout(ideo);});\n\n  if (ideo.onDrawAnnotsCallback) {\n    ideo.onDrawAnnotsCallback();\n  }\n}\n\n/**\n * Set color and track index for raw annotation objects.\n */\nfunction getNewRawAnnots(heatmapKeyIndexes, rawAnnots, ideo) {\n  var j, k, ra, newRa, value, thresholds, color, trackIndex,\n    newRas = [];\n\n  for (j = 0; j < rawAnnots.length; j++) {\n    ra = rawAnnots[j];\n    for (k = 0; k < heatmapKeyIndexes.length; k++) {\n      newRa = ra.slice(0, 3); // name, start, length\n\n      value = ra[heatmapKeyIndexes[k]];\n      thresholds = ideo.config.heatmaps[k].thresholds;\n      color = getHeatmapAnnotColor(thresholds, value);\n\n      trackIndex = k;\n      newRa.push(trackIndex, color, value);\n      newRas.push(newRa);\n    }\n  }\n\n  return newRas;\n}\n\nfunction getNewRawAnnotContainers(heatmapKeyIndexes, rawAnnotBoxes, ideo) {\n  var raContainer, chr, rawAnnots, newRas, i,\n    newRaContainers = [];\n\n  for (i = 0; i < rawAnnotBoxes.length; i++) {\n    raContainer = rawAnnotBoxes[i];\n    chr = raContainer.chr;\n\n    rawAnnots = raContainer.annots;\n    newRas = getNewRawAnnots(heatmapKeyIndexes, rawAnnots, ideo);\n\n    newRaContainers.push({chr: chr, annots: newRas});\n  }\n  return newRaContainers;\n}\n\nfunction reportPerformance(t0, ideo) {\n  var t1 = new Date().getTime();\n  if (ideo.config.debug) {\n    console.log('Time in deserializeAnnotsForHeatmap: ' + (t1 - t0) + ' ms');\n  }\n}\n\n/**\n * Deserialize compressed annotation data into a format suited for heatmaps.\n *\n * This enables the annotations to be downloaded from a server without the\n * requested annotations JSON needing to explicitly specify track index or\n * color.  The track index and color are inferred from the \"heatmaps\" Ideogram\n * configuration option defined before ideogram initialization.\n *\n * This saves time for the user.\n *\n * @param rawAnnotsContainer {Object} Raw annotations as passed from server\n */\nfunction deserializeAnnotsForHeatmap(rawAnnotsContainer) {\n  var newRaContainers, heatmapKey, heatmapKeyIndexes, i,\n    t0 = new Date().getTime(),\n    keys = rawAnnotsContainer.keys,\n    rawAnnotBoxes = rawAnnotsContainer.annots,\n    ideo = this;\n\n  heatmapKeyIndexes = [];\n  for (i = 0; i < ideo.config.heatmaps.length; i++) {\n    heatmapKey = ideo.config.heatmaps[i].key;\n    heatmapKeyIndexes.push(keys.indexOf(heatmapKey));\n  }\n\n  newRaContainers =\n    getNewRawAnnotContainers(heatmapKeyIndexes, rawAnnotBoxes, ideo);\n\n  keys.splice(3, 0, 'trackIndex');\n  keys.splice(4, 0, 'color');\n\n  ideo.rawAnnots.keys = keys;\n  ideo.rawAnnots.annots = newRaContainers;\n\n  reportPerformance(t0, ideo);\n}\n\nexport {drawHeatmaps, deserializeAnnotsForHeatmap};\n","import {d3, formatSiPrefix} from '../lib';\n// import {getShapes} from './draw';\n\n/**\n * Optional callback, invoked when annotations are loaded\n */\nfunction onLoadAnnots() {\n  call(this.onLoadAnnotsCallback);\n}\n\nfunction onBeforeDrawAnnots() {\n  call(this.onBeforeDrawAnnotsCallback);\n}\n\n/**\n * Optional callback, invoked when annotations are drawn\n */\nfunction onDrawAnnots() {\n  call(this.onDrawAnnotsCallback);\n}\n\nfunction hideAnnotTooltip() {\n  d3.selectAll('._ideogramTooltip').transition()\n    .duration(500) // fade out for half second\n    .style('opacity', 0)\n    .style('pointer-events', 'none');\n}\n\n/**\n * Starts a timer that, upon expiring, hides the annotation tooltip.\n *\n * To enable users to copy tooltip content to their clipboard, a timer is\n * used to control when the tooltip disappears.  It starts when the user's\n * cursor leaves the annotation or the tooltip.  If the user moves the cursor\n * back over the annot or tooltip after the timer starts and before it expires,\n * then the timer is cleared.\n */\nfunction startHideAnnotTooltipTimeout() {\n  const ideo = this;\n\n  if (ideo.config.showAnnotTooltip === false) {\n    return;\n  }\n\n  // See \"Without this...\" note in gene-structure.js\n  const hideMs = ideo.oneTimeDelayTooltipHideMs ?? 250;\n  delete ideo.oneTimeDelayTooltipHideMs;\n\n  // Hide tooltip after `hideMs` milliseconds\n  ideo.hideAnnotTooltipTimeout = window.setTimeout(function() {\n    hideAnnotTooltip();\n  }, hideMs);\n\n  // Enable clients to not show tooltip immediately after clicking gene,\n  // e.g. in related genes kit\n  ideo.isTooltipCooling = true;\n  ideo.hideAnnotTooltipCounter = window.setTimeout(function() {\n    ideo.isTooltipCooling = false;\n  }, 500);\n}\n\nfunction renderTooltip(tooltip, content, matrix, yOffset, ideo) {\n  const left = ideo.config.orientation === 'horizontal' ?\n    matrix.left + (matrix.width / 2) :\n    matrix.left + matrix.width;\n\n  tooltip.html(content)\n    .style('opacity', 1) // Make tooltip visible\n    .style('left', left + 'px')\n    .style('top', (matrix.top - yOffset) + 'px')\n    .style('font-family', ideo.config.fontFamily)\n    .style('pointer-events', null) // Prevent bug in clicking chromosome\n    .on('mouseover', function() {\n      clearTimeout(ideo.hideAnnotTooltipTimeout);\n    })\n    .on('mouseout', function() {\n      ideo.startHideAnnotTooltipTimeout();\n    });\n}\n\nfunction getCoarseBpLength(annot) {\n  const length = Math.abs(annot.stop - annot.start);\n  return formatSiPrefix(length) + 'bp';\n}\n\nfunction getContentAndYOffset(annot, includeLength=false) {\n  var content, yOffset, range, displayName;\n\n  range = 'chr' + annot.chr + ':' + annot.start.toLocaleString();\n  if (annot.displayCoordinates) {\n    range = annot.displayCoordinates;\n  } else if (annot.length > 0) {\n    // Only show range if stop differs from start\n    range += '-' + annot.stop.toLocaleString();\n    if (includeLength) range += ' (' + getCoarseBpLength(annot) + ')';\n  }\n  content = `<span class=\"_ideoTooltipFooter\"><br />${range}</span>`;\n  yOffset = 24;\n\n  if (annot.name) {\n    displayName = annot.displayName ? annot.displayName : annot.name;\n    content = displayName + content;\n    yOffset += 8;\n  }\n\n  return [content, yOffset];\n}\n\n/**\n * Optional callback, invoked before showing annotation tooltip\n */\nasync function onWillShowAnnotTooltip(event, context) {\n  await call(this.onWillShowAnnotTooltipCallback, event, context);\n}\n\nfunction onDidShowAnnotTooltip() {\n  call(this.onDidShowAnnotTooltipCallback);\n}\n\n/**\n * Optional callback, invoked on clicking annotation\n */\nfunction onClickAnnot(annot) {\n  this.prevClickedAnnot = annot;\n  this.hasShownAnnotSinceClick = false;\n  this.onClickAnnotCallback(annot);\n}\n\n// /** Get list of annotation objects by names, e.g. [\"BRCA1\", \"APOE\"] */\n// function getAnnotsByName(annotNames, ideo) {\n//   return annotNames.map(name => getAnnotByName(name, ideo));\n// }\n\n/**\n * Shows a tooltip for the given annotation.\n *\n * See notes in startHideAnnotTooltipTimeout about show/hide logic.\n *\n * @param annot {Object} Processed annotation object\n * @param context {Object} \"This\" of the caller -- an SVG path DOM object\n */\nasync function showAnnotTooltip(annot, context) {\n  var content, yOffset, tooltip,\n    ideo = this;\n\n  if (ideo.config.showAnnotTooltip === false) return;\n\n  clearTimeout(ideo.hideAnnotTooltipTimeout);\n\n  if (ideo.onWillShowAnnotTooltipCallback) {\n    annot = await ideo.onWillShowAnnotTooltipCallback(annot, context);\n  }\n\n  // Enable onWillShowAnnotTooltipCallback to cancel showing tooltip\n  if (annot === null) {\n    hideAnnotTooltip();\n    return;\n  }\n\n  ideo.prevTooltipAnnotName = annot.name;\n  tooltip = d3\n    .select(`#${ideo.config.container.replace('#', '')}_ideogramTooltip`);\n  tooltip.interrupt(); // Stop any in-progress disapperance\n\n  const includeLength = true;\n  [content, yOffset] = getContentAndYOffset(annot, includeLength);\n\n  const matrix = context.getBoundingClientRect();\n  renderTooltip(tooltip, content, matrix, yOffset, ideo);\n\n  if (ideo.onDidShowAnnotTooltipCallback) {\n    ideo.onDidShowAnnotTooltipCallback();\n  }\n}\n\nexport {\n  onLoadAnnots, onBeforeDrawAnnots, onDrawAnnots, startHideAnnotTooltipTimeout,\n  onWillShowAnnotTooltip, showAnnotTooltip, onClickAnnot,\n  onDidShowAnnotTooltip\n};\n","import {d3, getFont, getTextSize, deepCopy, ensureContrast} from '../lib';\n\nimport {sortAnnotsByRank} from './annotations';\n\nconst allLabelStyle = `\n  <style>\n    #_ideogram .annot path, ._ideogramLabel {\n      cursor: pointer;\n    }\n\n    #_ideogram .annot path {\n      stroke-width: 1px;\n      stroke: white;\n      stroke-linejoin: bevel;\n    }\n\n    #_ideogram .annot ._ideogramLabel._ideoActive {\n      fill: #77F !important;\n      stroke: #F0F0FF !important;\n    }\n\n    #_ideogram .annot > path._ideoActive {\n      stroke: #D0D0DD !important;\n      stroke-width: 1.5px;\n    }\n\n    #_ideogram .annot ._ideogramLabel {\n      stroke: white;\n      stroke-width: 5px;\n      stroke-linejoin: round;\n      paint-order: stroke fill;\n      text-align: center;\n    }\n  </style>\n  `;\n\n/** Return DOM ID of annotation object */\nfunction getAnnotDomLabelId(annot) {\n  return 'ideogramLabel_' + annot.domId;\n}\n\nfunction changeAnnotState(state, labelId, annotId) {\n  d3.selectAll('._ideoActive').classed('_ideoActive', false);\n  d3.select('#' + labelId).attr('class', '_ideogramLabel ' + state);\n  d3.select('#' + annotId + ' > path').attr('class', state);\n}\n\nfunction triggerAnnotEvent(event, ideo) {\n  let labelId, annotId;\n  const target = event.target;\n  const type = event.type;\n\n  const targetClasses = Array.from(target.classList);\n  if (targetClasses.includes('_ideogramLabel')) {\n    labelId = target.id;\n    annotId = target.id.split('ideogramLabel_')[1];\n    d3.select('#' + annotId + ' path').dispatch(type);\n  } else {\n    const annotElement = target.parentElement;\n    labelId = 'ideogramLabel_' + annotElement.id;\n    annotId = annotElement.id;\n\n    if (targetClasses.includes('_ideogramLabelRect')) {\n      d3.select('#' + annotId + ' path').dispatch(type);\n    }\n  }\n\n  if (type === 'mouseout') {\n    ideo.time.prevTooltipOff = performance.now();\n    ideo.time.prevTooltipAnnotDomId = annotId;\n  }\n\n  // On mouseover, activate immediately\n  // Otherwise, wait a moment (250 ms), then deactivate.\n  // Delayed deactivation mitigates flicker when moving from\n  // annot label to annot triangle.\n  if (type === 'mouseover') {\n    clearTimeout(window._ideoActiveTimeout);\n    changeAnnotState('_ideoActive', labelId, annotId);\n  } else {\n    window._ideoActiveTimeout = window.setTimeout(function() {\n      changeAnnotState('', labelId, annotId);\n    }, 250);\n  }\n}\n\nfunction renderLabel(annot, style, ideo) {\n\n  if (!ideo.didSetLabelStyle) {\n    document.querySelector('#_ideogramInnerWrap')\n      .insertAdjacentHTML('afterbegin', allLabelStyle);\n    ideo.didSetLabelStyle = true;\n  }\n\n  const id = getAnnotDomLabelId(annot);\n\n  const font = getFont(ideo);\n\n  let fill = annot.color === 'pink' ? '#CF406B' : annot.color;\n\n  fill = ensureContrast(fill);\n\n  const translate = `translate(-${style.width + 9},${style.height/2 - 1.5})`;\n  d3.select('#' + annot.domId).append('text')\n    .attr('id', id)\n    .attr('class', '_ideogramLabel')\n    .attr('transform', `rotate(-90) ${translate}`)\n    .style('font', font)\n    .style('fill', fill)\n    .style('pointer-events', null) // Prevent bug in clicking chromosome\n    .html(annot.name);\n\n  const paralogNeighborhoodMargin = 10;\n  const rectWidth = style.width + paralogNeighborhoodMargin;\n  const rectTranslate = `translate(-${rectWidth}, -${style.height/2})`;\n\n  d3.select('#' + annot.domId).append('rect')\n    .attr('class', '_ideogramLabelRect')\n    .attr('transform', `rotate(-90) ${rectTranslate}`)\n    .attr('width', style.width + 10)\n    .attr('height', style.height)\n    .attr('style', 'opacity: 0');\n}\n\n/** Get annotation object by name, e.g. \"BRCA1\" */\nfunction getAnnotByName(annotName, ideo) {\n  var annot;\n  var found = false;\n  ideo.annots.forEach((annotsByChr) => {\n    if (found) return;\n    annotsByChr.annots.forEach((thisAnnot) => {\n      if (found) return;\n      if (thisAnnot.name === annotName) {\n        annot = thisAnnot;\n        found = true;\n      }\n    });\n  });\n\n  return annot;\n}\n\n/** Get label's top and left offsets relative to chromosome, and width */\nfunction getAnnotLabelLayout(annot, ideo) {\n  var annotDom, annotRect, ideoRect, width, height, top, bottom, left, right,\n    config = ideo.config;\n\n  annotDom = document.querySelector('#' + annot.domId);\n\n  // Handles cases when annotation is not yet in DOM\n  if (annotDom === null) return null;\n\n  annotRect = annotDom.getBoundingClientRect();\n\n  ideoRect =\n    document.querySelector('#_ideogram').getBoundingClientRect();\n\n  const textSize = getTextSize(annot.name, ideo);\n  width = textSize.width;\n\n  // `pad` is a heuristic that accounts for:\n  // 1px left pad, 1px right pad, 1px right border, 1px left border\n  // as set in renderLabel\n  const pad = (config.fontFamily) ? 9 : 7;\n  width += pad;\n\n  const labelSize = config.annotLabelSize ? config.annotLabelSize : 13;\n\n  // Accounts for 1px top border, 1px bottom border as set in renderLabel\n  height = labelSize;\n\n  top = annotRect.top - ideoRect.top + height - 1;\n  bottom = top + height;\n  left = annotRect.left - ideoRect.left - width;\n  right = left + width;\n  name = annot.name;\n\n  return {top, bottom, right, left, width, height, name};\n}\n\n/**\n * Label an annotation.\n *\n * @param annotName {String} Name of annotation, e.g. \"BRCA1\"\n * @param backgroundColor {String} Background color.  Default: white.\n * @param backgroundColor {String} Border color.  Default: black.\n */\nfunction addAnnotLabel(annotName, backgroundColor, borderColor) {\n  var annot,\n    ideo = this;\n\n  annot = getAnnotByName(annotName, ideo);\n\n  const layout = getAnnotLabelLayout(annot, ideo);\n  if (layout === null) return;\n\n  const style = Object.assign(layout, {backgroundColor, borderColor});\n\n  renderLabel(annot, style, ideo);\n}\n\nfunction getIsXOverlap(o, n, p) {\n  const oLeft = o.left - p;\n  const nLeft = n.left - p;\n  const oRight = o.right + p;\n  const nRight = n.right + p;\n  // A) oLeft < nLeft && oLeft < nRight && oRight < nRight && oRight > nLeft\n  // o     o\n  // o     o\n  // o     o\n  //\n  //    n      n\n  //    n      n\n  //    n      n\n  //\n  // B) oLeft > nLeft && oLeft < nRight && oRight > nRight && oRight > nLeft\n  //    o     o\n  //    o     o\n  //    o     o\n  //\n  // n     n\n  // n     n\n  // n     n\n  //\n  // C) oLeft < nLeft && oLeft < nRight && oRight > nRight && oRight > nLeft\n  // o         o\n  // o         o\n  // o         o\n  //\n  //    n   n\n  //    n   n\n  //\n  // D) oLeft > nLeft && oLeft < nRight && oRight > nLeft && oRight < nRight\n  //    o   o\n  //    o   o\n  //    o   o\n  //\n  // n         n\n  // n         n\n  // n         n\n  return (\n    (oLeft <= nLeft && oLeft <= nRight && oRight <= nRight && oRight >= nLeft) ||\n    (oLeft >= nLeft && oLeft <= nRight && oRight >= nRight && oRight >= nLeft) ||\n    (oLeft <= nLeft && oLeft <= nRight && oRight >= nRight && oRight >= nLeft) ||\n    (oLeft >= nLeft && oLeft <= nRight && oRight >= nLeft && oRight <= nRight)\n  )\n}\n\nfunction getIsYOverlap(o, n, p) {\n    const oTop = o.top - p;\n    const nTop = n.top - p;\n    const oBottom = o.bottom + p;\n    const nBottom = n.bottom + p;\n    // Top of old annot (o) is above bottom of new annot (n),\n    // and bottom of old annot is below top of new annot\n    //\n    //  A) yOverlap = true\n    //      o.top < n.top && o.top < n.bottom && o.bottom < n.bottom && o.bottom > n.top\n    //    ooooo\n    //            nnnnn\n    //\n    //    ooooo\n    //            nnnnn\n    //\n    //  A.2)\n    //\n    //    ppppp\n    //    ppppp\n    //    ooooo\n    //\n    //            ppppp\n    //    ooooo   ppppp\n    //    ppppp   nnnnn\n    //    ppppp\n    //\n    //            nnnnn\n    //            ppppp\n    //            ppppp\n    //\n    //  B) yOverlap = true\n    //     o.top > n.top && o.top < n.bottom && o.bottom > n.bottom && o.bottom > n.top\n    //            nnnnn\n    //    ooooo\n    //\n    //            nnnnn\n    //    ooooo\n    //\n    //   B.2)\n    //\n    //            ppppp\n    //    ppppp   ppppp\n    //    ppppp   nnnnn\n    //    ooooo\n    //\n    //            nnnnn\n    //    ooooo   ppppp\n    //    ppppp   ppppp\n    //    ppppp\n    //\n    //\n    //  C) yOverlap = false\n    //     old.top < new.top && old.bottom < new.top\n    //    ooooo\n    //\n    //\n    //    ooooo\n    //\n    //          nnnnn\n    //\n    //\n    //          nnnnn\n    //\n    //  D) yOverlap = false\n    //          nnnnn\n    //\n    //\n    //          nnnnn\n    //\n    //    ooooo\n    //\n    //\n    //    ooooo\n    // sl.top - p < layout.bottom && sl.bottom > layout.top - p ||\n    // layout.top - p < sl.bottom && layout.bottom > sl.bottom\n\n    // XY overlap\n    // A)\n    //\n    //  ooooooo\n    //  o     o\n    //  o    nonnnnn\n    //  ooooooo    n\n    //       n     n\n    //       nnnnnnn\n    //\n    //\n    //  B)\n    //       ooooooo\n    //       o     o\n    //  nnnnnnn    o\n    //  n    onooooo\n    //  n     n\n    //  nnnnnnn\n    //\n    //  C)\n    //\n    //  ooooooo   nnnnnnn\n    //  o     o   n     n\n    //  o     o   n     n\n    //  ooooooo   nnnnnnn\n    //\n    //  D)\n    //\n    //  ooooooo\n    //  o     o\n    //  o     o\n    //  ooooooo\n    //\n    //  nnnnnnn\n    //  n     n\n    //  n     n\n    //  nnnnnnn\n    return (\n      // false\n      (oTop <= nTop && oTop <= nBottom && oBottom <= nBottom && oBottom >= nTop) ||\n      (oTop >= nTop && oTop <= nBottom && oBottom >= nBottom && oBottom >= nTop)\n    );\n\n    // (sl.top - p < layout.bottom || sl.bottom > layout.top - p) &&\n    // (layout.top - p < sl.bottom || layout.bottom > sl.bottom)\n}\n\n/** Label as many annotations as possible, without overlap */\nfunction fillAnnotLabels(sortedAnnots=[], numLabels=10) {\n  const ideo = this;\n\n  sortedAnnots = deepCopy(sortedAnnots); // copy by value\n\n  // Remove any pre-existing annotation labels, to avoid duplicates\n  ideo.clearAnnotLabels();\n\n  let spacedAnnots = [];\n  const spacedLayouts = [];\n\n  // sortedAnnots = applyRankCutoff(sortedAnnots, 100, ideo);\n\n  // sortedAnnots = sortedAnnots.sort(ideo.annotSortFunction);\n\n  if (sortedAnnots.length === 0) {\n    sortedAnnots = ideo.flattenAnnots();\n  }\n\n  const strokeWidth = 0; // like padding\n\n  sortedAnnots.forEach((annot, i) => {\n    const layout = getAnnotLabelLayout(annot, ideo);\n\n    if (layout === null) {\n      console.debug(annot.name + ' has null layout');\n      return;\n    }\n\n    const hasOverlap =\n      spacedLayouts.length > 0 && spacedLayouts.some((sl, j) => {\n        const xOverlap = getIsXOverlap(sl, layout, strokeWidth);\n        const yOverlap = getIsYOverlap(sl, layout, strokeWidth);\n\n        // if (annot.name === 'AKT1' || annot.name === 'XRCC3') {\n        //   const spacedAnnot = spacedAnnots[j].name;\n        //   if (spacedAnnot === 'HIF1A' || spacedAnnot === 'RAD51') {\n        //   // if (xOverlap && yOverlap) {\n        //     // console.log('sl.top - strokeWidth', sl.top - strokeWidth)\n        //     // console.log('sl.top - strokeWidth < layout.bottom')\n        //     // console.log(sl.top - strokeWidth < layout.bottom)\n        //     // console.log('sl.bottom > layout.top - strokeWidth')\n        //     // console.log(sl.bottom > layout.top - strokeWidth)\n        //     // console.log('layout.top - strokeWidth < sl.bottom')\n        //     // console.log(layout.top - strokeWidth < sl.bottom)\n        //     // console.log('layout.bottom > sl.bottom')\n        //     // console.log(layout.bottom > sl.bottom)\n        //     console.log(\n        //       'xOverlap, yOverlap, spacedAnnot, sl, annot.name, layout'\n        //     );\n        //     console.log(\n        //       xOverlap, yOverlap, spacedAnnot, sl, annot.name, layout\n        //     );\n        //   }\n        // }\n\n        // if (xOverlap && yOverlap) {\n        //   console.log('overlap! annot');\n        //   console.log(annot.name, annot.chr, annot.color);\n        // }\n        return xOverlap && yOverlap;\n      });\n\n    if (hasOverlap) return;\n\n    spacedAnnots.push(annot);\n    spacedLayouts.push(layout);\n  });\n\n  const config = ideo.config;\n  if (\n    'relatedGenesMode' in config &&\n    ['hints'].includes(config.relatedGenesMode)\n  ) {\n    numLabels = 20;\n  }\n  // spacedAnnots = applyRankCutoff(spacedAnnots, numLabels, ideo);\n  spacedAnnots = spacedAnnots.sort(ideo.annotSortFunction).slice(0, numLabels);\n\n\n  // Ensure highest-ranked annots are ordered last in SVG,\n  // to ensure the are written before lower-ranked annots\n  // (which, due to SVG z-index being tied to layering)\n  spacedAnnots.reverse();\n\n  spacedAnnots.forEach((annot) => {\n    ideo.addAnnotLabel(annot.name);\n  });\n\n  d3.selectAll('.annot')\n    .on('mouseover', (event) => triggerAnnotEvent(event))\n    .on('mouseout', (event) => triggerAnnotEvent(event, ideo))\n    .on('click', (event) => triggerAnnotEvent(event));\n}\n\nfunction removeAnnotLabel(annotName) {\n  const ideo = this;\n  const annot = getAnnotByName(annotName, ideo);\n  const id = getAnnotDomLabelId(annot);\n  document.querySelector('#' + id).remove();\n}\n\nfunction clearAnnotLabels() {\n  const labels = document.querySelectorAll('._ideogramLabel');\n  labels.forEach((label) => {label.remove();});\n}\n\nexport {\n  addAnnotLabel, clearAnnotLabels, fillAnnotLabels, getAnnotLabelLayout,\n  removeAnnotLabel\n};\n","import {shouldUseThreshold} from './heatmap-lib';\n\nfunction histogramAnnots(ideo, annot) {\n  var value, thresholds, histogramKeyIndexes, height;\n  var keys = ideo.rawAnnots.keys;\n  histogramKeyIndexes = [];\n  for (var i = 0; i < ideo.config.histogram.length; i++) {\n    var histogramKey = ideo.config.histogram[i].key;\n    histogramKeyIndexes.push(keys.indexOf(histogramKey));\n  }\n\n  value = annot[keys[histogramKeyIndexes]];\n  if (ideo.config.histogram) {\n    thresholds = ideo.config.histogram.thresholds;\n    height = getHistogramHeight(thresholds, value, ideo);\n  }\n  return height;\n}\n\nfunction getHistogramHeight(thresholds, value, ideo) {\n  var thresholds = ideo.config.histogram[0].thresholds;\n  var m, numThresholds, thresholdList, threshold, tvNum,\n    prevThreshold, useThresholdHeight, height;\n\n  for (m = 0; m < thresholds.length; m++) {\n    numThresholds = thresholds.length - 1;\n    thresholdList = thresholds[m];\n    threshold = thresholdList[0];\n\n    tvNum = parseFloat(threshold);\n    if (isNaN(tvNum) === false) threshold = tvNum;\n    if (m !== 0) prevThreshold = parseFloat(thresholds[m - 1][0]);\n\n    useThresholdHeight = shouldUseThreshold(m, numThresholds, value,\n      prevThreshold, threshold);\n\n    if (useThresholdHeight) height = parseFloat(thresholdList[1]);\n  }\n\n  return height;\n}\n\n/**\n * Get containers to group individual annotations into higher-level \"bar\"\n * annotations.\n */\nfunction getRawBars(chrModels, ideo) {\n  var chr, chrModel, lastBand, numBins, bar, h, i, px,\n    barWidth = ideo.config.barWidth,\n    bars = [];\n\n  for (h = 0; h < ideo.chromosomesArray.length; h++) {\n    chr = ideo.chromosomesArray[h].name;\n    chrModel = chrModels[chr];\n    lastBand = chrModel.bands[chrModel.bands.length - 1];\n    numBins = Math.round(lastBand.px.stop / barWidth); // chrPxStop / barWidth\n    bar = {chr: chr, annots: []};\n\n    for (i = 0; i < numBins; i++) {\n      px = i * barWidth - ideo.bump;\n      bar.annots.push({\n        bp: ideo.convertPxToBp(chrModel, px + ideo.bump),\n        px: px,\n        count: 0,\n        chrIndex: chrModel.chrIndex,\n        chrName: chr,\n        color: ideo.config.annotationsColor,\n        annots: []\n      });\n    }\n    bars.push(bar);\n  }\n  return bars;\n}\n\n/**\n * Assign how many, and which annotations each histogram bar contains\n */\nfunction assignAnnotsToBars(annots, bars, chrModels, ideo) {\n  var chrAnnots, chrModel, barAnnots, h, i, annot, px, j, barPx, nextBarPx,\n    barWidth = ideo.config.barWidth;\n\n  for (h = 0; h < annots.length; h++) {\n    chrAnnots = annots[h].annots;\n    chrModel = chrModels[annots[h].chr]; // get chr by name\n    barAnnots = bars[chrModel.chrIndex].annots;\n    for (i = 0; i < chrAnnots.length; i++) {\n      annot = chrAnnots[i];\n      px = annot.px - ideo.bump;\n      for (j = 0; j < barAnnots.length; j++) {\n        barPx = barAnnots[j].px;\n        nextBarPx = barPx + barWidth;\n        if (j === barAnnots.length - 1) nextBarPx += barWidth;\n        if (px >= barPx && px < nextBarPx) {\n          bars[chrModel.chrIndex].annots[j].count += 1;\n          bars[chrModel.chrIndex].annots[j].annots.push(annot);\n          break;\n        }\n      }\n    }\n  }\n  return bars;\n}\n\nfunction setIdeoMaxAnnotsPerBar(bars, isFirstGet, ideo) {\n  var maxAnnotsPerBarAllChrs, i, maxAnnotsPerBar, annots, chr, j, barCount;\n\n  if (isFirstGet || ideo.config.histogramScaling === 'relative') {\n    maxAnnotsPerBarAllChrs = 0;\n    for (i = 0; i < bars.length; i++) {\n      maxAnnotsPerBar = 0;\n      annots = bars[i].annots;\n      chr = bars[i].chr;\n      for (j = 0; j < annots.length; j++) {\n        barCount = annots[j].count;\n        if (barCount > maxAnnotsPerBar) maxAnnotsPerBar = barCount;\n        if (barCount > maxAnnotsPerBarAllChrs) {\n          maxAnnotsPerBarAllChrs = barCount;\n        }\n      }\n      ideo.maxAnnotsPerBar[chr] = maxAnnotsPerBar;\n    }\n    ideo.maxAnnotsPerBarAllChrs = maxAnnotsPerBarAllChrs;\n  }\n}\n\n/**\n * Set each bar's height to be proportional to the height of the bar with the\n * most annotations\n */\nfunction setProportionalBarHeight(bars, ideo) {\n  var i, annots, chr, j, barCount, barCountRatio, height,\n    ideoIsRotated = ideo._layout._isRotated;\n\n  for (i = 0; i < bars.length; i++) {\n    annots = bars[i].annots;\n    chr = bars[i].chr;\n    for (j = 0; j < annots.length; j++) {\n      barCount = annots[j].count;\n      if (ideo.config.histogramScaling === 'relative') {\n        barCountRatio = barCount / ideo.maxAnnotsPerBar[chr];\n      } else {\n        barCountRatio = barCount / ideo.maxAnnotsPerBarAllChrs;\n      }\n      if (ideoIsRotated === false) {\n        height = barCountRatio * ideo.config.chrMargin;\n      } else {\n        height = barCountRatio * ideo.config.chrHeightOriginal * 3;\n      }\n      if (isNaN(height)) {\n        height = 0;\n      }\n      bars[i].annots[j].height = height;\n    }\n  }\n  return bars;\n}\n\nfunction reportGetHistogramBarPerformance(t0, ideo) {\n  var t1 = new Date().getTime();\n  if (ideo.config.debug) {\n    console.log('Time spent in getHistogramBars: ' + (t1 - t0) + ' ms');\n  }\n}\n\nfunction setIdeoHistogramScaling(ideo) {\n  if ('histogramScaling' in ideo.config === false) {\n    ideo.config.histogramScaling = 'absolute';\n  }\n}\n\n/**\n * Returns and sets bars used for histogram\n */\nfunction getHistogramBars(annots) {\n  var chrModels, bars,\n    isFirstGet = false,\n    t0 = new Date().getTime(),\n    ideo = this;\n\n  chrModels = ideo.chromosomes[ideo.config.taxid];\n\n  setIdeoHistogramScaling(ideo);\n\n  if (typeof ideo.maxAnnotsPerBar === 'undefined') {\n    ideo.maxAnnotsPerBar = {};\n    isFirstGet = true;\n  }\n\n  bars = getRawBars(chrModels, ideo);\n  bars = assignAnnotsToBars(annots, bars, chrModels, ideo);\n\n  setIdeoMaxAnnotsPerBar(bars, isFirstGet, ideo);\n  bars = setProportionalBarHeight(bars, ideo);\n\n  reportGetHistogramBarPerformance(t0, ideo);\n  ideo.bars = bars;\n  return bars;\n}\n\nfunction getHistogramPoints(d, chrWidth, chrWidths, ideo) {\n  var x1, x2, y1, y2;\n\n  x1 = d.px + ideo.bump;\n  x2 = d.px + ideo.config.barWidth + ideo.bump;\n  y1 = chrWidth;\n  y2 = chrWidth + d.height;\n\n  var thisChrWidth = chrWidths[d.chr];\n\n  if (x2 > thisChrWidth) {\n    x2 = thisChrWidth;\n  }\n\n  return (\n    x1 + ',' + y1 + ' ' +\n    x2 + ',' + y1 + ' ' +\n    x2 + ',' + y2 + ' ' +\n    x1 + ',' + y2\n  );\n}\n\nfunction writeHistogramAnnots(chrAnnot, ideo) {\n  var chrs, chr,\n    chrWidths = {},\n    chrWidth = ideo.config.chrWidth;\n\n  chrs = ideo.chromosomes[ideo.config.taxid];\n  for (chr in chrs) {\n    chrWidths[chr] = chrs[chr];\n  }\n\n  chrAnnot.append('polygon')\n    // .attr('id', function(d, i) { return d.id; })\n    .attr('class', 'annot')\n    .attr('points', function(d) {\n      return getHistogramPoints(d, chrWidth, chrWidths, ideo);\n    })\n    .attr('fill', function(d) {return d.color;});\n}\n\nexport {\n  getHistogramBars, writeHistogramAnnots,\n  getHistogramHeight, histogramAnnots\n};\n","/**\n * @fileoverview Functions for drawing a legend for genome annotations.\n * A legend consists of rows, each with a colored icon and a text label.\n * Icons may have different shapes.  A legend may also have a name.\n */\n\nimport {d3, getTextSize, round} from '../lib';\n\nvar legendStyle =\n  '#_ideogramLegend {font: 12px Arial; overflow: auto; cursor: default;} ' +\n  '#_ideogramLegend svg {float: left;} ' +\n  '#_ideogramLegend ul {' +\n    'position: relative; left: -14px; list-style: none; float: left; ' +\n    'padding-left: 10px; margin: 0 0 1em 0; width: auto; border: none;' +\n  '} ' +\n  '#_ideogramLegend li {float: none; margin: 0;}' +\n  '#_ideogramLegend ul span {position: relative; left: -15px;} ';\n\nexport function getIcon(row, ideo) {\n  var icon, triangleAttrs, circleAttrs, rectAttrs,\n    fill = 'fill=\"' + row.color + '\" style=\"stroke: #AAA;\"',\n    shape = row.shape;\n\n  triangleAttrs = 'd=\"m7,3 l -5 9 l 9 0 z\"';\n  circleAttrs = 'd=\"m2,9a 4.5,4.5 0 1,0 9,0a 4.5,4.5 0 1,0 -9,0\"';\n  rectAttrs = 'height=\"10\" width=\"10\" y=\"3\"';\n\n  if ('shape' in row && ['circle', 'triangle'].includes(shape)) {\n    if (shape === 'circle') {\n      icon = '<path ' + circleAttrs + ' ' + fill + '></path>';\n    } else if (shape === 'triangle') {\n      var transform = '';\n      if (ideo.config.orientation === 'vertical') {\n        // Orient arrows in legend as they are in annotations\n        transform = ' transform=\"rotate(90, 7, 7)\"';\n      }\n      if (ideo.config.orientation === 'down') {\n        transform = ' transform=\"rotate(180, 7, 7)\"';\n      }\n      icon = '<path ' + triangleAttrs + transform + ' ' + fill + '></path>';\n    }\n  } else {\n    icon = '<rect ' + rectAttrs + ' ' + fill + '/>';\n  }\n\n  return icon;\n}\n\nfunction getListItems(labels, svg, list, nameHeight, ideo) {\n  var i, icon, y, row,\n    lineHeight = getLineHeight(ideo);\n\n  for (i = 0; i < list.rows.length; i++) {\n    row = list.rows[i];\n    labels += '<li class=\"_ideoLegendEntry\">' + row.name + '</li>';\n    y = lineHeight * (i - 1) + nameHeight + 1;\n    if ('name' in list) y += lineHeight;\n    icon = getIcon(row, ideo);\n    const transform = 'translate(0, ' + y + ')';\n    svg += '<g transform=\"' + transform + '\">' + icon + '</g>';\n  }\n\n  return [labels, svg];\n}\n\nfunction getLineHeight(ideo) {\n  return round(getTextSize('A', ideo).height) * 2 + 0.5;\n}\n\n/**\n * Display a legend for genome annotations, using `legend` configuration option\n */\nfunction writeLegend(ideo) {\n  var i, legend, svg, labels, list, content,\n    config = ideo.config,\n    lineHeight = getLineHeight(ideo);\n\n  d3.select(config.container + ' #_ideogramLegend').remove();\n\n  legend = config.legend;\n  content = '';\n\n  for (i = 0; i < legend.length; i++) {\n    list = legend[i];\n    let nameHeight = lineHeight;\n    if (list.nameHeight) {\n      nameHeight = list.nameHeight;\n    }\n    let nameStyle = '';\n    if (nameHeight) {\n      nameStyle =\n        `style=\"height: ${nameHeight}px; ` +\n        `position: relative; ` +\n        `left: -${nameHeight - 5}px;\"`;\n    }\n    if ('name' in list) {\n      labels =\n        `<li class=\"_ideoLegendName\" ${nameStyle}>` + list.name + `</li>`;\n    }\n    svg = '<svg id=\"_ideogramLegendSvg\" width=\"' + lineHeight + '\">';\n    [labels, svg] = getListItems(labels, svg, list, nameHeight, ideo);\n    svg += '</svg>';\n    content += svg + '<ul>' + labels + '</ul>';\n  }\n\n  var fontFamily = `font-family: ${config.fontFamily};`;\n  var lineHeightCss = `line-height: ${getLineHeight(ideo)}px;`;\n  legendStyle +=\n    `#_ideogramLegend {${fontFamily} ${lineHeightCss}}`;\n\n  var target = d3.select(config.container + ' #_ideogramOuterWrap');\n  target.append('style').html(legendStyle);\n  target.append('div').attr('id', '_ideogramLegend').html(content);\n}\n\nexport {writeLegend};\n","import {d3} from '../lib';\nimport {writeHistogramAnnots} from './histogram';\nimport {writeLegend} from './legend';\n\n\nfunction parseFriendlyAnnots(friendlyAnnots, rawAnnots) {\n  var i, j, annot, rawAnnot;\n\n  for (i = 0; i < friendlyAnnots.length; i++) {\n    annot = friendlyAnnots[i];\n\n    for (j = 0; j < rawAnnots.length; j++) {\n      if (annot.chr === rawAnnots[j].chr) {\n        rawAnnot = [\n          annot.name,\n          annot.start,\n          annot.stop - annot.start\n        ];\n        if ('color' in annot) rawAnnot.push(annot.color);\n        if ('shape' in annot) rawAnnot.push(annot.shape);\n        if ('placement' in annot) rawAnnot.push(annot.placement);\n        rawAnnots[j].annots.push(rawAnnot);\n        break;\n      }\n    }\n  }\n  return rawAnnots;\n}\n\nfunction parseFriendlyKeys(friendlyAnnots) {\n  var keys = ['name', 'start', 'length'];\n  if ('color' in friendlyAnnots[0]) {\n    keys.push('color');\n  }\n  if ('shape' in friendlyAnnots[0]) {\n    keys.push('shape');\n  }\n  if ('placement'in friendlyAnnots[0]) {\n    keys.push('placement');\n  }\n  return keys;\n}\n\n/**\n * Draws annotations defined by user\n */\nfunction drawAnnots(friendlyAnnots, layout, keep=false, isOtherLayout=false) {\n  var keys, chr,\n    rawAnnots = [],\n    ideo = this,\n    chrs = ideo.chromosomes[ideo.config.taxid]; // TODO: multiorganism\n\n  if (friendlyAnnots.length === 0) {\n    ideo.annots = [];\n    return;\n  }\n\n  if (\n    'annots' in friendlyAnnots[0] || // When filtering\n    'values' in friendlyAnnots[0] // When drawing cached expression matrices\n  ) {\n    return ideo.drawProcessedAnnots(friendlyAnnots, layout);\n  }\n\n  for (chr in chrs) {\n    rawAnnots.push({chr: chr, annots: []});\n  }\n  rawAnnots = parseFriendlyAnnots(friendlyAnnots, rawAnnots);\n  keys = parseFriendlyKeys(friendlyAnnots);\n\n  ideo.rawAnnots = {keys: keys, annots: rawAnnots};\n\n  const processedAnnots = ideo.processAnnotData(ideo.rawAnnots);\n  if (!isOtherLayout) {\n    ideo.annots = processedAnnots;\n  } else {\n    ideo.annotsOther = processedAnnots;\n  }\n\n  ideo.drawProcessedAnnots(processedAnnots, layout, keep);\n}\n\nfunction getShapes(annotHeight) {\n  var reverseTriangle, triangle, circle, rectangle, r, span, histo;\n\n  reverseTriangle =\n    'm0,0 l -' + annotHeight + ' ' + (-2 * annotHeight) +\n    ' l ' + (2 * annotHeight) + ' 0 z';\n\n  triangle =\n    'm0,0 l -' + annotHeight + ' ' + (2 * annotHeight) +\n    ' l ' + (2 * annotHeight) + ' 0 z';\n\n  // From http://stackoverflow.com/a/10477334, with a minor change (\"m -r, r\")\n  // Circles are supported natively via <circle>, but having it as a path\n  // simplifies handling triangles, circles and other shapes in the same\n  // D3 call\n  r = annotHeight;\n  circle =\n    'm -' + r + ', ' + r +\n    'a ' + r + ',' + r + ' 0 1,0 ' + (r * 2) + ',0' +\n    'a ' + r + ',' + r + ' 0 1,0 -' + (r * 2) + ',0';\n\n  rectangle =\n    'm0,0 l 0 ' + (2 * annotHeight) +\n    'l ' + annotHeight + ' 0' +\n    'l 0 -' + (2 * annotHeight) + 'z';\n\n  span = ` `;\n\n  histo = ` `;\n\n  return {reverseTriangle: reverseTriangle, triangle: triangle, circle: circle,\n    rectangle: rectangle, span: span, histo: histo};\n}\n\nfunction getChrAnnotNodes(filledAnnots, ideo) {\n  return d3.selectAll(ideo.selector + ' .chromosome')\n    .data(filledAnnots)\n    .selectAll('path.annot')\n    .data(function(d) {\n      return d.annots;\n    })\n    .enter();\n}\n\nfunction determineShape(d, shapes) {\n  if (!d.shape || d.shape === 'triangle') {\n    if (d.placement < 0) {\n      return shapes.reverseTriangle;\n    }\n    return shapes.triangle;\n  } else if (d.shape === 'circle') {\n    return shapes.circle;\n  } else if (d.shape === 'rectangle') {\n    return shapes.rectangle;\n  } else if (d.shape === 'span') {\n    return shapes.span;\n  } else if (d.shape === 'histo') {\n    return shapes.histo;\n  } else {\n    return d.shape;\n  }\n}\n\n/**\n * Multiple annotations appear next to chromosomes\n */\nfunction writeTrackAnnots(chrAnnot, ideo) {\n  var shapes,\n    annotHeight = ideo.config.annotationHeight;\n  shapes = getShapes(annotHeight);\n\n  var gElement = chrAnnot.append('g')\n    .attr('id', function(d) {return d.domId;})\n    .attr('class', 'annot')\n    .attr('transform', function(d) {\n      if (d.shape !== 'span' && d.shape !== 'histo') {\n        var y = ideo.config.chrWidth + (d.placement * annotHeight * 2);\n        if (d.placement < 0) {\n          var y = ((d.placement + 1) * annotHeight * 2);\n        }\n        return 'translate(' + d.px + ',' + y + ')';\n      }\n    })\n    .attr('fill', function(d) {return d.color;});\n\n  gElement\n    .filter(function(d) {\n      return d.shape === 'span' || d.shape == 'histo';\n    })\n    .on('mouseover', function(event, d) {ideo.showAnnotTooltip(d, this);})\n    .on('mouseout', function() {ideo.startHideAnnotTooltipTimeout();})\n    .on('click', function(event, d) {ideo.onClickAnnot(d);})\n    .append('polygon')\n    .attr('points', function(d) {\n      var x1 = d.startPx;\n      var x2 = d.stopPx;\n      var annotHeight = ideo.config.annotationHeight * 2;\n      var y = ideo.config.chrWidth + (d.placement * annotHeight);\n      if (d.shape === 'span') {\n        if (d.placement < 0) {\n          var y = annotHeight + ((d.placement - 1) * annotHeight);\n        }\n\n        var points = [\n          `${x1},${y + annotHeight}`,\n          `${x2},${y + annotHeight}`,\n          `${x2},${y}`,\n          `${x1},${y}`\n        ];\n        const bars = points.join(' ');\n        return bars;\n      }\n      if (d.shape === 'histo') {\n        if (d.placement >= 0) {\n          var points = [\n            `${x1},${y}`,\n            `${x2},${y}`,\n            `${x2},${y + d.height}`,\n            `${x1},${y + d.height}`\n          ];\n        } else if (d.placement < 0) {\n          var y = ((d.placement + 1) * annotHeight);\n          var points = [\n            `${x1},${y - d.height}`,\n            `${x2},${y - d.height}`,\n            `${x2},${y}`,\n            `${x1},${y}`\n          ];\n        }\n        const bars = points.join(' ');\n        return bars;\n      }\n    });\n\n  gElement\n    .filter(function(d) {\n      return d.shape !== 'span' && d.shape !== 'histo';\n    })\n    .append('path')\n    .attr('d', function(d) {return determineShape(d, shapes);})\n    .on('mouseover', function(event, d) {ideo.showAnnotTooltip(d, this);})\n    .on('mouseout', function() {ideo.startHideAnnotTooltipTimeout();})\n    .on('click', function(event, d) {ideo.onClickAnnot(d);});\n}\n\n/**\n * Overlaid annotations appear directly on chromosomes\n */\nfunction writeOverlayAnnots(chrAnnot, ideo) {\n  chrAnnot.append('polygon')\n    .attr('id', function(d) {return d.id;})\n    .attr('class', 'annot')\n    .attr('points', function(d) {\n      var x1, x2,\n        chrWidth = ideo.config.chrWidth;\n\n      if (d.stopPx - d.startPx > 1) {\n        x1 = d.startPx;\n        x2 = d.stopPx;\n      } else {\n        x1 = d.px - 0.5;\n        x2 = d.px + 0.5;\n      }\n\n      return (\n        x1 + ',' + chrWidth + ' ' + x2 + ',' + chrWidth + ' ' +\n        x2 + ',0 ' + x1 + ',0'\n      );\n    })\n    .attr('fill', function(d) {return d.color;})\n    .on('mouseover', function(event, d) {ideo.showAnnotTooltip(d, this);})\n    .on('mouseout', function() {ideo.startHideAnnotTooltipTimeout();});\n}\n\n/**\n * Annotations appear next to chromosomes\n */\nfunction writeSpanAnnots(chrAnnot, ideo) {\n  chrAnnot.append('g')\n    .attr('id', function(d) {return d.domId;})\n    .attr('class', 'annot')\n    .append('polygon')\n    .attr('points', function(d) {\n      var annotHeight = ideo.config.annotationHeight * 2;\n      var x1 = d.startPx;\n      var x2 = d.stopPx;\n      var y = ideo.config.chrWidth + (d.placement * annotHeight);\n\n      var points = [\n        `${x1},${y + annotHeight}`,\n        `${x2},${y + annotHeight}`,\n        `${x2},${y}`,\n        `${x1},${y}`\n      ];\n      const bars = points.join(' ');\n      return bars;\n    })\n    .attr('fill', function(d) {return d.color;})\n    .on('mouseover', function(event, d) {ideo.showAnnotTooltip(d, this);})\n    .on('mouseout', function() {ideo.startHideAnnotTooltipTimeout();})\n    .on('click', function(event, d) {ideo.onClickAnnot(d);});\n};\n\nfunction warnIfTooManyAnnots(layout, annots) {\n  var i, numAnnots;\n\n  if (!/heatmap/.test(layout) && layout !== 'histogram') {\n    numAnnots = 0;\n    for (i = 0; i < annots.length; i++) {\n      numAnnots += annots[i].annots.length;\n    }\n    if (numAnnots > 2000) {\n      console.warn(\n        'Rendering more than 2000 annotations in Ideogram?\\n' +\n        'Try setting \"annotationsLayout\" to \"heatmap\" or \"histogram\" in your ' +\n        'Ideogram configuration object for better layout and performance.'\n      );\n    }\n  }\n}\n\nfunction drawAnnotsByLayoutType(layout, annots, ideo) {\n  var filledAnnots, chrAnnot;\n\n  warnIfTooManyAnnots(layout, annots);\n\n  if (layout === 'histogram') annots = ideo.getHistogramBars(annots);\n\n  filledAnnots = ideo.fillAnnots(annots);\n\n  chrAnnot = getChrAnnotNodes(filledAnnots, ideo);\n\n  if (layout === 'tracks') {\n    writeTrackAnnots(chrAnnot, ideo);\n  } else if (layout === 'overlay') {\n    writeOverlayAnnots(chrAnnot, ideo);\n  } else if (layout === 'histogram') {\n    writeHistogramAnnots(chrAnnot, ideo);\n  } else if (layout === 'span') {\n    writeSpanAnnots(chrAnnot, ideo);\n  }\n}\n\n/**\n * Draws genome annotations on chromosomes.\n * Annotations can be rendered as either overlaid directly\n * on a chromosome, or along one or more \"tracks\"\n * running parallel to each chromosome.\n */\nfunction drawProcessedAnnots(annots, layout, keep=false) {\n\n  var ideo = this;\n\n  if (ideo.onBeforeDrawAnnotsCallback) {\n    ideo.onBeforeDrawAnnotsCallback();\n  }\n\n  if (!keep) {\n    d3.selectAll(ideo.selector + ' .annot').remove();\n  }\n\n  if (layout === undefined) layout = 'tracks';\n  if (ideo.config.annotationsLayout) layout = ideo.config.annotationsLayout;\n\n  if ('legend' in ideo.config) writeLegend(ideo);\n\n  if (/heatmap/.test(layout)) {\n    ideo.drawHeatmaps(annots);\n    return;\n  }\n\n  drawAnnotsByLayoutType(layout, annots, ideo);\n  if (ideo.onDrawAnnotsCallback) ideo.onDrawAnnotsCallback();\n}\n\nexport {drawAnnots, drawProcessedAnnots, getShapes};\n","import {d3} from '../lib';\n\nexport function writeSyntenicRegion(syntenies, regionID, ideo) {\n  return syntenies.append('g')\n    .attr('class', 'syntenicRegion')\n    .attr('id', regionID)\n    .on('click', function() {\n      var activeRegion = this;\n      var others = d3.selectAll(ideo.selector + ' .syntenicRegion')\n        .filter(function() {return (this !== activeRegion);});\n\n      others.classed('hidden', !others.classed('hidden'));\n    })\n    .on('mouseover', function() {\n      var activeRegion = this;\n      d3.selectAll(ideo.selector + ' .syntenicRegion')\n        .filter(function() {return (this !== activeRegion);})\n        .classed('ghost', true);\n    })\n    .on('mouseout', function() {\n      d3.selectAll(ideo.selector + ' .syntenicRegion')\n        .classed('ghost', false);\n    });\n}\n\nexport function writeSyntenicRegionPolygons(\n  syntenicRegion, x1, x2, r1, r2, regions\n) {\n  var color, opacity;\n\n  color = ('color' in regions) ? regions.color : '#CFC';\n  opacity = ('opacity' in regions) ? regions.opacity : 1;\n\n  syntenicRegion.append('polygon')\n    .attr('points',\n      x1 + ', ' + r1.startPx + ' ' +\n      x1 + ', ' + r1.stopPx + ' ' +\n      x2 + ', ' + r2.stopPx + ' ' +\n      x2 + ', ' + r2.startPx\n    )\n    .style('fill', color)\n    .style('fill-opacity', opacity);\n}\n\nexport function writeSyntenicRegionPolygonsHorizontal(\n  syntenicRegion, y1, y2, r1, r2, regions\n) {\n  var color, opacity;\n\n  color = ('color' in regions) ? regions.color : '#CFC';\n  opacity = ('opacity' in regions) ? regions.opacity : 1;\n\n  syntenicRegion.append('polygon')\n    .attr('points',\n      (r1.startPx - 15) + ', ' + y1 + ' ' +\n      (r1.stopPx - 15) + ', ' + y1 + ' ' +\n      (r2.stopPx - 15) + ', ' + y2 + ' ' +\n      (r2.startPx - 15) + ', ' + y2\n    )\n    .style('fill', color)\n    .style('fill-opacity', opacity);\n}\n\nexport function getRegionsR1AndR2(regions, ideo, xOffset = null) {\n  var r1, r2,\n    r1Offset, r2Offset;\n\n  r1 = regions.r1;\n  r2 = regions.r2;\n\n  if (typeof r1.chr === 'string') {\n    const taxids = ideo.config.taxids;\n    if (ideo.config.multiorganism) {\n      r1.chr = ideo.chromosomes[taxids[0]][r1.chr];\n      r2.chr = ideo.chromosomes[taxids[1]][r2.chr];\n    } else {\n      r1.chr = ideo.chromosomes[taxids[0]][r1.chr];\n      r2.chr = ideo.chromosomes[taxids[0]][r2.chr];\n    }\n  }\n\n  var r1ChrDom = document.querySelector('#' + r1.chr.id + '-chromosome-set');\n  var r1GenomeHorizontalXOffset = r1ChrDom.getCTM().e;\n  var r1GenomeVerticalXOffset = r1ChrDom.getCTM().f;\n  var r2ChrDom = document.querySelector('#' + r2.chr.id + '-chromosome-set');\n  // var r2GenomeOffset = r2ChrDom.getBoundingClientRect().top;\n  var r2GenomeHorizontalXOffset = r2ChrDom.getCTM().e;\n  var r2GenomeVerticalXOffset = r2ChrDom.getCTM().f;\n\n  if (xOffset === null) {\n    if (ideo.config.orientation === 'vertical') {\n      // When vertical collinear\n      // http://localhost:8080/examples/vanilla/compare-whole-genomes?chromosome-scale=absolute&orientation=vertical\n      r1Offset = r1GenomeVerticalXOffset - 12;\n      r2Offset = r2GenomeVerticalXOffset - 12;\n    } else {\n      // When horizontal collinear, e.g.\n      // http://localhost:8080/examples/vanilla/compare-whole-genomes?chromosome-scale=absolute&orientation=horizontal\n      r1Offset = r1GenomeHorizontalXOffset;\n      r2Offset = r2GenomeHorizontalXOffset;\n    }\n  } else {\n    // When horizontal parallel\n    r1Offset = xOffset;\n    r2Offset = xOffset;\n  }\n\n  r1.startPx = ideo.convertBpToPx(r1.chr, r1.start) + r1Offset;\n  r1.stopPx = ideo.convertBpToPx(r1.chr, r1.stop) + r1Offset;\n  r2.startPx = ideo.convertBpToPx(r2.chr, r2.start) + r2Offset;\n  r2.stopPx = ideo.convertBpToPx(r2.chr, r2.stop) + r2Offset;\n\n  return [r1, r2];\n}\n","import {d3} from '../lib';\nimport {\n  getRegionsR1AndR2, writeSyntenicRegionPolygons, writeSyntenicRegion\n} from './synteny-lib';\n\nfunction writeSyntenicRegionLines(syntenicRegion, x1, x2, r1, r2) {\n  syntenicRegion.append('line')\n    .attr('class', 'syntenyBorder')\n    .attr('x1', x1)\n    .attr('x2', x2)\n    .attr('y1', r1.startPx)\n    .attr('y2', r2.startPx);\n\n  syntenicRegion.append('line')\n    .attr('class', 'syntenyBorder')\n    .attr('x1', x1)\n    .attr('x2', x2)\n    .attr('y1', r1.stopPx)\n    .attr('y2', r2.stopPx);\n}\n\nfunction writeSyntenicRegions(syntenicRegions, syntenies, ideo) {\n  var i, regions, r1, r2, regionID, syntenicRegion, chrWidth, x1, x2;\n\n  for (i = 0; i < syntenicRegions.length; i++) {\n    regions = syntenicRegions[i];\n\n    [r1, r2] = getRegionsR1AndR2(regions, ideo);\n\n    regionID = (\n      r1.chr.id + '_' + r1.start + '_' + r1.stop + '_' +\n      '__' +\n      r2.chr.id + '_' + r2.start + '_' + r2.stop\n    );\n\n    syntenicRegion = writeSyntenicRegion(syntenies, regionID, ideo);\n\n    chrWidth = ideo.config.chrWidth;\n    x1 = chrWidth + 51;\n    x2 = chrWidth + 245; // Genomes are spaced ~200 pixels apart\n\n    writeSyntenicRegionPolygons(syntenicRegion, x1, x2, r1, r2, regions);\n    writeSyntenicRegionLines(syntenicRegion, x1, x2, r1, r2);\n  }\n}\n\nfunction reportPerformance(t0, ideo) {\n  var t1 = new Date().getTime();\n  if (ideo.config.debug) {\n    console.log('Time in drawSyntenicRegions: ' + (t1 - t0) + ' ms');\n  }\n}\n\n/**\n * Draws a trapezoid connecting a genomic range on\n * one chromosome to a genomic range on another chromosome;\n * a syntenic region.\n */\nfunction drawSyntenyCollinear(syntenicRegions, ideo) {\n  var syntenies,\n    t0 = new Date().getTime();\n\n  syntenies = d3.select(ideo.selector)\n    .insert('g', ':first-child')\n    .attr('class', 'synteny');\n\n  writeSyntenicRegions(syntenicRegions, syntenies, ideo);\n\n  reportPerformance(t0, ideo);\n}\n\nexport {drawSyntenyCollinear};\n","import {d3} from '../lib';\nimport {\n  getRegionsR1AndR2, writeSyntenicRegionPolygonsHorizontal, writeSyntenicRegion\n} from './synteny-lib';\n\nfunction writeSyntenicRegionLines(syntenicRegion, y1, y2, r1, r2) {\n  syntenicRegion.append('line')\n    .attr('class', 'syntenyBorder')\n    .attr('x1', r1.startPx - 15)\n    .attr('x2', r2.startPx - 15)\n    .attr('y1', y1)\n    .attr('y2', y2);\n\n  syntenicRegion.append('line')\n    .attr('class', 'syntenyBorder')\n    .attr('x1', r1.stopPx - 15)\n    .attr('x2', r2.stopPx - 15)\n    .attr('y1', y1)\n    .attr('y2', y2);\n}\n\nfunction writeSyntenicRegions(syntenicRegions, syntenies, ideo) {\n  var i, regions, r1, r2, regionID, syntenicRegion, chrWidth, y1, y2;\n\n  for (i = 0; i < syntenicRegions.length; i++) {\n    regions = syntenicRegions[i];\n\n    [r1, r2] = getRegionsR1AndR2(regions, ideo);\n\n    regionID = (\n      r1.chr.id + '_' + r1.start + '_' + r1.stop + '_' +\n      '__' +\n      r2.chr.id + '_' + r2.start + '_' + r2.stop\n    );\n\n    syntenicRegion = writeSyntenicRegion(syntenies, regionID, ideo);\n\n    chrWidth = ideo.config.chrWidth;\n    y1 = chrWidth + 31;\n    y2 = chrWidth + 191; // Genomes are spaced ~200 pixels apart\n\n    writeSyntenicRegionPolygonsHorizontal(\n      syntenicRegion, y1, y2, r1, r2, regions\n    );\n    writeSyntenicRegionLines(syntenicRegion, y1, y2, r1, r2);\n  }\n}\n\nfunction reportPerformance(t0, ideo) {\n  var t1 = new Date().getTime();\n  if (ideo.config.debug) {\n    console.log('Time in drawSyntenicRegions: ' + (t1 - t0) + ' ms');\n  }\n}\n\n/**\n * Draws a trapezoid connecting a genomic range on\n * one chromosome to a genomic range on another chromosome;\n * a syntenic region.\n */\nfunction drawSyntenyCollinearHorizontal(syntenicRegions, ideo) {\n  var syntenies,\n    t0 = new Date().getTime();\n\n  syntenies = d3.select(ideo.selector)\n    .insert('g', ':first-child')\n    .attr('class', 'synteny');\n\n  writeSyntenicRegions(syntenicRegions, syntenies, ideo);\n\n  reportPerformance(t0, ideo);\n}\n\nexport {drawSyntenyCollinearHorizontal};\n","import {d3} from '../lib';\nimport {drawSyntenyCollinear} from './synteny-collinear';\nimport {drawSyntenyCollinearHorizontal} from './synteny-collinear-horizontal';\nimport {\n  getRegionsR1AndR2, writeSyntenicRegionPolygons, writeSyntenicRegion\n} from './synteny-lib';\n\nfunction writeSyntenicRegionLines(syntenicRegion, x1, x2, r1, r2, regions) {\n\n  var stroke, width;\n  if (\n    Math.abs(r1.startPx - r1.startPx) < 2 &&\n    Math.abs(r1.stopPx - r1.stopPx) < 2\n  ) {\n    stroke = regions.color;\n    width = regions.width;\n  } else {\n    stroke = '';\n    width = '';\n  }\n\n  syntenicRegion.append('line')\n    .attr('class', 'syntenyBorder')\n    .attr('x1', x1)\n    .attr('x2', x2)\n    .attr('y1', r1.startPx)\n    .attr('y2', r2.startPx)\n    .style('stroke', stroke)\n    .style('stroke-width', width);\n\n  syntenicRegion.append('line')\n    .attr('class', 'syntenyBorder')\n    .attr('x1', x1)\n    .attr('x2', x2)\n    .attr('y1', r1.stopPx)\n    .attr('y2', r2.stopPx)\n    .style('stroke', stroke)\n    .style('stroke-width', stroke);\n}\n\nfunction writeSyntenicRegionLabels(syntenicRegion, x1, x2, r1, r2, regionId) {\n  var rangeIds = regionId.split('__').map(d => 'label_' + d);\n  if ('name' in r1) {\n    syntenicRegion.append('text')\n      .attr('id', rangeIds[0])\n      .attr('y', r1.startPx + 3)\n      .text(r1.name);\n    var r1Width =\n      document.querySelector('#' + rangeIds[0]).getBoundingClientRect().width;\n    d3.select('#' + rangeIds[0]).attr('x', x1 - 15 - r1Width);\n  }\n  if ('name' in r2) {\n    syntenicRegion.append('text')\n      .attr('id', rangeIds[1])\n      .text(r2.name)\n      .attr('x', x2 + 15)\n      .attr('y', r2.startPx + 3)\n      .text(r2.name);\n  }\n}\n\nfunction writeSyntenicRegions(syntenicRegions, syntenies, xOffset, ideo) {\n  var i, regions, r1, r2, regionID, syntenicRegion, chrWidth, x1, x2;\n\n  for (i = 0; i < syntenicRegions.length; i++) {\n    regions = syntenicRegions[i];\n\n    [r1, r2] = getRegionsR1AndR2(regions, ideo, xOffset);\n\n    regionID = (\n      r1.chr.id + '_' + r1.start + '_' + r1.stop + '_' +\n      '__' +\n      r2.chr.id + '_' + r2.start + '_' + r2.stop\n    );\n\n    syntenicRegion = writeSyntenicRegion(syntenies, regionID, ideo);\n\n    chrWidth = ideo.config.chrWidth;\n    x1 = ideo._layout.getChromosomeSetYTranslate(0);\n    x2 = ideo._layout.getChromosomeSetYTranslate(1) - chrWidth;\n\n    writeSyntenicRegionPolygons(syntenicRegion, x1, x2, r1, r2, regions);\n    writeSyntenicRegionLines(syntenicRegion, x1, x2, r1, r2, regions);\n    writeSyntenicRegionLabels(syntenicRegion, x1, x2, r1, r2, regionID);\n  }\n}\n\nfunction reportPerformance(t0, ideo) {\n  var t1 = new Date().getTime();\n  if (ideo.config.debug) {\n    console.log('Time in drawSyntenicRegions: ' + (t1 - t0) + ' ms');\n  }\n}\n\n/**\n * Draws a trapezoid connecting a genomic range on\n * one chromosome to a genomic range on another chromosome;\n * a syntenic region.\n */\nfunction drawSynteny(syntenicRegions) {\n  var syntenies, xOffset,\n    t0 = new Date().getTime(),\n    ideo = this,\n    config = ideo.config;\n\n  // Make synteny / orthologs readable from client apps\n  ideo.syntenicRegions = syntenicRegions;\n\n  if (\n    config.multiorganism &&\n    config.geometry === 'collinear'\n  ) {\n    if (config.orientation === 'vertical') {\n      return drawSyntenyCollinear(syntenicRegions, ideo);\n    } else {\n      return drawSyntenyCollinearHorizontal(syntenicRegions, ideo);\n    }\n  }\n\n  syntenies = d3.select(ideo.selector)\n    .insert('g', ':first-child')\n    .attr('class', 'synteny');\n\n  xOffset = ideo._layout.margin.left;\n\n  writeSyntenicRegions(syntenicRegions, syntenies, xOffset, ideo);\n\n  reportPerformance(t0, ideo);\n}\n\nexport {drawSynteny};\n","import {d3} from '../lib';\nimport collinearizeChromosomes from '../collinear';\n\n/**\n * Reset displayed tracks to those originally displayed\n */\nfunction restoreDefaultTracks() {\n  var ideo = this;\n  ideo.config.numAnnotTracks = ideo.config.annotationsNumTracks;\n  d3.selectAll(ideo.selector + ' .annot').remove();\n  ideo.drawAnnots(ideo.processAnnotData(ideo.rawAnnots));\n}\n\nfunction getDisplayedRawAnnotsByChr(annotsByChr, trackIndexes) {\n  var annot, displayedRawAnnotsByChr, annots, i, displayedAnnots, j,\n    trackIndex;\n\n  displayedRawAnnotsByChr = [];\n\n  // Filter displayed tracks by selected track indexes\n  for (i = 0; i < annotsByChr.length; i++) {\n    annots = annotsByChr[i];\n    displayedAnnots = [];\n    for (j = 0; j < annots.annots.length; j++) {\n      annot = annots.annots[j].slice(); // copy array by value\n      trackIndex = annot[3] + 1;\n      if (trackIndexes.includes(trackIndex)) {\n        annot[3] = trackIndexes.indexOf(trackIndex);\n        displayedAnnots.push(annot);\n      }\n    }\n    displayedRawAnnotsByChr.push({chr: annots.chr, annots: displayedAnnots});\n  }\n\n  return displayedRawAnnotsByChr;\n}\n\n/**\n * Adds or removes tracks from the displayed list of tracks.\n * Only works when raw annotations are dense.\n *\n * @param trackIndexes Array of indexes of tracks to display\n */\nfunction updateDisplayedTracks(trackIndexes) {\n  var displayedRawAnnotsByChr, displayedAnnots, rawAnnots,\n    ideo = this,\n    annotsByChr = ideo.rawAnnots.annots;\n\n  ideo.config.numAnnotTracks = trackIndexes.length;\n\n  displayedRawAnnotsByChr =\n    getDisplayedRawAnnotsByChr(annotsByChr, trackIndexes);\n  rawAnnots = {keys: ideo.rawAnnots.keys, annots: displayedRawAnnotsByChr};\n\n  if (ideo.config.geometry === 'collinear') {\n    collinearizeChromosomes(ideo);\n  }\n\n  displayedAnnots = ideo.processAnnotData(rawAnnots);\n\n  d3.selectAll(ideo.selector + ' .annot').remove();\n  ideo.displayedTrackIndexes = trackIndexes;\n  ideo.drawAnnots(displayedAnnots);\n\n  return displayedAnnots;\n}\n\nfunction getSetAnnotsByChr(annotsByChr, ideo) {\n  var i, j, annots, annot, setAnnots, trackIndexOriginal, numAvailTracks,\n    setAnnotsByChr = [];\n\n  numAvailTracks = 1;\n\n  for (i = 0; i < annotsByChr.length; i++) {\n    annots = annotsByChr[i];\n    setAnnots = [];\n    for (j = 0; j < annots.annots.length; j++) {\n      annot = annots.annots[j].slice();\n      trackIndexOriginal = annot[3];\n      if (trackIndexOriginal + 1 > numAvailTracks) {\n        numAvailTracks = trackIndexOriginal + 1;\n      }\n      annot.splice(4, 0, trackIndexOriginal);\n      setAnnots.push(annot);\n    }\n    setAnnotsByChr.push({chr: annots.chr, annots: setAnnots});\n  }\n\n  ideo.numAvailTracks = numAvailTracks;\n\n  return setAnnotsByChr;\n}\n\nfunction setOriginalTrackIndexes(rawAnnots) {\n  var keys, annotsByChr, setAnnotsByChr,\n    ideo = this;\n\n  keys = rawAnnots.keys;\n\n  // If this method is unnecessary, pass through\n  if (\n    keys.length < 4 ||\n    keys[3] !== 'trackIndex' ||\n    keys[4] === 'trackIndexOriginal'\n  ) {\n    return rawAnnots;\n  }\n\n  annotsByChr = rawAnnots.annots;\n  setAnnotsByChr = getSetAnnotsByChr(annotsByChr, ideo);\n\n  keys.splice(4, 0, 'trackIndexOriginal');\n  rawAnnots = {keys: keys, annots: setAnnotsByChr};\n  if (ideo.rawAnnots.metadata) rawAnnots.metadata = ideo.rawAnnots.metadata;\n\n  return rawAnnots;\n}\n\nexport {restoreDefaultTracks, setOriginalTrackIndexes, updateDisplayedTracks};\n","import {add2dAnnotsForChr} from './heatmap-2d';\nimport {setAnnotRanks} from './annotations';\nimport {histogramAnnots} from './histogram';\n\n\n// Default colors for tracks of annotations\nvar colorMap = [\n  ['F00'], // If there is 1 track, then color it red.\n  ['F00', '88F'], // If 2 tracks, color one red and one light blue.\n  ['F00', 'CCC', '88F'], // If 3, color one red, one grey, one light blue.\n  ['F00', 'FA0', '0AF', '88F'], // And so on.\n  ['F00', 'FA0', 'CCC', '0AF', '88F'],\n  ['F00', 'FA0', '875', '578', '0AF', '88F'],\n  ['F00', 'FA0', '875', 'CCC', '578', '0AF', '88F'],\n  ['F00', 'FA0', '7A0', '875', '0A7', '578', '0AF', '88F'],\n  ['F00', 'FA0', '7A0', '875', 'CCC', '0A7', '578', '0AF', '88F'],\n  ['F00', 'FA0', '7A0', '875', '552', '255', '0A7', '578', '0AF', '88F']\n];\n\n/**\n * Ensure annotation containers are ordered by chromosome.\n */\nfunction orderAnnotContainers(annots, ideo) {\n  var unorderedAnnots, i, j, annot, chr, chrs;\n\n  unorderedAnnots = annots;\n  annots = [];\n  chrs = ideo.chromosomesArray;\n  for (i = 0; i < chrs.length; i++) {\n    chr = chrs[i].name;\n    for (j = 0; j < unorderedAnnots.length; j++) {\n      annot = unorderedAnnots[j];\n      if (annot.chr === chr) {\n        annots.push(annot);\n      }\n    }\n  }\n\n  return annots;\n}\n\n/**\n * Add client annotations, as in annotations-tracks.html\n */\nfunction addClientAnnot(annots, annot, ra, m, annotationTracks) {\n  var annotTrack;\n\n  annot.trackIndex = ra[3];\n  annotTrack = annotationTracks[annot.trackIndex];\n  if (annotTrack.color) {\n    annot.color = annotTrack.color;\n  }\n  if (annotTrack.shape) {\n    annot.shape = annotTrack.shape;\n  }\n  if (annotTrack.placement) {\n    annot.placement = annotTrack.placement;\n  } else {\n    annot.placement = annot.trackIndex;\n  }\n\n  annots[m].annots.push(annot);\n\n  return annots;\n}\n\n/**\n * Add sparse server annotations, as in annotations-track-filters.html\n */\nfunction addSparseServerAnnot(annot, ra, omittedAnnots, annots, m, ideo) {\n  var colors = colorMap[ideo.numAvailTracks - 1];\n\n  annot.trackIndex = ra[3];\n  annot.trackIndexOriginal = ra[4];\n  annot.color = '#' + colors[annot.trackIndexOriginal];\n\n  // Catch annots that will be omitted from display\n  if (annot.trackIndex > ideo.config.numTracks - 1) {\n    if (annot.trackIndex in omittedAnnots) {\n      omittedAnnots[annot.trackIndex].push(annot);\n    } else {\n      omittedAnnots[annot.trackIndex] = [annot];\n    }\n    return [annots, omittedAnnots];\n  }\n  annots[m].annots.push(annot);\n\n  return [annots, omittedAnnots];\n}\n\n/**\n * Basic client annotations, as in annotations-basic.html\n * and annotations-external.html\n */\nfunction addBasicClientAnnot(annots, annot, m, ideo) {\n  if (!annot.trackIndex) {\n    annot.trackIndex = 0;\n  }\n  if (!annot.color) {\n    annot.color = ideo.config.annotationsColor;\n  }\n  if (!annot.shape) {\n    annot.shape = 'triangle';\n  }\n  if (!annot.placement) {\n    annot.placement = annot.trackIndex;\n  }\n  annots[m].annots.push(annot);\n\n  return annots;\n}\n\nfunction addAnnot(annot, keys, ra, omittedAnnots, annots, m, ideo) {\n\n  if (ideo.config.annotationTracks) {\n    annots = addClientAnnot(annots, annot, ra, m, ideo.config.annotationTracks);\n  } else if (keys[3] === 'trackIndex' && ideo.numAvailTracks !== 1) {\n    [annots, omittedAnnots] =\n      addSparseServerAnnot(annot, ra, omittedAnnots, annots, m, ideo);\n  // } else if (\n  //   keys.length > 3 &&\n  //   keys[3] in {trackIndex: 1, color: 1, shape: 1} === false &&\n  //   keys[4] === 'trackIndexOriginal'\n  // ) {\n  //   annots = addDenseServerAnnot(keys, annots, annot, m);\n  } else {\n    annots = addBasicClientAnnot(annots, annot, m, ideo);\n  }\n\n  return [annots, omittedAnnots];\n}\n\nfunction getAnnotDomId(chrIndex, annotIndex) {\n  return '_c' + chrIndex + '_a' + annotIndex;\n}\n\nfunction addAnnotsForChr(annots, omittedAnnots, annotsByChr, chrModel,\n  m, keys, ideo) {\n  var j, k, annot, ra;\n\n  // Assign DOM ID if annots are rendered as individual DOM elements\n  const shouldAssignDomId = (\n    !ideo.config.annotationsLayout ||\n    ideo.config.annotationsLayout === 'tracks'\n  );\n  for (j = 0; j < annotsByChr.annots.length; j++) {\n    ra = annotsByChr.annots[j];\n    annot = {};\n\n    for (k = 0; k < keys.length; k++) {\n      annot[keys[k]] = ra[k];\n    }\n    if (ideo.config.heatmaps) {\n      // assign annot value to the correct heatmap key\n      if (keys.includes('trackIndex')) {\n        var trackIndex = ra[keys.indexOf('trackIndex')];\n        var heatmapKey = ideo.config.heatmaps[trackIndex].key;\n        annot[heatmapKey] = ra[ra.length - 1];\n      }\n    }\n    annot.stop = annot.start + annot.length;\n\n    annot.chr = annotsByChr.chr;\n    annot.chrIndex = m;\n    if (ideo.config.histogram) {\n      annot.height = histogramAnnots(ideo, annot);\n    }\n\n    annot.startPx = ideo.convertBpToPx(chrModel, annot.start);\n    annot.stopPx = ideo.convertBpToPx(chrModel, annot.stop);\n    annot.px = Math.round((annot.startPx + annot.stopPx) / 2);\n    if (shouldAssignDomId) annot.domId = getAnnotDomId(m, j);\n\n    [annots, omittedAnnots] =\n      addAnnot(annot, keys, ra, omittedAnnots, annots, m, ideo);\n  }\n\n  if (shouldAssignDomId) {\n    if (ideo.annotSortFunction) {\n      annots[m].annots = setAnnotRanks(annots[m].annots, ideo);\n      annots[m].annots.sort((a, b) => {\n        // Reverse-sort, so first annots are drawn last, and thus at top layer\n        return -ideo.annotSortFunction(a, b);\n      });\n    } else {\n      // Sort by genomic position, in ascending order\n      annots[m].annots.sort((a, b) => a[1] - b[1]);\n    }\n\n    for (j = 0; j < annots[m].annots.length; j++) {\n      annots[m].annots[j].domId = getAnnotDomId(m, j);\n    }\n  }\n\n  return [annots, omittedAnnots];\n}\n\nfunction warnOfUndefinedChromosome(annotsByChr) {\n  console.warn(\n    'Chromosome \"' + annotsByChr.chr + '\" undefined in ideogram; ' +\n    annotsByChr.annots.length + ' annotations not shown'\n  );\n}\n\nfunction addAnnots(rawAnnots, keys, ideo) {\n  var m, i, annotsByChr, chrModel,\n    annots = [],\n    omittedAnnots = {};\n\n  m = -1;\n  for (i = 0; i < rawAnnots.length; i++) {\n    annotsByChr = rawAnnots[i];\n    chrModel = ideo.chromosomes[ideo.config.taxid][annotsByChr.chr];\n\n    if (typeof chrModel === 'undefined') {\n      warnOfUndefinedChromosome(annotsByChr);\n      continue;\n    }\n\n    m++;\n    annots.push({chr: annotsByChr.chr, annots: []});\n\n    if (ideo.config.annotationsLayout !== 'heatmap-2d') {\n      [annots, omittedAnnots] =\n        addAnnotsForChr(annots, omittedAnnots, annotsByChr, chrModel, m,\n          keys, ideo);\n    } else {\n      [annots, omittedAnnots] =\n        add2dAnnotsForChr(annots, omittedAnnots, annotsByChr, chrModel, m,\n          keys, ideo);\n    }\n  }\n  return [annots, omittedAnnots];\n}\n\nfunction sendTrackAndAnnotWarnings(omittedAnnots, ideo) {\n  var numOmittedTracks,\n    layout = ideo.config.annotationsLayout,\n    numTracks = ideo.config.numAnnotTracks;\n\n  if (!/heatmap/.test(layout) && numTracks > 10) {\n    console.error(\n      'Ideogram only displays up to 10 tracks at a time.  ' +\n      'You specified ' + numTracks + ' tracks.  ' +\n      'Perhaps consider a different way to visualize your data.'\n    );\n  }\n\n  numOmittedTracks = Object.keys(omittedAnnots).length;\n  if (numOmittedTracks) {\n    console.warn(\n      'Ideogram configuration specified ' + numTracks + ' tracks, ' +\n      'but loaded annotations contain ' + numOmittedTracks + ' ' +\n      'extra tracks.'\n    );\n  }\n}\n\n/**\n * Proccesses genome annotation data.\n *\n * This method converts raw annotation data from server, which is structured as\n * an array of arrays, into a more verbose data structure consisting of an\n * array of objects.  It also adds pixel offset information.\n */\nfunction processAnnotData(rawAnnots) {\n  var keys, annots, omittedAnnots,\n    ideo = this;\n\n  keys = rawAnnots.keys;\n  rawAnnots = rawAnnots.annots;\n\n  [annots, omittedAnnots] = addAnnots(rawAnnots, keys, ideo);\n  annots = orderAnnotContainers(annots, ideo);\n\n  sendTrackAndAnnotWarnings(omittedAnnots, ideo);\n\n  return annots;\n}\n\nexport {processAnnotData, getAnnotDomId};\n","/**\n * @fileoverview Parse raw Ideogram.js annotations from an expression matrix.\n * This module handles dense gene expression matrixes.\n * In gene expression expressions, rows are genes and columns are cells.\n */\n\nexport class ExpressionMatrixParser {\n\n  /**\n   * @param {String} matrix Tab-delimited gene expression matrix\n   * @param {Object} coordinates Coordinates [chr, start, length] by gene name\n   * @param {Object} ideo Ideogram object\n   */\n  constructor(matrix, ideo) {\n    this.matrix = matrix;\n    this.ideo = ideo;\n  }\n\n  /**\n   * Initialize rawAnnots by fetching genomic coordinates, then merging them\n   * with the gene expression matrix supplied in constructor.\n   */\n  setRawAnnots() {\n    var parser, ideo, matrix;\n    parser = this;\n    ideo = this.ideo;\n    matrix = this.matrix;\n\n    return new Promise(function(resolve) {\n      parser.rawAnnots = parser.fetchCoordinates(ideo)\n        .then(function(coordinates) {\n          parser.coordinates = coordinates;\n          resolve(parser.parseExpressionMatrix(matrix, ideo));\n        });\n    });\n  }\n\n  /**\n   * Get chromosome, start and stop coordinates from genome annotation file\n   *\n   * TODO: Support non-human organisms\n   */\n  fetchCoordinates(ideo) {\n    var coordinates = {};\n\n    if (ideo.config.organism === 'human') {\n      var ensemblData =\n        ideo.config.dataDir +\n        '../../annotations/Homo_sapiens,_Ensembl_80.tsv';\n\n      return new Promise(function(resolve) {\n        ideo.fetch(ensemblData, 'text').then(function(data) {\n          // eslint-disable-next-line no-unused-vars\n          var tsvLines, i, start, stop, gene, chr, length;\n\n          tsvLines = data.split(/\\r\\n|\\n/).slice(1);\n          for (i = 0; i < tsvLines.length; i++) {\n            [start, stop, gene, , chr] = tsvLines[i].split(/\\s/g);\n            start = parseInt(start);\n            stop = parseInt(stop);\n            length = stop - start;\n            coordinates[gene] = [chr, start, length];\n          }\n          resolve(coordinates);\n        });\n      });\n    } else {\n      throw Error('Expression matrix parsing is only supported for human');\n    }\n  }\n\n  /**\n   * Parses an annotation from a tab-separated line of a matrix file\n   */\n  parseAnnotFromTsvLine(tsvLine, chrs) {\n    var annot, chrIndex, chr, start, gene, expressions,\n      columns = tsvLine.split(/\\s/g);\n\n    gene = columns[0];\n    if (gene in this.coordinates === false) return [null, null];\n\n    expressions = columns.slice(1).map(d => parseFloat(d));\n    [chr, start, length] = this.coordinates[gene];\n\n    chrIndex = chrs.indexOf(chr);\n    if (chrIndex === -1) return [null, null];\n\n    annot = [gene, start, length];\n    annot = annot.concat(expressions);\n\n    return [chrIndex, annot];\n  }\n\n  /**\n  * Parses a gene expression matrix file, returns raw annotations\n  */\n  parseExpressionMatrix(matrix, ideo) {\n    var i, chrs, rawAnnots, cells, line, chrIndex, annot, keys,\n      annots = [],\n      tsvLines = matrix.split(/\\r\\n|\\n/);\n\n    chrs = Object.keys(ideo.chromosomes[ideo.config.taxid]);\n    for (i = 0; i < chrs.length; i++) {\n      annots.push({chr: chrs[i], annots: []});\n    }\n\n    for (i = 1; i < tsvLines.length; i++) {\n      line = tsvLines[i];\n      [chrIndex, annot] = this.parseAnnotFromTsvLine(line, chrs);\n      if (chrIndex !== null) annots[chrIndex].annots.push(annot);\n    }\n\n    cells = tsvLines[0].split(/\\s/g);\n    keys = ['name', 'start', 'length'].concat(cells);\n    rawAnnots = {keys: keys, annots: annots};\n\n    return rawAnnots;\n  }\n\n}\n","function downloadAnnotations() {\n\n  const ideo = this;\n  const annots = {};\n\n  ideo.annots.forEach(chrAnnots => {\n    chrAnnots.annots.forEach(annot => {\n      const desc = ideo.annotDescriptions.annots[annot.name];\n\n      annots[annot.name] = [\n        annot.name, desc.ensemblId,\n        annot.chr, annot.start, annot.stop, annot.length,\n        desc.type\n      ];\n    });\n  });\n\n  const header = [\n    '# Gene name', 'Ensembl ID', 'Chromosome', 'Start', 'Stop', 'Length', 'Type'\n  ];\n  const rows = [header].concat(Object.values(annots));\n  const annotsTsv =\n    ideo.annotDescriptions.headers + '\\n#\\n' +\n    rows.map(row => row.join('\\t')).join('\\n');\n\n  const annotsHref =\n    'data:text/plain;charset=utf-8,' + encodeURIComponent(annotsTsv);\n\n  var evt = new MouseEvent('click', {\n    view: window,\n    bubbles: false,\n    cancelable: true\n  });\n\n  var a = document.createElement('a');\n  a.setAttribute('download', 'ideogram.tsv');\n  a.setAttribute('href', annotsHref);\n  a.setAttribute('target', '_blank');\n\n  // Enables easy testing\n  a.setAttribute('id', '_ideo-undisplayed-dl-annots-link');\n  a.setAttribute('style', 'display: none;');\n  document.body.appendChild(a);\n\n  a.dispatchEvent(evt);\n}\n\nexport {downloadAnnotations};\n","/**\n * @fileoverview Methods for ideogram annotations.\n * Annotations are graphical objects that represent features of interest\n * located on the chromosomes, e.g. genes or variations.  They can\n * appear beside a chromosome, overlaid on top of it, or between multiple\n * chromosomes.\n */\n\nimport {BedParser} from '../parsers/bed-parser';\nimport {TsvParser} from '../parsers/tsv-parser';\nimport {drawHeatmaps, deserializeAnnotsForHeatmap} from './heatmap';\nimport {inflateThresholds} from './heatmap-lib';\nimport {inflateHeatmaps} from './heatmap-collinear';\nimport {\n  onLoadAnnots, onDrawAnnots, startHideAnnotTooltipTimeout,\n  onWillShowAnnotTooltip, onDidShowAnnotTooltip, showAnnotTooltip, onClickAnnot\n} from './events';\n\nimport {\n  addAnnotLabel, removeAnnotLabel, fillAnnotLabels, clearAnnotLabels\n  // fadeOutAnnotLabels\n} from './labels';\n\nimport {drawAnnots, drawProcessedAnnots} from './draw';\nimport {getHistogramBars} from './histogram';\nimport {drawSynteny} from './synteny';\nimport {\n  restoreDefaultTracks, setOriginalTrackIndexes, updateDisplayedTracks\n} from './filter';\nimport {processAnnotData} from './process';\nimport {ExpressionMatrixParser} from '../parsers/expression-matrix-parser';\nimport {downloadAnnotations} from './download';\n\nfunction initNumTracksAndBarWidth(ideo, config) {\n\n  if (config.annotationTracks) {\n    ideo.config.numAnnotTracks = config.annotationTracks.length;\n  } else if (config.annotationsNumTracks) {\n    ideo.config.numAnnotTracks = config.annotationsNumTracks;\n  } else {\n    ideo.config.numAnnotTracks = 1;\n  }\n  ideo.config.annotTracksHeight =\n    config.annotationHeight * config.numAnnotTracks;\n\n  if (typeof config.barWidth === 'undefined') {\n    ideo.config.barWidth = 3;\n  }\n}\n\nfunction initTooltip(ideo, config) {\n  if (config.showAnnotTooltip !== false) {\n    ideo.config.showAnnotTooltip = true;\n  }\n\n  if (config.onWillShowAnnotTooltip) {\n    ideo.onWillShowAnnotTooltipCallback = config.onWillShowAnnotTooltip;\n  }\n\n  if (config.onDidShowAnnotTooltip) {\n    ideo.onDidShowAnnotTooltipCallback = config.onDidShowAnnotTooltip;\n  }\n}\n\nfunction initAnnotLabel(ideo, config) {\n  if (config.addAnnotLabel !== false) {\n    ideo.config.addAnnotLabel = true;\n  }\n\n  if (config.onWillAddAnnotLabel) {\n    ideo.onWillAddAnnotLabelCallback = config.onWillAddAnnotLabel;\n  }\n}\n\nfunction initAnnotHeight(ideo) {\n  var config = ideo.config;\n  var annotHeight;\n\n  if (!config.annotationHeight) {\n    if (config.annotationsLayout === 'heatmap') {\n      annotHeight = config.chrWidth - 1;\n    } else {\n      annotHeight = Math.round(config.chrHeight / 100);\n      if (annotHeight < 3) annotHeight = 3;\n    }\n    ideo.config.annotationHeight = annotHeight;\n  }\n}\n\n/**\n * Initializes various annotation settings.  Constructor help function.\n */\nfunction initAnnotSettings() {\n  var ideo = this,\n    config = ideo.config;\n\n  initAnnotHeight(ideo);\n\n  if (\n    config.annotationsPath || config.localAnnotationsPath ||\n    ideo.annots || config.annotations\n  ) {\n    initNumTracksAndBarWidth(ideo, config);\n  } else {\n    ideo.config.annotTracksHeight = 0;\n    ideo.config.numAnnotTracks = 0;\n  }\n\n  if (typeof config.annotationsColor === 'undefined') {\n    ideo.config.annotationsColor = '#F00';\n  }\n\n  if (config.onClickAnnot) {\n    ideo.onClickAnnotCallback = config.onClickAnnot;\n  }\n\n  initTooltip(ideo, config);\n  initAnnotLabel(ideo, config);\n}\n\nfunction validateAnnotsUrl(annotsUrl) {\n  var tmp, extension;\n\n  tmp = annotsUrl.split('?')[0].split('.');\n  extension = tmp[tmp.length - 1];\n\n  if (['bed', 'json', 'tsv'].includes(extension) === false) {\n    extension = extension.toUpperCase();\n    alert(\n      'Ideogram.js only supports BED and Ideogram JSON and TSV ' +\n      'at the moment.  ' +\n      'Sorry, check back soon for ' + extension + ' support!'\n    );\n    return;\n  }\n  return extension;\n}\n\n/** Find redundant chromosomes in raw annotations */\nfunction detectDuplicateChrsInRawAnnots(ideo) {\n  const seen = {};\n  const duplicates = [];\n  const chrs = ideo.rawAnnots.annots.map(annot => annot.chr);\n\n  chrs.forEach((chr) => {\n    if (chr in seen) duplicates.push(chr);\n    seen[chr] = 1;\n  });\n\n  if (duplicates.length > 0) {\n    const message =\n      `Duplicate chromosomes detected.\\n` +\n      `Chromosome list: ${chrs}.  Duplicates: ${duplicates}.\\n` +\n      `To fix this, edit your raw annotations JSON data to remove redundant ` +\n      `chromosomes.`;\n    throw Error(message);\n  }\n}\n\nfunction afterRawAnnots() {\n  var ideo = this,\n    config = ideo.config;\n\n  // Ensure annots are ordered by chromosome\n  ideo.rawAnnots.annots = ideo.rawAnnots.annots.sort(Ideogram.sortChromosomes);\n\n  if (ideo.onLoadAnnotsCallback) {\n    ideo.onLoadAnnotsCallback();\n  }\n\n  if (\n    'heatmapThresholds' in config ||\n    'metadata' in ideo.rawAnnots &&\n    'heatmapThresholds' in ideo.rawAnnots.metadata\n  ) {\n    if (config.annotationsLayout === 'heatmap') {\n      inflateHeatmaps(ideo);\n    } else if (config.annotationsLayout === 'heatmap-2d') {\n      ideo.config.heatmapThresholds = inflateThresholds(ideo);\n    }\n  }\n\n  if (config.heatmaps) {\n    ideo.deserializeAnnotsForHeatmap(ideo.rawAnnots);\n  }\n\n  detectDuplicateChrsInRawAnnots(ideo);\n}\n\n/**\n * Converts list of annotation-by-chromosome objects to list of annot objects\n */\nfunction flattenAnnots() {\n  const ideo = this;\n  return ideo.annots.reduce((accumulator, annots) => {\n    return [...accumulator, ...annots.annots];\n  }, []);\n}\n\n/**\n * Requests annotations URL via HTTP, sets ideo.rawAnnots for downstream\n * processing.\n *\n * @param annotsUrl Absolute or relative URL for native or BED annotations file\n */\nfunction fetchAnnots(annotsUrl) {\n  var extension, is2dHeatmap,\n    ideo = this,\n    config = ideo.config;\n\n  is2dHeatmap = config.annotationsLayout === 'heatmap-2d';\n\n  var extension = validateAnnotsUrl(annotsUrl);\n\n  if (annotsUrl.slice(0, 4) !== 'http' && !is2dHeatmap && extension !== 'tsv') {\n    ideo.fetch(annotsUrl)\n      .then(function(data) {\n        ideo.rawAnnotsResponse = data; // Preserve truly raw response content\n        ideo.rawAnnots = data; // Sometimes gets partially processed\n        ideo.afterRawAnnots();\n      });\n    return;\n  }\n\n  extension = (is2dHeatmap ? '' : extension);\n\n  ideo.fetch(annotsUrl, 'text')\n    .then(function(text) {\n      ideo.rawAnnotsResponse = text;\n      if (is2dHeatmap) {\n        var parser = new ExpressionMatrixParser(text, ideo);\n        parser.setRawAnnots().then(function(d) {\n          ideo.rawAnnots = d;\n          ideo.afterRawAnnots();\n        });\n      } else {\n        if (extension === 'tsv') {\n          ideo.rawAnnots = new TsvParser(text, ideo).rawAnnots;\n        } else if (extension === 'bed') {\n          ideo.rawAnnots = new BedParser(text, ideo).rawAnnots;\n        } else {\n          ideo.rawAnnots = JSON.parse(text);\n        }\n        ideo.afterRawAnnots();\n      }\n    });\n}\n\n/**\n * Fills out annotations data structure such that its top-level list of arrays\n * matches that of this ideogram's chromosomes list in order and number\n * Fixes https://github.com/eweitz/ideogram/issues/66\n */\nfunction fillAnnots(annots) {\n  var filledAnnots, chrs, chrArray, i, chr, annot, chrIndex;\n\n  filledAnnots = [];\n  chrs = [];\n  chrArray = this.chromosomesArray;\n\n  for (i = 0; i < chrArray.length; i++) {\n    chr = chrArray[i].name;\n    chrs.push(chr);\n    filledAnnots.push({chr: chr, annots: []});\n  }\n\n  for (i = 0; i < annots.length; i++) {\n    annot = annots[i];\n    chrIndex = chrs.indexOf(annot.chr);\n    if (chrIndex !== -1) {\n      filledAnnots[chrIndex] = annot;\n    }\n  }\n\n  return filledAnnots;\n}\n\nexport function applyRankCutoff(annots, cutoff, ideo) {\n  const rankedAnnots = sortAnnotsByRank(annots, ideo);\n\n  // Take the top N ranked genes, where N is `cutoff`\n  annots = rankedAnnots.slice(0, cutoff);\n\n  return annots;\n}\n\nexport function setAnnotRanks(annots, ideo) {\n  if (annots.length === 0) return annots;\n  if ('initRank' in annots[0] === false) {\n    if ('geneCache' in Ideogram === false) return annots;\n\n    const ranks = Ideogram.geneCache.interestingNames;\n\n    return annots.map(annot => {\n      if (ranks.includes(annot.name)) {\n        annot.rank = ranks.indexOf(annot.name) + 1;\n      } else {\n        annot.rank = 1E10;\n      }\n      return annot;\n    });\n  } else {\n    return annots.map(annot => {\n      annot.rank = annot.initRank;\n      return annot;\n    });\n  }\n}\n\nexport function sortAnnotsByRank(annots, ideo) {\n\n  if (ideo) {\n    annots = setAnnotRanks(annots, ideo);\n  }\n  // Ranks annots by popularity\n  return annots.sort((a, b) => {\n\n    // // Search gene is most important, regardless of popularity\n    // if (a.color === 'red') return -1;\n    // if (b.color === 'red') return 1;\n\n    // Rank 3 is more important than rank 30\n    return a.rank - b.rank;\n  });\n}\n\nexport {\n  onLoadAnnots, onDrawAnnots, processAnnotData, restoreDefaultTracks,\n  updateDisplayedTracks, initAnnotSettings, fetchAnnots, drawAnnots,\n  getHistogramBars, drawHeatmaps, deserializeAnnotsForHeatmap, fillAnnots,\n  drawProcessedAnnots, drawSynteny, startHideAnnotTooltipTimeout,\n  showAnnotTooltip, onWillShowAnnotTooltip, onDidShowAnnotTooltip,\n  setOriginalTrackIndexes,\n  afterRawAnnots, onClickAnnot, downloadAnnotations, addAnnotLabel,\n  removeAnnotLabel, fillAnnotLabels, clearAnnotLabels, flattenAnnots\n  // fadeOutAnnotLabels\n};\n","/** Adds boxes behind a list of chromosomes; can indicate selection, etc. */\nfunction highlight(chrNames, color='red') {\n  const ideo = this;\n  const taxid = ideo.config.taxid;\n\n  const highlightsHtml = chrNames.map(chrName => {\n    const chrId = ideo.chromosomes[taxid][chrName].id;\n    const chrSet = `${ideo.selector} #${chrId}-chromosome-set`;\n    const chrDom = document.querySelector(chrSet);\n    const rect = chrDom.getBoundingClientRect();\n\n    const style = `style=\"\n      stroke-width: 1px;\n      stroke: ${color};\n      fill: ${color};\n      fill-opacity: 0.05;\n      position: absolute;\n      rx: 4;\n      ry: 4;\n      height: ${rect.width + 15}px;\n      width: ${rect.height + 15}px\"`;\n\n    const left = chrDom.transform.baseVal[1].matrix.f - 7.5;\n    const transform = `transform=\"rotate(90) translate(10, ${left})\"`;\n    const id = `id=\"ideo-highlight-${chrId}\"`;\n\n    return `<rect class=\"ideo-highlight\" ${id} ${style} ${transform}/>`;\n  }).join();\n\n  const ideoDom = document.querySelector(ideo.selector);\n  ideoDom.insertAdjacentHTML('afterBegin', highlightsHtml);\n}\n\n/** Removes highlight from a list of chromosomes (or all chromosomes)  */\nfunction unhighlight(chrNames) {\n  const ideo = this;\n\n  let highlightsSelector = `${ideo.selector} .ideo-highlight`;\n  if (typeof chrNames !== 'undefined') {\n    const taxid = ideo.config.taxid;\n    highlightsSelector = chrNames.map(chrName => {\n      const chrId = ideo.chromosomes[taxid][chrName].id;\n      return `${ideo.selector} #ideo-highlight-${chrId}`;\n    });\n  }\n\n  document.querySelectorAll(highlightsSelector).forEach((element) => {\n    element.remove();\n  });\n\n}\n\nexport {highlight, unhighlight};\n","// The E-Utilies In Depth: Parameters, Syntax and More:\n// https://www.ncbi.nlm.nih.gov/books/NBK25499/\n\nvar apiKey = '&api_key=7e33ac6a08a6955ec3b83d214d22b21a2808';\n\nvar eutils = 'https://eutils.ncbi.nlm.nih.gov/entrez/eutils/';\nvar esearch = eutils + 'esearch.fcgi?retmode=json' + apiKey;\nvar esummary = eutils + 'esummary.fcgi?retmode=json' + apiKey;\nvar elink = eutils + 'elink.fcgi?retmode=json' + apiKey;\n\nfunction getAssemblySearchUrl(taxid, ideo) {\n  var termStem, asmSearchUrl;\n\n  if (ideo.assemblyIsAccession()) {\n    termStem = ideo.config.assembly + '%22[Assembly%20Accession]';\n  } else {\n    termStem = (\n      taxid + '%22[taxid]' +\n      'AND%20(%22latest%20refseq%22[filter])%20'\n    );\n  }\n\n  asmSearchUrl =\n    ideo.esearch +\n    '&db=assembly' +\n    '&term=%22' + termStem +\n    'AND%20(%22chromosome%20level%22[filter]%20' +\n    'OR%20%22complete%20genome%22[filter])';\n\n  return asmSearchUrl;\n}\n\nexport {esearch, esummary, elink, getAssemblySearchUrl};\n","import {d3, slug, fetchWithRetry} from '../lib';\n\n/**\n *  Returns NCBI Taxonomy identifier (taxid) for organism name\n */\nfunction getTaxidFromEutils(orgName, ideo) {\n  var taxonomySearch, taxid;\n\n  taxonomySearch = ideo.esearch + '&db=taxonomy&term=' + orgName;\n\n  return d3.json(taxonomySearch).then(function(data) {\n    var idlist = data.esearchresult.idlist;\n    if (idlist.length === 0) {\n      var warning =\n        'Organism \"' + orgName + '\" is generally unknown; it was not found ' +\n        'in the NCBI Taxonomy database.  If you did not intend to specify a ' +\n        'novel or custom taxon, then try using the organism\\'s ' +\n        'scientific name, e.g. Homo sapiens or Arabidopsis thaliana.';\n      throw warning;\n    } else {\n      taxid = data.esearchresult.idlist[0];\n      return [orgName, taxid];\n    }\n  });\n}\n\n/**\n * Returns organism common name given an NCBI Taxonomy ID\n *\n * @param taxid NCBI Taxonomy ID\n * @param callback Function to call upon completing ESearch request\n */\nfunction getOrganismFromEutils(taxid, callback) {\n  var organism, taxonomySearch,\n    ideo = this;\n\n  taxid = ideo.config.organism;\n\n  taxonomySearch = ideo.esummary + '&db=taxonomy&id=' + taxid;\n\n  d3.json(taxonomySearch).then(function(data) {\n    organism = data.result[String(taxid)].commonname;\n    ideo.config.organism = organism;\n    return callback(organism);\n  });\n}\n\nfunction setTaxidData(taxid, ideo) {\n\n  var dataDir, urlOrg, taxids;\n\n  if (ideo.assemblyIsAccession()) {\n    return new Promise(function(resolve) {\n      ideo.coordinateSystem = 'bp';\n      ideo.getAssemblyAndChromosomesFromEutils(taxid, resolve);\n    });\n  }\n\n  dataDir = ideo.config.dataDir;\n  urlOrg = slug(ideo.organisms[taxid].scientificName);\n\n  taxids = [taxid];\n\n  var fullyBandedTaxids = ['9606', '10090', '10116'];\n  if (fullyBandedTaxids.includes(taxid) && !ideo.config.showFullyBanded) {\n    urlOrg += '-no-bands';\n  }\n  var chromosomesUrl = dataDir + urlOrg + '.json';\n\n  var promise2 = new Promise((resolve, reject) => {\n    return fetchWithRetry(chromosomesUrl)\n      .then(response => {\n        return response.json().then(function(json) {\n          resolve(json);\n        });\n      })\n      .catch((errorMessage) => {\n        reject(errorMessage);\n      });\n  });\n\n  return promise2\n    .then(function(chrData) {\n      // Check if chromosome data exists locally.\n      // This is used for pre-processed centromere data,\n      // which is not accessible via EUtils.  See get_chromosomes.py.\n      var chrBands = chrData.chrBands\n\n      var asmAndChrTaxidsArray = [''],\n        chromosomes = [],\n        seenChrs = {},\n        chr, maxLength, splitBand, length;\n\n      ideo.bandData[chrData.taxid] = chrBands;\n\n      for (var i = 0; i < chrBands.length; i++) {\n        splitBand = chrBands[i].split(' ');\n        chr = splitBand[0];\n        length = splitBand.slice(-1)[0];\n        if (chr in seenChrs) {\n          continue;\n        } else {\n          chromosomes.push({name: chr, type: 'nuclear', length: length});\n          seenChrs[chr] = 1;\n        }\n      }\n      chromosomes = chromosomes.sort(Ideogram.sortChromosomes);\n      maxLength = {bp: 0, iscn: 0};\n      chromosomes.forEach(chr => {\n        if (chr.length > maxLength.bp) maxLength.bp = chr.length;\n      });\n      ideo.maxLength[taxid] = maxLength;\n      asmAndChrTaxidsArray.push(chromosomes);\n      asmAndChrTaxidsArray.push(taxids);\n      return asmAndChrTaxidsArray;\n    },\n    function() {\n      // If request in `then` errs (404), fetch data from EUtils\n      return new Promise(function(resolve) {\n        ideo.coordinateSystem = 'bp';\n        ideo.getAssemblyAndChromosomesFromEutils(taxid, resolve);\n      });\n    });\n}\n\nfunction setAssemblyAndChromosomes(taxid, resolve, ideo) {\n  var assembly, chrs, originalChrs, orgName, filteredChrs,\n    config = ideo.config;\n\n  setTaxidData(taxid, ideo)\n    .then(function(asmChrTaxidsArray) {\n      assembly = asmChrTaxidsArray[0];\n      chrs = asmChrTaxidsArray[1];\n\n      if ('chromosomes' in config === false || config.chromosomes === null) {\n        ideo.config.chromosomes = {};\n        ideo.config.chromosomes[taxid] = chrs;\n      } else {\n        if (config.multiorganism) {\n          if (taxid in config.chromosomes) {\n            // Encountered when either organism has centromere data\n            originalChrs = config.chromosomes[taxid];\n          } else {\n            // Encountered when neither organism has centromere data\n            orgName = slug(ideo.getScientificName(taxid));\n            ideo.config.chromosomes[taxid] =\n              config.chromosomes[orgName].slice();\n            originalChrs = ideo.config.chromosomes[taxid];\n            // delete ideo.config.chromosomes[orgName];\n          }\n        } else {\n          originalChrs = config.chromosomes;\n        }\n\n        filteredChrs = chrs.filter(d => originalChrs.includes(d.name));\n        ideo.config.chromosomes[taxid] = filteredChrs;\n      }\n      ideo.chromosomes[taxid] = ideo.config.chromosomes[taxid].slice();\n      ideo.organisms[taxid].assemblies = {\n        default: assembly\n      };\n      resolve();\n    });\n}\n\n/**\n * Determine if organism is natively supported, using its name.\n */\nfunction isOrganismSupported(org, ideo) {\n  var taxid, ideoOrg;\n\n  for (taxid in ideo.organisms) {\n    ideoOrg = ideo.organisms[taxid];\n    if (\n      taxid === slug(org) ||\n      slug(ideoOrg.commonName) === slug(org) ||\n      slug(ideoOrg.scientificName) === slug(org)\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Augment \"organisms\" metadata with for any requested organism that is\n * not natively supported (i.e., not in organism-metadata.js).\n*/\nfunction populateNonNativeOrg(orgs, ideo) {\n  var org, promise, i,\n    getTaxidFromEutilsPromises = [],\n    augmentedOrganismMetadata = {};\n\n  for (i = 0; i < orgs.length; i++) {\n    org = orgs[i];\n    if (isOrganismSupported(org, ideo) === false) {\n      promise = getTaxidFromEutils(org, ideo)\n        .then(function(orgNameAndTaxid) {\n\n          var taxid = orgNameAndTaxid[1],\n            orgName = orgNameAndTaxid[0],\n            name, scientificName;\n\n          name = orgName.replace('-', ' ');\n          scientificName = name[0].toUpperCase() + name.slice(1);\n\n          augmentedOrganismMetadata[taxid] = {\n            scientificName: scientificName,\n            commonName: '',\n            assemblies: {default: ''}\n          };\n\n          Object.assign(ideo.organisms, augmentedOrganismMetadata);\n        }, function(warning) {\n          console.warn(warning);\n          var customMetadata = {\n            scientificName: org,\n            commonName: org,\n            assemblies: {default: ''}\n          };\n\n          // Use a negative number as unofficial taxid for custom organism.\n          // Use case: https://github.com/eweitz/ideogram/issues/265\n          //\n          // If support for *multiple* custom specifies is ever\n          // needed, we can decrement from -1.\n          ideo.organisms['-1'] = customMetadata;\n          augmentedOrganismMetadata['-1'] = customMetadata;\n        });\n    } else {\n      promise = new Promise(function(resolve) {\n        var taxid = ideo.getTaxid(org);\n        augmentedOrganismMetadata[taxid] = ideo.organisms[taxid];\n        resolve();\n      });\n    }\n    getTaxidFromEutilsPromises.push(promise);\n  }\n\n  return Promise.all(getTaxidFromEutilsPromises).then(function() {\n    return augmentedOrganismMetadata;\n  });\n}\n\nfunction prepareTmpChrsAndTaxids(ideo) {\n  var orgs, taxids, tmpChrs, org, taxid, chrsOrgSlugs,\n    config = ideo.config;\n\n  taxids = [];\n  tmpChrs = {};\n  orgs = (config.multiorganism) ? config.organism : [config.organism];\n\n  return populateNonNativeOrg(orgs, ideo).then(function(orgMetadata) {\n    var orgFields = orgMetadata[taxid];\n\n    for (taxid in orgMetadata) {\n      orgFields = orgMetadata[taxid];\n      taxids.push(taxid);\n      if (config.multiorganism) {\n        if (typeof config.chromosomes !== 'undefined') {\n          chrsOrgSlugs = Object.keys(config.chromosomes).map(org => slug(org));\n          // Adjusts 'chromosomes' configuration parameter to make object\n          // keys use taxid instead of common organism name\n          if (chrsOrgSlugs.includes(slug(orgFields.scientificName))) {\n            org = orgFields.scientificName;\n          } else if (chrsOrgSlugs.includes(slug(orgFields.commonName))) {\n            org = orgFields.commonName;\n          }\n          if (slug(org) in config.chromosomes) {\n            tmpChrs[taxid] = config.chromosomes[slug(org)];\n          } else {\n            tmpChrs[taxid] = config.chromosomes[org.toLowerCase()];\n          }\n        } else {\n          tmpChrs = null;\n        }\n      }\n    }\n    return [tmpChrs, taxids];\n  });\n}\n\n/**\n * Sort taxids by the \"organism\" configuration option\n *\n * TODO: Handle taxid being passed as organism\n */\nfunction sortTaxidsByOriginalOrganismOption(ideo) {\n  var configOrganisms, sortedTaxids, i;\n  configOrganisms = ideo.config.organism;\n  sortedTaxids = [];\n  if (Array.isArray(configOrganisms)) {\n    // Handling multi-organism ideogram\n    for (i = 0; i < configOrganisms.length; i++) {\n      sortedTaxids.push(ideo.getTaxid(configOrganisms[i]));\n    }\n  } else {\n    // Handling single-organism ideogram\n    sortedTaxids.push(ideo.getTaxid(configOrganisms));\n  }\n  return sortedTaxids;\n}\n\nfunction getTaxidsForOrganismsInConfig(callback, ideo) {\n\n  prepareTmpChrsAndTaxids(ideo).then(function([tmpChrs, taxids]) {\n    var i, taxid, promise, assemblies, asmAccs,\n      config = ideo.config,\n      asmAndChrPromises = [];\n\n    for (i = 0; i < taxids.length; i++) {\n      taxid = taxids[i];\n      assemblies = ideo.organisms[taxid].assemblies;\n      asmAccs = Object.values(assemblies);\n      if (\n        assemblies.default === '' ||\n        ideo.assemblyIsAccession() && !asmAccs.includes(config.assembly)\n      ) {\n        promise = new Promise(function(resolve) {\n          setAssemblyAndChromosomes(taxid, resolve, ideo);\n        });\n      } else {\n        ideo.config.taxids = taxids;\n        if (ideo.config.multiorganism) {\n          ideo.config.chromosomes = tmpChrs;\n        }\n        promise = new Promise(function(resolve) {\n          resolve();\n        });\n      }\n\n      asmAndChrPromises.push(promise);\n    }\n\n    Promise.all(asmAndChrPromises).then(function() {\n      taxids = sortTaxidsByOriginalOrganismOption(ideo);\n      ideo.config.taxids = taxids;\n      return callback(taxids);\n    });\n  });\n}\n\nfunction getIsMultiorganism(taxidInit, ideo) {\n  return (\n    ('organism' in ideo.config && ideo.config.organism instanceof Array) ||\n    (taxidInit && ideo.config.taxid instanceof Array)\n  );\n}\n\n/**\n * Configure Ideogram taxids when 'organism' is not in ideo.config\n */\nfunction getTaxidsForOrganismsNotInConfig(taxidInit, callback, ideo) {\n  var taxids;\n\n  if (ideo.config.multiorganism) {\n    if (taxidInit) {\n      taxids = ideo.config.taxid;\n    }\n  } else {\n    if (taxidInit) {\n      taxids = [ideo.config.taxid];\n    }\n    ideo.config.taxids = taxids;\n  }\n  callback(taxids);\n}\n\n/**\n * Returns an array of taxids for the current ideogram\n * Also sets configuration parameters related to taxid(s), whether ideogram is\n * multiorganism, and adjusts chromosomes parameters as needed\n **/\nfunction getTaxids(callback) {\n  var taxidInit,\n    ideo = this;\n\n  taxidInit = 'taxid' in ideo.config;\n\n  ideo.config.multiorganism = getIsMultiorganism(taxidInit, ideo);\n\n  if (ideo.config.multiorganism) ideo.coordinateSystem = 'bp';\n\n  if ('organism' in ideo.config) {\n    const org = ideo.config.organism;\n    if (typeof org === 'string') {\n      // Canonicalize e.g. \"Homo sapiens\" to \"homo-sapiens\"\n      ideo.config.organism = slug(org.toLowerCase());\n    }\n\n    getTaxidsForOrganismsInConfig(callback, ideo);\n  } else {\n    getTaxidsForOrganismsNotInConfig(taxidInit, callback, ideo);\n  }\n}\n\nexport {\n  getTaxids, getOrganismFromEutils\n};\n","import {d3} from '../lib';\nimport {\n  esearch, esummary, elink, getAssemblySearchUrl\n} from './eutils-config.js';\nimport {\n  getTaxids, getOrganismFromEutils\n} from './organisms.js';\n\n/**\n * Get a URL to ESearch the NCBI Nucleotide DB for an Assembly UID\n */\nfunction getESearchUrlForChromosomes(asmUid, ideo) {\n  var qs;\n\n  // Get a list of IDs for the chromosomes in this genome.\n  //\n  // Query chromosomes sequences in Nucleotide DB (nuccore) via\n  // Assembly DB E-Utils link.\n  qs = ('&db=nuccore&dbfrom=assembly&linkname=assembly_nuccore&' +\n    'cmd=neighbor_history&from_uid=' + asmUid);\n\n  return d3.json(ideo.elink + qs)\n    .then(function(data) {\n      var webenv = data.linksets[0].webenv;\n      qs =\n        '&db=nuccore' +\n        '&term=%231+AND+%28' +\n          'sequence_from_chromosome[Properties]+OR+' +\n          'sequence_from_plastid[Properties]+OR+' +\n          'sequence_from_mitochondrion[Properties]%29' +\n        '&WebEnv=' + webenv + '&usehistory=y&retmax=1000';\n      return ideo.esearch + qs;\n    });\n}\n\n/**\n * Request basic data on a list of chromosome IDs from ESearch\n */\nfunction fetchNucleotideSummary(data, ideo) {\n  var ids, ntSummary;\n  ids = data.esearchresult.idlist.join(',');\n  ntSummary = ideo.esummary + '&db=nucleotide&id=' + ids;\n  return d3.json(ntSummary);\n}\n\n/**\n * Get name and type for mitochondrial chromosome\n *\n * See example of \"MT\" in yeast:\n * https://eweitz.github.io/ideogram/eukaryotes?org=saccharomyces-cerevisiae\n */\nfunction parseMitochondrion(result, ideo) {\n  var type, cnIndex, chrName;\n\n  if (ideo.config.showNonNuclearChromosomes) {\n    type = result.genome;\n    cnIndex = result.subtype.split('|').indexOf('plasmid');\n    if (cnIndex === -1) {\n      chrName = 'MT';\n    } else {\n      // Seen in e.g. rice genome IRGSP-1.0 (GCF_001433935.1),\n      // From https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?retmode=json&db=nucleotide&id=996703432,996703431,996703430,996703429,996703428,996703427,996703426,996703425,996703424,996703423,996703422,996703421,194033210,11466763,7524755\n      // genome: 'mitochondrion',\n      // subtype: 'cell_line|plasmid',\n      // subname: 'A-58 CMS|B1',\n      chrName = result.subname.split('|')[cnIndex];\n    }\n  } else {\n    return [null, null];\n  }\n\n  return [chrName, type];\n}\n\n/**\n * Get name and type for chloroplastic chromosome.\n *\n * Plants have chloroplasts.  See e.g. green algae:\n * https://eweitz.github.io/ideogram/eukaryotes?org=micromonas-commoda\n */\nfunction parseChloroplastOrPlastid(ideo) {\n  // Plastid encountered with rice genome IRGSP-1.0 (GCF_001433935.1)\n  if (ideo.config.showNonNuclearChromosomes) {\n    return ['CP', 'chloroplast'];\n  }\n  return [null, null];\n}\n\n/**\n * Get name and type for apicoplast chromosome\n *\n * Plasmodium falciparum (malaria parasite) has such a chromosome, see e.g.:\n * https://eweitz.github.io/ideogram/eukaryotes?org=plasmodium-falciparum\n */\nfunction parseApicoplast(ideo) {\n  if (ideo.config.showNonNuclearChromosomes) {\n    return ['AP', 'apicoplast'];\n  }\n  return [null, null];\n}\n\n/**\n * Get name and type for nuclear chromosome\n *\n * These are typical chromosomes, like chromosome 1.\n */\nfunction parseNuclear(result) {\n  var type, cnIndex, chrName;\n\n  type = 'nuclear';\n  cnIndex = result.subtype.split('|').indexOf('chromosome');\n  chrName = result.subname.split('|')[cnIndex];\n\n  if (typeof chrName !== 'undefined' && chrName.substr(0, 3) === 'chr') {\n    // Convert \"chr12\" to \"12\", e.g. for banana (GCF_000313855.2)\n    chrName = chrName.substr(3);\n  }\n\n  return [chrName, type];\n}\n\n/**\n * Get name and type of any chromosome object from NCBI Nucleotide ESummary\n */\nfunction getChrNameAndType(result, ideo) {\n  var genome = result.genome;\n  if (genome === 'mitochondrion') {\n    return parseMitochondrion(result, ideo);\n  } else if (genome === 'chloroplast' || genome === 'plastid') {\n    return parseChloroplastOrPlastid(ideo);\n  } else if (genome === 'apicoplast') {\n    return parseApicoplast(ideo);\n  } else {\n    return parseNuclear(result);\n  }\n}\n\nfunction parseChromosome(result, ideo) {\n  var chrName, type, chromosome;\n\n  [chrName, type] = getChrNameAndType(result, ideo);\n\n  chromosome = {\n    name: chrName,\n    length: result.slen,\n    type: type\n  };\n\n  return chromosome;\n}\n\nfunction parseChromosomes(results, taxid, ideo) {\n  var x, chromosome, seenChrId, maxLength,\n    seenChrs = {},\n    chromosomes = [];\n\n  for (x in results) {\n    // omit list of result uids\n    if (x === 'uids') continue;\n\n    chromosome = parseChromosome(results[x], ideo);\n    seenChrId = chromosome.name + '_' + chromosome.length;\n    if (chromosome.type !== null && seenChrId in seenChrs === false) {\n      // seenChrs accounts for duplicate chromosomes seen with\n      // pig (Sus scrofa), likely GenBank and RefSeq copies.\n      chromosomes.push(chromosome);\n    }\n\n    seenChrs[seenChrId] = 1;\n  }\n\n  chromosomes = chromosomes.sort(Ideogram.sortChromosomes);\n\n  maxLength = {bp: 0, iscn: 0};\n  chromosomes.forEach(chr => {\n    if (chr.length > maxLength.bp) maxLength.bp = chr.length;\n  });\n  if (maxLength.bp > ideo.maxLength.bp) ideo.maxLength.bp = maxLength.bp;\n  ideo.maxLength[taxid] = maxLength;\n  ideo.coordinateSystem = 'bp';\n\n  return chromosomes;\n}\n\n/**\n * Request ESummary data from an ESearch on a genome assembly\n */\nfunction fetchAssemblySummary(data, ideo) {\n  var asmUid, asmSummaryUrl;\n\n  // NCBI Assembly database's internal identifier (uid) for this assembly\n  asmUid = data.esearchresult.idlist[0];\n  asmSummaryUrl = ideo.esummary + '&db=assembly&id=' + asmUid;\n\n  return d3.json(asmSummaryUrl);\n}\n\n/**\n * Returns assembly accession, as well as names and lengths of chromosomes for\n * an organism's best-known genome assembly, or for a specified assembly.\n *\n * Gets data from NCBI EUtils web API.\n *\n * @param callback Function to call upon completion of this async method\n */\nfunction getAssemblyAndChromosomesFromEutils(taxid, callback) {\n  var assemblyAccession,\n    ideo = this;\n\n  // Search for assembly, then\n  // get summary of that assembly, then\n  // get search URL for chromosomes in that assembly, then\n  // get search results containing chromosome IDs, then\n  // get summaries of each of those chromosome IDs, then\n  // format the chromosome summaries and pass them into callback function.\n  var asmSearchUrl = getAssemblySearchUrl(taxid, ideo);\n  d3.json(asmSearchUrl)\n    .then(function(data) {return fetchAssemblySummary(data, ideo);})\n    .then(function(data) {\n      var asmUid = data.result.uids[0];\n      assemblyAccession = data.result[asmUid];\n      return getESearchUrlForChromosomes(asmUid, ideo);\n    }).then(function(esearchUrl) {return d3.json(esearchUrl);})\n    .then(function(data) {return fetchNucleotideSummary(data, ideo);})\n    .then(function(data) {\n      var chromosomes = parseChromosomes(data.result, taxid, ideo);\n      return callback([assemblyAccession, chromosomes]);\n    }, function(rejectedReason) {\n      console.warn(rejectedReason);\n    });\n}\n\nexport {\n  esearch, esummary, elink, getOrganismFromEutils,\n  getTaxids, getAssemblyAndChromosomesFromEutils\n};\n","/**\n * @fileoverview Methods to show (or hide) cytogenetic banding data\n */\n\nimport {d3} from '../lib';\n\nfunction hideUnshownBandLabels() {\n  var ideo = this;\n  var bandsToShow = ideo.bandsToShow.join(',');\n\n  // Handles edge-case when ideogram consists of one chromosome\n  // that lacks bands in a genome that has bands (e.g. MT in human)\n  if (ideo.bandsToShow.length === 0) return;\n\n  // d3.selectAll resolves to querySelectorAll (QSA).\n  // QSA takes a surprisingly long time to complete,\n  // and scales with the number of selectors.\n  // Most bands are hidden, so we can optimize by\n  // Hiding all bands, then QSA'ing and displaying the\n  // relatively few bands that are shown.\n  d3.selectAll(ideo.selector + ' .bandLabel, .bandLabelStalk')\n    .style('display', 'none');\n  d3.selectAll(bandsToShow).style('display', '');\n}\n\nfunction getPrevRight(prevLabelXRight, prevHiddenBoxIndex, i,\n  textOffsets, chrModel) {\n  var prevTextBoxLeft, prevTextBoxWidth;\n\n  if (prevHiddenBoxIndex !== i) {\n    // This getBoundingClientRect() forces Chrome's\n    // 'Recalculate Style' and 'Layout', which takes 30-40 ms on Chrome.\n    // TODO: This forced synchronous layout would be nice to eliminate.\n    // prevTextBox = texts[i].getBoundingClientRect();\n    // prevLabelXRight = prevTextBox.left + prevTextBox.width;\n\n    // TODO: Account for number of characters in prevTextBoxWidth,\n    // maybe also zoom.\n    prevTextBoxLeft = textOffsets[chrModel.id][i];\n    prevTextBoxWidth = 36;\n\n    prevLabelXRight = prevTextBoxLeft + prevTextBoxWidth;\n  }\n\n  return prevLabelXRight;\n}\n\nfunction updateShown(indexesToShow, overlapRight, left, pad, prevRight, i,\n  isBefore) {\n  var hiddenIndex, doSkip,\n    thisRight = isBefore ? overlapRight : prevRight;\n\n  if (left < pad + thisRight) {\n    overlapRight = prevRight;\n    hiddenIndex = i;\n    doSkip = isBefore;\n  } else {\n    indexesToShow.push(i);\n  }\n\n  return [indexesToShow, overlapRight, hiddenIndex, doSkip];\n}\n\nfunction getIndexesToShow(offsets, chrModel) {\n  var i, hiddenIndex, left, prevRight, doSkip,\n    indexesToShow = [],\n    textsLength = offsets[chrModel.id].length,\n    overlapRight = 0, // Right X coordinate of overlapping label\n    pad = 5; // text padding\n\n  for (i = 0; i < textsLength; i++) {\n    // Ensures band labels don't overlap\n    left = offsets[chrModel.id][i];\n\n    [indexesToShow, overlapRight, hiddenIndex, doSkip] =\n      updateShown(indexesToShow, overlapRight, left, pad, prevRight, i, true);\n    if (doSkip) continue;\n\n    prevRight = getPrevRight(prevRight, hiddenIndex, i, offsets, chrModel);\n\n    [indexesToShow, overlapRight, hiddenIndex, doSkip] =\n      updateShown(indexesToShow, overlapRight, left, pad, prevRight, i, false);\n  }\n\n  return indexesToShow;\n}\n\n/**\n * Sets band labels to display on each chromosome, avoiding label overlap\n */\nfunction setBandsToShow(chrs, textOffsets) {\n  var index, i, j, indexesToShow, chrModel, selectorsToShow, ithLength,\n    ideo = this;\n\n  ideo.bandsToShow = [];\n\n  for (i = 0; i < chrs.length; i++) {\n\n    chrModel = chrs[i];\n\n    indexesToShow = getIndexesToShow(textOffsets, chrModel);\n\n    selectorsToShow = [];\n    ithLength = indexesToShow.length;\n\n    for (j = 0; j < ithLength; j++) {\n      index = indexesToShow[j];\n      selectorsToShow.push('#' + chrModel.id + ' .bsbsl-' + index);\n    }\n\n    ideo.bandsToShow = ideo.bandsToShow.concat(selectorsToShow);\n  }\n}\n\nexport {hideUnshownBandLabels, setBandsToShow};\n","/**\n * @fileoverview Methods to draw cytogenetic bands and their labels\n *\n */\n\nimport {d3} from '../lib';\nimport {hideUnshownBandLabels, setBandsToShow} from './show';\nimport {staticColors, staticGradients} from './styles';\nimport {configuredCss} from './../init/configure';\n\n/**\n * Draws text of cytoband label\n */\nfunction drawBandLabelText(chr, bandsToLabel, chrModel, textOffsets) {\n  var ideo = this,\n    layout = ideo._layout,\n    chrIndex = chrModel.chrIndex;\n\n  chr.selectAll('text')\n    .data(bandsToLabel)\n    .enter()\n    .append('g')\n    .attr('class', function(d, i) {\n      return 'bandLabel bsbsl-' + i;\n    })\n    .attr('transform', function(d) {\n      var transform = layout.getChromosomeBandLabelTranslate(d, chrIndex);\n\n      if (ideo.config.orientation === 'horizontal') {\n        textOffsets[chrModel.id].push(transform.x + 13);\n      } else {\n        textOffsets[chrModel.id].push(transform.y + 6);\n      }\n\n      return transform.translate;\n    })\n    .append('text')\n    .attr('text-anchor', layout.getChromosomeBandLabelAnchor(chrIndex))\n    .text(function(d) {return d.name;});\n\n  return textOffsets;\n}\n\n/**\n * Draws line between cytoband and its text label\n */\nfunction drawBandLabelStalk(chr, bandsToLabel, chrModel, textOffsets) {\n  var ideo = this;\n\n  chr.selectAll('line.bandLabelStalk')\n    .data(bandsToLabel)\n    .enter()\n    .append('g')\n    .attr('class', function(d, i) {\n      return 'bandLabelStalk bsbsl-' + i;\n    })\n    .attr('transform', function(d) {\n      var x, y;\n\n      x = ideo.round(d.px.start + d.px.width / 2);\n      y = -10;\n\n      textOffsets[chrModel.id].push(x + 13);\n\n      return 'translate(' + x + ',' + y + ')';\n    })\n    .append('line')\n    .attr('x1', 0)\n    .attr('y1', ideo._layout.getChromosomeBandTickY1(chrModel.chrIndex))\n    .attr('x2', 0)\n    .attr('y2', ideo._layout.getChromosomeBandTickY2(chrModel.chrIndex));\n}\n\nfunction getChrModels(chromosomes) {\n  var taxid, chr,\n    chrModels = [];\n\n  for (taxid in chromosomes) {\n    for (chr in chromosomes[taxid]) {\n      chrModels.push(chromosomes[taxid][chr]);\n    }\n  }\n\n  return chrModels;\n}\n\n/**\n * Draws text and stalks for cytogenetic band labels.\n *\n * Band labels are text like \"p11.11\".\n * Stalks are small lines that visually connect labels to their bands.\n */\nfunction drawBandLabels(chromosomes) {\n  var i, chr, chrModel, chrModels, bandsToLabel,\n    ideo = this,\n    textOffsets = {};\n\n  chrModels = getChrModels(chromosomes);\n\n  for (i = 0; i < chrModels.length; i++) {\n    chrModel = chrModels[i];\n    chr = d3.select(ideo.selector + ' #' + chrModel.id);\n    textOffsets[chrModel.id] = [];\n\n    // Don't show \"pter\" label for telocentric chromosomes, e.g. mouse\n    bandsToLabel = chrModel.bands.filter(d => d.name !== 'pter');\n\n    textOffsets =\n      ideo.drawBandLabelText(chr, bandsToLabel, chrModel, textOffsets);\n\n    ideo.drawBandLabelStalk(chr, bandsToLabel, chrModel, textOffsets);\n  }\n\n  ideo.setBandsToShow(chrModels, textOffsets);\n}\n\nfunction getStainAndColors(i, colors) {\n  var stain, color1, color2, color3;\n\n  stain = colors[i][0];\n  color1 = colors[i][1];\n  color2 = colors[i][2];\n  color3 = colors[i][3];\n\n  return [stain, color1, color2, color3];\n}\n\nfunction getGradients(colors) {\n  var i, stain, color1, color2, color3,\n    gradients = '';\n\n  for (i = 0; i < colors.length; i++) {\n    [stain, color1, color2, color3] = getStainAndColors(i, colors);\n    gradients +=\n      '<linearGradient id=\"' + stain + '\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">';\n    if (stain === 'gneg') {\n      gradients +=\n        '<stop offset=\"70%\" stop-color=\"' + color2 + '\" />' +\n        '<stop offset=\"95%\" stop-color=\"' + color3 + '\" />' +\n        '<stop offset=\"100%\" stop-color=\"' + color1 + '\" />';\n    } else {\n      gradients +=\n        '<stop offset=\"5%\" stop-color=\"' + color1 + '\" />' +\n        '<stop offset=\"15%\" stop-color=\"' + color2 + '\" />' +\n        '<stop offset=\"60%\" stop-color=\"' + color3 + '\" />';\n    }\n    gradients +=\n      '</linearGradient>';\n  }\n\n  return gradients;\n}\n\n/**\n * Returns SVG gradients that give chromosomes a polished look\n */\nfunction getBandColorGradients() {\n  var css,\n    gradients = '';\n\n  gradients = getGradients(staticColors);\n\n  css = `<style>${configuredCss}</style>`;\n\n  gradients += staticGradients;\n  gradients = '<defs>' + gradients + '</defs>';\n  gradients = css + gradients;\n\n  return gradients;\n}\n\nexport {\n  drawBandLabels, getBandColorGradients, hideUnshownBandLabels, setBandsToShow,\n  drawBandLabelText, drawBandLabelStalk\n};\n","\nfunction getDelimiterTsvLinesAndInit(source, content) {\n  var delimiter, tsvLines, init;\n\n  if (typeof chrBands === 'undefined' && source !== 'native') {\n    delimiter = /\\t/;\n    tsvLines = content.split(/\\r\\n|\\n/);\n    init = 1;\n  } else {\n    delimiter = / /;\n    tsvLines = content;\n    init = 0;\n  }\n\n  return [delimiter, tsvLines, init];\n}\n\nfunction updateChromosomes(chromosomes) {\n  var tmp, i;\n\n  if (chromosomes instanceof Array && typeof chromosomes[0] === 'object') {\n    tmp = [];\n    for (i = 0; i < chromosomes.length; i++) {\n      tmp.push(chromosomes[i].name);\n    }\n    chromosomes = tmp;\n  }\n  return chromosomes;\n}\n\nfunction getLineObject(chr, columns, stain, taxid) {\n  return {\n    chr: chr,\n    bp: {\n      start: parseInt(columns[5], 10),\n      stop: parseInt(columns[6], 10)\n    },\n    iscn: {\n      start: parseInt(columns[3], 10),\n      stop: parseInt(columns[4], 10)\n    },\n    px: {\n      start: -1,\n      stop: -1,\n      width: -1\n    },\n    name: columns[1] + columns[2],\n    stain: stain,\n    taxid: taxid\n  };\n}\n\nfunction getStain(columns) {\n  var stain = columns[7];\n  // For e.g. acen and gvar, columns[8] (density) is undefined\n  if (columns[8]) stain += columns[8];\n  return stain;\n}\n\nfunction updateLines(lines, columns, taxid) {\n  var chr, stain, line;\n\n  chr = columns[0];\n  if (chr in lines === false) lines[chr] = [];\n\n  stain = getStain(columns);\n\n  line = getLineObject(chr, columns, stain, taxid);\n  lines[chr].push(line);\n\n  return lines;\n}\n\n/**\n * Reports if a cytogenetic band should be included in parse results\n *\n * TODO:\n * Normalize ideogram.chromosomes upstream.\n *\n * This function is complex because ideogram.chromosomes is (likely\n * unnecessarily) complex.  The \"ideogram.chromosomes\" object can\n * take many forms depending on the use case, and this results in\n * hard-to-reason-about functions like this.\n *\n * Normalizing ideogram.chromosomes to a common format somewhere upstream\n * would likely make this specific function and Ideogram in general much\n * more maintainable.\n */\nfunction shouldSkipBand(chrs, chr, taxid, ideo) {\n\n  var hasChrs, chrsAreList, chrNotInList, chrsAreObject,\n    innerChrsAreStrings, matchingChrObjs, chrNotInObject,\n    multiorganism = ideo.config.multiorganism;\n\n  hasChrs = typeof chrs !== 'undefined' && chrs !== null;\n  if (!hasChrs) return false;\n\n  chrsAreList = Array.isArray(chrs);\n  chrNotInList = chrsAreList && chrs.indexOf(chr) === -1;\n  chrsAreObject = typeof chrs === 'object';\n\n  if (chrsAreList && !chrsAreObject && chrNotInList) return true;\n\n  if (taxid in chrs === false && multiorganism) return false;\n\n  if (!multiorganism) {\n    // Encountered in single organism when showing subset of all chromosomes,\n    // e.g. only human X and Y as in https://eweitz.github.io/ideogram/homology-basic\n    matchingChrObjs = chrs.filter(thisChr => thisChr === chr);\n    chrNotInObject = matchingChrObjs.length === 0;\n  } else {\n    innerChrsAreStrings = typeof chrs[taxid][0] === 'string';\n    if (innerChrsAreStrings) {\n      chrNotInObject = chrs[taxid].includes(chr) === false;\n    } else {\n      matchingChrObjs = chrs[taxid].filter(thisChr => thisChr.name === chr);\n      chrNotInObject = matchingChrObjs.length === 0;\n    }\n  }\n  return chrNotInObject;\n\n}\n\n/**\n * Parses cytogenetic band data from a TSV file, or, if band data is\n * prefetched, from an array\n *\n * NCBI:\n * #chromosome arm band iscn_start iscn_stop bp_start bp_stop stain density\n * ftp://ftp.ncbi.nlm.nih.gov/pub/gdp/ideogram_9606_GCF_000001305.14_550_V1\n */\nfunction parseBands(taxid, chromosomes, ideo) {\n  var delimiter, tsvLines, columns, chr, i, init, source, content,\n    lines = {};\n\n  content = ideo.bandData[taxid];\n\n  if (Array.isArray(content)) source = 'native';\n\n  chromosomes = updateChromosomes(chromosomes);\n\n  // Destructure assignment fails oddly when transpiled.  2019-05-23\n  var result = getDelimiterTsvLinesAndInit(source, content);\n  delimiter = result[0];\n  tsvLines = result[1];\n  init = result[2];\n\n  for (i = init; i < tsvLines.length; i++) {\n    columns = tsvLines[i].split(delimiter);\n\n    chr = columns[0];\n    if (shouldSkipBand(chromosomes, chr, taxid, ideo)) {\n      // If specific chromosomes are configured, then skip processing all\n      // other fetched chromosomes.\n      continue;\n    }\n\n    lines = updateLines(lines, columns, taxid);\n  }\n\n  return lines;\n}\n\nexport {parseBands};\n","/**\n * @fileoverview Methods for processing chromosome length and banding data.\n *\n * Ideogram.js depicts chromosomes using data on their length, name, and\n * (if dealing with a very well-studied organism) cytogenetic banding data.\n * This file processes cytoband data that comes from biological research\n * institutions.\n *\n * For background on cytogenetic bands and how they are used in genomics, see:\n * https://ghr.nlm.nih.gov/primer/howgeneswork/genelocation\n *\n */\n\nimport {\n  drawBandLabels, getBandColorGradients, hideUnshownBandLabels, setBandsToShow,\n  drawBandLabelText, drawBandLabelStalk\n} from './draw';\nimport {parseBands} from './parse';\nimport {organismMetadata} from '../init/organism-metadata';\n\n/**\n * Gets bands array for given chromosomes, sets ideo.maxLength\n */\nfunction getBandsArray(chromosome, bandsByChr, taxid, ideo) {\n  var bands, chrLength,\n    bandsArray = [];\n\n  bands = bandsByChr[chromosome];\n  bandsArray.push(bands);\n\n  chrLength = {\n    iscn: bands[bands.length - 1].iscn.stop,\n    bp: bands[bands.length - 1].bp.stop\n  };\n\n  if (taxid in ideo.maxLength === false) {\n    ideo.maxLength[taxid] = {bp: 0, iscn: 0};\n  }\n\n  if (chrLength.iscn > ideo.maxLength[taxid].iscn) {\n    ideo.maxLength[taxid].iscn = chrLength.iscn;\n    if (chrLength.iscn > ideo.maxLength.iscn) {\n      ideo.maxLength.iscn = chrLength.iscn;\n    }\n  }\n\n  if (chrLength.bp > ideo.maxLength[taxid].bp) {\n    ideo.maxLength[taxid].bp = chrLength.bp;\n    if (chrLength.bp > ideo.maxLength.bp) {\n      ideo.maxLength.bp = chrLength.bp;\n    }\n  }\n\n  return bandsArray;\n}\n\n/**\n * Updates bandsArray, sets ideo.config.chromosomes and ideo.numChromosomes\n */\nfunction setChrsByTaxidsWithBands(taxid, chrs, bandsArray, ideo) {\n  var bandsByChr, chromosome, k, chrBandsArray;\n\n  bandsByChr = parseBands(taxid, chrs, ideo);\n\n  chrs = Object.keys(bandsByChr).sort(Ideogram.sortChromosomes);\n\n  if (\n    'chromosomes' in ideo.config === false ||\n    ideo.config.chromosomes === null\n  ) {\n    ideo.config.chromosomes = {};\n  }\n  if (chrs.length > 0) {\n    ideo.config.chromosomes[taxid] = chrs.slice();\n  }\n  ideo.numChromosomes += ideo.config.chromosomes[taxid].length;\n\n  for (k = 0; k < chrs.length; k++) {\n    chromosome = chrs[k];\n    chrBandsArray = getBandsArray(chromosome, bandsByChr, taxid, ideo);\n    bandsArray = bandsArray.concat(chrBandsArray);\n  }\n\n  return bandsArray;\n}\n\nfunction setChromosomesByTaxid(taxid, chrs, bandsArray, ideo) {\n  var chr, i;\n\n  if (\n    taxid in ideo.bandData ||\n    taxid in organismMetadata &&\n    ideo.assemblyIsAccession() === false\n  ) {\n    bandsArray = setChrsByTaxidsWithBands(taxid, chrs, bandsArray, ideo);\n  } else {\n    // If lacking band-level data\n    ideo.numChromosomes += chrs.length;\n\n    for (i = 0; i < chrs.length; i++) {\n      chr = chrs[i];\n      if (chr.length > ideo.maxLength.bp) ideo.maxLength.bp = chr.length;\n    }\n  }\n\n  return bandsArray;\n}\n\nfunction reportPerformance(t0, ideo) {\n  var t1 = new Date().getTime();\n  if (ideo.config.debug) {\n    console.log('Time in processBandData: ' + (t1 - t0) + ' ms');\n  }\n}\n\n/**\n * Completes default ideogram initialization by calling downstream functions\n * to process raw band data into full JSON objects, render chromosome and\n * cytoband figures and labels, apply initial graphical transformations,\n * hide overlapping band labels, and execute callbacks defined by client code\n */\nfunction processBandData(taxid) {\n  var bandsArray, chrs,\n    ideo = this,\n    config = ideo.config,\n    t0 = new Date().getTime();\n\n  bandsArray = [];\n\n  if ('chromosomes' in config) {\n    if (config.multiorganism) {\n      // Copy object\n      chrs = config.chromosomes;\n    } else if (taxid in config.chromosomes) {\n      // Copy array by value\n      chrs = config.chromosomes[taxid].slice();\n    } else {\n      // Copy array by value.  Needed for e.g. \"Homology, basic\"\n      chrs = config.chromosomes.slice();\n    }\n  }\n\n  bandsArray = setChromosomesByTaxid(taxid, chrs, bandsArray, ideo);\n\n  reportPerformance(t0, ideo);\n  return [taxid, bandsArray];\n}\n\nexport {\n  drawBandLabels, getBandColorGradients, processBandData,\n  setBandsToShow, hideUnshownBandLabels, drawBandLabelText, drawBandLabelStalk\n};\n","/**\n * @fileoverview Methods to create and handle a brush on a chromosome.\n *\n * Ideogram.js enables users to display a box around part of a chromosome\n * that represents a \"currently selected\" region.  The user can move this\n * box like a sliding window, e.g. by clicking and dragging the mouse.\n *\n * For background, see:\n * https://github.com/d3/d3-brush\n */\n\nimport {d3} from './lib';\n\n/**\n * Custom event handler, fired upon dragging sliding window on chromosome\n */\nfunction onBrushMove() {\n  call(this.onBrushMoveCallback);\n}\n\nfunction onBrushEnd() {\n  call(this.onBrushEndCallback);\n}\n\nfunction setBrush(bpDomain, pxRange, xOffset, width, ideo) {\n  var xScale,\n    length = ideo.config.chrHeight;\n\n  xScale = d3.scaleLinear().domain(bpDomain).range(pxRange);\n\n  ideo.brush = d3.brushX()\n    .extent([[xOffset, 0], [length + xOffset, width]])\n    .on('brush', _onBrushMove)\n    .on('end', _onBrushEnd);\n\n  function _onBrushMove({selection}) {\n    var extent = selection.map(xScale.invert),\n      from = Math.floor(extent[0]),\n      to = Math.ceil(extent[1]);\n\n    ideo.selectedRegion = {from: from, to: to, extent: (to - from)};\n\n    if (ideo.onBrushMoveCallback) {\n      ideo.onBrushMoveCallback();\n    }\n  }\n\n  function _onBrushEnd({selection}) {\n    if (ideo.onBrushEndCallback) {\n      ideo.onBrushEndCallback();\n    }\n  }\n}\n\nfunction getBasePairDomainAndPixelRange(chrModel, xOffset) {\n  var band, i,\n    bpDomain = [1],\n    pxRange = [1],\n    lastBand = chrModel.bands.slice(-1)[0];\n\n  for (i = 0; i < chrModel.bands.length; i++) {\n    band = chrModel.bands[i];\n    bpDomain.push(band.bp.start);\n    pxRange.push(band.px.start + xOffset);\n  }\n\n  bpDomain.push(lastBand.bp.stop - 1);\n  pxRange.push(lastBand.px.stop + xOffset);\n\n  return [bpDomain, pxRange];\n}\n\n/**\n * Account for calls like createBrush('chr1:104325484-119977655')\n */\nfunction refineGenomicCoordinates(chr, from, to) {\n  var nameSplit, fromToSplit;\n\n  // Account for calls like createBrush('chr1:104325484-119977655')\n  nameSplit = chr.split(':');\n  fromToSplit = chr.split('-');\n  if (nameSplit.length > 1 && fromToSplit.length > 1) {\n    chr = nameSplit[0].replace('chr', '');\n    fromToSplit = nameSplit[1].split('-');\n    from = parseInt(fromToSplit[0]);\n    to = parseInt(fromToSplit[1] - 1);\n  }\n\n  return [chr, from, to];\n}\n\nfunction getChrModel(chr, ideo) {\n  var i, cm, chrModel;\n\n  for (i = 0; i < ideo.chromosomesArray.length; i++) {\n    cm = ideo.chromosomesArray[i];\n    if (cm.name === chr) {\n      chrModel = cm;\n      return chrModel;\n    }\n  }\n}\n\nfunction writeBrush(chrModel, from, to, xOffset, width, ideo) {\n  var x0, x1, yTranslate, yOffset;\n\n  x0 = ideo.convertBpToPx(chrModel, from) + xOffset;\n  x1 = ideo.convertBpToPx(chrModel, to) + xOffset;\n\n  yTranslate = ideo._layout.getChromosomeSetYTranslate(0);\n  yOffset = yTranslate + (ideo.config.chrWidth - width) / 2;\n\n  d3.select(ideo.selector).append('g')\n    .attr('class', 'brush')\n    .attr('transform', 'translate(0, ' + yOffset + ')')\n    .call(ideo.brush)\n    .call(ideo.brush.move, [x0, x1]);\n}\n\nfunction setSelectedRegion(from, to, ideo) {\n  // Genomics web UIs are 1-based, fully closed.\n  // I.e. If start = 20 bp and stop = 10 bp, then extent = 11 bp.\n  // Details:\n  // http://genome.ucsc.edu/blog/the-ucsc-genome-browser-coordinate-counting-systems/\n  // https://www.biostars.org/p/84686/\n  var extent = to - from + 1;\n  ideo.selectedRegion = {from: from, to: to, extent: extent};\n}\n\n/**\n * Creates a sliding window along a chromosome\n *\n * @param chr Chromosome name (e.g. 1) or range, e.g. chr1:104325484-119977655\n * @param from Genomic start coordinate in base pairs, e.g. 104325484\n * @param to Genomic end coordinate in base pairs, e.g. 119977655\n */\nfunction createBrush(chr, from, to) {\n  var chrModel, chrLengthBp, bpDomain, pxRange, lastBand,\n    ideo = this,\n    width = ideo.config.chrWidth + 6.5,\n    xOffset = ideo._layout.margin.left;\n\n  [chr, from, to] = refineGenomicCoordinates(chr, from, to);\n\n  chrModel = getChrModel(chr, ideo);\n\n  [bpDomain, pxRange] = getBasePairDomainAndPixelRange(chrModel, xOffset);\n\n  lastBand = chrModel.bands.slice(-1)[0];\n  chrLengthBp = lastBand.bp.stop;\n\n  if (typeof from === 'undefined') from = Math.floor(chrLengthBp / 10);\n  if (typeof to === 'undefined') to = Math.ceil(from * 2);\n\n  setBrush(bpDomain, pxRange, xOffset, width, ideo);\n\n  setSelectedRegion(from, to, ideo);\n  writeBrush(chrModel, from, to, xOffset, width, ideo);\n}\n\nexport {onBrushMove, onBrushEnd, createBrush};\n","/**\n * @fileoverview Allows a click event handler to be attached to the ideogram\n *\n * This works similar to the \"brush\" which allows a region to be selected.\n * The click handler does not allow a region, but a precise location.\n *\n */\n\nimport {d3} from './lib';\n\n/**\n * Custom event handler, fired upon clicks on the chromosome (to change\n * position)\n */\nfunction onCursorMove() {\n  call(this.onCursorMoveCallback);\n}\n\nfunction setCursor(position, bpDomain, pxRange, xOffset, width, ideo) {\n  var xScale;\n\n  xScale = d3.scaleLinear().domain(bpDomain).range(pxRange);\n\n  if (!('rotatable' in ideo.config && ideo.config.rotatable === false)) {\n    console.warn('Using the cursor with rotate is not supported.');\n  }\n\n  var yTranslate = ideo._layout.getChromosomeSetYTranslate(0);\n  var yOffset = yTranslate + (ideo.config.chrWidth - width) / 2;\n\n  // TODO: check if newPosition is valid value (in range)\n\n  var cursorBrush = d3.select(ideo.selector).append('g')\n    .attr('class', 'brush')\n    .attr('transform', 'translate(0, ' + yOffset + ')')\n    .append('rect')\n    .attr('class', 'cursor')\n    .attr('x', xScale(position))\n    .attr('y', 0)\n    .attr('width', 1) // this could be a configuration param\n    .attr('height', 30); // MAGIC NUMBER! need help with this one\n\n  // call the callback for the first time (onLoad)\n  if (ideo.onCursorMove) {\n    ideo.onCursorMoveCallback(position);\n  }\n\n  if (!ideo.setCursorPosition) {\n    ideo.setCursorPosition = function(newPosition) {\n      // TODO: check if newPosition is valid value (in range)\n      cursorBrush.attr('x', xScale(newPosition));\n      if (ideo.onCursorMove) {\n        ideo.onCursorMoveCallback(newPosition);\n      }\n    };\n  }\n\n  d3.selectAll(ideo.selector + ' .chromosome').on('click', function(event) {\n    var x = event.offsetX; // minimum value seems to be 25\n\n    // adjust for screen (6 is a magic number that seems to work)\n    x -=6;\n\n    // move the cursor\n    cursorBrush.attr('x', x);\n\n    // calculate the new position and perform callback\n    var newPosition = Math.floor(xScale.invert(x));\n    if (ideo.onCursorMove) {\n      ideo.onCursorMoveCallback(newPosition);\n    }\n  });\n}\n\nfunction getBasePairDomainAndPixelRange(chrModel, xOffset) {\n  var band, i,\n    bpDomain = [1],\n    pxRange = [1],\n    lastBand = chrModel.bands.slice(-1)[0];\n\n  for (i = 0; i < chrModel.bands.length; i++) {\n    band = chrModel.bands[i];\n    bpDomain.push(band.bp.start);\n    pxRange.push(band.px.start + xOffset);\n  }\n\n  bpDomain.push(lastBand.bp.stop - 1);\n  pxRange.push(lastBand.px.stop + xOffset);\n\n  return [bpDomain, pxRange];\n}\n\nfunction getChrModel(chr, ideo) {\n  var i, cm, chrModel;\n\n  for (i = 0; i < ideo.chromosomesArray.length; i++) {\n    cm = ideo.chromosomesArray[i];\n    if (cm.name === chr) {\n      chrModel = cm;\n      return chrModel;\n    }\n  }\n}\n\n/**\n * Creates a clickable cursor along a chromosome.\n *\n * @param position Genomic start coordinate in base pairs, e.g. 104325484\n */\nfunction createClickCursor(position) {\n  var chrModel, bpDomain,\n    pxRange,\n    ideo = this,\n    width = ideo.config.chrWidth + 6.5, // 6.5 magic number?\n    xOffset = ideo._layout.margin.left;\n\n  if (typeof position === 'undefined') {\n    return false;\n  }\n\n  chrModel = getChrModel(ideo.config.chromosome, ideo);\n  [bpDomain, pxRange] = getBasePairDomainAndPixelRange(chrModel, xOffset);\n\n  // call setCursor to complete the job.\n  setCursor(position, bpDomain, pxRange, xOffset, width, ideo);\n}\n\nexport {onCursorMove, createClickCursor};\n","/**\n * @fileoverview Instance methods for sex chromosomes (allosomes).\n *\n * This module provides methods for drawing karyotypically normal\n * male and female mammalian genomes.\n */\n\n/**\n * Appends SVG elements depicting sex chromosomes to the document.\n */\nfunction drawSexChromosomes(container, chrIndex) {\n  var bandsArray, taxid, chrs,\n    sexChromosomeIndexes, sciLength,\n    chromosome, bands, chrModel, sci, homologIndex;\n\n  bandsArray = this.bandsArray;\n  taxid = this.config.taxid;\n  chrs = this.config.chromosomes[taxid];\n\n  if (this.config.sex === 'male') {\n    sexChromosomeIndexes = [1, 0];\n  } else {\n    sexChromosomeIndexes = [0, 0];\n  }\n\n  sciLength = sexChromosomeIndexes.length;\n\n  for (homologIndex = 0; homologIndex < sciLength; homologIndex++) {\n    sci = sexChromosomeIndexes[homologIndex] + chrIndex;\n    chromosome = chrs[sci];\n    bands = bandsArray[taxid][sci];\n    chrModel = this.getChromosomeModel(bands, chromosome, taxid, sci);\n    this.appendHomolog(chrModel, chrIndex, homologIndex, container);\n  }\n}\n\n/**\n * Sets instance properties regarding sex chromosomes.\n * Currently only supported for mammals.\n * TODO: Support all sexually reproducing taxa\n *   XY sex-determination (mammals):\n *     - Male: XY <- heterogametic\n *     - Female: XX\n *   ZW sex-determination (birds):\n *     - Male: ZZ\n *     - Female: ZW <- heterogametic\n *   X0 sex-determination (some insects):\n *     - Male: X0, i.e. only X <- heterogametic?\n *     - Female: XX\n * TODO: Support sex chromosome aneuploidies in mammals\n *     - Turner syndrome: X0\n *     - Klinefelter syndome: XXY\n *  More types:\n *  https://en.wikipedia.org/wiki/Category:Sex_chromosome_aneuploidies\n */\nfunction setSexChromosomes(chrs) {\n  var chr, i,\n    ideo = this,\n    sexChrs = {X: 1, Y: 1};\n\n  if (this.config.ploidy !== 2 || !this.config.sex) return;\n\n  ideo.sexChromosomes.list = [];\n\n  for (i = 0; i < chrs.length; i++) {\n    chr = chrs[i];\n    if (ideo.config.sex === 'male' && chr in sexChrs) {\n      ideo.sexChromosomes.list.push(chr);\n      if (!ideo.sexChromosomes.index) {\n        ideo.sexChromosomes.index = i;\n      }\n    } else if (chr === 'X') {\n      ideo.sexChromosomes.list.push(chr, chr);\n      ideo.sexChromosomes.index = i;\n    }\n  }\n}\n\nexport {drawSexChromosomes, setSexChromosomes};\n","/**\n * @fileoverview Methods to convert to and from different types of coordinates.\n *\n * Ideogram.js uses multiple coordinate systems, e.g. base pairs (bp) and\n * pixels (px).  These methods interconvert between those coordinate systems.\n *\n * TODO:\n * - Add methods to interconvert between ISCN coordinates and base pairs,\n * pixels.\n */\n\nfunction throwBpToPxError(bp, chr, band) {\n  throw new Error(\n    'Base pair out of range.  ' +\n    'bp: ' + bp + '; length of chr' + chr.name + ': ' + band.bp.stop\n  );\n}\n\nfunction getPx(chr, bp) {\n  var i, px, band, bpToIscnScale, iscn, iscnStart, iscnStop, iscnLength,\n    bpStart, bpStop, bpLength, pxStart, pxLength;\n\n  for (i = 0; i < chr.bands.length; i++) {\n    band = chr.bands[i];\n    bpStart = band.bp.start;\n    bpStop = band.bp.stop;\n    bpLength = bpStop - bpStart;\n    iscnStart = band.iscn.start;\n    iscnStop = band.iscn.stop;\n    iscnLength = iscnStop - iscnStart;\n    pxStart = band.px.start;\n    pxLength = band.px.width;\n\n    if (bp >= bpStart && bp <= bpStop) {\n      bpToIscnScale = iscnLength / bpLength;\n      iscn = iscnStart + (bp - bpStart) * bpToIscnScale;\n      px = pxStart + (pxLength * (iscn - iscnStart) / (iscnLength));\n\n      return [px, band];\n    }\n  }\n  return [null, band];\n}\n\n/**\n * Converts base pair coordinates to pixel offsets.\n * Bp-to-pixel scales differ among cytogenetic bands.\n *\n * For example, if we want to depict a gene on a chromosome, then we need\n * to convert the gene's location in base pairs to a location in pixels offset\n * from the start of the chromosome.\n */\nfunction convertBpToPx(chr, bp) {\n  var band, px;\n\n  if (chr.bands.length > 1 || chr.name === 'MT') {\n    [px, band] = getPx(chr, bp);\n    if (px !== null) return px;\n  } else if (bp >= 1 && bp <= chr.length) {\n    px = chr.scale.bp * bp;\n    return px;\n  }\n\n  throwBpToPxError(bp, chr, band);\n}\n\nfunction throwPxToBpError(px, chr, pxStop) {\n  throw new Error(\n    'Pixel out of range.  ' +\n    'px: ' + px + '; length of chr' + chr.name + ': ' + pxStop\n  );\n}\n\nfunction getBp(iscnStop, iscnStart, px, pxStop, pxStart, band, iscnLength) {\n  var pxLength, bpLength, pxToIscnScale, iscn, bp;\n\n  iscnLength = iscnStop - iscnStart;\n  pxLength = pxStop - pxStart;\n  bpLength = band.bp.stop - band.bp.start;\n\n  pxToIscnScale = iscnLength / pxLength;\n  iscn = iscnStart + (px - pxStart) * pxToIscnScale;\n\n  bp = band.bp.start + (bpLength * (iscn - iscnStart) / iscnLength);\n\n  return Math.round(bp);\n}\n\n/**\n * Converts pixel offsets to base pair coordinates.\n * Pixel-to-bp scales differ among cytogenetic bands.\n *\n * For example, if we want to determine the genomic location a user clicked on\n * (e.g. when creating a brush / sliding window region), then we need to\n * convert pixels to base pairs.\n */\nfunction convertPxToBp(chr, px) {\n  var i, band, bp, pxStart, pxStop, iscnStart, iscnStop, iscnLength;\n\n  if (px === 0) {\n    px = chr.bands[0].px.start;\n  }\n\n  for (i = 0; i < chr.bands.length; i++) {\n    band = chr.bands[i];\n\n    pxStart = band.px.start;\n    pxStop = band.px.stop;\n    iscnStart = band.iscn.start;\n    iscnStop = band.iscn.stop;\n\n    if (px >= pxStart && px <= pxStop) {\n      bp = getBp(iscnStop, iscnStart, px, pxStop, pxStart, band, iscnLength);\n      return bp;\n    }\n  }\n  throwPxToBpError(px, chr, pxStop);\n}\n\nexport {convertBpToPx, convertPxToBp};\n","let array8 = arrayUntyped,\n    array16 = arrayUntyped,\n    array32 = arrayUntyped,\n    arrayLengthen = arrayLengthenUntyped,\n    arrayWiden = arrayWidenUntyped;\nif (typeof Uint8Array !== \"undefined\") {\n  array8 = function(n) { return new Uint8Array(n); };\n  array16 = function(n) { return new Uint16Array(n); };\n  array32 = function(n) { return new Uint32Array(n); };\n\n  arrayLengthen = function(array, length) {\n    if (array.length >= length) return array;\n    var copy = new array.constructor(length);\n    copy.set(array);\n    return copy;\n  };\n\n  arrayWiden = function(array, width) {\n    var copy;\n    switch (width) {\n      case 16: copy = array16(array.length); break;\n      case 32: copy = array32(array.length); break;\n      default: throw new Error(\"invalid array width!\");\n    }\n    copy.set(array);\n    return copy;\n  };\n}\n\nfunction arrayUntyped(n) {\n  var array = new Array(n), i = -1;\n  while (++i < n) array[i] = 0;\n  return array;\n}\n\nfunction arrayLengthenUntyped(array, length) {\n  var n = array.length;\n  while (n < length) array[n++] = 0;\n  return array;\n}\n\nfunction arrayWidenUntyped(array, width) {\n  if (width > 32) throw new Error(\"invalid array width!\");\n  return array;\n}\n\n// An arbitrarily-wide array of bitmasks\nfunction bitarray(n) {\n  this.length = n;\n  this.subarrays = 1;\n  this.width = 8;\n  this.masks = {\n    0: 0\n  }\n\n  this[0] = array8(n);\n}\n\nbitarray.prototype.lengthen = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i] = arrayLengthen(this[i], n);\n  }\n  this.length = n;\n};\n\n// Reserve a new bit index in the array, returns {offset, one}\nbitarray.prototype.add = function() {\n  var m, w, one, i, len;\n\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    m = this.masks[i];\n    w = this.width - (32 * i);\n    // isolate the rightmost zero bit and return it as an unsigned int of 32 bits, if NaN or -1, return a 0 \n    one = (~m & (m + 1)) >>> 0;\n\n    if (w >= 32 && !one) {\n      continue;\n    }\n\n    if (w < 32 && (one & (1 << w))) {\n      // widen this subarray\n      this[i] = arrayWiden(this[i], w <<= 1);\n      this.width = 32 * i + w;\n    }\n\n    this.masks[i] |= one;\n\n    return {\n      offset: i,\n      one: one\n    };\n  }\n\n  // add a new subarray\n  this[this.subarrays] = array8(this.length);\n  this.masks[this.subarrays] = 1;\n  this.width += 8;\n  return {\n    offset: this.subarrays++,\n    one: 1\n  };\n};\n\n// Copy record from index src to index dest\nbitarray.prototype.copy = function(dest, src) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i][dest] = this[i][src];\n  }\n};\n\n// Truncate the array to the given length\nbitarray.prototype.truncate = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    for (var j = this.length - 1; j >= n; j--) {\n      this[i][j] = 0;\n    }\n  }\n  this.length = n;\n};\n\n// Checks that all bits for the given index are 0\nbitarray.prototype.zero = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for possibly one\nbitarray.prototype.zeroExcept = function(n, offset, zero) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (i === offset ? this[i][n] & zero : this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for the specified mask.\n// The mask should be an array of the same size as the filter subarrays width.\nbitarray.prototype.zeroExceptMask = function(n, mask) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] & mask[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Checks that only the specified bit is set for the given index\nbitarray.prototype.only = function(n, offset, one) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] != (i === offset ? one : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that only the specified bit is set for the given index except for possibly one other\nbitarray.prototype.onlyExcept = function(n, offset, zero, onlyOffset, onlyOne) {\n  var mask;\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    mask = this[i][n];\n    if (i === offset)\n      mask &= zero;\n    if (mask != (i === onlyOffset ? onlyOne : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport default {\n  array8: arrayUntyped,\n  array16: arrayUntyped,\n  array32: arrayUntyped,\n  arrayLengthen: arrayLengthenUntyped,\n  arrayWiden: arrayWidenUntyped,\n  bitarray: bitarray\n};\n","const filterExact = (bisect, value) => {\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n  };\n}\n\nconst filterRange = (bisect, range) => {\n  var min = range[0],\n      max = range[1];\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n  };\n}\n\nconst filterAll = values => {\n  return [0, values.length];\n}\n\nexport default {\n  filterExact,\n  filterRange,\n  filterAll\n};\n","export default d => {\n  return d;\n};\n","export default () =>  {\n  return null;\n}\n","export default () => {\n  return 0;\n}\n","import identity from './identity';\n\nfunction heap_by(f) {\n\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n        i = (n >>> 1) + 1;\n    while (--i > 0) sift(a, i, n, lo);\n    return a;\n  }\n\n  // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n        t;\n    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    return a;\n  }\n\n  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n        x = f(d),\n        child;\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n    a[lo + i] = d;\n  }\n\n  heap.sort = sort;\n  return heap;\n}\n\nconst h = heap_by(identity);\nh.by = heap_by;\n\nexport default h;\n","import identity from './identity';\nimport xFilterHeap from './heap';\n\nfunction heapselect_by(f) {\n  var heap = xFilterHeap.by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n        min,\n        i,\n        d;\n\n    for (i = 0; i < k; ++i) queue[i] = a[lo++];\n    heap(queue, 0, k);\n\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n\n    return queue;\n  }\n\n  return heapselect;\n}\n\n\nconst h = heapselect_by(identity);\nh.by = heapselect_by; // assign the raw function to the export as well\n\nexport default h;\n","import identity from './identity';\n\nfunction bisect_by(f) {\n\n  // Locate the insertion point for x in a to maintain sorted order. The\n  // arguments lo and hi may be used to specify a subset of the array which\n  // should be considered; by default the entire array is used. If x is already\n  // present in a, the insertion point will be before (to the left of) any\n  // existing entries. The return value is suitable for use as the first\n  // argument to `array.splice` assuming that a is already sorted.\n  //\n  // The returned insertion point i partitions the array a into two halves so\n  // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n  // a[i:hi] for the right side.\n  function bisectLeft(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (f(a[mid]) < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  // Similar to bisectLeft, but returns an insertion point which comes after (to\n  // the right of) any existing entries of x in a.\n  //\n  // The returned insertion point i partitions the array into two halves so that\n  // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n  // a[i:hi] for the right side.\n  function bisectRight(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (x < f(a[mid])) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  bisectRight.right = bisectRight;\n  bisectRight.left = bisectLeft;\n  return bisectRight;\n}\n\nconst bisect = bisect_by(identity);\nbisect.by = bisect_by; // assign the raw function to the export as well\n\nexport default bisect;\n\n","export default (array, index, deep) => {\n  for (var i = 0, n = index.length, copy = deep ? JSON.parse(JSON.stringify(array)) : new Array(n); i < n; ++i) {\n    copy[i] = array[index[i]];\n  }\n  return copy;\n}\n","const reduceIncrement = p => {\n  return p + 1;\n}\n\nconst reduceDecrement = p => {\n  return p - 1;\n}\n\nconst reduceAdd = f => {\n  return function(p, v) {\n    return p + +f(v);\n  };\n}\n\nconst reduceSubtract = f => {\n  return function(p, v) {\n    return p - f(v);\n  };\n}\n\nexport default {\n  reduceIncrement,\n  reduceDecrement,\n  reduceAdd,\n  reduceSubtract\n};\n","export default function(t,e,i,n,r){for(r in n=(i=i.split(\".\")).splice(-1,1),i)e=e[i[r]]=e[i[r]]||{};return t(e,n)};\n//# sourceMappingURL=deepobj.m.js.map\n","import deep from \"@ranfdev/deepobj\"\n// Note(cg): result was previsouly using lodash.result, not ESM compatible.\n \nconst get = (obj, prop) => {\n  const value = obj[prop];\n  return (typeof value === 'function') ? value.call(obj) : value;\n}\n\n/**\n * get value of object at a deep path.\n * if the resolved value is a function,\n * it's invoked with the `this` binding of \n * its parent object and its result is returned. \n *  \n * @param  {Object} obj  the object (e.g. { 'a': [{ 'b': { 'c1': 3, 'c2': 4} }], 'd': {e:1} }; )\n * @param  {String} path deep path (e.g. `d.e`` or `a[0].b.c1`. Dot notation (a.0.b)is also supported)\n * @return {Any}      the resolved value\n */\nconst reg = /\\[([\\w\\d]+)\\]/g;\nexport default (obj, path) => {\n  return deep(get, obj, path.replace(reg, '.$1'))\n}\n","import xfilterArray from './array';\nimport xfilterFilter from './filter';\nimport cr_identity from './identity';\nimport cr_null from './null';\nimport cr_zero from './zero';\nimport xfilterHeapselect from './heapselect';\nimport xfilterHeap from './heap';\nimport bisect from './bisect';\nimport permute from './permute';\nimport xfilterReduce from './reduce';\nimport result from './result';\n\n// constants\nvar REMOVED_INDEX = -1;\n\ncrossfilter.heap = xfilterHeap;\ncrossfilter.heapselect = xfilterHeapselect;\ncrossfilter.bisect = bisect;\ncrossfilter.permute = permute;\nexport default crossfilter;\n\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size,\n    all: all,\n    allFiltered: allFiltered,\n    onChange: onChange,\n    isElementFiltered: isElementFiltered\n  };\n\n  var data = [], // the records\n      n = 0, // the number of records; data.length\n      filters, // 1 is filtered out\n      filterListeners = [], // when the filters change\n      dataListeners = [], // when data is added\n      removeDataListeners = [], // when data is removed\n      callbacks = [];\n\n  filters = new xfilterArray.bitarray(0);\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n        n1 = newData.length;\n\n    // If there's actually new data to add\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters.lengthen(n += n1);\n      dataListeners.forEach(function(l) { l(newData, n0, n1); });\n      triggerOnChange('dataAdded');\n    }\n\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters, or if a predicate function is passed,\n  // removes all records matching the predicate (ignoring filters).\n  function removeData(predicate) {\n    var // Mapping from old record indexes to new indexes (after records removed)\n        newIndex = new Array(n),\n        removed = [],\n        usePred = typeof predicate === 'function',\n        shouldRemove = function (i) {\n          return usePred ? predicate(data[i], i) : filters.zero(i)\n        };\n\n    for (var index1 = 0, index2 = 0; index1 < n; ++index1) {\n      if ( shouldRemove(index1) ) {\n        removed.push(index1);\n        newIndex[index1] = REMOVED_INDEX;\n      } else {\n        newIndex[index1] = index2++;\n      }\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function(l) { l(-1, -1, [], removed, true); });\n\n    // Update indexes.\n    removeDataListeners.forEach(function(l) { l(newIndex); });\n\n    // Remove old filters and data by overwriting.\n    for (var index3 = 0, index4 = 0; index3 < n; ++index3) {\n      if ( newIndex[index3] !== REMOVED_INDEX ) {\n        if (index3 !== index4) filters.copy(index4, index3), data[index4] = data[index3];\n        ++index4;\n      }\n    }\n\n    data.length = n = index4;\n    filters.truncate(index4);\n    triggerOnChange('dataRemoved');\n  }\n\n  function maskForDimensions(dimensions) {\n    var n,\n        d,\n        len,\n        id,\n        mask = Array(filters.subarrays);\n    for (n = 0; n < filters.subarrays; n++) { mask[n] = ~0; }\n    for (d = 0, len = dimensions.length; d < len; d++) {\n      // The top bits of the ID are the subarray offset and the lower bits are the bit\n      // offset of the \"one\" mask.\n      id = dimensions[d].id();\n      mask[id >> 7] &= ~(0x1 << (id & 0x3f));\n    }\n    return mask;\n  }\n\n  // Return true if the data element at index i is filtered IN.\n  // Optionally, ignore the filters of any dimensions in the ignore_dimensions list.\n  function isElementFiltered(i, ignore_dimensions) {\n    var mask = maskForDimensions(ignore_dimensions || []);\n    return filters.zeroExceptMask(i,mask);\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value, iterable) {\n\n    if (typeof value === 'string') {\n      var accessorPath = value;\n      value = function(d) { return result(d, accessorPath); };\n    }\n\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      currentFilter: currentFilter,\n      hasCurrentFilter: hasCurrentFilter,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose, // for backwards-compatibility\n      accessor: value,\n      id: function() { return id; }\n    };\n\n    var one, // lowest unset bit as mask, e.g., 00001000\n        zero, // inverted one, e.g., 11110111\n        offset, // offset into the filters arrays\n        id, // unique ID for this dimension (reused when dimensions are disposed)\n        values, // sorted, cached array\n        index, // maps sorted value index -> record index (in data)\n        newValues, // temporary array storing newly-added values\n        newIndex, // temporary array storing newly-added index\n        iterablesIndexCount,\n        iterablesIndexFilterStatus,\n        iterablesEmptyRows = [],\n        sortRange = function(n) {\n          return cr_range(n).sort(function(A, B) {\n            var a = newValues[A], b = newValues[B];\n            return a < b ? -1 : a > b ? 1 : A - B;\n          });\n        },\n        refilter = xfilterFilter.filterAll, // for recomputing filter\n        refilterFunction, // the custom filter function in use\n        filterValue, // the value used for filtering (value, array, function or undefined)\n        filterValuePresent, // true if filterValue contains something\n        indexListeners = [], // when data is added\n        dimensionGroups = [],\n        lo0 = 0,\n        hi0 = 0,\n        t = 0,\n        k;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n\n    removeDataListeners.push(removeData);\n\n    // Add a new dimension in the filter bitmap and store the offset and bitmask.\n    var tmp = filters.add();\n    offset = tmp.offset;\n    one = tmp.one;\n    zero = ~one;\n\n    // Create a unique ID for the dimension\n    // IDs will be re-used if dimensions are disposed.\n    // For internal use the ID is the subarray offset shifted left 7 bits or'd with the\n    // bit offset of the set bit in the dimension's \"one\" mask.\n    id = (offset << 7) | (Math.log(one) / Math.log(2));\n\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n      var newIterablesIndexCount,\n          newIterablesIndexFilterStatus;\n\n      if (iterable){\n        // Count all the values\n        t = 0;\n        j = 0;\n        k = [];\n\n        for (var i0 = 0; i0 < newData.length; i0++) {\n          for(j = 0, k = value(newData[i0]); j < k.length; j++) {\n            t++;\n          }\n        }\n\n        newValues = [];\n        newIterablesIndexCount = cr_range(newData.length);\n        newIterablesIndexFilterStatus = cr_index(t,1);\n        var unsortedIndex = cr_range(t);\n\n        for (var l = 0, index1 = 0; index1 < newData.length; index1++) {\n          k = value(newData[index1])\n          //\n          if(!k.length){\n            newIterablesIndexCount[index1] = 0;\n            iterablesEmptyRows.push(index1 + n0);\n            continue;\n          }\n          newIterablesIndexCount[index1] = k.length\n          for (j = 0; j < k.length; j++) {\n            newValues.push(k[j]);\n            unsortedIndex[l] = index1;\n            l++;\n          }\n        }\n\n        // Create the Sort map used to sort both the values and the valueToData indices\n        var sortMap = sortRange(t);\n\n        // Use the sortMap to sort the newValues\n        newValues = permute(newValues, sortMap);\n\n\n        // Use the sortMap to sort the unsortedIndex map\n        // newIndex should be a map of sortedValue -> crossfilterData\n        newIndex = permute(unsortedIndex, sortMap)\n\n      } else{\n        // Permute new values into natural order using a standard sorted index.\n        newValues = newData.map(value);\n        newIndex = sortRange(n1);\n        newValues = permute(newValues, newIndex);\n      }\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1];\n\n      var index2, index3, index4;\n      if(iterable) {\n        n1 = t;\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              if(--newIterablesIndexCount[newIndex[index2]] === 0) {\n                filters[offset][newIndex[index2] + n0] |= one;\n              }\n              newIterablesIndexFilterStatus[index2] = 1;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            if(--newIterablesIndexCount[newIndex[index3]] === 0) {\n              filters[offset][newIndex[index3] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index3] = 1;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            if(--newIterablesIndexCount[newIndex[index4]] === 0) {\n              filters[offset][newIndex[index4] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index4] = 1;\n          }\n        }\n      } else {\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              filters[offset][newIndex[index2] + n0] |= one;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            filters[offset][newIndex[index3] + n0] |= one;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            filters[offset][newIndex[index4] + n0] |= one;\n          }\n        }\n      }\n\n      // If this dimension previously had no data, then we don't need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        iterablesIndexCount = newIterablesIndexCount;\n        iterablesIndexFilterStatus = newIterablesIndexFilterStatus;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n\n\n\n      var oldValues = values,\n        oldIndex = index,\n        oldIterablesIndexFilterStatus = iterablesIndexFilterStatus,\n        old_n0,\n        i1 = 0;\n\n      i0 = 0;\n\n      if(iterable){\n        old_n0 = n0\n        n0 = oldValues.length;\n        n1 = t\n      }\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = iterable ? new Array(n0 + n1) : new Array(n);\n      index = iterable ? new Array(n0 + n1) : cr_index(n, n);\n      if(iterable) iterablesIndexFilterStatus = cr_index(n0 + n1, 1);\n\n      // Concatenate the newIterablesIndexCount onto the old one.\n      if(iterable) {\n        var oldiiclength = iterablesIndexCount.length;\n        iterablesIndexCount = xfilterArray.arrayLengthen(iterablesIndexCount, n);\n        for(var j=0; j+oldiiclength < n; j++) {\n          iterablesIndexCount[j+oldiiclength] = newIterablesIndexCount[j];\n        }\n      }\n\n      // Merge the old and new sorted values, and old and new index.\n      var index5 = 0;\n      for (; i0 < n0 && i1 < n1; ++index5) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[index5] = oldValues[i0];\n          if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n          index[index5] = oldIndex[i0++];\n        } else {\n          values[index5] = newValues[i1];\n          if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n          index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++index5) {\n        values[index5] = oldValues[i0];\n        if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n        index[index5] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++index5) {\n        values[index5] = newValues[i1];\n        if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n        index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\n      newValues = newIndex = null;\n    }\n\n    function removeData(reIndex) {\n      if (iterable) {\n        for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {\n          if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {\n            iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];\n            i1++;\n          }\n        }\n        iterablesEmptyRows.length = i1;\n        for (i0 = 0, i1 = 0; i0 < n; i0++) {\n          if (reIndex[i0] !== REMOVED_INDEX) {\n            if (i1 !== i0) iterablesIndexCount[i1] = iterablesIndexCount[i0];\n            i1++;\n          }\n        }\n        iterablesIndexCount = iterablesIndexCount.slice(0, i1);\n      }\n      // Rewrite our index, overwriting removed values\n      var n0 = values.length;\n      for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {\n        oldDataIndex = index[i];\n        if (reIndex[oldDataIndex] !== REMOVED_INDEX) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[oldDataIndex];\n          if (iterable) {\n            iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];\n          }\n          ++j;\n        }\n      }\n      values.length = j;\n      if (iterable) iterablesIndexFilterStatus = iterablesIndexFilterStatus.slice(0, j);\n      while (j < n0) index[j++] = 0;\n\n      // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n\n      var lo1 = bounds[0],\n          hi1 = bounds[1];\n\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; }, bounds[0] === 0 && bounds[1] === values.length);\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n\n      var i,\n          j,\n          k,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [];\n\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      if(!iterable) {\n        // Flip filters normally.\n\n        for(i=0; i<added.length; i++) {\n          filters[offset][added[i]] ^= one;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          filters[offset][removed[i]] ^= one;\n        }\n\n      } else {\n        // For iterables, we need to figure out if the row has been completely removed vs partially included\n        // Only count a row as added if it is not already being aggregated. Only count a row\n        // as removed if the last element being aggregated is removed.\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          iterablesIndexCount[added[i]]++\n          iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n          if(iterablesIndexCount[added[i]] === 1) {\n            filters[offset][added[i]] ^= one;\n            newAdded.push(added[i]);\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          iterablesIndexCount[removed[i]]--\n          iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n          if(iterablesIndexCount[removed[i]] === 0) {\n            filters[offset][removed[i]] ^= one;\n            newRemoved.push(removed[i]);\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(refilter === xfilterFilter.filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null\n          ? filterAll() : Array.isArray(range)\n          ? filterRange(range) : typeof range === \"function\"\n          ? filterFunction(range)\n          : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      filterValue = value;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      filterValue = range;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      filterValue = undefined;\n      filterValuePresent = false;\n      return filterIndexBounds((refilter = xfilterFilter.filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      filterValue = f;\n      filterValuePresent = true;\n      \n      refilterFunction = f;\n      refilter = xfilterFilter.filterAll;\n\n      filterIndexFunction(f, false);\n\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n\n      return dimension;\n    }\n\n    function filterIndexFunction(f, filterAll) {\n      var i,\n          k,\n          x,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [],\n          indexLength = values.length;\n\n      if(!iterable) {\n        for (i = 0; i < indexLength; ++i) {\n          if (!(filters[offset][k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n            if (x) added.push(k);\n            else removed.push(k);\n          }\n        }\n      }\n\n      if(iterable) {\n        for(i=0; i < indexLength; ++i) {\n          if(f(values[i], i)) {\n            added.push(index[i]);\n            valueIndexAdded.push(i);\n          } else {\n            removed.push(index[i]);\n            valueIndexRemoved.push(i);\n          }\n        }\n      }\n\n      if(!iterable) {\n        for(i=0; i<added.length; i++) {\n          if(filters[offset][added[i]] & one) filters[offset][added[i]] &= zero;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          if(!(filters[offset][removed[i]] & one)) filters[offset][removed[i]] |= one;\n        }\n      } else {\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          // First check this particular value needs to be added\n          if(iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {\n            iterablesIndexCount[added[i]]++\n            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n            if(iterablesIndexCount[added[i]] === 1) {\n              filters[offset][added[i]] ^= one;\n              newAdded.push(added[i]);\n            }\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          // First check this particular value needs to be removed\n          if(iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {\n            iterablesIndexCount[removed[i]]--\n            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n            if(iterablesIndexCount[removed[i]] === 0) {\n              filters[offset][removed[i]] ^= one;\n              newRemoved.push(removed[i]);\n            }\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n    }\n    \n    function currentFilter() {\n      return filterValue;\n    }\n    \n    function hasCurrentFilter() {\n      return filterValuePresent;\n    }\n\n    // Returns the top K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function top(k, top_offset) {\n      var array = [],\n          i = hi0,\n          j,\n          toSkip = 0;\n\n      if(top_offset && top_offset > 0) toSkip = top_offset;\n\n      while (--i >= lo0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n      }\n\n      if(iterable){\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          // Add row with empty iterable column at the end\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function bottom(k, bottom_offset) {\n      var array = [],\n          i,\n          j,\n          toSkip = 0;\n\n      if(bottom_offset && bottom_offset > 0) toSkip = bottom_offset;\n\n      if(iterable) {\n        // Add row with empty iterable column at the top\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      i = lo0;\n\n      while (i < hi0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n        i++;\n      }\n\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n\n      var groups, // array of {key, value}\n          groupIndex, // object id  group id\n          groupWidth = 8,\n          groupCapacity = capacity(groupWidth),\n          k = 0, // cardinality\n          select,\n          heap,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          update = cr_null,\n          reset = cr_null,\n          resetNeeded = true,\n          groupAll = key === cr_null,\n          n0old;\n\n      if (arguments.length < 1) key = cr_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n\n        if(iterable) {\n          n0old = n0\n          n0 = values.length - newValues.length\n          n1 = newValues.length;\n        }\n\n        var oldGroups = groups,\n            reIndex = iterable ? [] : cr_index(k, groupCapacity),\n            add = reduceAdd,\n            remove = reduceRemove,\n            initial = reduceInitial,\n            k0 = k, // old cardinality\n            i0 = 0, // index of old group\n            i1 = 0, // index of new record\n            j, // object id\n            g0, // old group\n            x0, // old key\n            x1, // new key\n            g, // group to add\n            x; // key of group to add\n\n        // If a reset is needed, we don't need to update the reduce values.\n        if (resetNeeded) add = initial = cr_null;\n        if (resetNeeded) remove = initial = cr_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        if(iterable){\n          groupIndex = k0 ? groupIndex : [];\n        }\n        else{\n          groupIndex = k0 > 1 ? xfilterArray.arrayLengthen(groupIndex, n) : cr_index(n, groupCapacity);\n        }\n\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n\n        // While new keys remain\n        while (i1 < n1) {\n\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            g0 = oldGroups[++i0];\n            if (g0) x0 = g0.key;\n          } else {\n            g = {key: x1, value: initial()}, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n\n          while (x1 <= x) {\n            j = newIndex[i1] + (iterable ? n0old : n0)\n\n\n            if(iterable){\n              if(groupIndex[j]){\n                groupIndex[j].push(k)\n              }\n              else{\n                groupIndex[j] = [k]\n              }\n            }\n            else{\n              groupIndex[j] = k;\n            }\n\n            // Always add new values to groups. Only remove when not in filter.\n            // This gives groups full information on data life-cycle.\n            g.value = add(g.value, data[j], true);\n            if (!filters.zeroExcept(j, offset, zero)) g.value = remove(g.value, data[j], false);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater th1an all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n\n        // Fill in gaps with empty arrays where there may have been rows with empty iterables\n        if(iterable){\n          for (var index1 = 0; index1 < n; index1++) {\n            if(!groupIndex[index1]){\n              groupIndex[index1] = [];\n            }\n          }\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if(k > i0){\n          if(iterable){\n            for (i0 = 0; i0 < n0old; ++i0) {\n              for (index1 = 0; index1 < groupIndex[i0].length; index1++) {\n                groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];\n              }\n            }\n          }\n          else{\n            for (i0 = 0; i0 < n0; ++i0) {\n              groupIndex[i0] = reIndex[groupIndex[i0]];\n            }\n          }\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1 || iterable) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{key: null, value: initial()}];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = cr_null;\n            reset = cr_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if(iterable){\n            k++\n            return\n          }\n          if (++k === groupCapacity) {\n            reIndex = xfilterArray.arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = xfilterArray.arrayWiden(groupIndex, groupWidth);\n            groupCapacity = capacity(groupWidth);\n          }\n        }\n      }\n\n      function removeData(reIndex) {\n        if (k > 1 || iterable) {\n          var oldK = k,\n              oldGroups = groups,\n              seenGroups = cr_index(oldK, oldK),\n              i,\n              i0,\n              j;\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          if (!iterable) {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n                ++j;\n              }\n            }\n          } else {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                groupIndex[j] = groupIndex[i];\n                for (i0 = 0; i0 < groupIndex[j].length; i0++) {\n                  seenGroups[groupIndex[j][i0]] = 1;\n                }\n                ++j;\n              }\n            }\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n\n          if (k > 1 || iterable) {\n            // Reindex the group index using seenGroups to find the new index.\n            if (!iterable) {\n              for (i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n            } else {\n              for (i = 0; i < j; ++i) {\n                for (i0 = 0; i0 < groupIndex[i].length; ++i0) {\n                  groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];\n                }\n              }\n            }\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1 || iterable\n              ? (reset = resetMany, update = updateMany)\n              : k === 1 ? (reset = resetOne, update = updateOne)\n              : reset = update = cr_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var index3 = 0; index3 < n; ++index3) if (reIndex[index3] !== REMOVED_INDEX) return;\n          groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] =\n          update = reset = cr_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateMany(filterOne, filterOffset, added, removed, notFilter) {\n\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            j,\n            k,\n            n,\n            g;\n\n        if(iterable){\n          // Add the added values.\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (filters.zeroExcept(k = added[i], offset, zero)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceAdd(g.value, data[k], false, j);\n              }\n            }\n          }\n\n          // Remove the removed values.\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceRemove(g.value, data[k], notFilter, j);\n              }\n            }\n          }\n          return;\n        }\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateOne(filterOne, filterOffset, added, removed, notFilter) {\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i,\n            j,\n            g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        if(iterable){\n          for (i = 0; i < n; ++i) {\n            for (j = 0; j < groupIndex[i].length; j++) {\n              g = groups[groupIndex[i][j]];\n              g.value = reduceAdd(g.value, data[i], true, j);\n            }\n          }\n          for (i = 0; i < n; ++i) {\n            if (!filters.zeroExcept(i, offset, zero)) {\n              for (j = 0; j < groupIndex[i].length; j++) {\n                g = groups[groupIndex[i][j]];\n                g.value = reduceRemove(g.value, data[i], false, j);\n              }\n            }\n          }\n          return;\n        }\n\n        for (i = 0; i < n; ++i) {\n          g = groups[groupIndex[i]];\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n            g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        for (i = 0; i < n; ++i) {\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension's natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = xfilterHeapselect.by(valueOf);\n        heap = xfilterHeap.by(valueOf);\n        function valueOf(d) { return value(d.value); }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(cr_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        i = dimensionGroups.indexOf(group);\n        if (i >= 0) dimensionGroups.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(cr_null), all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function() { return all()[0].value; };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function(group) { group.dispose(); });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      filters.masks[offset] &= zero;\n      return filterAll();\n    }\n\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n\n      if (resetNeeded) return;\n\n      // Cycle through all the values.\n      for (i = n0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, filterOffset, added, removed, notFilter) {\n      var i,\n          k,\n          n;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (filters.zero(k = added[i])) {\n          reduceValue = reduceAdd(reduceValue, data[k], notFilter);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters.only(k = removed[i], filterOffset, filterOne)) {\n          reduceValue = reduceRemove(reduceValue, data[k], notFilter);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n\n      reduceValue = reduceInitial();\n\n      // Cycle through all the values.\n      for (i = 0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if it is filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i, 1);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i, 1);\n      return group;\n    }\n\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  // Returns the raw row data contained in this crossfilter\n  function all(){\n    return data;\n  }\n\n  // Returns row data with all dimension filters applied, except for filters in ignore_dimensions\n  function allFiltered(ignore_dimensions) {\n    var array = [],\n        i = 0,\n        mask = maskForDimensions(ignore_dimensions || []);\n\n      for (i = 0; i < n; i++) {\n        if (filters.zeroExceptMask(i, mask)) {\n          array.push(data[i]);\n        }\n      }\n\n      return array;\n  }\n\n  function onChange(cb){\n    if(typeof cb !== 'function'){\n      /* eslint no-console: 0 */\n      console.warn('onChange callback parameter must be a function!');\n      return;\n    }\n    callbacks.push(cb);\n    return function(){\n      callbacks.splice(callbacks.indexOf(cb), 1);\n    };\n  }\n\n  function triggerOnChange(eventName){\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](eventName);\n    }\n  }\n\n  return arguments.length\n      ? add(arguments[0])\n      : crossfilter;\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction cr_index(n, m) {\n  return (m < 0x101\n      ? xfilterArray.array8 : m < 0x10001\n      ? xfilterArray.array16\n      : xfilterArray.array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction cr_range(n) {\n  var range = cr_index(n, n);\n  for (var i = -1; ++i < n;) range[i] = i;\n  return range;\n}\n\nfunction capacity(w) {\n  return w === 8\n      ? 0x100 : w === 16\n      ? 0x10000\n      : 0x100000000;\n}\n","export { default } from  './src/index.js';\n","import {d3} from './lib';\nimport crossfilter from 'crossfilter2';\n\n/* Decompresses ideogram's annotations for crossfilter initialization\nBy default, annotations are clustered by chromosome, e.g.\n[\n  {\"chr\": \"1\", \"annots\": [{\"from\": 100, \"to\", 101, \"chr\": \"1\", ...}, ...]},\n  {\"chr\": \"2\", \"annots\": [{\"from\": 500, \"to\", 501, \"chr\": \"2\", ...}, ...]},\n  ...\n]\nThis method flattens that structure to e.g.\n[\n  {\"from\": 100, \"to\": 101, \"chr\": \"1\", ...},\n  ...\n  {\"from\": 500, \"to\": 501, \"chr\": \"2\", ...},\n]\nSee also: packAnnots\n*/\nfunction unpackAnnots() {\n  var chr, annots, i,\n    unpackedAnnots = [],\n    ideo = this,\n    chrs = ideo.annots;\n\n  for (i = 0; i < chrs.length; i++) {\n    chr = chrs[i];\n    annots = chr.annots;\n    unpackedAnnots = unpackedAnnots.concat(annots);\n  }\n\n  return unpackedAnnots;\n}\n\n/*\n  Compresses annots back to default state.  Inverse of unpackAnnots.\n*/\nfunction packAnnots(unpackedAnnots) {\n  var chr, annot, i,\n    annots = [],\n    ideo = this,\n    chrs = ideo.annots;\n\n  for (chr in chrs) {\n    annots.push({chr: chrs[chr].chr, annots: []});\n  }\n\n  for (i = 0; i < unpackedAnnots.length; i++) {\n    annot = unpackedAnnots[i];\n    annots[annot.chrIndex].annots.push(annot);\n  }\n\n  return annots;\n}\n\n/*\n  Initializes crossfilter.  Needed for client-side filtering.\n  More: https://github.com/square/crossfilter/wiki/API-Reference\n*/\nfunction initCrossFilter() {\n  var i, facet,\n    ideo = this,\n    keys = ideo.rawAnnots.keys;\n\n  ideo.unpackedAnnots = ideo.unpackAnnots();\n  ideo.crossfilter = crossfilter(ideo.unpackedAnnots);\n\n  ideo.annotsByFacet = {};\n  ideo.facets = keys.slice(3, keys.length);\n\n  for (i = 0; i < ideo.facets.length; i++) {\n    facet = ideo.facets[i];\n    ideo.annotsByFacet[facet] =\n      ideo.crossfilter.dimension(function(d) {\n        return d[facet];\n      });\n  }\n\n  if ('filterSelections' in ideo) {\n    ideo.filterAnnots(ideo.filterSelections);\n  }\n\n  ideo.filteredAnnots = ideo.annots;\n}\n\nfunction getFilteredResults(selections, ideo) {\n  var fn, i, facet, results, filter,\n    counts = {};\n\n  if (Object.keys(selections).length === 0) {\n    results = ideo.unpackedAnnots;\n  } else {\n    for (i = 0; i < ideo.facets.length; i++) {\n      facet = ideo.facets[i];\n      if (facet in selections) {\n        filter = selections[facet];\n        if (Array.isArray(filter)) {\n          fn = function(d) {\n            // Filter is numeric range\n            if (filter.length === 2) {\n              // [min, max]\n              return filter[0] <= d && d < filter[1];\n            } else if (filter.length === 4) {\n              // [min1, max1, min2, max2]\n              return (\n                filter[0] <= d && d < filter[1] ||\n                filter[2] <= d && d < filter[3]\n              );\n            }\n          };\n        } else {\n          fn = function(d) {\n            // Filter is set of categories\n            return (d in filter);\n          };\n        }\n      } else {\n        fn = null;\n      }\n      ideo.annotsByFacet[facet].filter(fn);\n      counts[facet] = ideo.annotsByFacet[facet].group().top(Infinity);\n    }\n    results = ideo.annotsByFacet[facet].top(Infinity);\n  }\n\n  return [results, counts];\n}\n\n/*\n  Filters annotations based on the given selections.\n  \"selections\" is an object of objects, e.g.\n\n    {\n      \"tissue-type\": {          <-- a facet\n        \"cerebral-cortex\": 1,   <-- a filter; \"1\" means it is selected\n        \"liver\": 1\n      },\n      \"gene-type\": {\n        mirna\": 1\n      }\n    }\n\n  Translation:\n  select where:\n      (tissue-type is cerebral-cortex OR liver) and (gene-type is mirna)\n\n  TODO:\n    * Filter counts\n    * Integrate server-side filtering for very large datasets\n*/\nfunction filterAnnots(selections) {\n  var i, facet, results, counts,\n    t0 = Date.now(),\n    ideo = this;\n\n  ideo.filterSelections = selections;\n  [results, counts] = getFilteredResults(selections, ideo);\n\n  for (i < 0; i < ideo.facets.length; i++) {\n    ideo.annotsByFacet[facet].filterAll(); // clear filters\n  }\n\n  results = ideo.packAnnots(results);\n\n  delete ideo.maxAnnotsPerBar;\n  delete ideo.maxAnnotsPerBarAllChrs;\n\n  ideo.filteredAnnots = results;\n\n  d3.selectAll(ideo.selector + ' polygon.annot').remove();\n  ideo.drawAnnots(results);\n\n  console.log('Time in filterAnnots: ' + (Date.now() - t0) + ' ms');\n\n  return counts;\n}\n\nexport {unpackAnnots, packAnnots, initCrossFilter, filterAnnots};\n","function getPixelAndOtherData(bands, chr, hasBands, ideo) {\n  var i, band, csLength, width, maxLength,\n    pxStop = 0,\n    taxid = chr.id.split('-')[1],\n    cs = ideo.coordinateSystem,\n    chrHeight = ideo.config.chrHeight;\n\n  for (i = 0; i < bands.length; i++) {\n    band = bands[i];\n    csLength = band[cs].stop - band[cs].start;\n\n    // If ideogram is rotated (and thus showing only one chromosome),\n    // then set its width independent of the longest chromosome in this\n    // genome.\n    if (ideo._layout._isRotated) {\n      width = chrHeight * csLength / chr.length;\n    } else {\n      if (ideo.config.chromosomeScale === 'relative') {\n        maxLength = ideo.maxLength[taxid][cs];\n      } else {\n        maxLength = ideo.maxLength[cs];\n      }\n      width = chrHeight * chr.length / maxLength * csLength / chr.length;\n    }\n    bands[i].px = {start: pxStop, stop: pxStop + width, width: width};\n\n    pxStop = bands[i].px.stop;\n\n    if (hasBands && band.stain === 'acen' && band.name[0] === 'p') {\n      chr.pcenIndex = i;\n    }\n  }\n  return [bands, chr, pxStop];\n}\n\n/**\n * TODO:\n * A chromosome-level scale property is likely\n * nonsensical for any chromosomes that have cytogenetic band data.\n * Different bands tend to have ratios between number of base pairs\n * and physical length.\n *\n * However, a chromosome-level scale property is likely\n * necessary for chromosomes that do not have band data.\n *\n * This needs further review.\n */\nfunction getChrScale(chr, hasBands, ideo) {\n  var chrHeight = ideo.config.chrHeight,\n    chrLength = chr.length,\n    maxLength = ideo.maxLength,\n    taxid = chr.id.split('-')[1],\n    scale = {};\n\n  scale.bp = chrHeight / maxLength.bp;\n\n  if (ideo.config.multiorganism === true) {\n    // chr.scale.bp = band.iscn.stop / band.bp.stop;\n    if (ideo.config.chromosomeScale === 'relative') {\n      scale.iscn = chrHeight * chrLength / maxLength[taxid].bp;\n      scale.bp = chrHeight / maxLength[taxid].bp;\n    } else {\n      scale.iscn = chrHeight * chrLength / maxLength.bp;\n    }\n  } else if (hasBands) {\n    scale.iscn = chrHeight / maxLength.iscn;\n  }\n\n  return scale;\n}\n\nfunction getChromosomePixels(chr) {\n  var bands, chrHeight, pxStop, hasBands, maxLength,\n    taxid = chr.id.split('-')[1],\n    ideo = this;\n\n  bands = chr.bands;\n  chrHeight = ideo.config.chrHeight;\n  pxStop = 0;\n  hasBands = (typeof bands !== 'undefined');\n\n  if (hasBands) {\n    [bands, chr, pxStop] = getPixelAndOtherData(bands, chr, hasBands, ideo);\n  } else {\n    if (ideo.config.chromosomeScale === 'relative') {\n      maxLength = ideo.maxLength[taxid][ideo.coordinateSystem];\n    } else {\n      maxLength = ideo.maxLength[ideo.coordinateSystem];\n    }\n    pxStop = chrHeight * chr.length / maxLength;\n  }\n\n  chr.width = pxStop;\n  chr.scale = getChrScale(chr, hasBands, ideo);\n  chr.bands = bands;\n\n  return chr;\n}\n\nfunction getChrModelScaffold(chr, bands, chrName, ideo) {\n  var hasBands = (typeof bands !== 'undefined');\n\n  if (hasBands) {\n    const lastBand = bands.slice(-1)[0];\n    chr.name = chrName;\n    chr.length = lastBand[ideo.coordinateSystem].stop;\n\n    // Accounts for case where this chromosome\n    chr.bpLength = lastBand.bp.stop;\n\n    chr.type = 'nuclear';\n  } else {\n    chr = chrName;\n  }\n\n  return chr;\n}\n\n/**\n * Encountered when processing an assembly that has chromosomes with\n * centromere data, but this chromosome does not.\n * Example: chromosome F1 in Felis catus.\n */\nfunction deleteExtraneousBands(chr, hasBands) {\n  if (hasBands && chr.bands.length === 1) {\n    delete chr.bands;\n  }\n  return chr;\n}\n\nfunction getCentromerePosition(hasBands, bands) {\n\n  if (hasBands === false) return '';\n\n  // As with Macaca mulatta chromosome Y\n  const firstBand = bands[0];\n  const lastBand = bands.slice(-1)[0];\n  const chrLength = lastBand.bp.stop - firstBand.bp.start;\n  const smallLength = chrLength/20;\n\n  if (\n    // As with almost all mouse chromosome, chimpanzee chr22\n    firstBand.name[0] === 'p' && bands[1].name[0] === 'q' &&\n    firstBand.bp.stop - firstBand.bp.start < smallLength\n  ) {\n    return 'telocentric-p';\n  }\n\n  const penultimateBand = bands.slice(-2)[0];\n\n  if (\n    penultimateBand.name[0] === 'p' && lastBand.name[0] === 'q' &&\n    lastBand.bp.stop - lastBand.bp.start < smallLength\n  ) {\n    // As with Macaca mulatta chromosome Y\n    return 'telocentric-q';\n  }\n\n  return '';\n}\n\n/**\n * Generates a model object for each chromosome containing information on\n * its name, DOM ID, length in base pairs or ISCN coordinates, cytogenetic\n * bands, centromere position, etc.\n */\nfunction getChromosomeModel(bands, chrName, taxid, chrIndex) {\n  var hasBands, org,\n    chr = {},\n    ideo = this;\n\n  hasBands = (typeof bands !== 'undefined');\n\n  chr = getChrModelScaffold(chr, bands, chrName, ideo);\n\n  chr.chrIndex = chrIndex;\n  chr.id = 'chr' + chr.name + '-' + taxid;\n\n  if (ideo.config.fullChromosomeLabels === true) {\n    org = this.organisms[taxid];\n    chr.name = org.scientificName + ' chr' + chr.name;\n  }\n\n  chr.bands = bands;\n  chr = ideo.getChromosomePixels(chr);\n  chr.centromerePosition = getCentromerePosition(hasBands, bands);\n\n  chr = deleteExtraneousBands(chr, hasBands);\n\n  return chr;\n}\n\nexport {getChromosomeModel, getChromosomePixels};\n","// import {getSettings, handleSettingsHeaderClick} from './settings-ui';\nimport version from '../version';\nimport {downloadPng} from '../lib';\n\nconst style = `\n  <style>\n\n    #gear {\n      position: absolute;\n      right: 3px;\n      top: 24px;\n      z-index: 8001;\n      cursor: pointer;\n      height: 18px;\n      width: 18px;\n    }\n\n    #tools {\n      position: absolute;\n      width: 120px;\n      right: 27px;\n      top: 16px;\n      z-index: 8000;\n      background: white;\n      margin: 0;\n      border: 1px solid #CCC;\n      border-radius: 4px;\n      box-shadow: -2px 4px 6px #CCC;\n    }\n\n    #tools ul {\n      margin-block-start: 0;\n      margin-block-end: 0;\n      padding-inline-start: 0;\n    }\n\n    #tools li, #download li {\n      padding: 2px 12px 2px 12px;\n      cursor: pointer;\n    }\n\n    #tools li:hover,\n    #tools li.active,\n    #download li:hover {\n      background: #DDD;\n    }\n\n    #tools li.ideo-disabled,\n    #tools li.active.ideo-disabled,\n    #download li.ideo-disabled {\n      background: #FFF;\n      color: #CCC;\n      cursor: default;\n    }\n\n    #download {\n      position: absolute;\n      right: 3px;\n      top: 16px;\n      z-index: 8000;\n      background: white;\n      margin: 0;\n      padding-inline-start: 0;\n    }\n\n    #settings {\n      position: absolute;\n      right: 3px;\n      top: 16px;\n      z-index: 8000;\n      background: white;\n      margin: 0;\n      padding-inline-start: 0;\n    }\n\n    #about {\n      position: absolute;\n      right: 24px;\n      top: -8px;\n      z-index: 8000;\n      background: white;\n      width: 300px;\n      border: 1px solid #CCC;\n      padding: 10px;\n      border-radius: 4px;\n      box-shadow: -2px 4px 6px #CCC;\n      cursor: default;\n    }\n\n    #close {\n      float: right;\n      border: 1px solid #DDD;\n      border-radius: 4px;\n      padding: 0 6px;\n      background: #EEE;\n      font-weight: bold;\n      cursor: pointer;\n    }\n\n    #settings label {\n      display: inline;\n      text-decoration: underline;\n      text-decoration-style: dotted;\n      cursor: pointer;\n    }\n\n    #download {\n      position: absolute;\n      width: 120px;\n      top: -2px;\n      right: 120px;\n      z-index: 8000;\n      background: white;\n      margin: 0;\n      border: 1px solid #CCC;\n      border-radius: 4px;\n      box-shadow: -2px 4px 6px #CCC;\n    }\n\n    li {\n      list-style-type: none;\n    }\n\n    #settings .no-underline {\n      text-decoration: none;\n    }\n\n    #settings .setting {\n      margin-right: 8px;\n    }\n\n    #settings input[type=\"checkbox\"], #settings input[type=\"radio\"] {\n      position: relative;\n      top: 2px;\n    }\n\n    .area-header {\n      font-size: 16px;\n      font-weight: bold;\n      margin-bottom: 10px;\n      clear: both;\n    }\n\n    .area-content {\n      display: flex;\n      flex-wrap: wrap;\n    }\n\n    .area-content > div {\n      margin-right: 30px;\n      margin-bottom: 15px;\n    }\n\n    .tab-panel input[type=\"number\"] {\n      width: 50px;\n    }\n\n    .tab-panel ul {\n      width: 600px;\n      list-style: none;\n      border-bottom: 1px solid #CCC;\n      box-sizing: border-box;\n      margin-bottom: 0;\n      padding-left: 0;\n    }\n\n    .tab-panel .nav:before, .tab-panel .nav:after {\n      content: \" \";\n      display: table;\n      clear: both;\n    }\n\n    .tab-panel li {\n      float: left;\n      margin-right: 2px;\n      display: block;\n      margin-bottom: -1px;\n    }\n\n    .tab-panel li > a {\n      padding: 10px 15px;\n      text-decoration: none;\n      border-radius: 4px 4px 0 0;\n      display: block;\n      position: relative;\n    }\n\n    .tab-panel li.active > a {\n      border: 1px solid #CCC;\n      border-bottom: none;\n      background-color: white;\n    }\n\n    .tab-panel .tab-content {\n      width: 600px;\n    }\n\n    .tab-panel .tab-content > div {\n      display: none;\n      padding-top: 20px;\n      clear: both;\n    }\n\n    .tab-panel .tab-content > div {\n      padding: 20px 10px 5px 10px;\n    }\n\n    .tab-panel .tab-content > div.active {\n      display: block;\n      border: 1px solid #CCC;\n      border-top: none;\n    }\n\n  </style>`;\n\n// eslint-disable-next-line max-len\nconst gearIcon = '<svg viewBox=\"0 0 512 512\"><path fill=\"#AAA\" d=\"M444.788 291.1l42.616 24.599c4.867 2.809 7.126 8.618 5.459 13.985-11.07 35.642-29.97 67.842-54.689 94.586a12.016 12.016 0 0 1-14.832 2.254l-42.584-24.595a191.577 191.577 0 0 1-60.759 35.13v49.182a12.01 12.01 0 0 1-9.377 11.718c-34.956 7.85-72.499 8.256-109.219.007-5.49-1.233-9.403-6.096-9.403-11.723v-49.184a191.555 191.555 0 0 1-60.759-35.13l-42.584 24.595a12.016 12.016 0 0 1-14.832-2.254c-24.718-26.744-43.619-58.944-54.689-94.586-1.667-5.366.592-11.175 5.459-13.985L67.212 291.1a193.48 193.48 0 0 1 0-70.199l-42.616-24.599c-4.867-2.809-7.126-8.618-5.459-13.985 11.07-35.642 29.97-67.842 54.689-94.586a12.016 12.016 0 0 1 14.832-2.254l42.584 24.595a191.577 191.577 0 0 1 60.759-35.13V25.759a12.01 12.01 0 0 1 9.377-11.718c34.956-7.85 72.499-8.256 109.219-.007 5.49 1.233 9.403 6.096 9.403 11.723v49.184a191.555 191.555 0 0 1 60.759 35.13l42.584-24.595a12.016 12.016 0 0 1 14.832 2.254c24.718 26.744 43.619 58.944 54.689 94.586 1.667 5.366-.592 11.175-5.459 13.985L444.788 220.9a193.485 193.485 0 0 1 0 70.2zM336 256c0-44.112-35.888-80-80-80s-80 35.888-80 80 35.888 80 80 80 80-35.888 80-80z\"/></svg>';\n// Font Awesome Free 5.2.0 by @fontawesome - https://fontawesome.com\n// License - https://fontawesome.com/license (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)\n\nfunction deactivate(items) {\n  items.forEach(item => {item.classList.remove('active');});\n}\n\nfunction closeTools() {\n  const toolHeaders = document.querySelectorAll('#tools > ul > li');\n  deactivate(toolHeaders);\n  const itemsToClose =\n    document.querySelectorAll('.ideo-modal, .ideo-tool-panel');\n  itemsToClose.forEach(item => {item.remove();});\n\n  document.querySelector('#tools').style.display = 'none';\n}\n\n/**\n * As needed, hide tool panels that are triggered by hovering\n */\nfunction handleHideForHoverables(trigger, tool, toolHeader, toolHeaders) {\n  if (trigger === 'mouseenter') {\n\n    // Hide panel when hover leaves tool header, if new target element\n    // is part of the tools UI (and not the panel itself)\n    toolHeader.addEventListener('mouseleave', event => {\n      const toElement = event.toElement;\n      const toId = toElement.id;\n      const panelElement = document.querySelector('.ideo-tool-panel');\n      const toolsElement = document.querySelector('#tools');\n      if (\n        toolsElement.contains(toElement) &&\n        panelElement && !panelElement.contains(toElement) &&\n        toId !== tool\n      ) {\n        deactivate(toolHeaders);\n        panelElement.remove();\n      }\n    });\n  }\n}\n\n/** Determine action that should trigger a tool panel to display */\nfunction getTrigger(toolHeader) {\n  const shouldHover =\n    Array.from(toolHeader.classList).includes('ideo-tool-hover');\n  const trigger = shouldHover ? 'mouseenter' : 'click';\n  return trigger;\n}\n\n/** Shows clicked tool as active, displays resulting panel */\nfunction handleToolClick(ideo) {\n  const toolHeaders = document.querySelectorAll('#tools > ul > li');\n\n  toolHeaders.forEach(toolHeader => {\n    const trigger = getTrigger(toolHeader);\n\n    toolHeader.addEventListener(trigger, event => {\n\n      // Show only clicked tool header as active\n      deactivate(toolHeaders);\n      toolHeader.classList += ' active';\n\n      const tool = toolHeader.id.split('-')[0];\n      const panel = getPanel(tool, ideo);\n\n      if (trigger === 'mouseenter') {\n        toolHeader.insertAdjacentHTML('beforeend', panel);\n        handleHideForHoverables(trigger, tool, toolHeader, toolHeaders);\n\n        if (tool === 'download') {\n          document.querySelector('#download-image')\n            .addEventListener('click', event => {\n              closeTools();\n              downloadPng(ideo);\n            });\n\n          document.querySelector('#download-annots')\n            .addEventListener('click', event => {\n              const element = document.querySelector('#download-annots');\n              const classes = Array.from(element.classList);\n              if (classes.includes('ideo-disabled') === false) {\n                closeTools();\n                ideo.downloadAnnotations();\n              }\n            });\n        }\n      } else {\n        document.querySelector('#gear').insertAdjacentHTML('beforeend', panel);\n      }\n    });\n  });\n\n  // Upon clicking \"close\" (x), remove tools UI\n  document.querySelectorAll('#close').forEach(closeButton => {\n    closeButton.addEventListener('click', () => {closeTools();});\n  });\n\n}\n\nfunction handleGearClick(ideo) {\n  document.querySelector('#gear')\n    .addEventListener('click', event => {\n      var options = document.querySelector('#tools');\n      if (options.style.display === 'none') {\n        options.style.display = '';\n        hideOnClickOutside();\n      } else {\n        options.style.display = 'none';\n        closeTools();\n      }\n    });\n\n  handleToolClick(ideo);\n\n  // handleSettingsHeaderClick(ideo);\n}\n\nfunction showGearOnIdeogramHover(ideo) {\n  const container = document.querySelector(ideo.selector);\n  const gear = document.querySelector('#gear');\n  const panel = document.querySelector('#tools');\n\n  container.addEventListener('mouseover', () => gear.style.display = '');\n  container.addEventListener('mouseout', () => {\n    // Hide gear only if panel is not shown\n    if (panel.style.display === 'none') {\n      gear.style.display = 'none';\n    }\n  });\n\n  gear.addEventListener('mouseover', () => gear.style.display = '');\n}\n\nfunction getPanel(tool, ideo) {\n  var panel;\n  // if (tool === 'settings') panel = getSettings();\n  if (tool === 'download') panel = getDownload(ideo);\n  if (tool === 'about') panel = getAbout();\n  return panel.trim();\n}\n\nfunction getDownload(ideo) {\n\n  const numAnnots = document.querySelectorAll('.annot').length;\n  const annotsClass = (numAnnots > 0) ? '' : 'ideo-disabled';\n\n  return `\n    <div id=\"download\" class=\"ideo-tool-panel\">\n      <li id=\"download-image\">Image</li>\n      <li id=\"download-annots\" class=\"${annotsClass}\">Annotations</li>\n    </div>\n  `;\n}\n\nfunction getAbout() {\n  const ideogramLink = `\n    <a href=\"https://github.com/eweitz/ideogram\" target=\"_blank\" rel=\"noopener\">\n      Ideogram.js</a>`;\n  const closeButton = '<span id=\"close\">x</span>';\n  return `\n    <div id=\"about\" class=\"ideo-modal\">\n      ${ideogramLink}, version ${version} ${closeButton}<br/>\n      <i>Chromosome visualization for the web</i>\n    </div>`;\n}\n\nfunction hideOnClickOutside(selector) {\n  const elements = document.querySelectorAll('#gear, #tools');\n  const outsideClickListener = event => {\n    let clickedOutsideCount = 0;\n    elements.forEach((element) => {\n      if (!element.contains(event.target)) {\n        clickedOutsideCount += 1;\n      }\n    });\n    if (clickedOutsideCount === elements.length) {\n      closeTools();\n      removeClickListener();\n    }\n  };\n\n  const removeClickListener = () => {\n    document.removeEventListener('click', outsideClickListener);\n  };\n\n  document.addEventListener('click', outsideClickListener);\n}\n\nfunction initTools(ideo) {\n\n  const triangle = '<span style=\"float: right\">&blacktriangleright;</span>';\n\n  const toolsHtml = `\n    ${style}\n    <div id=\"gear\" style=\"display: none\">${gearIcon}</div>\n    <div id=\"tools\" style=\"display: none\">\n      <ul>\n        <li id=\"download-tool\" class=\"ideo-tool-hover\">Download ${triangle}</li>\n        <li id=\"about-tool\">About</li>\n      </ul>\n    </div>`;\n\n\n  document.querySelector(ideo.selector)\n    .insertAdjacentHTML('beforebegin', toolsHtml);\n\n  handleGearClick(ideo);\n\n  showGearOnIdeogramHover(ideo);\n}\n\nexport {initTools};\n\n","/* eslint-disable no-use-before-define */\n\nexport class ModelAdapter {\n\n  constructor(model) {\n    this._model = model;\n    this._class = 'ModelAdapter';\n  }\n\n  static getInstance(model) {\n    if (model.bands) {\n      return new ModelAdapter(model);\n    } else {\n      return new ModelNoBandsAdapter(model);\n    }\n  }\n\n  getModel() {\n    return this._model;\n  }\n\n  getCssClass() {\n    return '';\n  }\n}\n\nexport class ModelNoBandsAdapter extends ModelAdapter {\n\n  constructor(model) {\n    super(model);\n    this._class = 'ModelNoBandsAdapter';\n  }\n\n  getModel() {\n    this._model.bands = [];\n\n    const isMT = this._model.name === 'MT'; // Is mitochondrial chromosome\n    const width = this._model.width;\n\n    if (width > 1 || isMT) {\n      // Add single band to bands array\n      this._model.bands.push({\n        name: 'q',\n        px: {\n          start: 0,\n          stop: width,\n          width: width\n        },\n        bp: {\n          start: 1,\n          stop: this._model.bpLength ?? this._model.length\n        },\n        iscn: {\n          start: 1,\n          stop: this._model.length\n        }\n      });\n    }\n\n    return this._model;\n  }\n\n  getCssClass() {\n    return 'noBands';\n  }\n\n}\n","import {Ploidy} from './ploidy';\n\nexport class Color {\n\n  constructor(config) {\n    // Ideogram config\n    this._config = config;\n    this._ploidy = new Ploidy(this._config);\n  }\n\n  getArmColor(chrSetIndex, chrIndex, armIndex) {\n    if (this._config.armColors) {\n      return this._config.armColors[armIndex];\n    } else if (this._config.ancestors) {\n      return this._getPolyploidArmColor(chrSetIndex, chrIndex, armIndex);\n    } else {\n      return null;\n    }\n  }\n\n  getBorderColor(chrSetIndex, chrIndex, armIndex) {\n    const config = this._config;\n    const color = config.chrBorderColor ? config.chrBorderColor : '#000';\n    if (chrIndex < config.ploidy) {\n      return color;\n    } else if (this._ploidy.exists(chrSetIndex, chrIndex, armIndex)) {\n      return color;\n    } else {\n      return '#fff';\n    }\n  }\n\n  getFillColor() {\n    const config = this._config;\n    if (!config.chrFillColor) return '#AAA';\n    const color = config.chrFillColor;\n    if (typeof color === 'string') {\n      return {arm: color, centromere: ''};\n    } else {\n      return color;\n    };\n  }\n\n  _getPolyploidArmColor(chrSetIndex, chrIndex, armIndex) {\n    if (!this._ploidy.exists(chrSetIndex, chrIndex, armIndex)) {\n      return 'transparent';\n    } else {\n      var ancestor =\n        this._ploidy.getAncestor(chrSetIndex, chrIndex, armIndex);\n      return this._config.ancestors[ancestor];\n    }\n  }\n\n}\n","export class Range {\n\n  /**\n  * Chromosome range.\n  * @public\n  * @class\n  * @param {Object} data - range data.\n  * @param {Integer} data.chr - chromosome index.\n  * @param {Integer[]} [data.ploidy] - array which controls on which\n  *                                    chromosomes range should appear in case\n  *                                    of ploidy.\n  * @param {Integer} data.start - range start.\n  * @param {Integer} data.stop - range end.\n  * @param {String} data.color - range color.\n  */\n  constructor(data) {\n    this._data = data;\n    this.start = data.start;\n    this.stop = data.stop;\n    this.length = this.stop - this.start;\n  }\n\n  getColor(chrIndex) {\n    if (!('ploidy' in this._data)) {\n      return this._getColor(chrIndex);\n    } else if ('ploidy' in this._data && this._data.ploidy[chrIndex]) {\n      return this._getColor(chrIndex);\n    } else {\n      return 'transparent';\n    }\n  }\n\n  _getColor(chrIndex) {\n    if (Array.isArray(this._data.color)) {\n      return this._data.color[chrIndex];\n    } else {\n      return this._data.color;\n    }\n  }\n\n}\n","/* eslint-disable no-use-before-define */\nimport {Color} from './../color';\nimport {Range} from './../range';\n\nexport class Chromosome {\n\n  constructor(adapter, config, ideo) {\n    this._adapter = adapter;\n    this._model = this._adapter.getModel();\n    this._config = config;\n    this._ideo = ideo;\n    this._color = new Color(this._config);\n    this._bumpCoefficient = 5;\n  }\n\n  /**\n   * Factory method\n   */\n  static getInstance(adapter, config, ideo) {\n    const centromerePosition = adapter.getModel().centromerePosition;\n    if (centromerePosition === 'telocentric-p') {\n      return new TelocentricPChromosome(adapter, config, ideo);\n    } else if (centromerePosition === 'telocentric-q') {\n      return new TelocentricQChromosome(adapter, config, ideo);\n    } else {\n      return new MetacentricChromosome(adapter, config, ideo);\n    }\n  }\n\n  _addPArmShape(clipPath, isPArmRendered) {\n    if (isPArmRendered) {\n      return clipPath.concat(this._getPArmShape());\n    } else {\n      return clipPath;\n    }\n  }\n\n  _addQArmShape(clipPath, isQArmRendered) {\n    if (isQArmRendered) {\n      return clipPath.concat(this._getQArmShape());\n    } else {\n      return clipPath;\n    }\n  }\n\n  /**\n   * Append bands container and apply clip-path to it\n   */\n  render(container, chrSetIndex, chrIndex) {\n\n    var self, isPArmRendered, isQArmRendered, clipPath, opacity, fill,\n      isFullyBanded;\n\n    self = this;\n\n    container = container.append('g')\n      .attr('class', 'bands')\n      .attr('clip-path',\n        'url(#' + this._model.id + '-chromosome-set-clippath)'\n      );\n\n    // Render chromosome arms\n    isPArmRendered = this._renderArm(container, chrSetIndex, chrIndex, 'p');\n    isQArmRendered = this._renderArm(container, chrSetIndex, chrIndex, 'q');\n\n    // Render range set\n    this._renderRangeSet(container, chrSetIndex, chrIndex);\n\n    // Push arms shape string into clipPath array\n    clipPath = [];\n    clipPath = this._addPArmShape(clipPath, isPArmRendered);\n    clipPath = this._addQArmShape(clipPath, isQArmRendered);\n\n    opacity = '0';\n    fill = '';\n    isFullyBanded = this.isFullyBanded();\n    if (\n      'ancestors' in this._ideo.config &&\n      !('rangeSet' in this._ideo.config)\n    ) {\n      // E.g. diploid human genome (with translucent overlay)\n      fill = self._color.getArmColor(chrSetIndex, chrIndex, 0);\n      if (isFullyBanded) {\n        opacity = '0.5';\n      }\n    } else if (isFullyBanded) {\n      // E.g. mouse reference genome\n      opacity = null;\n      fill = 'transparent';\n    } else if (!('ancestors' in this._ideo.config)) {\n      // E.g. chimpanzee assembly Pan_tro 3.0\n      opacity = '1';\n    }\n\n    let centromereFill;\n    if (this._ideo.config.chrFillColor) {\n      const fillColor = self._color.getFillColor();\n      fill = fillColor.arm;\n      centromereFill = fillColor.centromere;\n    }\n\n    // Render chromosome border\n    container.append('g')\n      .attr('class', 'chromosome-border')\n      .selectAll('path')\n      .data(clipPath)\n      .enter()\n      .append('path')\n      .attr('fill', fill)\n      .style('fill-opacity', opacity)\n      .style('fill', function(d) {\n        if (d.class === 'acen' && centromereFill) {\n          return centromereFill;\n        }\n      })\n      .attr('stroke', function(d, i) {\n        return self._color.getBorderColor(chrSetIndex, chrIndex, i);\n      })\n      .attr('stroke-width', function(d) {\n        return ('strokeWidth' in d ? d.strokeWidth : 1);\n      })\n      .attr('d', function(d) {\n        return d.path;\n      }).attr('class', function(d) {\n        return d.class;\n      });\n\n    return clipPath;\n  }\n\n  _renderRangeSet(container, chrSetIndex, chrIndex) {\n\n    var self, rangeSet, rangesContainer, ideo;\n\n    if (!('rangeSet' in this._config)) {\n      return;\n    }\n\n    rangeSet = this._config.rangeSet.filter(function(range) {\n      return range.chr - 1 === chrSetIndex;\n    }).map(function(range) {\n      return new Range(range);\n    });\n\n    rangesContainer = container.append('g').attr('class', 'range-set');\n\n    self = this;\n    ideo = self._ideo;\n\n    rangesContainer.selectAll('rect.range')\n      .data(rangeSet)\n      .enter()\n      .append('rect')\n      .attr('class', 'range')\n      .attr('x', function(range) {\n        return ideo.convertBpToPx(self._model, range.start);\n      }).attr('y', 0)\n      .attr('width', function(range) {\n        return ideo.convertBpToPx(self._model, range.length);\n      }).attr('height', this._config.chrWidth)\n      .style('fill', function(range) {\n        return range.getColor(chrIndex);\n      });\n  }\n\n  /**\n   * Get chromosome's shape main values\n   */\n  _getShapeData() {\n\n    var firstQBand, i, lastBand, rightTerminalPosition;\n\n    // First q band from bands sequence\n    for (i = 0; i < this._model.bands.length; i++) {\n      if (this._model.bands[i].name[0] === 'q') {\n        firstQBand = this._model.bands[i];\n        break;\n      }\n    }\n\n    // Chromosome's right position\n    lastBand = this._model.bands.length - 1;\n    rightTerminalPosition = this._model.bands[lastBand].px.stop;\n\n    // Properties description:\n    // x1 - left terminal start position\n    // x2 - centromere position\n    // x3 - right terminal end position\n    // w - chromosome width\n    // b - bump size\n    return {\n      x1: 0,\n      x2: firstQBand ? firstQBand.px.start : rightTerminalPosition,\n      x3: rightTerminalPosition,\n      w: this._config.chrWidth,\n      b: this._config.chrWidth / this._bumpCoefficient\n    };\n  }\n\n  _getPArmShape() {\n    var d = this._getShapeData(),\n      x = d.x2 - d.b;\n\n    if (this.isFullyBanded() || 'ancestors' in this._ideo.config) {\n      // Encountered when chromosome has any of:\n      //  - One placeholder \"band\", e.g. pig genome GCF_000003025.5\n      //  - Many (> 2) bands, e.g. human reference genome\n      //  - Ancestor colors in ploidy configuration, as in ploidy-basic.html\n      return {\n        class: '',\n        path:\n          'M' + d.b + ',0 ' +\n          'L' + x + ',0 ' +\n          'Q' + (d.x2 + d.b) + ',' + (d.w / 2) + ',' + x + ',' + d.w + ' ' +\n          'L' + d.b + ',' + d.w + ' ' +\n          'Q-' + d.b + ',' + (d.w / 2) + ',' + d.b + ',0'\n      };\n    } else {\n      // e.g. chimpanzee assembly Pan_tro 3.0\n      return [{\n        class: '',\n        path:\n          'M' + d.b + ',0 ' +\n          'L' + (x - 2) + ',0 ' +\n          'L' + (x - 2) + ',' + d.w + ' ' +\n          'L' + d.b + ',' + d.w + ' ' +\n          'Q-' + d.b + ',' + (d.w / 2) + ',' + d.b + ',0'\n      }, {\n        class: 'acen',\n        path:\n          'M' + x + ',0 ' +\n          'Q' + (d.x2 + d.b) + ',' + (d.w / 2) + ',' + x + ',' + d.w + ' ' +\n          'L' + x + ',' + d.w + ' ' +\n          'L' + (x - 2) + ',' + d.w + ' ' +\n          'L' + (x - 2) + ',0'\n      }];\n    }\n  }\n\n  _getQArmShape() {\n    var d = this._getShapeData(),\n      x = d.x3 - d.b,\n      x2b = d.x2 + d.b;\n\n    if (this.isFullyBanded() || 'ancestors' in this._ideo.config) {\n      return {\n        class: '',\n        path:\n          'M' + x2b + ',0 ' +\n          'L' + x + ',0 ' +\n          'Q' + (d.x3 + d.b) + ',' + (d.w / 2) + ',' + x + ',' + d.w + ' ' +\n          'L' + x2b + ',' + d.w + ' ' +\n          'Q' + (d.x2 - d.b) + ',' + (d.w / 2) + ',' + x2b + ',0'\n      };\n    } else {\n      // e.g. chimpanzee assembly Pan_tro 3.0\n      return [{\n        path:\n          'M' + x2b + ',0 ' +\n          'L' + x + ',0 ' +\n          'Q' + (d.x3 + d.b) + ',' + (d.w / 2) + ',' + x + ',' + d.w + ' ' +\n          'L' + x2b + ',' + d.w + ' ' +\n          'L' + x2b + ',0'\n      }, {\n        class: 'acen',\n        path:\n          'M' + x2b + ',0' +\n          'Q' + (d.x2 - d.b) + ',' + (d.w / 2) + ',' + x2b + ',' + d.w + ' ' +\n          'L' + x2b + ',' + d.w +\n          'L' + (x2b + 2) + ',' + d.w +\n          'L' + (x2b + 2) + ',0'\n      }];\n    }\n  }\n\n  isFullyBanded() {\n    return (\n      this._model.bands &&\n      (this._model.bands.length !== 2 || this._model.bands[0].name[0] === 'q')\n    );\n  }\n\n  /**\n   * Render arm bands\n   */\n  _renderBands(container, chrSetIndex, chrIndex, bands, arm) {\n\n    var self, armIndex, fill;\n\n    self = this;\n    armIndex = arm === 'p' ? 0 : 1;\n    fill = '';\n\n    if ('ancestors' in self._ideo.config && !(self.isFullyBanded())) {\n      fill = self._color.getArmColor(chrSetIndex, chrIndex, armIndex);\n    }\n\n    container.selectAll('path.band.' + arm)\n      .data(bands)\n      .enter()\n      .append('path')\n      .attr('id', function(d) {\n        return self._model.id + '-' + d.name.replace('.', '-');\n      })\n      .attr('class', function(d) {\n        return 'band ' + arm + '-band ' + d.stain;\n      })\n      .attr('d', function(d) {\n        var start, length;\n\n        start = self._ideo.round(d.px.start);\n        length = self._ideo.round(d.px.width);\n\n        return 'M ' + start + ', 0' +\n              'l ' + length + ' 0 ' +\n              'l 0 ' + self._config.chrWidth + ' ' +\n              'l -' + length + ' 0 z';\n      })\n      .style('fill', fill);\n  }\n\n  /**\n   * Render a chromosome arm.\n   * Returns boolean indicating if any bands were rendered.\n   */\n  _renderArm(container, chrSetIndex, chrIndex, arm) {\n    var bands = this._model.bands.filter(function(band) {\n      return band.name[0] === arm;\n    });\n\n    this._renderBands(container, chrSetIndex, chrIndex, bands, arm);\n\n    return Boolean(bands.length);\n  }\n}\n\nexport class MetacentricChromosome extends Chromosome {\n\n  constructor(model, config, ideo) {\n    super(model, config, ideo);\n    this._class = 'MetacentricChromosome';\n  }\n}\n\nexport class TelocentricPChromosome extends Chromosome {\n\n  constructor(model, config, ideo) {\n    // alert('p')\n    super(model, config, ideo);\n    this._class = 'TelocentricPChromosome';\n    this._pArmOffset = 3;\n  }\n\n  _addPArmShape(clipPath) {\n    return clipPath.concat(this._getPArmShape());\n  }\n\n  _getPArmShape() {\n    // Properties description:\n    // x1 - left terminal start position\n    // x2 - centromere position\n    // x3 - right terminal end position\n    // w - chromosome width\n    // b - bump size\n    var d = this._getShapeData();\n    d.o = this._pArmOffset;\n\n    return [{\n      class: 'acen',\n      path: 'M' + (d.x2 + 2) + ',1' +\n      'L' + (d.x2 + d.o + 3.25) + ',1 ' +\n      'L' + (d.x2 + d.o + 3.25) + ',' + (d.w - 1) + ' ' +\n      'L' + (d.x2 + 2) + ',' + (d.w - 1)\n    }, {\n      class: 'gpos66',\n      path: 'M' + (d.x2 - d.o + 5) + ',0' +\n      'L' + (d.x2 - d.o + 3) + ',0 ' +\n      'L' + (d.x2 - d.o + 3) + ',' + d.w + ' ' +\n      'L' + (d.x2 - d.o + 5) + ',' + d.w,\n      strokeWidth: 0.5\n    }];\n  }\n\n  _getQArmShape() {\n    // Properties description:\n    // x1 - left terminal start position\n    // x2 - centromere position\n    // x3 - right terminal end position\n    // w - chromosome width\n    // b - bump size\n    var d = this._getShapeData(),\n      x = d.x3 - d.b,\n      o = this._pArmOffset + 3;\n\n    return {\n      class: '',\n      path:\n      'M' + (d.x2 + o) + ',0 ' +\n      'L' + x + ',0 ' +\n      'Q' + (d.x3 + d.b) + ',' + (d.w / 2) + ',' + x + ',' + d.w + ' ' +\n      'L' + (d.x2 + o) + ',' + d.w\n    };\n  }\n}\n\nexport class TelocentricQChromosome extends Chromosome {\n\n  constructor(model, config, ideo) {\n    // alert('q')\n    super(model, config, ideo);\n    this._class = 'TelocentricQChromosome';\n    this._qArmOffset = 3;\n  }\n\n  _getPArmShape() {\n    // Properties description:\n    // x1 - left terminal start position\n    // x2 - centromere position\n    // x3 - right terminal end position\n    // w - chromosome width\n    // b - bump size\n\n    var d = this._getShapeData(),\n      x = d.x3 - d.b,\n      o = this._qArmOffset;\n\n    return {\n      class: '',\n      path:\n      // 'M1,0, ' +\n      'M' + (d.x2 + o) + ',0 ' +\n      'L' + (x + o) + ',0 ' +\n      'L' + (x + o) + ',' + d.w + ' ' +\n      'L' + d.b + ',' + d.w + ' ' +\n      'Q-' + d.b + ',' + (d.w / 2) + ',' + d.b + ',0'\n    };\n  }\n\n  _addQArmShape(clipPath) {\n    return clipPath.concat(this._getQArmShape());\n  }\n\n  _getQArmShape() {\n    // Properties description:\n    // x1 - left terminal start position\n    // x2 - centromere position\n    // x3 - right terminal end position\n    // w - chromosome width\n    // b - bump size\n    var d = this._getShapeData();\n    d.o = this._qArmOffset;\n\n    return [{\n      class: 'acen',\n      path: 'M' + (d.x2 + 2) + ',1 ' +\n      'L' + (d.x2 + d.o + 3.25) + ',1 ' +\n      'L' + (d.x2 + d.o + 3.25) + ',' + (d.w - 1) + ' ' +\n      'L' + (d.x2 + 2) + ',' + (d.w - 1)\n    }, {\n      class: 'gpos66',\n      path: 'M' + (d.x2 + d.o + 5) + ',0 ' +\n      'L' + (d.x2 + d.o + 3) + ',0 ' +\n      'L' + (d.x2 + d.o + 3) + ',' + d.w + ' ' +\n      'L' + (d.x2 + d.o + 5) + ',' + d.w,\n      strokeWidth: 0.5\n    }];\n  }\n}\n","import {d3} from '../lib';\nimport {initTools} from '../tools/tools';\nimport {ModelAdapter} from '../model-adapter';\nimport {Chromosome} from './chromosome';\n\n/**\n * Adds a copy of a chromosome (i.e. a homologous chromosome, homolog) to DOM\n *\n * @param chrModel\n * @param chrIndex\n * @param homologIndex\n * @param container\n */\nfunction appendHomolog(chrModel, chrIndex, homologIndex, container) {\n\n  var homologOffset, chromosome, shape, defs, adapter;\n\n  defs = d3.select(this.selector + ' defs');\n  // Get chromosome model adapter class\n  adapter = ModelAdapter.getInstance(chrModel);\n\n  // How far this copy of the chromosome is from another\n  homologOffset = homologIndex * this.config.chrMargin;\n\n  // Append chromosome's container\n  chromosome = container\n    .append('g')\n    .attr('id', chrModel.id)\n    .attr('class', 'chromosome ' + adapter.getCssClass())\n    .attr('transform', 'translate(0, ' + homologOffset + ')');\n\n  // Render chromosome\n  shape = Chromosome.getInstance(adapter, this.config, this)\n    .render(chromosome, chrIndex, homologIndex);\n\n  d3.select('#' + chrModel.id + '-chromosome-set-clippath').remove();\n\n  defs.append('clipPath')\n    .attr('id', chrModel.id + '-chromosome-set-clippath')\n    .selectAll('path')\n    .data(shape)\n    .enter()\n    .append('path')\n    .attr('d', function(d) {return d.path;})\n    .attr('class', function(d) {return d.class;});\n\n\n  if (chrModel.width < 1) {\n    d3.select('#' + chrModel.id + ' .bands').style('opacity', 0);\n  }\n}\n\n/**\n * Renders all the bands and outlining boundaries of a chromosome.\n */\nfunction drawChromosome(chrModel) {\n  var chrIndex, container, numChrsInSet, transform, homologIndex,\n    chrSetSelector;\n\n  chrIndex = chrModel.chrIndex;\n\n  transform = this._layout.getChromosomeSetTranslate(chrIndex);\n\n  chrSetSelector = this.selector + ' #' + chrModel.id + '-chromosome-set';\n\n  d3.selectAll(chrSetSelector + ' g').remove();\n\n  container = d3.select(chrSetSelector);\n\n  if (container.nodes().length === 0) {\n    // Append chromosome set container\n    container = d3.select(this.selector)\n      .append('g')\n      .attr('class', 'chromosome-set')\n      .attr('transform', transform)\n      .attr('id', chrModel.id + '-chromosome-set');\n  }\n\n  if (\n    'sex' in this.config &&\n    this.config.ploidy === 2 &&\n    this.sexChromosomes.index === chrIndex\n  ) {\n    this.drawSexChromosomes(container, chrIndex);\n    return;\n  }\n\n  numChrsInSet = 1;\n  if (this.config.ploidy > 1) {\n    numChrsInSet = this._ploidy.getChromosomesNumber(chrIndex);\n  }\n\n  for (homologIndex = 0; homologIndex < numChrsInSet; homologIndex++) {\n    this.appendHomolog(chrModel, chrIndex, homologIndex, container);\n  }\n}\n\n/**\n * Rotates a chromosome 90 degrees and shows or hides all other chromosomes\n * Useful for focusing or defocusing a particular chromosome\n */\nfunction rotateAndToggleDisplay(chrElement) {\n  var chrName, chrModel, chrIndex;\n\n  this.unhighlight();\n\n  // Do nothing if taxid not defined. But it should be defined.\n  // To fix that bug we should have a way to find chromosome set number.\n  if (!this.config.taxid) return;\n\n  chrName = chrElement.id.split('-')[0].replace('chr', '');\n  chrModel = this.chromosomes[this.config.taxid][chrName];\n  chrIndex = chrModel.chrIndex;\n\n  this._layout.rotate(chrIndex, chrIndex, chrElement);\n}\n\nfunction setOverflowScroll() {\n  var ideo, config, ideoWidth, ideoInnerWrap, ideoMiddleWrap, ideoSvg,\n    ploidy, ploidyPad;\n\n  ideo = this;\n  config = ideo.config;\n\n  ideoSvg = d3.select(config.container + ' svg#_ideogram');\n  ideoInnerWrap = d3.select(config.container + ' #_ideogramInnerWrap');\n  ideoMiddleWrap = d3.select(config.container + ' #_ideogramMiddleWrap');\n\n  ploidy = config.ploidy;\n  if (ploidy === 1) {\n    ploidyPad = ploidy;\n  } else {\n    ploidyPad = ploidy * 1.12;\n  }\n\n  let annotHeight = 0;\n  if ('annotationsLayout' in config) {\n    annotHeight = config.annotationHeight * config.numAnnotTracks;\n  }\n\n  if (\n    config.orientation === 'vertical' &&\n    config.perspective !== 'comparative' &&\n    config.geometry !== 'collinear'\n  ) {\n    ideoWidth =\n      (ideo.numChromosomes) *\n      (config.chrWidth + config.chrMargin + annotHeight);\n  } else {\n    return;\n  }\n\n  if (config.annotationsLayout === 'heatmap-2d') {\n    return;\n  }\n\n  ideoWidth = Math.ceil(ideoWidth * ploidyPad / config.rows);\n  if (ideo._layout._class === 'SmallLayout') ideoWidth += 100;\n\n  ideoWidth += 35; // Account for settings gear\n\n  // Ensures absolutely-positioned elements, e.g. heatmap overlaps, display\n  // properly if ideogram container also has position: absolute\n  ideoMiddleWrap.style('height', ideo._layout.getHeight() + 'px');\n\n  ideoInnerWrap\n    .style('max-width', ideoWidth + 'px')\n    .style('overflow-x', 'scroll')\n    .style('position', 'absolute');\n\n  ideoSvg.style('min-width', (ideoWidth - 5) + 'px');\n\n  if (ideo.config.showTools) {\n    initTools(ideo);\n  }\n}\n\nexport {\n  appendHomolog, drawChromosome, rotateAndToggleDisplay, setOverflowScroll\n};\n","import {d3} from '../lib';\n\nfunction getChrSetLabelLines(d, i, ideo) {\n  var lines;\n  if (d.name.indexOf(' ') === -1) {\n    lines = [d.name];\n  } else {\n    lines = d.name.match(/^(.*)\\s+([^\\s]+)$/).slice(1).reverse();\n  }\n\n  if (\n    'sex' in ideo.config &&\n    ideo.config.ploidy === 2 &&\n    i === ideo.sexChromosomes.index\n  ) {\n    if (ideo.config.sex === 'male') {\n      lines = ['XY'];\n    } else {\n      lines = ['XX'];\n    }\n  }\n\n  return lines;\n}\n\nfunction renderChromosomeSetLabel(d, i, textElement, ideo) {\n  // Get label lines\n  var lines = getChrSetLabelLines(d, i, ideo);\n\n  // Render label lines\n  d3.select(textElement).selectAll('tspan')\n    .data(lines)\n    .enter()\n    .append('tspan')\n    .attr('dy', function(d, i) {\n      return i * -1.2 + 'em';\n    })\n    .attr('x', ideo._layout.getChromosomeSetLabelXPosition())\n    .attr('class', function(a, i) {\n      var fullLabels = ideo.config.fullChromosomeLabels;\n      return i === 1 && fullLabels ? 'italic' : null;\n    })\n    .text(String);\n}\n\nfunction appendChromosomeSetLabels(ideo) {\n  var layout = ideo._layout;\n\n  d3.selectAll(ideo.selector + ' .chromosome-set')\n    .insert('text', ':first-child')\n    .data(ideo.chromosomesArray)\n    .attr('class', layout.getChromosomeLabelClass())\n    .attr('transform', layout.getChromosomeSetLabelTranslate())\n    .attr('x', layout.getChromosomeSetLabelXPosition())\n    .attr('y', function(d, i) {\n      return layout.getChromosomeSetLabelYPosition(i);\n    })\n    .attr('text-anchor', layout.getChromosomeSetLabelAnchor())\n    .each(function(d, i) {\n      renderChromosomeSetLabel(d, i, this, ideo);\n    });\n}\n\nfunction appendChromosomeLabels(ideo) {\n  var layout = ideo._layout;\n\n  d3.selectAll(ideo.selector + ' .chromosome-set')\n    .each(function(a, chrSetIndex) {\n      d3.select(this).selectAll('.chromosome')\n        .append('text')\n        .attr('class', 'chrLabel')\n        .attr('transform', layout.getChromosomeSetLabelTranslate())\n        .attr('x', function(d, i) {\n          return layout.getChromosomeLabelXPosition(i);\n        })\n        .attr('y', function(d, i) {\n          return layout.getChromosomeLabelYPosition(i);\n        })\n        .text(function(d, chrIndex) {\n          return ideo._ploidy.getAncestor(chrSetIndex, chrIndex);\n        })\n        .attr('text-anchor', 'middle');\n    });\n}\n\n/**\n * Draws labels for each chromosome, e.g. \"1\", \"2\", \"X\".\n * If ideogram configuration has 'fullChromosomeLabels: True',\n * then labels includes name of taxon, which can help when\n * depicting orthologs.\n */\nfunction drawChromosomeLabels() {\n  var ideo = this;\n  appendChromosomeSetLabels(ideo);\n  appendChromosomeLabels(ideo);\n}\n\nfunction getLabelPositionAttrs(scale) {\n  var x, y, scaleSvg;\n\n  if (\n    typeof (scale) !== 'undefined' &&\n    scale.hasOwnProperty('x') &&\n    !(scale.x === 1 && scale.y === 1)\n  ) {\n    scaleSvg = 'scale(' + scale.x + ',' + scale.y + ')';\n    x = -6;\n    y = (scale === '' ? -16 : -14);\n  } else {\n    x = -8;\n    y = -16;\n    scale = {x: 1, y: 1};\n    scaleSvg = '';\n  }\n\n  return {x: x, y: y, scaleSvg: scaleSvg, scale: scale};\n}\n\nfunction updateChrIndex(chrIndex, config) {\n  if (config.numAnnotTracks > 1 || config.orientation === '') chrIndex -= 1;\n  return chrIndex;\n}\n\nfunction rotateVerticalChromosomeLabels(chr, chrIndex, labelPosAttrs, ideo) {\n  var chrMargin2, chrMargin, y,\n    config = ideo.config;\n\n  chrIndex = updateChrIndex(chrIndex, config);\n\n  chrMargin2 = -4;\n  if (config.showBandLabels === true) {\n    chrMargin2 = config.chrMargin + config.chrWidth + 26;\n  }\n\n  chrMargin = config.chrMargin * chrIndex;\n  if (config.numAnnotTracks > 1 === false) chrMargin += 1;\n\n  y = chrMargin + chrMargin2;\n\n  chr.selectAll('text.chrLabel')\n    .attr('transform', labelPosAttrs.scaleSvg)\n    .selectAll('tspan')\n    .attr('x', labelPosAttrs.x)\n    .attr('y', y);\n}\n\nfunction rotateHorizontalChromosomeLabels(chr, chrIndex, labelPosAttrs, ideo) {\n  var chrMargin, chrMargin2, tracksHeight, x,\n    config = ideo.config;\n\n  chrMargin2 = -config.chrWidth - 2;\n  if (config.showBandLabels === true) chrMargin2 = config.chrMargin + 8;\n\n  tracksHeight = config.annotTracksHeight;\n  if (config.annotationsLayout !== 'overlay') tracksHeight *= 2;\n\n  chrMargin = config.chrMargin * chrIndex;\n  x = -(chrMargin + chrMargin2) + 3 + tracksHeight;\n  x /= labelPosAttrs.scale.x;\n\n  chr.selectAll('text.chrLabel')\n    .attr('transform', 'rotate(-90)' + labelPosAttrs.scaleSvg)\n    .selectAll('tspan')\n    .attr('x', x)\n    .attr('y', labelPosAttrs.y);\n}\n\n/**\n * Rotates chromosome labels by 90 degrees, e.g. upon clicking a chromosome.\n */\nfunction rotateChromosomeLabels(chr, chrIndex, orientation, scale) {\n  var labelPosAttrs,\n    ideo = this;\n\n  chrIndex -= 1;\n\n  labelPosAttrs = getLabelPositionAttrs(scale);\n\n  if (orientation === 'vertical' || orientation === '') {\n    rotateVerticalChromosomeLabels(chr, chrIndex, labelPosAttrs, ideo);\n  } else {\n    rotateHorizontalChromosomeLabels(chr, chrIndex, labelPosAttrs, ideo);\n  }\n}\n\nexport {drawChromosomeLabels, rotateChromosomeLabels};\n","export default function getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}","import getWindow from \"./getWindow.js\";\n\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\nfunction isShadowRoot(node) {\n  // IE 11 has no ShadowRoot\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  var OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\nexport { isElement, isHTMLElement, isShadowRoot };","export var max = Math.max;\nexport var min = Math.min;\nexport var round = Math.round;","export default function getUAString() {\n  var uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(function (item) {\n      return item.brand + \"/\" + item.version;\n    }).join(' ');\n  }\n\n  return navigator.userAgent;\n}","import getUAString from \"../utils/userAgent.js\";\nexport default function isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}","import { isElement, isHTMLElement } from \"./instanceOf.js\";\nimport { round } from \"../utils/math.js\";\nimport getWindow from \"./getWindow.js\";\nimport isLayoutViewport from \"./isLayoutViewport.js\";\nexport default function getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  var clientRect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  var _ref = isElement(element) ? getWindow(element) : window,\n      visualViewport = _ref.visualViewport;\n\n  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n  var width = clientRect.width / scaleX;\n  var height = clientRect.height / scaleY;\n  return {\n    width: width,\n    height: height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x: x,\n    y: y\n  };\n}","import getWindow from \"./getWindow.js\";\nexport default function getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}","export default function getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}","import getWindowScroll from \"./getWindowScroll.js\";\nimport getWindow from \"./getWindow.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nimport getHTMLElementScroll from \"./getHTMLElementScroll.js\";\nexport default function getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}","export default function getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}","import { isElement } from \"./instanceOf.js\";\nexport default function getDocumentElement(element) {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n  element.document) || window.document).documentElement;\n}","import getBoundingClientRect from \"./getBoundingClientRect.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport getWindowScroll from \"./getWindowScroll.js\";\nexport default function getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}","import getWindow from \"./getWindow.js\";\nexport default function getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}","import getComputedStyle from \"./getComputedStyle.js\";\nexport default function isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}","import getBoundingClientRect from \"./getBoundingClientRect.js\";\nimport getNodeScroll from \"./getNodeScroll.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nimport getWindowScrollBarX from \"./getWindowScrollBarX.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport isScrollParent from \"./isScrollParent.js\";\nimport { round } from \"../utils/math.js\";\n\nfunction isElementScaled(element) {\n  var rect = element.getBoundingClientRect();\n  var scaleX = round(rect.width) / element.offsetWidth || 1;\n  var scaleY = round(rect.height) / element.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\n\nexport default function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}","import getBoundingClientRect from \"./getBoundingClientRect.js\"; // Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\n\nexport default function getLayoutRect(element) {\n  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n  // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: width,\n    height: height\n  };\n}","import getNodeName from \"./getNodeName.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport { isShadowRoot } from \"./instanceOf.js\";\nexport default function getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || ( // DOM Element detected\n    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n\n  );\n}","import getParentNode from \"./getParentNode.js\";\nimport isScrollParent from \"./isScrollParent.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nexport default function getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}","import getScrollParent from \"./getScrollParent.js\";\nimport getParentNode from \"./getParentNode.js\";\nimport getWindow from \"./getWindow.js\";\nimport isScrollParent from \"./isScrollParent.js\";\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/\n\nexport default function listScrollParents(element, list) {\n  var _element$ownerDocumen;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = getScrollParent(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(getParentNode(target)));\n}","import getNodeName from \"./getNodeName.js\";\nexport default function isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n}","import getWindow from \"./getWindow.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport getComputedStyle from \"./getComputedStyle.js\";\nimport { isHTMLElement, isShadowRoot } from \"./instanceOf.js\";\nimport isTableElement from \"./isTableElement.js\";\nimport getParentNode from \"./getParentNode.js\";\nimport getUAString from \"../utils/userAgent.js\";\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n\nfunction getContainingBlock(element) {\n  var isFirefox = /firefox/i.test(getUAString());\n  var isIE = /Trident/i.test(getUAString());\n\n  if (isIE && isHTMLElement(element)) {\n    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n    var elementCss = getComputedStyle(element);\n\n    if (elementCss.position === 'fixed') {\n      return null;\n    }\n  }\n\n  var currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nexport default function getOffsetParent(element) {\n  var window = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}","export var top = 'top';\nexport var bottom = 'bottom';\nexport var right = 'right';\nexport var left = 'left';\nexport var auto = 'auto';\nexport var basePlacements = [top, bottom, right, left];\nexport var start = 'start';\nexport var end = 'end';\nexport var clippingParents = 'clippingParents';\nexport var viewport = 'viewport';\nexport var popper = 'popper';\nexport var reference = 'reference';\nexport var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nexport var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nexport var beforeRead = 'beforeRead';\nexport var read = 'read';\nexport var afterRead = 'afterRead'; // pure-logic modifiers\n\nexport var beforeMain = 'beforeMain';\nexport var main = 'main';\nexport var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nexport var beforeWrite = 'beforeWrite';\nexport var write = 'write';\nexport var afterWrite = 'afterWrite';\nexport var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];","import { modifierPhases } from \"../enums.js\"; // source: https://stackoverflow.com/questions/49875255\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nexport default function orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}","export default function debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}","export default function mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}","import getCompositeRect from \"./dom-utils/getCompositeRect.js\";\nimport getLayoutRect from \"./dom-utils/getLayoutRect.js\";\nimport listScrollParents from \"./dom-utils/listScrollParents.js\";\nimport getOffsetParent from \"./dom-utils/getOffsetParent.js\";\nimport orderModifiers from \"./utils/orderModifiers.js\";\nimport debounce from \"./utils/debounce.js\";\nimport mergeByName from \"./utils/mergeByName.js\";\nimport detectOverflow from \"./utils/detectOverflow.js\";\nimport { isElement } from \"./dom-utils/instanceOf.js\";\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nexport function popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        });\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update  it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update  it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref) {\n        var name = _ref.name,\n            _ref$options = _ref.options,\n            options = _ref$options === void 0 ? {} : _ref$options,\n            effect = _ref.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nexport var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\nexport { detectOverflow };","import getWindow from \"../dom-utils/getWindow.js\"; // eslint-disable-next-line import/no-unused-modules\n\nvar passive = {\n  passive: true\n};\n\nfunction effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n};","import { auto } from \"../enums.js\";\nexport default function getBasePlacement(placement) {\n  return placement.split('-')[0];\n}","export default function getVariation(placement) {\n  return placement.split('-')[1];\n}","export default function getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}","import getBasePlacement from \"./getBasePlacement.js\";\nimport getVariation from \"./getVariation.js\";\nimport getMainAxisFromPlacement from \"./getMainAxisFromPlacement.js\";\nimport { top, right, bottom, left, start, end } from \"../enums.js\";\nexport default function computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n        break;\n\n      case end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n        break;\n\n      default:\n    }\n  }\n\n  return offsets;\n}","import computeOffsets from \"../utils/computeOffsets.js\";\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n};","import { top, left, right, bottom, end } from \"../enums.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport getWindow from \"../dom-utils/getWindow.js\";\nimport getDocumentElement from \"../dom-utils/getDocumentElement.js\";\nimport getComputedStyle from \"../dom-utils/getComputedStyle.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getVariation from \"../utils/getVariation.js\";\nimport { round } from \"../utils/math.js\"; // eslint-disable-next-line import/no-unused-modules\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsetsByDPR(_ref, win) {\n  var x = _ref.x,\n      y = _ref.y;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: round(x * dpr) / dpr || 0,\n    y: round(y * dpr) / dpr || 0\n  };\n}\n\nexport function mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n  var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n\n  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n    x: x,\n    y: y\n  }) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref3.x;\n  y = _ref3.y;\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = left;\n  var sideY = top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper);\n    var heightProp = 'clientHeight';\n    var widthProp = 'clientWidth';\n\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n\n      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {\n        heightProp = 'scrollHeight';\n        widthProp = 'scrollWidth';\n      }\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n    offsetParent = offsetParent;\n\n    if (placement === top || (placement === left || placement === right) && variation === end) {\n      sideY = bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]\n      offsetParent[heightProp];\n      y -= offsetY - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left || (placement === top || placement === bottom) && variation === end) {\n      sideX = right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]\n      offsetParent[widthProp];\n      x -= offsetX - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n    x: x,\n    y: y\n  }, getWindow(popper)) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref4.x;\n  y = _ref4.y;\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref5) {\n  var state = _ref5.state,\n      options = _ref5.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    variation: getVariation(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration,\n    isFixed: state.options.strategy === 'fixed'\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n};","import getNodeName from \"../dom-utils/getNodeName.js\";\nimport { isHTMLElement } from \"../dom-utils/instanceOf.js\"; // This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe[cannot-write]\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: effect,\n  requires: ['computeStyles']\n};","import getBasePlacement from \"../utils/getBasePlacement.js\";\nimport { top, left, right, placements } from \"../enums.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport function distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n};","var hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nexport default function getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}","var hash = {\n  start: 'end',\n  end: 'start'\n};\nexport default function getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return hash[matched];\n  });\n}","import getWindow from \"./getWindow.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport getWindowScrollBarX from \"./getWindowScrollBarX.js\";\nimport isLayoutViewport from \"./isLayoutViewport.js\";\nexport default function getViewportRect(element, strategy) {\n  var win = getWindow(element);\n  var html = getDocumentElement(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    var layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + getWindowScrollBarX(element),\n    y: y\n  };\n}","import getDocumentElement from \"./getDocumentElement.js\";\nimport getComputedStyle from \"./getComputedStyle.js\";\nimport getWindowScrollBarX from \"./getWindowScrollBarX.js\";\nimport getWindowScroll from \"./getWindowScroll.js\";\nimport { max } from \"../utils/math.js\"; // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nexport default function getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  var html = getDocumentElement(element);\n  var winScroll = getWindowScroll(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n  var y = -winScroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}","import { isShadowRoot } from \"./instanceOf.js\";\nexport default function contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}","export default function rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}","import { viewport } from \"../enums.js\";\nimport getViewportRect from \"./getViewportRect.js\";\nimport getDocumentRect from \"./getDocumentRect.js\";\nimport listScrollParents from \"./listScrollParents.js\";\nimport getOffsetParent from \"./getOffsetParent.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport getComputedStyle from \"./getComputedStyle.js\";\nimport { isElement, isHTMLElement } from \"./instanceOf.js\";\nimport getBoundingClientRect from \"./getBoundingClientRect.js\";\nimport getParentNode from \"./getParentNode.js\";\nimport contains from \"./contains.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport rectToClientRect from \"../utils/rectToClientRect.js\";\nimport { max, min } from \"../utils/math.js\";\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  var rect = getBoundingClientRect(element, false, strategy === 'fixed');\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(getParentNode(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nexport default function getClippingRect(element, boundary, rootBoundary, strategy) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}","export default function getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}","import getFreshSideObject from \"./getFreshSideObject.js\";\nexport default function mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), paddingObject);\n}","export default function expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}","import getClippingRect from \"../dom-utils/getClippingRect.js\";\nimport getDocumentElement from \"../dom-utils/getDocumentElement.js\";\nimport getBoundingClientRect from \"../dom-utils/getBoundingClientRect.js\";\nimport computeOffsets from \"./computeOffsets.js\";\nimport rectToClientRect from \"./rectToClientRect.js\";\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from \"../enums.js\";\nimport { isElement } from \"../dom-utils/instanceOf.js\";\nimport mergePaddingObject from \"./mergePaddingObject.js\";\nimport expandToHashMap from \"./expandToHashMap.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport default function detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$strategy = _options.strategy,\n      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n  var referenceClientRect = getBoundingClientRect(state.elements.reference);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}","import getVariation from \"./getVariation.js\";\nimport { variationPlacements, basePlacements, placements as allPlacements } from \"../enums.js\";\nimport detectOverflow from \"./detectOverflow.js\";\nimport getBasePlacement from \"./getBasePlacement.js\";\nexport default function computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? allPlacements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements;\n  var allowedPlacements = placements.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}","import getOppositePlacement from \"../utils/getOppositePlacement.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getOppositeVariationPlacement from \"../utils/getOppositeVariationPlacement.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport computeAutoPlacement from \"../utils/computeAutoPlacement.js\";\nimport { bottom, top, start, right, left, auto } from \"../enums.js\";\nimport getVariation from \"../utils/getVariation.js\"; // eslint-disable-next-line import/no-unused-modules\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases  research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n};","export default function getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}","import { max as mathMax, min as mathMin } from \"./math.js\";\nexport function within(min, value, max) {\n  return mathMax(min, mathMin(value, max));\n}\nexport function withinMaxClamp(min, value, max) {\n  var v = within(min, value, max);\n  return v > max ? max : v;\n}","import { top, left, right, bottom, start } from \"../enums.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getMainAxisFromPlacement from \"../utils/getMainAxisFromPlacement.js\";\nimport getAltAxis from \"../utils/getAltAxis.js\";\nimport { within, withinMaxClamp } from \"../utils/within.js\";\nimport getLayoutRect from \"../dom-utils/getLayoutRect.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport getVariation from \"../utils/getVariation.js\";\nimport getFreshSideObject from \"../utils/getFreshSideObject.js\";\nimport { min as mathMin, max as mathMax } from \"../utils/math.js\";\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = offset + overflow[mainSide];\n    var max = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? mathMin(min, tetherMin) : min, offset, tether ? mathMax(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _len = altAxis === 'y' ? 'height' : 'width';\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};","import getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getLayoutRect from \"../dom-utils/getLayoutRect.js\";\nimport contains from \"../dom-utils/contains.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport getMainAxisFromPlacement from \"../utils/getMainAxisFromPlacement.js\";\nimport { within } from \"../utils/within.js\";\nimport mergePaddingObject from \"../utils/mergePaddingObject.js\";\nimport expandToHashMap from \"../utils/expandToHashMap.js\";\nimport { left, right, basePlacements, top, bottom } from \"../enums.js\"; // eslint-disable-next-line import/no-unused-modules\n\nvar toPaddingObject = function toPaddingObject(padding, state) {\n  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n};\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === 'y' ? top : left;\n  var maxProp = axis === 'y' ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n};","import { top, bottom, left, right } from \"../enums.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [top, right, bottom, left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide\n};","import { popperGenerator, detectOverflow } from \"./createPopper.js\";\nimport eventListeners from \"./modifiers/eventListeners.js\";\nimport popperOffsets from \"./modifiers/popperOffsets.js\";\nimport computeStyles from \"./modifiers/computeStyles.js\";\nimport applyStyles from \"./modifiers/applyStyles.js\";\nimport offset from \"./modifiers/offset.js\";\nimport flip from \"./modifiers/flip.js\";\nimport preventOverflow from \"./modifiers/preventOverflow.js\";\nimport arrow from \"./modifiers/arrow.js\";\nimport hide from \"./modifiers/hide.js\";\nvar defaultModifiers = [eventListeners, popperOffsets, computeStyles, applyStyles, offset, flip, preventOverflow, arrow, hide];\nvar createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\nexport { createPopper, popperGenerator, defaultModifiers, detectOverflow }; // eslint-disable-next-line import/no-unused-modules\n\nexport { createPopper as createPopperLite } from \"./popper-lite.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport * from \"./modifiers/index.js\";","/**!\n* tippy.js v6.3.7\n* (c) 2017-2021 atomiks\n* MIT License\n*/\nimport { createPopper, applyStyles } from '@popperjs/core';\n\nvar ROUND_ARROW = '<svg width=\"16\" height=\"6\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z\"></svg>';\nvar BOX_CLASS = \"tippy-box\";\nvar CONTENT_CLASS = \"tippy-content\";\nvar BACKDROP_CLASS = \"tippy-backdrop\";\nvar ARROW_CLASS = \"tippy-arrow\";\nvar SVG_ARROW_CLASS = \"tippy-svg-arrow\";\nvar TOUCH_OPTIONS = {\n  passive: true,\n  capture: true\n};\nvar TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {\n  return document.body;\n};\n\nfunction hasOwnProperty(obj, key) {\n  return {}.hasOwnProperty.call(obj, key);\n}\nfunction getValueAtIndexOrReturn(value, index, defaultValue) {\n  if (Array.isArray(value)) {\n    var v = value[index];\n    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;\n  }\n\n  return value;\n}\nfunction isType(value, type) {\n  var str = {}.toString.call(value);\n  return str.indexOf('[object') === 0 && str.indexOf(type + \"]\") > -1;\n}\nfunction invokeWithArgsOrReturn(value, args) {\n  return typeof value === 'function' ? value.apply(void 0, args) : value;\n}\nfunction debounce(fn, ms) {\n  // Avoid wrapping in `setTimeout` if ms is 0 anyway\n  if (ms === 0) {\n    return fn;\n  }\n\n  var timeout;\n  return function (arg) {\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      fn(arg);\n    }, ms);\n  };\n}\nfunction removeProperties(obj, keys) {\n  var clone = Object.assign({}, obj);\n  keys.forEach(function (key) {\n    delete clone[key];\n  });\n  return clone;\n}\nfunction splitBySpaces(value) {\n  return value.split(/\\s+/).filter(Boolean);\n}\nfunction normalizeToArray(value) {\n  return [].concat(value);\n}\nfunction pushIfUnique(arr, value) {\n  if (arr.indexOf(value) === -1) {\n    arr.push(value);\n  }\n}\nfunction unique(arr) {\n  return arr.filter(function (item, index) {\n    return arr.indexOf(item) === index;\n  });\n}\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}\nfunction arrayFrom(value) {\n  return [].slice.call(value);\n}\nfunction removeUndefinedProps(obj) {\n  return Object.keys(obj).reduce(function (acc, key) {\n    if (obj[key] !== undefined) {\n      acc[key] = obj[key];\n    }\n\n    return acc;\n  }, {});\n}\n\nfunction div() {\n  return document.createElement('div');\n}\nfunction isElement(value) {\n  return ['Element', 'Fragment'].some(function (type) {\n    return isType(value, type);\n  });\n}\nfunction isNodeList(value) {\n  return isType(value, 'NodeList');\n}\nfunction isMouseEvent(value) {\n  return isType(value, 'MouseEvent');\n}\nfunction isReferenceElement(value) {\n  return !!(value && value._tippy && value._tippy.reference === value);\n}\nfunction getArrayOfElements(value) {\n  if (isElement(value)) {\n    return [value];\n  }\n\n  if (isNodeList(value)) {\n    return arrayFrom(value);\n  }\n\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  return arrayFrom(document.querySelectorAll(value));\n}\nfunction setTransitionDuration(els, value) {\n  els.forEach(function (el) {\n    if (el) {\n      el.style.transitionDuration = value + \"ms\";\n    }\n  });\n}\nfunction setVisibilityState(els, state) {\n  els.forEach(function (el) {\n    if (el) {\n      el.setAttribute('data-state', state);\n    }\n  });\n}\nfunction getOwnerDocument(elementOrElements) {\n  var _element$ownerDocumen;\n\n  var _normalizeToArray = normalizeToArray(elementOrElements),\n      element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body\n\n\n  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;\n}\nfunction isCursorOutsideInteractiveBorder(popperTreeData, event) {\n  var clientX = event.clientX,\n      clientY = event.clientY;\n  return popperTreeData.every(function (_ref) {\n    var popperRect = _ref.popperRect,\n        popperState = _ref.popperState,\n        props = _ref.props;\n    var interactiveBorder = props.interactiveBorder;\n    var basePlacement = getBasePlacement(popperState.placement);\n    var offsetData = popperState.modifiersData.offset;\n\n    if (!offsetData) {\n      return true;\n    }\n\n    var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;\n    var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;\n    var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;\n    var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;\n    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;\n    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;\n    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;\n    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;\n    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;\n  });\n}\nfunction updateTransitionEndListener(box, action, listener) {\n  var method = action + \"EventListener\"; // some browsers apparently support `transition` (unprefixed) but only fire\n  // `webkitTransitionEnd`...\n\n  ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {\n    box[method](event, listener);\n  });\n}\n/**\n * Compared to xxx.contains, this function works for dom structures with shadow\n * dom\n */\n\nfunction actualContains(parent, child) {\n  var target = child;\n\n  while (target) {\n    var _target$getRootNode;\n\n    if (parent.contains(target)) {\n      return true;\n    }\n\n    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;\n  }\n\n  return false;\n}\n\nvar currentInput = {\n  isTouch: false\n};\nvar lastMouseMoveTime = 0;\n/**\n * When a `touchstart` event is fired, it's assumed the user is using touch\n * input. We'll bind a `mousemove` event listener to listen for mouse input in\n * the future. This way, the `isTouch` property is fully dynamic and will handle\n * hybrid devices that use a mix of touch + mouse input.\n */\n\nfunction onDocumentTouchStart() {\n  if (currentInput.isTouch) {\n    return;\n  }\n\n  currentInput.isTouch = true;\n\n  if (window.performance) {\n    document.addEventListener('mousemove', onDocumentMouseMove);\n  }\n}\n/**\n * When two `mousemove` event are fired consecutively within 20ms, it's assumed\n * the user is using mouse input again. `mousemove` can fire on touch devices as\n * well, but very rarely that quickly.\n */\n\nfunction onDocumentMouseMove() {\n  var now = performance.now();\n\n  if (now - lastMouseMoveTime < 20) {\n    currentInput.isTouch = false;\n    document.removeEventListener('mousemove', onDocumentMouseMove);\n  }\n\n  lastMouseMoveTime = now;\n}\n/**\n * When an element is in focus and has a tippy, leaving the tab/window and\n * returning causes it to show again. For mouse users this is unexpected, but\n * for keyboard use it makes sense.\n * TODO: find a better technique to solve this problem\n */\n\nfunction onWindowBlur() {\n  var activeElement = document.activeElement;\n\n  if (isReferenceElement(activeElement)) {\n    var instance = activeElement._tippy;\n\n    if (activeElement.blur && !instance.state.isVisible) {\n      activeElement.blur();\n    }\n  }\n}\nfunction bindGlobalEventListeners() {\n  document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);\n  window.addEventListener('blur', onWindowBlur);\n}\n\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\nvar isIE11 = isBrowser ? // @ts-ignore\n!!window.msCrypto : false;\n\nfunction createMemoryLeakWarning(method) {\n  var txt = method === 'destroy' ? 'n already-' : ' ';\n  return [method + \"() was called on a\" + txt + \"destroyed instance. This is a no-op but\", 'indicates a potential memory leak.'].join(' ');\n}\nfunction clean(value) {\n  var spacesAndTabs = /[ \\t]{2,}/g;\n  var lineStartWithSpaces = /^[ \\t]*/gm;\n  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();\n}\n\nfunction getDevMessage(message) {\n  return clean(\"\\n  %ctippy.js\\n\\n  %c\" + clean(message) + \"\\n\\n  %c\\uD83D\\uDC77\\u200D This is a development-only message. It will be removed in production.\\n  \");\n}\n\nfunction getFormattedMessage(message) {\n  return [getDevMessage(message), // title\n  'color: #00C584; font-size: 1.3em; font-weight: bold;', // message\n  'line-height: 1.5', // footer\n  'color: #a6a095;'];\n} // Assume warnings and errors never have the same message\n\nvar visitedMessages;\n\nif (process.env.NODE_ENV !== \"production\") {\n  resetVisitedMessages();\n}\n\nfunction resetVisitedMessages() {\n  visitedMessages = new Set();\n}\nfunction warnWhen(condition, message) {\n  if (condition && !visitedMessages.has(message)) {\n    var _console;\n\n    visitedMessages.add(message);\n\n    (_console = console).warn.apply(_console, getFormattedMessage(message));\n  }\n}\nfunction errorWhen(condition, message) {\n  if (condition && !visitedMessages.has(message)) {\n    var _console2;\n\n    visitedMessages.add(message);\n\n    (_console2 = console).error.apply(_console2, getFormattedMessage(message));\n  }\n}\nfunction validateTargets(targets) {\n  var didPassFalsyValue = !targets;\n  var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;\n  errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' '));\n  errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' '));\n}\n\nvar pluginProps = {\n  animateFill: false,\n  followCursor: false,\n  inlinePositioning: false,\n  sticky: false\n};\nvar renderProps = {\n  allowHTML: false,\n  animation: 'fade',\n  arrow: true,\n  content: '',\n  inertia: false,\n  maxWidth: 350,\n  role: 'tooltip',\n  theme: '',\n  zIndex: 9999\n};\nvar defaultProps = Object.assign({\n  appendTo: TIPPY_DEFAULT_APPEND_TO,\n  aria: {\n    content: 'auto',\n    expanded: 'auto'\n  },\n  delay: 0,\n  duration: [300, 250],\n  getReferenceClientRect: null,\n  hideOnClick: true,\n  ignoreAttributes: false,\n  interactive: false,\n  interactiveBorder: 2,\n  interactiveDebounce: 0,\n  moveTransition: '',\n  offset: [0, 10],\n  onAfterUpdate: function onAfterUpdate() {},\n  onBeforeUpdate: function onBeforeUpdate() {},\n  onCreate: function onCreate() {},\n  onDestroy: function onDestroy() {},\n  onHidden: function onHidden() {},\n  onHide: function onHide() {},\n  onMount: function onMount() {},\n  onShow: function onShow() {},\n  onShown: function onShown() {},\n  onTrigger: function onTrigger() {},\n  onUntrigger: function onUntrigger() {},\n  onClickOutside: function onClickOutside() {},\n  placement: 'top',\n  plugins: [],\n  popperOptions: {},\n  render: null,\n  showOnCreate: false,\n  touch: true,\n  trigger: 'mouseenter focus',\n  triggerTarget: null\n}, pluginProps, renderProps);\nvar defaultKeys = Object.keys(defaultProps);\nvar setDefaultProps = function setDefaultProps(partialProps) {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    validateProps(partialProps, []);\n  }\n\n  var keys = Object.keys(partialProps);\n  keys.forEach(function (key) {\n    defaultProps[key] = partialProps[key];\n  });\n};\nfunction getExtendedPassedProps(passedProps) {\n  var plugins = passedProps.plugins || [];\n  var pluginProps = plugins.reduce(function (acc, plugin) {\n    var name = plugin.name,\n        defaultValue = plugin.defaultValue;\n\n    if (name) {\n      var _name;\n\n      acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;\n    }\n\n    return acc;\n  }, {});\n  return Object.assign({}, passedProps, pluginProps);\n}\nfunction getDataAttributeProps(reference, plugins) {\n  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {\n    plugins: plugins\n  }))) : defaultKeys;\n  var props = propKeys.reduce(function (acc, key) {\n    var valueAsString = (reference.getAttribute(\"data-tippy-\" + key) || '').trim();\n\n    if (!valueAsString) {\n      return acc;\n    }\n\n    if (key === 'content') {\n      acc[key] = valueAsString;\n    } else {\n      try {\n        acc[key] = JSON.parse(valueAsString);\n      } catch (e) {\n        acc[key] = valueAsString;\n      }\n    }\n\n    return acc;\n  }, {});\n  return props;\n}\nfunction evaluateProps(reference, props) {\n  var out = Object.assign({}, props, {\n    content: invokeWithArgsOrReturn(props.content, [reference])\n  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));\n  out.aria = Object.assign({}, defaultProps.aria, out.aria);\n  out.aria = {\n    expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,\n    content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content\n  };\n  return out;\n}\nfunction validateProps(partialProps, plugins) {\n  if (partialProps === void 0) {\n    partialProps = {};\n  }\n\n  if (plugins === void 0) {\n    plugins = [];\n  }\n\n  var keys = Object.keys(partialProps);\n  keys.forEach(function (prop) {\n    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));\n    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`\n\n    if (didPassUnknownProp) {\n      didPassUnknownProp = plugins.filter(function (plugin) {\n        return plugin.name === prop;\n      }).length === 0;\n    }\n\n    warnWhen(didPassUnknownProp, [\"`\" + prop + \"`\", \"is not a valid prop. You may have spelled it incorrectly, or if it's\", 'a plugin, forgot to pass it in an array as props.plugins.', '\\n\\n', 'All props: https://atomiks.github.io/tippyjs/v6/all-props/\\n', 'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/'].join(' '));\n  });\n}\n\nvar innerHTML = function innerHTML() {\n  return 'innerHTML';\n};\n\nfunction dangerouslySetInnerHTML(element, html) {\n  element[innerHTML()] = html;\n}\n\nfunction createArrowElement(value) {\n  var arrow = div();\n\n  if (value === true) {\n    arrow.className = ARROW_CLASS;\n  } else {\n    arrow.className = SVG_ARROW_CLASS;\n\n    if (isElement(value)) {\n      arrow.appendChild(value);\n    } else {\n      dangerouslySetInnerHTML(arrow, value);\n    }\n  }\n\n  return arrow;\n}\n\nfunction setContent(content, props) {\n  if (isElement(props.content)) {\n    dangerouslySetInnerHTML(content, '');\n    content.appendChild(props.content);\n  } else if (typeof props.content !== 'function') {\n    if (props.allowHTML) {\n      dangerouslySetInnerHTML(content, props.content);\n    } else {\n      content.textContent = props.content;\n    }\n  }\n}\nfunction getChildren(popper) {\n  var box = popper.firstElementChild;\n  var boxChildren = arrayFrom(box.children);\n  return {\n    box: box,\n    content: boxChildren.find(function (node) {\n      return node.classList.contains(CONTENT_CLASS);\n    }),\n    arrow: boxChildren.find(function (node) {\n      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);\n    }),\n    backdrop: boxChildren.find(function (node) {\n      return node.classList.contains(BACKDROP_CLASS);\n    })\n  };\n}\nfunction render(instance) {\n  var popper = div();\n  var box = div();\n  box.className = BOX_CLASS;\n  box.setAttribute('data-state', 'hidden');\n  box.setAttribute('tabindex', '-1');\n  var content = div();\n  content.className = CONTENT_CLASS;\n  content.setAttribute('data-state', 'hidden');\n  setContent(content, instance.props);\n  popper.appendChild(box);\n  box.appendChild(content);\n  onUpdate(instance.props, instance.props);\n\n  function onUpdate(prevProps, nextProps) {\n    var _getChildren = getChildren(popper),\n        box = _getChildren.box,\n        content = _getChildren.content,\n        arrow = _getChildren.arrow;\n\n    if (nextProps.theme) {\n      box.setAttribute('data-theme', nextProps.theme);\n    } else {\n      box.removeAttribute('data-theme');\n    }\n\n    if (typeof nextProps.animation === 'string') {\n      box.setAttribute('data-animation', nextProps.animation);\n    } else {\n      box.removeAttribute('data-animation');\n    }\n\n    if (nextProps.inertia) {\n      box.setAttribute('data-inertia', '');\n    } else {\n      box.removeAttribute('data-inertia');\n    }\n\n    box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + \"px\" : nextProps.maxWidth;\n\n    if (nextProps.role) {\n      box.setAttribute('role', nextProps.role);\n    } else {\n      box.removeAttribute('role');\n    }\n\n    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {\n      setContent(content, instance.props);\n    }\n\n    if (nextProps.arrow) {\n      if (!arrow) {\n        box.appendChild(createArrowElement(nextProps.arrow));\n      } else if (prevProps.arrow !== nextProps.arrow) {\n        box.removeChild(arrow);\n        box.appendChild(createArrowElement(nextProps.arrow));\n      }\n    } else if (arrow) {\n      box.removeChild(arrow);\n    }\n  }\n\n  return {\n    popper: popper,\n    onUpdate: onUpdate\n  };\n} // Runtime check to identify if the render function is the default one; this\n// way we can apply default CSS transitions logic and it can be tree-shaken away\n\nrender.$$tippy = true;\n\nvar idCounter = 1;\nvar mouseMoveListeners = []; // Used by `hideAll()`\n\nvar mountedInstances = [];\nfunction createTippy(reference, passedProps) {\n  var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================\n  //  Private members\n  // ===========================================================================\n\n  var showTimeout;\n  var hideTimeout;\n  var scheduleHideAnimationFrame;\n  var isVisibleFromClick = false;\n  var didHideDueToDocumentMouseDown = false;\n  var didTouchMove = false;\n  var ignoreOnFirstUpdate = false;\n  var lastTriggerEvent;\n  var currentTransitionEndListener;\n  var onFirstUpdate;\n  var listeners = [];\n  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);\n  var currentTarget; // ===========================================================================\n  //  Public members\n  // ===========================================================================\n\n  var id = idCounter++;\n  var popperInstance = null;\n  var plugins = unique(props.plugins);\n  var state = {\n    // Is the instance currently enabled?\n    isEnabled: true,\n    // Is the tippy currently showing and not transitioning out?\n    isVisible: false,\n    // Has the instance been destroyed?\n    isDestroyed: false,\n    // Is the tippy currently mounted to the DOM?\n    isMounted: false,\n    // Has the tippy finished transitioning in?\n    isShown: false\n  };\n  var instance = {\n    // properties\n    id: id,\n    reference: reference,\n    popper: div(),\n    popperInstance: popperInstance,\n    props: props,\n    state: state,\n    plugins: plugins,\n    // methods\n    clearDelayTimeouts: clearDelayTimeouts,\n    setProps: setProps,\n    setContent: setContent,\n    show: show,\n    hide: hide,\n    hideWithInteractivity: hideWithInteractivity,\n    enable: enable,\n    disable: disable,\n    unmount: unmount,\n    destroy: destroy\n  }; // TODO: Investigate why this early return causes a TDZ error in the tests \n  // it doesn't seem to happen in the browser\n\n  /* istanbul ignore if */\n\n  if (!props.render) {\n    if (process.env.NODE_ENV !== \"production\") {\n      errorWhen(true, 'render() function has not been supplied.');\n    }\n\n    return instance;\n  } // ===========================================================================\n  // Initial mutations\n  // ===========================================================================\n\n\n  var _props$render = props.render(instance),\n      popper = _props$render.popper,\n      onUpdate = _props$render.onUpdate;\n\n  popper.setAttribute('data-tippy-root', '');\n  popper.id = \"tippy-\" + instance.id;\n  instance.popper = popper;\n  reference._tippy = instance;\n  popper._tippy = instance;\n  var pluginsHooks = plugins.map(function (plugin) {\n    return plugin.fn(instance);\n  });\n  var hasAriaExpanded = reference.hasAttribute('aria-expanded');\n  addListeners();\n  handleAriaExpandedAttribute();\n  handleStyles();\n  invokeHook('onCreate', [instance]);\n\n  if (props.showOnCreate) {\n    scheduleShow();\n  } // Prevent a tippy with a delay from hiding if the cursor left then returned\n  // before it started hiding\n\n\n  popper.addEventListener('mouseenter', function () {\n    if (instance.props.interactive && instance.state.isVisible) {\n      instance.clearDelayTimeouts();\n    }\n  });\n  popper.addEventListener('mouseleave', function () {\n    if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {\n      getDocument().addEventListener('mousemove', debouncedOnMouseMove);\n    }\n  });\n  return instance; // ===========================================================================\n  //  Private methods\n  // ===========================================================================\n\n  function getNormalizedTouchSettings() {\n    var touch = instance.props.touch;\n    return Array.isArray(touch) ? touch : [touch, 0];\n  }\n\n  function getIsCustomTouchBehavior() {\n    return getNormalizedTouchSettings()[0] === 'hold';\n  }\n\n  function getIsDefaultRenderFn() {\n    var _instance$props$rende;\n\n    // @ts-ignore\n    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);\n  }\n\n  function getCurrentTarget() {\n    return currentTarget || reference;\n  }\n\n  function getDocument() {\n    var parent = getCurrentTarget().parentNode;\n    return parent ? getOwnerDocument(parent) : document;\n  }\n\n  function getDefaultTemplateChildren() {\n    return getChildren(popper);\n  }\n\n  function getDelay(isShow) {\n    // For touch or keyboard input, force `0` delay for UX reasons\n    // Also if the instance is mounted but not visible (transitioning out),\n    // ignore delay\n    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {\n      return 0;\n    }\n\n    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);\n  }\n\n  function handleStyles(fromHide) {\n    if (fromHide === void 0) {\n      fromHide = false;\n    }\n\n    popper.style.pointerEvents = instance.props.interactive && !fromHide ? '' : 'none';\n    popper.style.zIndex = \"\" + instance.props.zIndex;\n  }\n\n  function invokeHook(hook, args, shouldInvokePropsHook) {\n    if (shouldInvokePropsHook === void 0) {\n      shouldInvokePropsHook = true;\n    }\n\n    pluginsHooks.forEach(function (pluginHooks) {\n      if (pluginHooks[hook]) {\n        pluginHooks[hook].apply(pluginHooks, args);\n      }\n    });\n\n    if (shouldInvokePropsHook) {\n      var _instance$props;\n\n      (_instance$props = instance.props)[hook].apply(_instance$props, args);\n    }\n  }\n\n  function handleAriaContentAttribute() {\n    var aria = instance.props.aria;\n\n    if (!aria.content) {\n      return;\n    }\n\n    var attr = \"aria-\" + aria.content;\n    var id = popper.id;\n    var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n    nodes.forEach(function (node) {\n      var currentValue = node.getAttribute(attr);\n\n      if (instance.state.isVisible) {\n        node.setAttribute(attr, currentValue ? currentValue + \" \" + id : id);\n      } else {\n        var nextValue = currentValue && currentValue.replace(id, '').trim();\n\n        if (nextValue) {\n          node.setAttribute(attr, nextValue);\n        } else {\n          node.removeAttribute(attr);\n        }\n      }\n    });\n  }\n\n  function handleAriaExpandedAttribute() {\n    if (hasAriaExpanded || !instance.props.aria.expanded) {\n      return;\n    }\n\n    var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n    nodes.forEach(function (node) {\n      if (instance.props.interactive) {\n        node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');\n      } else {\n        node.removeAttribute('aria-expanded');\n      }\n    });\n  }\n\n  function cleanupInteractiveMouseListeners() {\n    getDocument().removeEventListener('mousemove', debouncedOnMouseMove);\n    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {\n      return listener !== debouncedOnMouseMove;\n    });\n  }\n\n  function onDocumentPress(event) {\n    // Moved finger to scroll instead of an intentional tap outside\n    if (currentInput.isTouch) {\n      if (didTouchMove || event.type === 'mousedown') {\n        return;\n      }\n    }\n\n    var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper\n\n    if (instance.props.interactive && actualContains(popper, actualTarget)) {\n      return;\n    } // Clicked on the event listeners target\n\n\n    if (normalizeToArray(instance.props.triggerTarget || reference).some(function (el) {\n      return actualContains(el, actualTarget);\n    })) {\n      if (currentInput.isTouch) {\n        return;\n      }\n\n      if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {\n        return;\n      }\n    } else {\n      invokeHook('onClickOutside', [instance, event]);\n    }\n\n    if (instance.props.hideOnClick === true) {\n      instance.clearDelayTimeouts();\n      instance.hide(); // `mousedown` event is fired right before `focus` if pressing the\n      // currentTarget. This lets a tippy with `focus` trigger know that it\n      // should not show\n\n      didHideDueToDocumentMouseDown = true;\n      setTimeout(function () {\n        didHideDueToDocumentMouseDown = false;\n      }); // The listener gets added in `scheduleShow()`, but this may be hiding it\n      // before it shows, and hide()'s early bail-out behavior can prevent it\n      // from being cleaned up\n\n      if (!instance.state.isMounted) {\n        removeDocumentPress();\n      }\n    }\n  }\n\n  function onTouchMove() {\n    didTouchMove = true;\n  }\n\n  function onTouchStart() {\n    didTouchMove = false;\n  }\n\n  function addDocumentPress() {\n    var doc = getDocument();\n    doc.addEventListener('mousedown', onDocumentPress, true);\n    doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);\n    doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);\n    doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);\n  }\n\n  function removeDocumentPress() {\n    var doc = getDocument();\n    doc.removeEventListener('mousedown', onDocumentPress, true);\n    doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);\n    doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);\n    doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);\n  }\n\n  function onTransitionedOut(duration, callback) {\n    onTransitionEnd(duration, function () {\n      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {\n        callback();\n      }\n    });\n  }\n\n  function onTransitionedIn(duration, callback) {\n    onTransitionEnd(duration, callback);\n  }\n\n  function onTransitionEnd(duration, callback) {\n    var box = getDefaultTemplateChildren().box;\n\n    function listener(event) {\n      if (event.target === box) {\n        updateTransitionEndListener(box, 'remove', listener);\n        callback();\n      }\n    } // Make callback synchronous if duration is 0\n    // `transitionend` won't fire otherwise\n\n\n    if (duration === 0) {\n      return callback();\n    }\n\n    updateTransitionEndListener(box, 'remove', currentTransitionEndListener);\n    updateTransitionEndListener(box, 'add', listener);\n    currentTransitionEndListener = listener;\n  }\n\n  function on(eventType, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n\n    var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n    nodes.forEach(function (node) {\n      node.addEventListener(eventType, handler, options);\n      listeners.push({\n        node: node,\n        eventType: eventType,\n        handler: handler,\n        options: options\n      });\n    });\n  }\n\n  function addListeners() {\n    if (getIsCustomTouchBehavior()) {\n      on('touchstart', onTrigger, {\n        passive: true\n      });\n      on('touchend', onMouseLeave, {\n        passive: true\n      });\n    }\n\n    splitBySpaces(instance.props.trigger).forEach(function (eventType) {\n      if (eventType === 'manual') {\n        return;\n      }\n\n      on(eventType, onTrigger);\n\n      switch (eventType) {\n        case 'mouseenter':\n          on('mouseleave', onMouseLeave);\n          break;\n\n        case 'focus':\n          on(isIE11 ? 'focusout' : 'blur', onBlurOrFocusOut);\n          break;\n\n        case 'focusin':\n          on('focusout', onBlurOrFocusOut);\n          break;\n      }\n    });\n  }\n\n  function removeListeners() {\n    listeners.forEach(function (_ref) {\n      var node = _ref.node,\n          eventType = _ref.eventType,\n          handler = _ref.handler,\n          options = _ref.options;\n      node.removeEventListener(eventType, handler, options);\n    });\n    listeners = [];\n  }\n\n  function onTrigger(event) {\n    var _lastTriggerEvent;\n\n    var shouldScheduleClickHide = false;\n\n    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {\n      return;\n    }\n\n    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';\n    lastTriggerEvent = event;\n    currentTarget = event.currentTarget;\n    handleAriaExpandedAttribute();\n\n    if (!instance.state.isVisible && isMouseEvent(event)) {\n      // If scrolling, `mouseenter` events can be fired if the cursor lands\n      // over a new target, but `mousemove` events don't get fired. This\n      // causes interactive tooltips to get stuck open until the cursor is\n      // moved\n      mouseMoveListeners.forEach(function (listener) {\n        return listener(event);\n      });\n    } // Toggle show/hide when clicking click-triggered tooltips\n\n\n    if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {\n      shouldScheduleClickHide = true;\n    } else {\n      scheduleShow(event);\n    }\n\n    if (event.type === 'click') {\n      isVisibleFromClick = !shouldScheduleClickHide;\n    }\n\n    if (shouldScheduleClickHide && !wasFocused) {\n      scheduleHide(event);\n    }\n  }\n\n  function onMouseMove(event) {\n    var target = event.target;\n    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);\n\n    if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {\n      return;\n    }\n\n    var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {\n      var _instance$popperInsta;\n\n      var instance = popper._tippy;\n      var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;\n\n      if (state) {\n        return {\n          popperRect: popper.getBoundingClientRect(),\n          popperState: state,\n          props: props\n        };\n      }\n\n      return null;\n    }).filter(Boolean);\n\n    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {\n      cleanupInteractiveMouseListeners();\n      scheduleHide(event);\n    }\n  }\n\n  function onMouseLeave(event) {\n    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;\n\n    if (shouldBail) {\n      return;\n    }\n\n    if (instance.props.interactive) {\n      instance.hideWithInteractivity(event);\n      return;\n    }\n\n    scheduleHide(event);\n  }\n\n  function onBlurOrFocusOut(event) {\n    if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {\n      return;\n    } // If focus was moved to within the popper\n\n\n    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {\n      return;\n    }\n\n    scheduleHide(event);\n  }\n\n  function isEventListenerStopped(event) {\n    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;\n  }\n\n  function createPopperInstance() {\n    destroyPopperInstance();\n    var _instance$props2 = instance.props,\n        popperOptions = _instance$props2.popperOptions,\n        placement = _instance$props2.placement,\n        offset = _instance$props2.offset,\n        getReferenceClientRect = _instance$props2.getReferenceClientRect,\n        moveTransition = _instance$props2.moveTransition;\n    var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;\n    var computedReference = getReferenceClientRect ? {\n      getBoundingClientRect: getReferenceClientRect,\n      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()\n    } : reference;\n    var tippyModifier = {\n      name: '$$tippy',\n      enabled: true,\n      phase: 'beforeWrite',\n      requires: ['computeStyles'],\n      fn: function fn(_ref2) {\n        var state = _ref2.state;\n\n        if (getIsDefaultRenderFn()) {\n          var _getDefaultTemplateCh = getDefaultTemplateChildren(),\n              box = _getDefaultTemplateCh.box;\n\n          ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {\n            if (attr === 'placement') {\n              box.setAttribute('data-placement', state.placement);\n            } else {\n              if (state.attributes.popper[\"data-popper-\" + attr]) {\n                box.setAttribute(\"data-\" + attr, '');\n              } else {\n                box.removeAttribute(\"data-\" + attr);\n              }\n            }\n          });\n          state.attributes.popper = {};\n        }\n      }\n    };\n    var modifiers = [{\n      name: 'offset',\n      options: {\n        offset: offset\n      }\n    }, {\n      name: 'preventOverflow',\n      options: {\n        padding: {\n          top: 2,\n          bottom: 2,\n          left: 5,\n          right: 5\n        }\n      }\n    }, {\n      name: 'flip',\n      options: {\n        padding: 5\n      }\n    }, {\n      name: 'computeStyles',\n      options: {\n        adaptive: !moveTransition\n      }\n    }, tippyModifier];\n\n    if (getIsDefaultRenderFn() && arrow) {\n      modifiers.push({\n        name: 'arrow',\n        options: {\n          element: arrow,\n          padding: 3\n        }\n      });\n    }\n\n    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);\n    instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {\n      placement: placement,\n      onFirstUpdate: onFirstUpdate,\n      modifiers: modifiers\n    }));\n  }\n\n  function destroyPopperInstance() {\n    if (instance.popperInstance) {\n      instance.popperInstance.destroy();\n      instance.popperInstance = null;\n    }\n  }\n\n  function mount() {\n    var appendTo = instance.props.appendTo;\n    var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so\n    // it's directly after the reference element so the elements inside the\n    // tippy can be tabbed to\n    // If there are clipping issues, the user can specify a different appendTo\n    // and ensure focus management is handled correctly manually\n\n    var node = getCurrentTarget();\n\n    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === 'parent') {\n      parentNode = node.parentNode;\n    } else {\n      parentNode = invokeWithArgsOrReturn(appendTo, [node]);\n    } // The popper element needs to exist on the DOM before its position can be\n    // updated as Popper needs to read its dimensions\n\n\n    if (!parentNode.contains(popper)) {\n      parentNode.appendChild(popper);\n    }\n\n    instance.state.isMounted = true;\n    createPopperInstance();\n    /* istanbul ignore else */\n\n    if (process.env.NODE_ENV !== \"production\") {\n      // Accessibility check\n      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard', 'navigation because it is not directly after the reference element', 'in the DOM source order.', '\\n\\n', 'Using a wrapper <div> or <span> tag around the reference element', 'solves this by creating a new parentNode context.', '\\n\\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle', 'keyboard navigation.', '\\n\\n', 'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity'].join(' '));\n    }\n  }\n\n  function getNestedPopperTree() {\n    return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));\n  }\n\n  function scheduleShow(event) {\n    instance.clearDelayTimeouts();\n\n    if (event) {\n      invokeHook('onTrigger', [instance, event]);\n    }\n\n    addDocumentPress();\n    var delay = getDelay(true);\n\n    var _getNormalizedTouchSe = getNormalizedTouchSettings(),\n        touchValue = _getNormalizedTouchSe[0],\n        touchDelay = _getNormalizedTouchSe[1];\n\n    if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {\n      delay = touchDelay;\n    }\n\n    if (delay) {\n      showTimeout = setTimeout(function () {\n        instance.show();\n      }, delay);\n    } else {\n      instance.show();\n    }\n  }\n\n  function scheduleHide(event) {\n    instance.clearDelayTimeouts();\n    invokeHook('onUntrigger', [instance, event]);\n\n    if (!instance.state.isVisible) {\n      removeDocumentPress();\n      return;\n    } // For interactive tippies, scheduleHide is added to a document.body handler\n    // from onMouseLeave so must intercept scheduled hides from mousemove/leave\n    // events when trigger contains mouseenter and click, and the tip is\n    // currently shown as a result of a click.\n\n\n    if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {\n      return;\n    }\n\n    var delay = getDelay(false);\n\n    if (delay) {\n      hideTimeout = setTimeout(function () {\n        if (instance.state.isVisible) {\n          instance.hide();\n        }\n      }, delay);\n    } else {\n      // Fixes a `transitionend` problem when it fires 1 frame too\n      // late sometimes, we don't want hide() to be called.\n      scheduleHideAnimationFrame = requestAnimationFrame(function () {\n        instance.hide();\n      });\n    }\n  } // ===========================================================================\n  //  Public methods\n  // ===========================================================================\n\n\n  function enable() {\n    instance.state.isEnabled = true;\n  }\n\n  function disable() {\n    // Disabling the instance should also hide it\n    // https://github.com/atomiks/tippy.js-react/issues/106\n    instance.hide();\n    instance.state.isEnabled = false;\n  }\n\n  function clearDelayTimeouts() {\n    clearTimeout(showTimeout);\n    clearTimeout(hideTimeout);\n    cancelAnimationFrame(scheduleHideAnimationFrame);\n  }\n\n  function setProps(partialProps) {\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));\n    }\n\n    if (instance.state.isDestroyed) {\n      return;\n    }\n\n    invokeHook('onBeforeUpdate', [instance, partialProps]);\n    removeListeners();\n    var prevProps = instance.props;\n    var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {\n      ignoreAttributes: true\n    }));\n    instance.props = nextProps;\n    addListeners();\n\n    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {\n      cleanupInteractiveMouseListeners();\n      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);\n    } // Ensure stale aria-expanded attributes are removed\n\n\n    if (prevProps.triggerTarget && !nextProps.triggerTarget) {\n      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {\n        node.removeAttribute('aria-expanded');\n      });\n    } else if (nextProps.triggerTarget) {\n      reference.removeAttribute('aria-expanded');\n    }\n\n    handleAriaExpandedAttribute();\n    handleStyles();\n\n    if (onUpdate) {\n      onUpdate(prevProps, nextProps);\n    }\n\n    if (instance.popperInstance) {\n      createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,\n      // and the nested ones get re-rendered first.\n      // https://github.com/atomiks/tippyjs-react/issues/177\n      // TODO: find a cleaner / more efficient solution(!)\n\n      getNestedPopperTree().forEach(function (nestedPopper) {\n        // React (and other UI libs likely) requires a rAF wrapper as it flushes\n        // its work in one\n        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);\n      });\n    }\n\n    invokeHook('onAfterUpdate', [instance, partialProps]);\n  }\n\n  function setContent(content) {\n    instance.setProps({\n      content: content\n    });\n  }\n\n  function show() {\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));\n    } // Early bail-out\n\n\n    var isAlreadyVisible = instance.state.isVisible;\n    var isDestroyed = instance.state.isDestroyed;\n    var isDisabled = !instance.state.isEnabled;\n    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;\n    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);\n\n    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {\n      return;\n    } // Normalize `disabled` behavior across browsers.\n    // Firefox allows events on disabled elements, but Chrome doesn't.\n    // Using a wrapper element (i.e. <span>) is recommended.\n\n\n    if (getCurrentTarget().hasAttribute('disabled')) {\n      return;\n    }\n\n    invokeHook('onShow', [instance], false);\n\n    if (instance.props.onShow(instance) === false) {\n      return;\n    }\n\n    instance.state.isVisible = true;\n\n    if (getIsDefaultRenderFn()) {\n      popper.style.visibility = 'visible';\n    }\n\n    handleStyles();\n    addDocumentPress();\n\n    if (!instance.state.isMounted) {\n      popper.style.transition = 'none';\n    } // If flipping to the opposite side after hiding at least once, the\n    // animation will use the wrong placement without resetting the duration\n\n\n    if (getIsDefaultRenderFn()) {\n      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),\n          box = _getDefaultTemplateCh2.box,\n          content = _getDefaultTemplateCh2.content;\n\n      setTransitionDuration([box, content], 0);\n    }\n\n    onFirstUpdate = function onFirstUpdate() {\n      var _instance$popperInsta2;\n\n      if (!instance.state.isVisible || ignoreOnFirstUpdate) {\n        return;\n      }\n\n      ignoreOnFirstUpdate = true; // reflow\n\n      void popper.offsetHeight;\n      popper.style.transition = instance.props.moveTransition;\n\n      if (getIsDefaultRenderFn() && instance.props.animation) {\n        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),\n            _box = _getDefaultTemplateCh3.box,\n            _content = _getDefaultTemplateCh3.content;\n\n        setTransitionDuration([_box, _content], duration);\n        setVisibilityState([_box, _content], 'visible');\n      }\n\n      handleAriaContentAttribute();\n      handleAriaExpandedAttribute();\n      pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the\n      // popper has been positioned for the first time\n\n      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();\n      invokeHook('onMount', [instance]);\n\n      if (instance.props.animation && getIsDefaultRenderFn()) {\n        onTransitionedIn(duration, function () {\n          instance.state.isShown = true;\n          invokeHook('onShown', [instance]);\n        });\n      }\n    };\n\n    mount();\n  }\n\n  function hide() {\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));\n    } // Early bail-out\n\n\n    var isAlreadyHidden = !instance.state.isVisible;\n    var isDestroyed = instance.state.isDestroyed;\n    var isDisabled = !instance.state.isEnabled;\n    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);\n\n    if (isAlreadyHidden || isDestroyed || isDisabled) {\n      return;\n    }\n\n    invokeHook('onHide', [instance], false);\n\n    if (instance.props.onHide(instance) === false) {\n      return;\n    }\n\n    instance.state.isVisible = false;\n    instance.state.isShown = false;\n    ignoreOnFirstUpdate = false;\n    isVisibleFromClick = false;\n\n    if (getIsDefaultRenderFn()) {\n      popper.style.visibility = 'hidden';\n    }\n\n    cleanupInteractiveMouseListeners();\n    removeDocumentPress();\n    handleStyles(true);\n\n    if (getIsDefaultRenderFn()) {\n      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),\n          box = _getDefaultTemplateCh4.box,\n          content = _getDefaultTemplateCh4.content;\n\n      if (instance.props.animation) {\n        setTransitionDuration([box, content], duration);\n        setVisibilityState([box, content], 'hidden');\n      }\n    }\n\n    handleAriaContentAttribute();\n    handleAriaExpandedAttribute();\n\n    if (instance.props.animation) {\n      if (getIsDefaultRenderFn()) {\n        onTransitionedOut(duration, instance.unmount);\n      }\n    } else {\n      instance.unmount();\n    }\n  }\n\n  function hideWithInteractivity(event) {\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));\n    }\n\n    getDocument().addEventListener('mousemove', debouncedOnMouseMove);\n    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);\n    debouncedOnMouseMove(event);\n  }\n\n  function unmount() {\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));\n    }\n\n    if (instance.state.isVisible) {\n      instance.hide();\n    }\n\n    if (!instance.state.isMounted) {\n      return;\n    }\n\n    destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper\n    // tree by default. This seems mainly for interactive tippies, but we should\n    // find a workaround if possible\n\n    getNestedPopperTree().forEach(function (nestedPopper) {\n      nestedPopper._tippy.unmount();\n    });\n\n    if (popper.parentNode) {\n      popper.parentNode.removeChild(popper);\n    }\n\n    mountedInstances = mountedInstances.filter(function (i) {\n      return i !== instance;\n    });\n    instance.state.isMounted = false;\n    invokeHook('onHidden', [instance]);\n  }\n\n  function destroy() {\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));\n    }\n\n    if (instance.state.isDestroyed) {\n      return;\n    }\n\n    instance.clearDelayTimeouts();\n    instance.unmount();\n    removeListeners();\n    delete reference._tippy;\n    instance.state.isDestroyed = true;\n    invokeHook('onDestroy', [instance]);\n  }\n}\n\nfunction tippy(targets, optionalProps) {\n  if (optionalProps === void 0) {\n    optionalProps = {};\n  }\n\n  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);\n  /* istanbul ignore else */\n\n  if (process.env.NODE_ENV !== \"production\") {\n    validateTargets(targets);\n    validateProps(optionalProps, plugins);\n  }\n\n  bindGlobalEventListeners();\n  var passedProps = Object.assign({}, optionalProps, {\n    plugins: plugins\n  });\n  var elements = getArrayOfElements(targets);\n  /* istanbul ignore else */\n\n  if (process.env.NODE_ENV !== \"production\") {\n    var isSingleContentElement = isElement(passedProps.content);\n    var isMoreThanOneReferenceElement = elements.length > 1;\n    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than', 'one tippy instance was created by this invocation. This means the', 'content element will only be appended to the last tippy instance.', '\\n\\n', 'Instead, pass the .innerHTML of the element, or use a function that', 'returns a cloned version of the element instead.', '\\n\\n', '1) content: element.innerHTML\\n', '2) content: () => element.cloneNode(true)'].join(' '));\n  }\n\n  var instances = elements.reduce(function (acc, reference) {\n    var instance = reference && createTippy(reference, passedProps);\n\n    if (instance) {\n      acc.push(instance);\n    }\n\n    return acc;\n  }, []);\n  return isElement(targets) ? instances[0] : instances;\n}\n\ntippy.defaultProps = defaultProps;\ntippy.setDefaultProps = setDefaultProps;\ntippy.currentInput = currentInput;\nvar hideAll = function hideAll(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      excludedReferenceOrInstance = _ref.exclude,\n      duration = _ref.duration;\n\n  mountedInstances.forEach(function (instance) {\n    var isExcluded = false;\n\n    if (excludedReferenceOrInstance) {\n      isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;\n    }\n\n    if (!isExcluded) {\n      var originalDuration = instance.props.duration;\n      instance.setProps({\n        duration: duration\n      });\n      instance.hide();\n\n      if (!instance.state.isDestroyed) {\n        instance.setProps({\n          duration: originalDuration\n        });\n      }\n    }\n  });\n};\n\n// every time the popper is destroyed (i.e. a new target), removing the styles\n// and causing transitions to break for singletons when the console is open, but\n// most notably for non-transform styles being used, `gpuAcceleration: false`.\n\nvar applyStylesModifier = Object.assign({}, applyStyles, {\n  effect: function effect(_ref) {\n    var state = _ref.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: '0',\n        top: '0',\n        margin: '0'\n      },\n      arrow: {\n        position: 'absolute'\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    } // intentionally return no cleanup function\n    // return () => { ... }\n\n  }\n});\n\nvar createSingleton = function createSingleton(tippyInstances, optionalProps) {\n  var _optionalProps$popper;\n\n  if (optionalProps === void 0) {\n    optionalProps = {};\n  }\n\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    errorWhen(!Array.isArray(tippyInstances), ['The first argument passed to createSingleton() must be an array of', 'tippy instances. The passed value was', String(tippyInstances)].join(' '));\n  }\n\n  var individualInstances = tippyInstances;\n  var references = [];\n  var triggerTargets = [];\n  var currentTarget;\n  var overrides = optionalProps.overrides;\n  var interceptSetPropsCleanups = [];\n  var shownOnCreate = false;\n\n  function setTriggerTargets() {\n    triggerTargets = individualInstances.map(function (instance) {\n      return normalizeToArray(instance.props.triggerTarget || instance.reference);\n    }).reduce(function (acc, item) {\n      return acc.concat(item);\n    }, []);\n  }\n\n  function setReferences() {\n    references = individualInstances.map(function (instance) {\n      return instance.reference;\n    });\n  }\n\n  function enableInstances(isEnabled) {\n    individualInstances.forEach(function (instance) {\n      if (isEnabled) {\n        instance.enable();\n      } else {\n        instance.disable();\n      }\n    });\n  }\n\n  function interceptSetProps(singleton) {\n    return individualInstances.map(function (instance) {\n      var originalSetProps = instance.setProps;\n\n      instance.setProps = function (props) {\n        originalSetProps(props);\n\n        if (instance.reference === currentTarget) {\n          singleton.setProps(props);\n        }\n      };\n\n      return function () {\n        instance.setProps = originalSetProps;\n      };\n    });\n  } // have to pass singleton, as it maybe undefined on first call\n\n\n  function prepareInstance(singleton, target) {\n    var index = triggerTargets.indexOf(target); // bail-out\n\n    if (target === currentTarget) {\n      return;\n    }\n\n    currentTarget = target;\n    var overrideProps = (overrides || []).concat('content').reduce(function (acc, prop) {\n      acc[prop] = individualInstances[index].props[prop];\n      return acc;\n    }, {});\n    singleton.setProps(Object.assign({}, overrideProps, {\n      getReferenceClientRect: typeof overrideProps.getReferenceClientRect === 'function' ? overrideProps.getReferenceClientRect : function () {\n        var _references$index;\n\n        return (_references$index = references[index]) == null ? void 0 : _references$index.getBoundingClientRect();\n      }\n    }));\n  }\n\n  enableInstances(false);\n  setReferences();\n  setTriggerTargets();\n  var plugin = {\n    fn: function fn() {\n      return {\n        onDestroy: function onDestroy() {\n          enableInstances(true);\n        },\n        onHidden: function onHidden() {\n          currentTarget = null;\n        },\n        onClickOutside: function onClickOutside(instance) {\n          if (instance.props.showOnCreate && !shownOnCreate) {\n            shownOnCreate = true;\n            currentTarget = null;\n          }\n        },\n        onShow: function onShow(instance) {\n          if (instance.props.showOnCreate && !shownOnCreate) {\n            shownOnCreate = true;\n            prepareInstance(instance, references[0]);\n          }\n        },\n        onTrigger: function onTrigger(instance, event) {\n          prepareInstance(instance, event.currentTarget);\n        }\n      };\n    }\n  };\n  var singleton = tippy(div(), Object.assign({}, removeProperties(optionalProps, ['overrides']), {\n    plugins: [plugin].concat(optionalProps.plugins || []),\n    triggerTarget: triggerTargets,\n    popperOptions: Object.assign({}, optionalProps.popperOptions, {\n      modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [applyStylesModifier])\n    })\n  }));\n  var originalShow = singleton.show;\n\n  singleton.show = function (target) {\n    originalShow(); // first time, showOnCreate or programmatic call with no params\n    // default to showing first instance\n\n    if (!currentTarget && target == null) {\n      return prepareInstance(singleton, references[0]);\n    } // triggered from event (do nothing as prepareInstance already called by onTrigger)\n    // programmatic call with no params when already visible (do nothing again)\n\n\n    if (currentTarget && target == null) {\n      return;\n    } // target is index of instance\n\n\n    if (typeof target === 'number') {\n      return references[target] && prepareInstance(singleton, references[target]);\n    } // target is a child tippy instance\n\n\n    if (individualInstances.indexOf(target) >= 0) {\n      var ref = target.reference;\n      return prepareInstance(singleton, ref);\n    } // target is a ReferenceElement\n\n\n    if (references.indexOf(target) >= 0) {\n      return prepareInstance(singleton, target);\n    }\n  };\n\n  singleton.showNext = function () {\n    var first = references[0];\n\n    if (!currentTarget) {\n      return singleton.show(0);\n    }\n\n    var index = references.indexOf(currentTarget);\n    singleton.show(references[index + 1] || first);\n  };\n\n  singleton.showPrevious = function () {\n    var last = references[references.length - 1];\n\n    if (!currentTarget) {\n      return singleton.show(last);\n    }\n\n    var index = references.indexOf(currentTarget);\n    var target = references[index - 1] || last;\n    singleton.show(target);\n  };\n\n  var originalSetProps = singleton.setProps;\n\n  singleton.setProps = function (props) {\n    overrides = props.overrides || overrides;\n    originalSetProps(props);\n  };\n\n  singleton.setInstances = function (nextInstances) {\n    enableInstances(true);\n    interceptSetPropsCleanups.forEach(function (fn) {\n      return fn();\n    });\n    individualInstances = nextInstances;\n    enableInstances(false);\n    setReferences();\n    setTriggerTargets();\n    interceptSetPropsCleanups = interceptSetProps(singleton);\n    singleton.setProps({\n      triggerTarget: triggerTargets\n    });\n  };\n\n  interceptSetPropsCleanups = interceptSetProps(singleton);\n  return singleton;\n};\n\nvar BUBBLING_EVENTS_MAP = {\n  mouseover: 'mouseenter',\n  focusin: 'focus',\n  click: 'click'\n};\n/**\n * Creates a delegate instance that controls the creation of tippy instances\n * for child elements (`target` CSS selector).\n */\n\nfunction delegate(targets, props) {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    errorWhen(!(props && props.target), ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' '));\n  }\n\n  var listeners = [];\n  var childTippyInstances = [];\n  var disabled = false;\n  var target = props.target;\n  var nativeProps = removeProperties(props, ['target']);\n  var parentProps = Object.assign({}, nativeProps, {\n    trigger: 'manual',\n    touch: false\n  });\n  var childProps = Object.assign({\n    touch: defaultProps.touch\n  }, nativeProps, {\n    showOnCreate: true\n  });\n  var returnValue = tippy(targets, parentProps);\n  var normalizedReturnValue = normalizeToArray(returnValue);\n\n  function onTrigger(event) {\n    if (!event.target || disabled) {\n      return;\n    }\n\n    var targetNode = event.target.closest(target);\n\n    if (!targetNode) {\n      return;\n    } // Get relevant trigger with fallbacks:\n    // 1. Check `data-tippy-trigger` attribute on target node\n    // 2. Fallback to `trigger` passed to `delegate()`\n    // 3. Fallback to `defaultProps.trigger`\n\n\n    var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || defaultProps.trigger; // @ts-ignore\n\n    if (targetNode._tippy) {\n      return;\n    }\n\n    if (event.type === 'touchstart' && typeof childProps.touch === 'boolean') {\n      return;\n    }\n\n    if (event.type !== 'touchstart' && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type]) < 0) {\n      return;\n    }\n\n    var instance = tippy(targetNode, childProps);\n\n    if (instance) {\n      childTippyInstances = childTippyInstances.concat(instance);\n    }\n  }\n\n  function on(node, eventType, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n\n    node.addEventListener(eventType, handler, options);\n    listeners.push({\n      node: node,\n      eventType: eventType,\n      handler: handler,\n      options: options\n    });\n  }\n\n  function addEventListeners(instance) {\n    var reference = instance.reference;\n    on(reference, 'touchstart', onTrigger, TOUCH_OPTIONS);\n    on(reference, 'mouseover', onTrigger);\n    on(reference, 'focusin', onTrigger);\n    on(reference, 'click', onTrigger);\n  }\n\n  function removeEventListeners() {\n    listeners.forEach(function (_ref) {\n      var node = _ref.node,\n          eventType = _ref.eventType,\n          handler = _ref.handler,\n          options = _ref.options;\n      node.removeEventListener(eventType, handler, options);\n    });\n    listeners = [];\n  }\n\n  function applyMutations(instance) {\n    var originalDestroy = instance.destroy;\n    var originalEnable = instance.enable;\n    var originalDisable = instance.disable;\n\n    instance.destroy = function (shouldDestroyChildInstances) {\n      if (shouldDestroyChildInstances === void 0) {\n        shouldDestroyChildInstances = true;\n      }\n\n      if (shouldDestroyChildInstances) {\n        childTippyInstances.forEach(function (instance) {\n          instance.destroy();\n        });\n      }\n\n      childTippyInstances = [];\n      removeEventListeners();\n      originalDestroy();\n    };\n\n    instance.enable = function () {\n      originalEnable();\n      childTippyInstances.forEach(function (instance) {\n        return instance.enable();\n      });\n      disabled = false;\n    };\n\n    instance.disable = function () {\n      originalDisable();\n      childTippyInstances.forEach(function (instance) {\n        return instance.disable();\n      });\n      disabled = true;\n    };\n\n    addEventListeners(instance);\n  }\n\n  normalizedReturnValue.forEach(applyMutations);\n  return returnValue;\n}\n\nvar animateFill = {\n  name: 'animateFill',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var _instance$props$rende;\n\n    // @ts-ignore\n    if (!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        errorWhen(instance.props.animateFill, 'The `animateFill` plugin requires the default render function.');\n      }\n\n      return {};\n    }\n\n    var _getChildren = getChildren(instance.popper),\n        box = _getChildren.box,\n        content = _getChildren.content;\n\n    var backdrop = instance.props.animateFill ? createBackdropElement() : null;\n    return {\n      onCreate: function onCreate() {\n        if (backdrop) {\n          box.insertBefore(backdrop, box.firstElementChild);\n          box.setAttribute('data-animatefill', '');\n          box.style.overflow = 'hidden';\n          instance.setProps({\n            arrow: false,\n            animation: 'shift-away'\n          });\n        }\n      },\n      onMount: function onMount() {\n        if (backdrop) {\n          var transitionDuration = box.style.transitionDuration;\n          var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the\n          // tooltip element. `clip-path` is the other alternative but is not\n          // well-supported and is buggy on some devices.\n\n          content.style.transitionDelay = Math.round(duration / 10) + \"ms\";\n          backdrop.style.transitionDuration = transitionDuration;\n          setVisibilityState([backdrop], 'visible');\n        }\n      },\n      onShow: function onShow() {\n        if (backdrop) {\n          backdrop.style.transitionDuration = '0ms';\n        }\n      },\n      onHide: function onHide() {\n        if (backdrop) {\n          setVisibilityState([backdrop], 'hidden');\n        }\n      }\n    };\n  }\n};\n\nfunction createBackdropElement() {\n  var backdrop = div();\n  backdrop.className = BACKDROP_CLASS;\n  setVisibilityState([backdrop], 'hidden');\n  return backdrop;\n}\n\nvar mouseCoords = {\n  clientX: 0,\n  clientY: 0\n};\nvar activeInstances = [];\n\nfunction storeMouseCoords(_ref) {\n  var clientX = _ref.clientX,\n      clientY = _ref.clientY;\n  mouseCoords = {\n    clientX: clientX,\n    clientY: clientY\n  };\n}\n\nfunction addMouseCoordsListener(doc) {\n  doc.addEventListener('mousemove', storeMouseCoords);\n}\n\nfunction removeMouseCoordsListener(doc) {\n  doc.removeEventListener('mousemove', storeMouseCoords);\n}\n\nvar followCursor = {\n  name: 'followCursor',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference;\n    var doc = getOwnerDocument(instance.props.triggerTarget || reference);\n    var isInternalUpdate = false;\n    var wasFocusEvent = false;\n    var isUnmounted = true;\n    var prevProps = instance.props;\n\n    function getIsInitialBehavior() {\n      return instance.props.followCursor === 'initial' && instance.state.isVisible;\n    }\n\n    function addListener() {\n      doc.addEventListener('mousemove', onMouseMove);\n    }\n\n    function removeListener() {\n      doc.removeEventListener('mousemove', onMouseMove);\n    }\n\n    function unsetGetReferenceClientRect() {\n      isInternalUpdate = true;\n      instance.setProps({\n        getReferenceClientRect: null\n      });\n      isInternalUpdate = false;\n    }\n\n    function onMouseMove(event) {\n      // If the instance is interactive, avoid updating the position unless it's\n      // over the reference element\n      var isCursorOverReference = event.target ? reference.contains(event.target) : true;\n      var followCursor = instance.props.followCursor;\n      var clientX = event.clientX,\n          clientY = event.clientY;\n      var rect = reference.getBoundingClientRect();\n      var relativeX = clientX - rect.left;\n      var relativeY = clientY - rect.top;\n\n      if (isCursorOverReference || !instance.props.interactive) {\n        instance.setProps({\n          // @ts-ignore - unneeded DOMRect properties\n          getReferenceClientRect: function getReferenceClientRect() {\n            var rect = reference.getBoundingClientRect();\n            var x = clientX;\n            var y = clientY;\n\n            if (followCursor === 'initial') {\n              x = rect.left + relativeX;\n              y = rect.top + relativeY;\n            }\n\n            var top = followCursor === 'horizontal' ? rect.top : y;\n            var right = followCursor === 'vertical' ? rect.right : x;\n            var bottom = followCursor === 'horizontal' ? rect.bottom : y;\n            var left = followCursor === 'vertical' ? rect.left : x;\n            return {\n              width: right - left,\n              height: bottom - top,\n              top: top,\n              right: right,\n              bottom: bottom,\n              left: left\n            };\n          }\n        });\n      }\n    }\n\n    function create() {\n      if (instance.props.followCursor) {\n        activeInstances.push({\n          instance: instance,\n          doc: doc\n        });\n        addMouseCoordsListener(doc);\n      }\n    }\n\n    function destroy() {\n      activeInstances = activeInstances.filter(function (data) {\n        return data.instance !== instance;\n      });\n\n      if (activeInstances.filter(function (data) {\n        return data.doc === doc;\n      }).length === 0) {\n        removeMouseCoordsListener(doc);\n      }\n    }\n\n    return {\n      onCreate: create,\n      onDestroy: destroy,\n      onBeforeUpdate: function onBeforeUpdate() {\n        prevProps = instance.props;\n      },\n      onAfterUpdate: function onAfterUpdate(_, _ref2) {\n        var followCursor = _ref2.followCursor;\n\n        if (isInternalUpdate) {\n          return;\n        }\n\n        if (followCursor !== undefined && prevProps.followCursor !== followCursor) {\n          destroy();\n\n          if (followCursor) {\n            create();\n\n            if (instance.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) {\n              addListener();\n            }\n          } else {\n            removeListener();\n            unsetGetReferenceClientRect();\n          }\n        }\n      },\n      onMount: function onMount() {\n        if (instance.props.followCursor && !wasFocusEvent) {\n          if (isUnmounted) {\n            onMouseMove(mouseCoords);\n            isUnmounted = false;\n          }\n\n          if (!getIsInitialBehavior()) {\n            addListener();\n          }\n        }\n      },\n      onTrigger: function onTrigger(_, event) {\n        if (isMouseEvent(event)) {\n          mouseCoords = {\n            clientX: event.clientX,\n            clientY: event.clientY\n          };\n        }\n\n        wasFocusEvent = event.type === 'focus';\n      },\n      onHidden: function onHidden() {\n        if (instance.props.followCursor) {\n          unsetGetReferenceClientRect();\n          removeListener();\n          isUnmounted = true;\n        }\n      }\n    };\n  }\n};\n\nfunction getProps(props, modifier) {\n  var _props$popperOptions;\n\n  return {\n    popperOptions: Object.assign({}, props.popperOptions, {\n      modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function (_ref) {\n        var name = _ref.name;\n        return name !== modifier.name;\n      }), [modifier])\n    })\n  };\n}\n\nvar inlinePositioning = {\n  name: 'inlinePositioning',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference;\n\n    function isEnabled() {\n      return !!instance.props.inlinePositioning;\n    }\n\n    var placement;\n    var cursorRectIndex = -1;\n    var isInternalUpdate = false;\n    var triedPlacements = [];\n    var modifier = {\n      name: 'tippyInlinePositioning',\n      enabled: true,\n      phase: 'afterWrite',\n      fn: function fn(_ref2) {\n        var state = _ref2.state;\n\n        if (isEnabled()) {\n          if (triedPlacements.indexOf(state.placement) !== -1) {\n            triedPlacements = [];\n          }\n\n          if (placement !== state.placement && triedPlacements.indexOf(state.placement) === -1) {\n            triedPlacements.push(state.placement);\n            instance.setProps({\n              // @ts-ignore - unneeded DOMRect properties\n              getReferenceClientRect: function getReferenceClientRect() {\n                return _getReferenceClientRect(state.placement);\n              }\n            });\n          }\n\n          placement = state.placement;\n        }\n      }\n    };\n\n    function _getReferenceClientRect(placement) {\n      return getInlineBoundingClientRect(getBasePlacement(placement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);\n    }\n\n    function setInternalProps(partialProps) {\n      isInternalUpdate = true;\n      instance.setProps(partialProps);\n      isInternalUpdate = false;\n    }\n\n    function addModifier() {\n      if (!isInternalUpdate) {\n        setInternalProps(getProps(instance.props, modifier));\n      }\n    }\n\n    return {\n      onCreate: addModifier,\n      onAfterUpdate: addModifier,\n      onTrigger: function onTrigger(_, event) {\n        if (isMouseEvent(event)) {\n          var rects = arrayFrom(instance.reference.getClientRects());\n          var cursorRect = rects.find(function (rect) {\n            return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;\n          });\n          var index = rects.indexOf(cursorRect);\n          cursorRectIndex = index > -1 ? index : cursorRectIndex;\n        }\n      },\n      onHidden: function onHidden() {\n        cursorRectIndex = -1;\n      }\n    };\n  }\n};\nfunction getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {\n  // Not an inline element, or placement is not yet known\n  if (clientRects.length < 2 || currentBasePlacement === null) {\n    return boundingRect;\n  } // There are two rects and they are disjoined\n\n\n  if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) {\n    return clientRects[cursorRectIndex] || boundingRect;\n  }\n\n  switch (currentBasePlacement) {\n    case 'top':\n    case 'bottom':\n      {\n        var firstRect = clientRects[0];\n        var lastRect = clientRects[clientRects.length - 1];\n        var isTop = currentBasePlacement === 'top';\n        var top = firstRect.top;\n        var bottom = lastRect.bottom;\n        var left = isTop ? firstRect.left : lastRect.left;\n        var right = isTop ? firstRect.right : lastRect.right;\n        var width = right - left;\n        var height = bottom - top;\n        return {\n          top: top,\n          bottom: bottom,\n          left: left,\n          right: right,\n          width: width,\n          height: height\n        };\n      }\n\n    case 'left':\n    case 'right':\n      {\n        var minLeft = Math.min.apply(Math, clientRects.map(function (rects) {\n          return rects.left;\n        }));\n        var maxRight = Math.max.apply(Math, clientRects.map(function (rects) {\n          return rects.right;\n        }));\n        var measureRects = clientRects.filter(function (rect) {\n          return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;\n        });\n        var _top = measureRects[0].top;\n        var _bottom = measureRects[measureRects.length - 1].bottom;\n        var _left = minLeft;\n        var _right = maxRight;\n\n        var _width = _right - _left;\n\n        var _height = _bottom - _top;\n\n        return {\n          top: _top,\n          bottom: _bottom,\n          left: _left,\n          right: _right,\n          width: _width,\n          height: _height\n        };\n      }\n\n    default:\n      {\n        return boundingRect;\n      }\n  }\n}\n\nvar sticky = {\n  name: 'sticky',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference,\n        popper = instance.popper;\n\n    function getReference() {\n      return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;\n    }\n\n    function shouldCheck(value) {\n      return instance.props.sticky === true || instance.props.sticky === value;\n    }\n\n    var prevRefRect = null;\n    var prevPopRect = null;\n\n    function updatePosition() {\n      var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;\n      var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;\n\n      if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {\n        if (instance.popperInstance) {\n          instance.popperInstance.update();\n        }\n      }\n\n      prevRefRect = currentRefRect;\n      prevPopRect = currentPopRect;\n\n      if (instance.state.isMounted) {\n        requestAnimationFrame(updatePosition);\n      }\n    }\n\n    return {\n      onMount: function onMount() {\n        if (instance.props.sticky) {\n          updatePosition();\n        }\n      }\n    };\n  }\n};\n\nfunction areRectsDifferent(rectA, rectB) {\n  if (rectA && rectB) {\n    return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;\n  }\n\n  return true;\n}\n\ntippy.setDefaultProps({\n  render: render\n});\n\nexport default tippy;\nexport { animateFill, createSingleton, delegate, followCursor, hideAll, inlinePositioning, ROUND_ARROW as roundArrow, sticky };\n//# sourceMappingURL=tippy.esm.js.map\n","/**\n * CSS styling rules for Tippy.js\n * Inlined to simplify Webpack configuration\n */\n\nexport const tippyCss =\n`.tippy-box[data-animation=fade][data-state=hidden]{opacity:0}[data-tippy-root]{max-width:calc(100vw - 10px)}.tippy-box{position:relative;background-color:#333;color:#fff;border-radius:4px;font-size:14px;line-height:1.4;white-space:normal;outline:0;transition-property:transform,visibility,opacity}.tippy-box[data-placement^=top]>.tippy-arrow{bottom:0}.tippy-box[data-placement^=top]>.tippy-arrow:before{bottom:-7px;left:0;border-width:8px 8px 0;border-top-color:initial;transform-origin:center top}.tippy-box[data-placement^=bottom]>.tippy-arrow{top:0}.tippy-box[data-placement^=bottom]>.tippy-arrow:before{top:-7px;left:0;border-width:0 8px 8px;border-bottom-color:initial;transform-origin:center bottom}.tippy-box[data-placement^=left]>.tippy-arrow{right:0}.tippy-box[data-placement^=left]>.tippy-arrow:before{border-width:8px 0 8px 8px;border-left-color:initial;right:-7px;transform-origin:center left}.tippy-box[data-placement^=right]>.tippy-arrow{left:0}.tippy-box[data-placement^=right]>.tippy-arrow:before{left:-7px;border-width:8px 8px 8px 0;border-right-color:initial;transform-origin:center right}.tippy-box[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-arrow{width:16px;height:16px;color:#333}.tippy-arrow:before{content:\"\";position:absolute;border-color:transparent;border-style:solid}.tippy-content{position:relative;padding:5px 9px;z-index:1}`\n\nexport const tippyLightCss = `.tippy-box[data-theme~=light-border]{background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,8,16,.15);color:#333;box-shadow:0 4px 14px -2px rgba(0,8,16,.08)}.tippy-box[data-theme~=light-border]>.tippy-backdrop{background-color:#fff}.tippy-box[data-theme~=light-border]>.tippy-arrow:after,.tippy-box[data-theme~=light-border]>.tippy-svg-arrow:after{content:\"\";position:absolute;z-index:-1}.tippy-box[data-theme~=light-border]>.tippy-arrow:after{border-color:transparent;border-style:solid}.tippy-box[data-theme~=light-border][data-placement^=top]>.tippy-arrow:before{border-top-color:#fff}.tippy-box[data-theme~=light-border][data-placement^=top]>.tippy-arrow:after{border-top-color:rgba(0,8,16,.2);border-width:7px 7px 0;top:17px;left:1px}.tippy-box[data-theme~=light-border][data-placement^=top]>.tippy-svg-arrow>svg{top:16px}.tippy-box[data-theme~=light-border][data-placement^=top]>.tippy-svg-arrow:after{top:17px}.tippy-box[data-theme~=light-border][data-placement^=bottom]>.tippy-arrow:before{border-bottom-color:#fff;bottom:16px}.tippy-box[data-theme~=light-border][data-placement^=bottom]>.tippy-arrow:after{border-bottom-color:rgba(0,8,16,.2);border-width:0 7px 7px;bottom:17px;left:1px}.tippy-box[data-theme~=light-border][data-placement^=bottom]>.tippy-svg-arrow>svg{bottom:16px}.tippy-box[data-theme~=light-border][data-placement^=bottom]>.tippy-svg-arrow:after{bottom:17px}.tippy-box[data-theme~=light-border][data-placement^=left]>.tippy-arrow:before{border-left-color:#fff}.tippy-box[data-theme~=light-border][data-placement^=left]>.tippy-arrow:after{border-left-color:rgba(0,8,16,.2);border-width:7px 0 7px 7px;left:17px;top:1px}.tippy-box[data-theme~=light-border][data-placement^=left]>.tippy-svg-arrow>svg{left:11px}.tippy-box[data-theme~=light-border][data-placement^=left]>.tippy-svg-arrow:after{left:12px}.tippy-box[data-theme~=light-border][data-placement^=right]>.tippy-arrow:before{border-right-color:#fff;right:16px}.tippy-box[data-theme~=light-border][data-placement^=right]>.tippy-arrow:after{border-width:7px 7px 7px 0;right:17px;top:1px;border-right-color:rgba(0,8,16,.2)}.tippy-box[data-theme~=light-border][data-placement^=right]>.tippy-svg-arrow>svg{right:11px}.tippy-box[data-theme~=light-border][data-placement^=right]>.tippy-svg-arrow:after{right:12px}.tippy-box[data-theme~=light-border]>.tippy-svg-arrow{fill:#fff}.tippy-box[data-theme~=light-border]>.tippy-svg-arrow:after{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMCA2czEuNzk2LS4wMTMgNC42Ny0zLjYxNUM1Ljg1MS45IDYuOTMuMDA2IDggMGMxLjA3LS4wMDYgMi4xNDguODg3IDMuMzQzIDIuMzg1QzE0LjIzMyA2LjAwNSAxNiA2IDE2IDZIMHoiIGZpbGw9InJnYmEoMCwgOCwgMTYsIDAuMikiLz48L3N2Zz4=);background-size:16px 6px;width:16px;height:6px}`;\n","var e={\"\":[\"<em>\",\"</em>\"],_:[\"<strong>\",\"</strong>\"],\"*\":[\"<strong>\",\"</strong>\"],\"~\":[\"<s>\",\"</s>\"],\"\\n\":[\"<br />\"],\" \":[\"<br />\"],\"-\":[\"<hr />\"]};function n(e){return e.replace(RegExp(\"^\"+(e.match(/^(\\t| )+/)||\"\")[0],\"gm\"),\"\")}function r(e){return(e+\"\").replace(/\"/g,\"&quot;\").replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\")}export default function t(a,c){var o,l,g,s,p,u=/((?:^|\\n+)(?:\\n---+|\\* \\*(?: \\*)+)\\n)|(?:^``` *(\\w*)\\n([\\s\\S]*?)\\n```$)|((?:(?:^|\\n+)(?:\\t|  {2,}).+)+\\n*)|((?:(?:^|\\n)([>*+-]|\\d+\\.)\\s+.*)+)|(?:!\\[([^\\]]*?)\\]\\(([^)]+?)\\))|(\\[)|(\\](?:\\(([^)]+?)\\))?)|(?:(?:^|\\n+)([^\\s].*)\\n(-{3,}|={3,})(?:\\n+|$))|(?:(?:^|\\n+)(#{1,6})\\s*(.+)(?:\\n+|$))|(?:`([^`].*?)`)|(  \\n\\n*|\\n{2,}|__|\\*\\*|[_*]|~~)/gm,m=[],h=\"\",i=c||{},d=0;function f(n){var r=e[n[1]||\"\"],t=m[m.length-1]==n;return r?r[1]?(t?m.pop():m.push(n),r[0|t]):r[0]:n}function $(){for(var e=\"\";m.length;)e+=f(m[m.length-1]);return e}for(a=a.replace(/^\\[(.+?)\\]:\\s*(.+)$/gm,function(e,n,r){return i[n.toLowerCase()]=r,\"\"}).replace(/^\\n+|\\n+$/g,\"\");g=u.exec(a);)l=a.substring(d,g.index),d=u.lastIndex,o=g[0],l.match(/[^\\\\](\\\\\\\\)*\\\\$/)||((p=g[3]||g[4])?o='<pre class=\"code '+(g[4]?\"poetry\":g[2].toLowerCase())+'\"><code'+(g[2]?' class=\"language-'+g[2].toLowerCase()+'\"':\"\")+\">\"+n(r(p).replace(/^\\n+|\\n+$/g,\"\"))+\"</code></pre>\":(p=g[6])?(p.match(/\\./)&&(g[5]=g[5].replace(/^\\d+/gm,\"\")),s=t(n(g[5].replace(/^\\s*[>*+.-]/gm,\"\"))),\">\"==p?p=\"blockquote\":(p=p.match(/\\./)?\"ol\":\"ul\",s=s.replace(/^(.*)(\\n|$)/gm,\"<li>$1</li>\")),o=\"<\"+p+\">\"+s+\"</\"+p+\">\"):g[8]?o='<img src=\"'+r(g[8])+'\" alt=\"'+r(g[7])+'\">':g[10]?(h=h.replace(\"<a>\",'<a href=\"'+r(g[11]||i[l.toLowerCase()])+'\">'),o=$()+\"</a>\"):g[9]?o=\"<a>\":g[12]||g[14]?o=\"<\"+(p=\"h\"+(g[14]?g[14].length:g[13]>\"=\"?1:2))+\">\"+t(g[12]||g[15],i)+\"</\"+p+\">\":g[16]?o=\"<code>\"+r(g[16])+\"</code>\":(g[17]||g[1])&&(o=f(g[17]||\"--\"))),h+=l,h+=o;return(h+a.substring(d)+$()).replace(/^\\n+|\\n+$/g,\"\")}\n//# sourceMappingURL=snarkdown.es.js.map\n","import snarkdown from 'snarkdown';\nimport tippy from 'tippy.js';\nimport {getTippyConfig} from '../lib';\n\nconst PVJS_URL = 'https://cdn.jsdelivr.net/npm/@wikipathways/pvjs@5.0.1/dist/pvjs.vanilla.js';\nconst SVGPANZOOM_URL = 'https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.5.0/dist/svg-pan-zoom.min.js';\nconst CONTAINER_ID = '_ideogramPathwayContainer';\n\n/** Request pvjs / kaavio JSON for a WikiPathways biological pathway diagram */\nasync function fetchPathwayViewerJson(pwId) {\n  const origin = 'https://raw.githubusercontent.com'\n  const repoAndBranch = '/wikipathways/wikipathways-assets/main';\n\n  // E.g. https://raw.githubusercontent.com/wikipathways/wikipathways-assets/main/pathways/WP5445/WP5445.json\n  const url = `${origin}${repoAndBranch}/pathways/${pwId}/${pwId}.json`;\n\n  const response = await fetch(url);\n  const pathwayJson = await response.json();\n\n  Ideogram.pathwayJson = pathwayJson;\n  return pathwayJson;\n}\n\n/**\n * Load pvjs via classic HTML <script> tag, dynamically written to page\n *\n * pvjs NPM package has several exports, but none quite work without significant\n * dependencies, e.g. React.\n *\n * TODO: Modify pvjs upstream to distribute module imports without e.g. React\n */\nasync function loadPvjsScript() {\n  const pvjsScript = document.createElement('script');\n  pvjsScript.setAttribute('src', PVJS_URL);\n  document.querySelector('body').appendChild(pvjsScript);\n}\n\n/**\n * Load svg-pan-zoom via classic HTML <script> tag, dynamically written to page\n */\nasync function loadSvgpanzoomScript() {\n  const svgpanzoomScript = document.createElement('script');\n  svgpanzoomScript.setAttribute('src', SVGPANZOOM_URL);\n  document.querySelector('body').appendChild(svgpanzoomScript);\n}\n\n/** Get pathway entities that have a term matching query text, e.g. a gene */\nfunction findEntitiesByText(text, pathwayJson) {\n  const matchedEntities =\n    Object.entries(pathwayJson.entitiesById).filter(([id, entity]) => {\n      return entity.textContent?.split(' ').some(token => token === text);\n    });\n  return matchedEntities;\n}\n\n/** Get IDs of entities that have a term matching query text, e.g. a gene */\nfunction getEntityIds(text, pathwayJson) {\n  const matchedEntities = findEntitiesByText(text, pathwayJson);\n  const entityIds = matchedEntities.map(e => e[0]);\n  return entityIds;\n}\n\n/** Get highlights to color nodes that match query text, e.g. a gene */\nfunction getHighlights(text, pathwayJson, color) {\n  const entityIds = getEntityIds(text, pathwayJson);\n  const highlights = entityIds.map(entityId => [null, entityId, color]);\n  return highlights;\n}\n\nfunction zoomToEntity(entityId, retryAttempt=0) {\n  let entityDom = document.querySelector(`#${entityId}`);\n  const parentClasses = Array.from(entityDom.parentNode.classList);\n  const isInGroup = parentClasses.includes('Group');\n  if (isInGroup) {\n    entityDom = entityDom.parentNode;\n  }\n\n  // Try drawing pathway, retry each .25 s for 10 s if Pvjs hasn't loaded yet\n  if (typeof entityDom === 'undefined') {\n    if (retryAttempt <= 40) {\n      setTimeout(() => {\n        zoomToEntity(entityId, retryAttempt++);\n      }, 250);\n      return;\n    } else {\n      throw Error(\n        'Zoomed entity DOM is undefined.  ' +\n        'Possible causes include unavailable network or CDN.'\n      );\n    }\n  }\n\n  const panZoom = svgPanZoom('.Diagram');\n  // const clientRect = entityDom.getBoundingClientRect();\n\n  const svgMatrix = entityDom.transform.baseVal[0].matrix;\n\n  const transformLeft = svgMatrix.e;\n  const transformTop = svgMatrix.f;\n  // const scale = 0.5161290261053255\n\n  const viewport = document.querySelector('.svg-pan-zoom_viewport')\n\n  const viewportMatrix = viewport.transform.baseVal[0].matrix;\n  const viewportScale = viewportMatrix.a;\n  const viewportLeft = viewportMatrix.e;\n\n  // panZoom.zoomAtPointBy(3, {x: 282*0.47+213-30, y: 107.5*0.47-10});\n  panZoom.zoomAtPointBy(3, {\n    x: transformLeft * viewportScale + viewportLeft - 60,\n    y: transformTop * viewportScale - 10\n  });\n\n  window.viewport = viewport;\n  window.panZoom = panZoom;\n  window.entityDom = entityDom;\n  // window.clientRect = clientRect\n  window.svgMatrix = svgMatrix\n  window.transformLeft = transformLeft\n  window.transformTop = transformTop\n  window.viewportScale = viewportScale\n  window.viewportLeft = viewportLeft\n\n  // panZoom.zoomAtPoint(2, sourceEntityDom.getBoundingClientRect());\n  // panZoom.zoomAtPoint(2, sourceEntityDom.getBoundingClientRect());\n}\n\n/** Add header bar to pathway diagram with name, link, close button, etc. */\nfunction addHeader(pwId, pathwayJson, pathwayContainer, showClose=true) {\n  const pathwayName = pathwayJson.pathway.name;\n  const url = `https://wikipathways.org/pathways/${pwId}`;\n  const linkAttrs = `href=\"${url}\" target=\"_blank\" style=\"margin-left: 4px;\"`;\n\n  // Link to full page on WikiPathways, using pathway title\n  const pathwayLink = `<a ${linkAttrs}>${pathwayName}</a>`;\n\n  let closeButton;\n  if (showClose) {\n    // Close button\n    const style =\n      'style=\"float: right; background-color: #aaa; border: none; ' +\n      'color: white; font-weight: bold; font-size: 16px; padding: 0px 4px; ' +\n      'border-radius: 3px; cursor: pointer;\"';\n    const buttonAttrs = `class=\"_ideoPathwayCloseButton\" ${style}`;\n    closeButton = `<button ${buttonAttrs}}>x</button>`;\n  } else {\n    closeButton = '';\n  }\n\n  const headerBar =\n    `<div class=\"_ideoPathwayHeader\">${pathwayLink}${closeButton}</div>`;\n  pathwayContainer.insertAdjacentHTML('afterBegin', headerBar);\n\n  if (showClose) {\n    const closeButtonDom = document.querySelector('._ideoPathwayCloseButton');\n    closeButtonDom.addEventListener('click', function(event) {\n      const pathwayContainer = document.querySelector(`#${CONTAINER_ID}`);\n      pathwayContainer.remove();\n    });\n  }\n}\n\n/**\n *\n */\nfunction removeCptacAssayPortalClause(inputText) {\n  // eslint-disable-next-line max-len\n  const regex = /Proteins on this pathway have targeted assays available via the \\[https:\\/\\/assays\\.cancer\\.gov\\/available_assays\\?wp_id=WP\\d+\\s+CPTAC Assay Portal\\]\\./g;\n  // eslint-disable-next-line max-len\n  const regex2 = /Proteins on this pathway have targeted assays available via the \\[CPTAC Assay Portal\\]\\(https:\\/\\/assays\\.cancer\\.gov\\/available_assays\\?wp_id=WP\\d+\\)\\./g;\n\n  return inputText.replace(regex, '').replace(regex2, '');\n}\n\n\nfunction removePhosphoSitePlusClause(inputText) {\n  // eslint-disable-next-line max-len\n  const regex = 'Phosphorylation sites were added based on information from PhosphoSitePlus (R), www.phosphosite.org.';\n\n  return inputText.replace(regex, '');\n}\n\n/** Convert Markdown links to standard <a href=\"... links */\nfunction convertMarkdownLinks(markdown) {\n  const html = snarkdown(markdown);\n\n  const htmlWithClassedLinks =\n    html.replace(\n      /<a href=\"([^\"]+)\">/g,\n      '<a href=\"$1\" class=\"_ideoPathwayDescriptionLink\" target=\"_blank\">'\n    );\n\n  return htmlWithClassedLinks;\n}\n\nfunction formatDescription(rawText) {\n  rawText = rawText.replaceAll('\\r\\n\\r\\n', '\\r\\n');\n  rawText = rawText.replaceAll('\\r\\n', '<br/><br/>');\n  const denoisedPhospho = removePhosphoSitePlusClause(rawText);\n  const denoisedText = removeCptacAssayPortalClause(denoisedPhospho);\n  const linkedText = convertMarkdownLinks(denoisedText);\n  const trimmedText = linkedText.trim();\n  return trimmedText;\n}\n\nfunction getDescription(pathwayJson) {\n  const rawText =\n  pathwayJson.pathway.comments.filter(\n    c => c.source === 'WikiPathways-description'\n  )[0].content;\n  const descriptionText = formatDescription(rawText);\n\n  const style = `style=\"font-weight: bold\"`;\n\n  const description =\n    `<div>` +\n      // `<div class=\"ideoPathwayDescription\" ${style}>Description</div>` +\n      descriptionText +\n    `</div>`;\n\n  return description;\n}\n\nfunction parsePwAnnotations(entitiesById, keys, ontology) {\n  const pwKeys = keys.filter(k => entitiesById[k].ontology === ontology);\n  const pwAnnotations = pwKeys.map(k => entitiesById[k]);\n  return pwAnnotations;\n}\n\nexport function getPathwayAnnotations(pathwayJson, selectedOntology) {\n  const entitiesById = pathwayJson.entitiesById;\n  const keys = Object.keys(entitiesById).filter(k => k.startsWith('http://identifiers.org'));\n  const sentenceCases = {\n    'Cell Type': 'Cell type'\n  };\n  const ontologies = [\n    'Cell Type',\n    'Disease'\n    // 'Pathway Ontology' // maybe later\n  ];\n  let selectedOntologies = ontologies;\n  if (selectedOntology) {\n    selectedOntologies = [ontologies.find(\n      ontology => ontology.toLowerCase() === selectedOntology.toLowerCase()\n    )];\n  }\n  const pathwayAnnotationsList = selectedOntologies.map(ontology => {\n    const pwAnnotations = parsePwAnnotations(entitiesById, keys, ontology);\n    const links = pwAnnotations.map(pwa => {\n      const id = pwa.xrefIdentifier.replace(':', '_');\n      const url = `https://purl.obolibrary.org/obo/${id}`;\n      const cls = 'class=\"_ideoPathwayOntologyLink\"';\n      return `<a href=\"${url}\" target=\"_blank\" ${cls}>${pwa.term}</a>`;\n    }).join(', ');\n\n    const refinedOntology = sentenceCases[ontology] ?? ontology;\n    const safeOntology = ontology.replaceAll(' ', '_');\n    const cls = `class=\"ideoPathwayOntology__${safeOntology}\"`;\n\n    if (links === '') return '';\n\n    return `<div ${cls}>${refinedOntology}: ${links}</div>`;\n  }).join('');\n\n  if (pathwayAnnotationsList.length === 0) {\n    return '';\n  }\n\n  const style = `style=\"font-weight: bold\"`;\n\n  const pathwayAnnotations =\n  `<div>` +\n    // `<div class=\"ideoPathwayAnnotations\" ${style}>Pathway annotations</div>` +\n    pathwayAnnotationsList +\n  `</div>`;\n\n  return pathwayAnnotations;\n}\n\n/** Get list of unique genes in pathway */\nexport function getPathwayGenes() {\n  const entities = Object.values(Ideogram.pathwayJson.entitiesById);\n  const genes = entities.filter(entity => {\n    return ['GeneProduct', 'RNA', 'Protein'].includes(entity.wpType);\n  }).map(e => e.textContent);\n  const uniqueGenes = Array.from(new Set(genes));\n  return uniqueGenes;\n}\n\n\nfunction addFooter(pathwayJson, pathwayContainer, showOntologies) {\n  const description = getDescription(pathwayJson);\n  const pathwayAnnotations =\n    showOntologies ? getPathwayAnnotations(pathwayJson) : '';\n  const footer =\n    `<br/>` +\n    `<div class=\"_ideoPathwayFooter\">` +\n      description +\n      `<br/>` +\n      pathwayAnnotations +\n    `</div>`;\n  pathwayContainer.insertAdjacentHTML('beforeEnd', footer);\n}\n\n/** Fetch and render WikiPathways diagram for given pathway ID */\nexport async function drawPathway(\n  pwId, sourceGene, destGene,\n  outerSelector='#_ideogramOuterWrap',\n  dimensions={height: 440, width: 900},\n  showClose=true,\n  geneNodeHoverFn,\n  pathwayNodeClickFn,\n  showDescription,\n  showOntologies,\n  showDefaultTooltips,\n  retryAttempt=0\n) {\n  const pvjsScript = document.querySelector(`script[src=\"${PVJS_URL}\"]`);\n  if (!pvjsScript) {loadPvjsScript();}\n\n  // const svgpanzoomScript =\n  //   document.querySelector(`script[src=\"${SVGPANZOOM_URL}\"]`);\n  // if (!svgpanzoomScript) {loadSvgpanzoomScript();}\n\n  const containerSelector = `#${CONTAINER_ID}`;\n\n  // Try drawing pathway, retry each .25 s for 10 s if Pvjs hasn't loaded yet\n  if (\n    typeof Pvjs === 'undefined'\n    // || typeof svgPanZoom === 'undefined'\n  ) {\n    if (retryAttempt <= 40) {\n      setTimeout(() => {\n        drawPathway(\n          pwId, sourceGene, destGene,\n          outerSelector, dimensions, showClose,\n          geneNodeHoverFn, pathwayNodeClickFn,\n          showDescription,\n          retryAttempt++\n        );\n      }, 250);\n      return;\n    } else {\n      throw Error(\n        'Pvjs is undefined.  ' +\n        'Possible causes include unavailable network or CDN.'\n      );\n    }\n  }\n\n  // Get pathway diagram data\n  const pathwayJson = await fetchPathwayViewerJson(pwId);\n\n  const sourceEntityId = getEntityIds(sourceGene, pathwayJson)[0];\n  const destEntityId = getEntityIds(destGene, pathwayJson)[0];\n\n  const sourceHighlights = getHighlights(sourceGene, pathwayJson, 'red');\n  const destHighlights = getHighlights(destGene, pathwayJson, 'purple');\n  const highlights = sourceHighlights.concat(destHighlights);\n\n  const oldPathwayContainer = document.querySelector(containerSelector);\n  const ideoContainerDom = document.querySelector(outerSelector);\n  if (oldPathwayContainer) {\n    oldPathwayContainer.remove();\n  }\n\n  const width = dimensions.width;\n  const height = dimensions.height;\n  const pvjsDimensions = `height: ${height}px; width: ${width - 2}px;`;\n  const containerDimensions = `height: ${height + 20}px; width: ${width}px;`;\n  const style =\n    `border: 0.5px solid #DDD; border-radius: 3px; ` +\n    `position: relative; margin: auto; background-color: #FFF; z-index: 99; ` +\n    `${containerDimensions} margin: auto;`;\n  const pvjsContainerHtml = `<div id=\"_ideogramPvjsContainer\" style=\"${pvjsDimensions}\"></div>`;\n  const containerAttrs =\n    `id=\"${CONTAINER_ID}\" style=\"${style}\" ` +\n    `data-ideo-pathway-searched=\"${sourceGene}\" ` +\n    `data-ideo-pathway-interacting=\"${destGene}\"`;\n  const containerHtml = `<div ${containerAttrs}>${pvjsContainerHtml}</div>`;\n  ideoContainerDom.insertAdjacentHTML('beforeEnd', containerHtml);\n  const pathwayContainer = document.querySelector(containerSelector);\n  const pvjsContainer = document.querySelector('#_ideogramPvjsContainer');\n\n  // Pvjs parameters\n  // Source: https://github.com/wikipathways/pvjs/blob/fb321e5b8796ecc3312c9a604f75b7ace94a81aa/src/Pvjs.tsx#L392\n  // Docs: https://github.com/wikipathways/pvjs#-props\n  const pvjsProps = {\n    theme: 'plain',\n    opacities: [],\n    highlights,\n    panned: [sourceEntityId], // TODO: Pvjs documents this, but it's unsupported\n    zoomed: [sourceEntityId], // TODO: Pvjs documents this, but it's unsupported\n    pathway: pathwayJson.pathway,\n    entitiesById: pathwayJson.entitiesById,\n    detailPanelOpen: false,\n    // showPanZoomControls: false,\n    selected: null\n  };\n\n  // const pathwayViewer = new Pvjs(pvjsProps);\n  const pathwayViewer = new Pvjs(pvjsContainer, pvjsProps);\n  addHeader(pwId, pathwayJson, pathwayContainer, showClose);\n\n  if (showDescription) {\n    addFooter(pathwayJson, pathwayContainer, showOntologies);\n  }\n\n  // zoomToEntity(sourceEntityId);\n\n  const detail = {\n    pathwayViewer,\n    pwId, sourceGene, destGene, dimensions\n  };\n\n  // Notify listeners of event completion\n  const ideogramPathwayEvent = new CustomEvent('ideogramDrawPathway', {detail});\n  document.dispatchEvent(ideogramPathwayEvent);\n\n  // Add mouseover handler to gene nodes in this pathway diagram\n  pathwayContainer.querySelectorAll('g.GeneProduct').forEach(geneNode => {\n    const geneName = geneNode.getAttribute('name');\n    let tooltipContent = geneName;\n    geneNode.addEventListener('mouseover', (event) => {\n      if (geneNodeHoverFn) {\n        tooltipContent = geneNodeHoverFn(event, geneName);\n        geneNode.setAttribute('data-tippy-content', tooltipContent);\n      }\n    });\n\n    if (showDefaultTooltips) {\n      geneNode.setAttribute(`data-tippy-content`, tooltipContent);\n    }\n  });\n  if (showDefaultTooltips) {\n    const tippyConfig = getTippyConfig();\n    tippyConfig.trigger = 'mouseenter';\n    tippy('g.GeneProduct[data-tippy-content]', tippyConfig);\n  }\n\n  // Add click handler to pathway nodes in this pathway diagram\n  if (pathwayNodeClickFn) {\n    pathwayContainer.querySelectorAll('g.Pathway').forEach(pathwayNode => {\n\n      // Add customizable click handler\n      pathwayNode.addEventListener('click', (event) => {\n        const domClasses = Array.from(pathwayNode.classList);\n        const pathwayId = domClasses\n          .find(c => c.startsWith('WikiPathways_'))\n          .split('WikiPathways_')[1]; // e.g. WikiPathways_WP2815 -> WP2815\n\n        pathwayNodeClickFn(event, pathwayId);\n      });\n\n      if (showDefaultTooltips) {\n        // Indicate this new pathway can be rendered on click\n        const tooltipContent = 'Click to show pathway';\n        pathwayNode.setAttribute('data-tippy-content', tooltipContent);\n      }\n    });\n\n    if (showDefaultTooltips) {\n      tippy('g.Pathway[data-tippy-content]', tippyConfig);\n    }\n  }\n}\n","/** Get time in milliseconds between a start time (t0) and now */\nfunction timeDiff(t0) {\n  return Math.round(performance.now() - t0);\n}\n\n/** Initialize performance analysis settings */\nfunction initAnalyzeRelatedGenes(ideo) {\n  ideo.time = {\n    rg: { // times for related genes\n      t0: performance.now()\n    }\n  };\n  if ('_didRelatedGenesFirstPlot' in ideo) {\n    delete ideo._didRelatedGenesFirstPlot;\n  }\n}\n\nfunction getRelatedGenesByType() {\n  const ideo = this;\n  const relatedGenes = ideo.annotDescriptions.annots;\n\n  const related = Object.values(relatedGenes).slice();\n\n  const paralogous = related.filter(r => {\n    return r.type && r.type.includes('paralogous');\n  });\n  const interacting = related.filter(r => {\n    return r.type && r.type.includes('interacting gene');\n  });\n  const searched = Object.entries(relatedGenes).filter(entry => {\n    return entry[1].type && entry[1].type.includes('searched gene');\n  })[0][0];\n\n  return {related, paralogous, interacting, searched};\n}\n\nfunction getRelatedGenesTooltipAnalytics(annot) {\n  const ideo = this;\n\n  const timeSincePrevTooltip = performance.now() - ideo.time.prevTooltipOff;\n  const prevAnnotDomId = ideo.time.prevTooltipAnnotDomId;\n\n  if (timeSincePrevTooltip < 300 && annot.domId === prevAnnotDomId) {\n    return null;\n  }\n\n  const tooltipGene = annot.name;\n\n  // e.g. \"interacting gene\" -> \"interacting\"\n  const tooltipRelatedType =\n    ideo.annotDescriptions.annots[annot.name].type.split(' ')[0];\n\n  const countsByType = getCountsByType(ideo);\n\n  const analytics = Object.assign(\n    {tooltipGene, tooltipRelatedType}, countsByType\n  );\n\n  return analytics;\n}\n\n/** Compute granular related genes plotting analytics */\nfunction analyzePlotTimes(type, ideo) {\n  // Paralogs and interacting genes:\n  // http://localhost:8080/examples/vanilla/related-genes?q=RAD51\n  //\n  // No paralogs:\n  // http://localhost:8080/examples/vanilla/related-genes?q=BRCA1&org=mus-musculus\n  //\n  // No interacting genes:\n  // http://localhost:8080/examples/vanilla/related-genes?q=DMC1\n  //\n  // No paralogs, no interacting genes:\n  // http://localhost:8080/examples/vanilla/related-genes?q=BRCA1&org=macaca-mulatta\n\n  if (type === 'pathway') {\n    return;\n  }\n  const otherTypes = {\n    paralogous: 'interacting',\n    interacting: 'paralogous'\n  };\n  const related = ideo.getRelatedGenesByType();\n  const otherType = otherTypes[type];\n  const numThisRelated = related[type].length;\n  const numOtherRelated = related[otherType] ? related[otherType].length : 0;\n\n  if (!ideo._didRelatedGenesFirstPlot) {\n    // 1st of 2 attempted plot logs\n    ideo._didRelatedGenesFirstPlot = true;\n\n    ideo.time.rg.totalFirstPlot = timeDiff(ideo.time.rg.t0);\n\n    if (numThisRelated > 0) {\n      ideo.time.rg.timestampFirstPlot = performance.now();\n      ideo._relatedGenesFirstPlotType = type;\n    }\n  } else {\n    // 2nd of 2 attempted plot logs\n    if (numThisRelated > 0 && numOtherRelated > 0) {\n      // Paralogs and interacting genes were found, e.g. human RAD51\n      const timestampFirstPlot = ideo.time.rg.timestampFirstPlot;\n      ideo.time.rg.totalLastPlotDiff = timeDiff(timestampFirstPlot);\n    } else if (numThisRelated > 0 && numOtherRelated === 0) {\n      // Other attempt did not plot, and this did, so log this as 1st\n      // Often seen when no interacting genes found, e.g. human DMC1\n      ideo.time.rg.timestampFirstPlot = performance.now();\n      ideo.time.rg.totalFirstPlot = timeDiff(ideo.time.rg.t0);\n      ideo._relatedGenesFirstPlotType = type;\n      ideo.time.rg.totalLastPlotDiff = 0;\n\n    } else if (numThisRelated === 0 && numOtherRelated > 0) {\n      // This attempt did not plot, the other did, so log 1st plot as also last\n      // Often seen when no paralogs found, e.g. mouse BRCA1\n      ideo.time.rg.totalLastPlotDiff = 0;\n    } else {\n      // No related genes found, so note only the searched gene is plotted\n      // Example: Macaca mulatta BRCA1\n      ideo._relatedGenesFirstPlotType = 'searched';\n      ideo.time.rg.totalLastPlotDiff = 0;\n    }\n  }\n}\n\nfunction getCountsByType(ideo) {\n  const related = ideo.getRelatedGenesByType();\n\n  const numRelatedGenes = related['related'].length;\n  const numParalogs = related['paralogous'].length;\n  const numInteractingGenes = related['interacting'].length;\n  const searchedGene = related['searched'];\n\n  return {\n    numRelatedGenes, numParalogs, numInteractingGenes, searchedGene\n  };\n}\n\n/** Summarizes number and kind of related genes, performance, etc. */\nfunction analyzeRelatedGenes(ideo) {\n\n  const countsByType = getCountsByType(ideo);\n\n  const timeTotal = ideo.time.rg.total;\n  const timeTotalFirstPlot = ideo.time.rg.totalFirstPlot;\n  const timeTotalLastPlotDiff = ideo.time.rg.totalLastPlotDiff;\n  const timeParalogs = ideo.time.rg.paralogs;\n  const timeInteractingGenes = ideo.time.rg.interactions;\n  const timeSearchedGene = ideo.time.rg.searchedGene;\n  const firstPlotType = ideo._relatedGenesFirstPlotType;\n\n  const analytics = Object.assign({\n    firstPlotType,\n    timeTotal, timeTotalFirstPlot, timeTotalLastPlotDiff,\n    timeSearchedGene, timeInteractingGenes, timeParalogs\n  }, countsByType);\n\n  ideo.relatedGenesAnalytics = analytics;\n}\n\nexport {\n  initAnalyzeRelatedGenes, analyzePlotTimes, analyzeRelatedGenes, timeDiff,\n  getRelatedGenesByType, getRelatedGenesTooltipAnalytics\n};\n","/**\n * @fileoverview Colors for protein features, e.g. domains, families, and sites\n *\n * The color design is intended to visually distinguish protein features, so\n * that patterns can be recognized among interacting and paralogous genes.\n * Colors for each domain were manually assigned, in an iterative process of\n * browsing gene leads ideogram and setting colors per that intent.  Color\n * sometimes overlaps with function, and sometimes not function but moreso\n * visually distinction from other protein features in a given gene leads view.\n */\n\n// Default\nconst grey = '#AAA';\nconst greyLine = '#555';\n\nconst lightGrey = '#D8D8D8';\nconst lightGreyLine = '#888';\n\nconst darkGrey = '#888';\nconst darkGreyLine = '#333';\n\n// const red = '#F00';\n// const redLines = '#800';\nconst red = '#F55';\nconst redLine = '#A00';\nconst magenta = '#922D5E';\nconst magentaLines = '#D26D9E';\nconst faintRed = '#CAA';\nconst faintRedLine = '#866';\nconst redderFaintRed = '#E88';\nconst redderFaintRedLine = '#A55';\nconst pink = '#FFC0CB';\nconst pinkLine = '#CF909B';\n\nconst blue = '#99D';\nconst blueLine = '#22C';\nconst lightBlue = '#CCF';\nconst lightBlueLine = '#33D';\nconst veryLightBlue = '#EEF';\nconst veryLightBlueLine = '#AAF';\nconst darkBlue = '#66B';\nconst darkBlueLine = '#116';\n\nconst green = '#7D7';\nconst greenLine = '#393';\nconst darkGreen = '#3A3';\nconst darkGreenLine = '#060';\nconst seafoam = '#93E9BE';\nconst seafoamLine = '#53AC7E';\n\n// Purples\nconst darkPurple = '#51087E';\nconst darkPurpleLine = '#8138AE';\nconst purple = '#880ED4';\nconst purpleLine = '#5800A4';\nconst purple2 = '#A020F0';\nconst purple2Line = '#7000C0';\nconst lightPurple = '#B24BF3';\nconst lightPurpleLine = '#520B83';\nconst veryLightPurple = '#D7A1F9';\nconst veryLightPurpleLine = '#A771C9';\nconst ultraLightPurple = '#EEDDFF';\nconst ultraLightPurpleLine = '#A771C9';\n\nconst darkBrown = '#964B00';\nconst darkBrownLine = '#660B00';\nconst brown = '#C87D32';\nconst brownLine = '#722810';\nconst lightBrown = '#DACDBA';\nconst lightBrownLine = '#A99A89';\n\nconst orange = '#FFA500';\nconst orangeLines = '#DD8000';\nconst darkOrange = '#DD8300';\nconst darkOrangeLines = '#883000';\n\nconst lightOrange = '#FFEA66';\nconst lightOrangeLine = '#FFB466';\n\nconst orangeBrown = '#EEBB00';\nconst orangeBrownLine = '#A99A89';\n\nconst yellow = '#FF3';\nconst yellowLine = '#AA0';\nconst lightYellow = '#FFFBCC';\nconst lightYellowLine = '#CCC89A';\n\n\nconst lightGreen = '#BCB';\nconst lightGreenLine = '#9A9';\nconst veryLightGreen = '#DFD';\nconst veryLightGreenLine = '#CDC';\n\nexport function getColors(domainType) {\n\n  // Signal peptides\n  if (domainType === 'S') {\n    // return ['#F90', '#5D5'];\n    // return ['#F90', '#090'];\n    // return ['#FF2', '#F99'];\n    return ['#FF2', '#F99'];\n  }\n\n  // Topological features\n  else if (domainType === 'Extracellular') {\n    return [veryLightBlue, veryLightBlueLine];\n  } else if (domainType === 'Cytoplasmic') {\n    return [lightYellow, lightYellowLine];\n  } else if (\n    domainType === 'Helical' ||\n    domainType.startsWith('Helical ---')\n  ) {\n    return [lightBrown, lightBrownLine];\n  } else if (\n    domainType === 'Lumenal'\n  ) {\n    return [lightOrange, lightOrangeLine];\n  } else if (\n    domainType === 'Lumenal, melanosome' // e.g. in TYR\n  ) {\n    return [orangeBrown, orangeBrownLine];\n  } else if (\n    domainType === 'Mitochondrial matrix' // e.g. SDHC in ACMG\n  ) {\n    return [veryLightGreen, veryLightGreenLine];\n  } else if (\n    domainType === 'Mitochondrial intermembrane'\n  ) {\n    return [lightGreen, lightGreenLine];\n  } else if (domainType === 'Perinuclear space') {\n    // E.g. TMEM43\n    return [ultraLightPurple, ultraLightPurpleLine];\n  } else if (domainType === 'Nuclear') {\n    return [veryLightPurple, veryLightPurpleLine];\n  } else if (domainType === 'Beta stranded') {\n    return [blue, blueLine];\n  }\n\n  // Sites, domains, features, and other entries\n  else if (\n    domainType.includes('conserved site') || // https://www.google.com/search?q=pymol+conserved+site+color&tbm=isch\n    domainType.includes('conserved domain') ||\n    domainType === 'WGR domain' ||\n    domainType === 'R3H domain' ||\n    domainType.includes('QLQ') ||\n    domainType === 'Sema domain' ||\n    domainType === 'Proteasome component (PCI) domain' ||\n    domainType === 'Sterol-sensing domain' ||\n    domainType === 'Erythropoietin/thrombopoietin' ||\n    domainType === 'SPRY domain' ||\n    domainType === 'Anaphylatoxin/fibulin' ||\n    domainType === 'Tetratricopeptide repeat' ||\n    domainType === 'Doublecortin domain' ||\n    domainType.includes('Glycosyl transferase') ||\n    (\n      domainType.toLowerCase().includes('lethal') &&\n      domainType.toLowerCase().includes('c-terminal')\n    ) ||\n    domainType.includes('PUB') ||\n    domainType.includes('Myogenic determination') ||\n    domainType === 'Globin' ||\n    domainType === 'GPS motif' ||\n    domainType.includes('D-like') ||\n    domainType.toLowerCase().includes('insertion domain') || // e.g. RPLP0\n    domainType === 'Macro domain' // e.g. MACROH2A1\n  ) {\n    return [magenta, magentaLines];\n  } else if (\n    // Enzymatic sites\n    domainType.includes('active site') ||\n    domainType.includes('hydroxylation site') ||\n    domainType.includes('catalytic domain') ||\n    domainType.includes('Lipid transport') ||\n    domainType === 'BRCA1, serine-rich domain' ||\n    domainType === 'Tower domain' || // Important in BRCA2\n    domainType.endsWith('attachment site') ||\n    domainType.endsWith('amyloid-beta peptide') ||\n    domainType === 'Reverse transcriptase domain' ||\n    domainType ===\n      'Membrane attack complex component/perforin (MACPF) domain' ||\n    domainType === 'Alpha-2-macroglobulin' ||\n    domainType === 'Kinesin motor domain' ||\n    domainType === 'Adenomatous polyposis coli tumour suppressor protein' ||\n    domainType.includes('endostatin')\n  ) {\n    return [red, redLine];\n  } else if (\n    // Enzymatic domains, C-terminal regions, and miscellaneous\n    domainType === 'Cyclin, C-terminal domain' ||\n    domainType.includes('OB C-terminal domain') ||\n    domainType === 'Cationic amino acid transporter, C-terminal' ||\n    domainType === 'High mobility group box domain' ||\n    domainType === 'HMG-box domain' ||\n    domainType.includes('CUB domain') ||\n    domainType === 'C-5 cytosine methyltransferase' ||\n    domainType.includes('(G-protein), alpha subunit') ||\n    domainType === 'SCAN domain' ||\n    domainType === 'Apolipoprotein A/E' ||\n    domainType.includes('Clusterin') || // a.k.a. apolipoprotein J, e.g. CLU\n    domainType.includes('SMAD domain') ||\n    domainType === 'PLAC' ||\n    domainType.endsWith('tripeptidyl peptidase II') ||\n    domainType === 'Prohormone convertase enzyme' ||\n    domainType.includes('rod domain') ||\n    domainType === 'Osteopontin' ||\n    domainType === 'SPRY-associated' ||\n    domainType === 'C1q domain' ||\n    domainType === 'OAR domain' ||\n    domainType.includes('FTO, C-terminal') ||\n    domainType.includes('ATPase, C-terminal') ||\n    domainType.includes('Hint domain') ||\n    domainType === 'Laminin IV' ||\n    domainType === 'NACHT-associated domain' ||\n    domainType.includes('FANCD2') ||\n    domainType.startsWith('Acyl-CoA') && domainType.endsWith('C-terminal') ||\n    domainType === 'Kinesin-like' ||\n    domainType === 'GUCT' ||\n    domainType.includes('(APC) repeat') || // e.g. as in APC gene\n    domainType.includes('IP3R') // e.g. RYR1\n  ) {\n    return [faintRed, faintRedLine];\n  } else if (\n    domainType.includes('trypsin domain') ||\n    domainType.includes('scaffold dimerization') ||\n    domainType.includes('eIF-4 gamma, MA3') || // e.g. PDCD4\n    domainType === 'Troponin' || // e.g. TNNT1\n    domainType === 'SKI/SNO/DAC domain' || // SKIL gene\n    domainType.toLowerCase().includes('large ribosom') || // RPLP0\n    domainType.includes('KA1') || // e.g. MARK2\n    domainType === 'V(D)J recombination-activating protein 1' || // e.g. RAG1\n    domainType.toLowerCase().includes('opiod') || // e.g. PDYN\n    domainType === 'Corticotropin-releasing factor' || // e.g. CRH\n    domainType.includes('2Fe-2S ferredoxin') || // e.g. XDH\n    domainType.includes('acidic domain') // e.g. SYNCRIP\n  ) {\n    return [redderFaintRed, redderFaintRedLine];\n  } else if (\n    domainType === 'EGF-like calcium-binding domain' ||\n    domainType.includes('PTX/LNS') ||\n    domainType === 'HSR domain' ||\n    domainType.includes('MutS, clamp') ||\n    domainType.includes('S5 domain 2-like') || // e.g. MLH1 in ACMG\n    domainType.endsWith('CC1/2') || // e.g. PRKDC\n    domainType.includes('MUN') || // e.g. UNC13C\n    domainType.includes('second molybdopterin') // e.g. XDH\n  ) {\n    return [darkGreen, darkGreenLine];\n  } else if (\n    // Binding sites, and smaller binding regions\n    domainType.includes('binding site') ||\n    domainType === 'EF-hand domain' ||\n    domainType.includes('EF hand-like') ||\n    domainType === 'Zinc finger, nuclear hormone receptor-type' ||\n    domainType.includes('Serpin domain') ||\n    domainType === 'Peptidase C14,  p20 domain' ||\n    domainType === 'PWWP domain' ||\n    domainType === 'Peptidoglycan binding-like' ||\n    domainType === 'MAD homology 1, Dwarfin-type' ||\n    domainType === 'F-actin binding' ||\n    (\n      domainType.includes('Glycoside hydrolase') &&\n      domainType.endsWith('domain')\n    ) ||\n    domainType === 'p53 tumour suppressor family' ||\n    domainType === 'Menin' || // tumor suppressor, e.g. MEN1 in ACMG\n    domainType.includes('von Hippel') && domainType.includes('beta') || // VHLL\n    domainType === 'Pointed domain' ||\n    domainType.includes('DNA binding') ||\n    domainType === 'Helix-hairpin-helix domain' ||\n    domainType === 'Helix-hairpin-helix motif' ||\n    domainType === 'MIR motif' ||\n    domainType === 'Rad52 family' ||\n    domainType === 'Oxidoreductase FAD/NAD(P)-binding' ||\n    domainType.endsWith('NAD-binding') ||\n    domainType.endsWith('NAD binding') ||\n    domainType.includes('Bromo adjacent') ||\n    domainType === 'HARP domain' ||\n    domainType === 'FATC domain' ||\n    domainType.startsWith('XRN2-binding') ||\n    domainType === 'SRCR-like domain' ||\n    domainType.includes('SRCR') ||\n    domainType === 'Gamma-carboxyglutamic acid-rich (GLA) domain' ||\n    domainType === 'Pterin-binding domain' ||\n    domainType === 'Receptor, ligand binding region' ||\n    domainType.includes('DHEX domain') ||\n    domainType === 'SANT/Myb domain' ||\n    domainType.includes('Forkhead-associated') ||\n    domainType === 'Rap/Ran-GAP domain' ||\n    domainType.endsWith('C2 domain') ||\n    domainType.includes('tri-helix bundle domain') || // e.g. MYBPC3\n    domainType.includes('Cx50') || // e.g. GJA8\n    domainType.includes('tyrosine-rich') ||\n    domainType === 'Filaggrin' // e.g. FLG\n  ) {\n    return [blue, blueLine];\n  } else if (\n    domainType.includes('dehydrogenase, molybdopterin binding') ||\n    domainType === 'Zinc finger CCHC HIVEP-type' ||\n    domainType === 'Cyclin, N-terminal' ||\n    domainType === 'MAD homology, MH1' ||\n    domainType === 'Sodium ion transport-associated' ||\n    domainType === 'Sodium ion transport-associated domain' ||\n    domainType.endsWith('head') ||\n    domainType.includes('Pleckstrin homology domain') ||\n    domainType === 'PH domain' ||\n    domainType.endsWith('pleckstrin homology-like domain') ||\n    domainType === 'DEP domain' ||\n    domainType === 'Post-SET domain' ||\n    domainType.includes('Glycoside hydrolase') ||\n    domainType === 'Pyridoxal phosphate-dependent decarboxylase' ||\n    domainType.includes('OB1') ||\n    domainType.includes('OB3') ||\n    domainType.includes('OB domain') ||\n    domainType === 'Fork head domain' ||\n    domainType === 'Histone deacetylase domain' ||\n    domainType.includes('MG1') ||\n    domainType === 'Homocysteine-binding domain' ||\n    domainType.startsWith('Acyl-CoA') && domainType.endsWith('N-terminal') ||\n    domainType === 'Clathrin light chain' ||\n    domainType === 'Hexokinase, N-terminal' // e.g. HK2\n  ) {\n    return [lightBlue, lightBlueLine];\n  } else if (\n    // Larger binding regions and miscellaneous\n    domainType.includes('zinc-binding') ||\n    domainType.includes('DNA-binding') ||\n    domainType === 'RUNT domain' || // a DNA-binding / PPI domain, e.g. RUNX1\n    domainType === 'G protein-coupled receptor, rhodopsin-like' ||\n    domainType.includes('CXC domain') ||\n    domainType.includes('Homeobox domain') ||\n    domainType.includes('BRCT domain') ||\n    domainType.includes('EF-hand') ||\n    domainType === 'Laminin G domain' ||\n    domainType === 'Peptidase C14, caspase non-catalytic subunit p10' ||\n    domainType === 'ADD domain' ||\n    domainType === 'PDZ domain' ||\n    domainType === 'Krueppel-associated box' ||\n    domainType === 'Ets domain' ||\n    domainType === 'P domain' ||\n    domainType.includes('bHLH') ||\n    domainType === 'Ras-associating (RA) domain' ||\n    domainType === 'Ras-associating domain' ||\n    domainType ===\n      'Calcium/calmodulin-dependent protein kinase II, association-domain' ||\n    domainType === 'Bromodomain' ||\n    domainType === 'Bromodomain associated domain' ||\n    domainType === 'SLIDE domain' ||\n    domainType === 'Peptidase M24' ||\n    domainType === 'Pentraxin-related' ||\n    domainType.includes('Notch ligand') ||\n    domainType === 'Anti-proliferative protein' ||\n    domainType.includes('transpeptidase') ||\n    domainType === 'Tuberin-type domain' ||\n    domainType === 'Ras-like guanine nucleotide exchange factor, N-terminal' ||\n    domainType.includes('factor-binding protein') || // as in IGFBP3\n    domainType.includes('GPD') || // e.g. MUTYH in ACMG\n    domainType === 'ELM2 domain' // e.g. MTA2\n  ) {\n    return [darkBlue, darkBlueLine];\n  } else if (\n    domainType === 'SH2 domain' ||\n    domainType.includes('SH2-like domain') ||\n    domainType.includes('Furin-like') ||\n    domainType.includes('heparin-binding') ||\n    domainType === 'SRCR domain' ||\n    domainType === 'EGF-like domain' ||\n    domainType === 'Basic leucine zipper domain, Maf-type' ||\n    domainType.startsWith('Leucine zipper') ||\n    domainType.includes('Interleukin') && domainType.includes('propeptide') ||\n    domainType === 'Sirtuin family' ||\n    domainType === 'Amino acid/polyamine transporter I' ||\n    domainType === 'Peptidase M10, metallopeptidase' ||\n    domainType === 'Metallothionein' ||\n    domainType === 'DDHD domain' ||\n    domainType === 'Zinc finger C2H2-type' ||\n    domainType === 'Zinc finger, PARP-type' ||\n    domainType.endsWith('tail domain') ||\n    domainType === 'SET domain' ||\n    domainType === 'Hamartin' || // e.g. TSC2 in ACMG; interacts with tuberin\n    domainType.includes('von Hippel') && domainType.includes('alpha') || // VHLL\n    domainType.includes('transactivation domain 2') ||\n    domainType === 'Phosphopantetheine binding ACP domain' ||\n    domainType === 'Multicopper oxidase, second cupredoxin domain' ||\n    domainType === 'Helicase, C-terminal' ||\n    domainType.includes('Carboxylesterase') || // e.g. ACHE\n    domainType.includes('presequence') || // e.g. ALAS2\n    domainType.endsWith('CC3') // e.g. PRKDC\n  ) {\n    return [green, greenLine];\n  } else if (\n    domainType === 'Insulin-like' ||\n    domainType === 'Fibroblast growth factor family' ||\n    domainType === 'Nerve growth factor-related' ||\n    domainType === 'Transforming growth factor-beta, C-terminal' ||\n    domainType === 'Telomere-length maintenance and DNA damage repair' ||\n    domainType === 'PDGF/VEGF domain' ||\n    domainType.includes('SH3-RhoGEF') ||\n    domainType.includes('MG4') ||\n    domainType.includes('RING domain') ||\n    domainType.includes('RING-type') ||\n    domainType.startsWith('DEAD/DEAH') ||\n    domainType === 'Laminin alpha, domain I' ||\n    domainType.toLowerCase().includes('nuclear/hormone receptor') ||\n    domainType === 'P-type trefoil domain' || // e.g. GAA in ACMG\n    domainType.includes('KHDRBS')\n  ) {\n    return [darkGreen, darkGreenLine];\n  } else if (\n    domainType === 'SH3 domain' ||\n    domainType === 'Variant SH3 domain' ||\n    domainType.endsWith('SH3 domain') ||\n    domainType.includes('copper-binding') ||\n    domainType === 'Sushi/SCR/CCP domain' ||\n    domainType.includes('Coagulation factor 5/8') ||\n    domainType === 'Basic-leucine zipper domain' ||\n    domainType === 'Basic region leucine zipper' ||\n    domainType === 'Sirtuin family, catalytic core domain' ||\n    domainType === 'Amine oxidase' ||\n    domainType.includes('peroxidase') ||\n    domainType.includes('lid domain') ||\n    domainType.includes('prodomain') ||\n    domainType === 'Pre-SET domain' ||\n    domainType.includes('transactivation domain') ||\n    domainType.includes(' activation domain') ||\n    domainType.includes('activating region') ||\n    domainType === 'Thioesterase' ||\n    domainType.toLowerCase().includes('thiored') || // e.g. TXNDC12\n    domainType.includes('esterase') ||\n    domainType.endsWith('Claudin superfamily') ||\n    domainType === 'Retinoblastoma-associated protein, A-box' ||\n    domainType.includes('Between PH and SH2') ||\n    domainType.includes('inter-SH2') ||\n    domainType === 'Chromogranin A/B/C' ||\n    domainType.toLowerCase().includes('helicase') ||\n    domainType.endsWith('pro-domain') ||\n    domainType === 'Brix domain' ||\n    domainType === 'Coagulation Factor Xa inhibitory site' ||\n    domainType === 'Trypsin Inhibitor-like, cysteine rich domain' ||\n    domainType === 'WIF domain' || // Wnt1 inhibitory factor, e.g. WIF1\n    domainType.toLowerCase().includes('cystatin') ||\n    domainType === 'EGF domain' ||\n    domainType === 'Axin beta-catenin binding' ||\n    domainType === 'Peptidase M2, peptidyl-dipeptidase A' ||\n    domainType.endsWith('phosphatase domain') ||\n    domainType === 'PIGA, GPI anchor biosynthesis' ||\n    domainType.startsWith('Acyl-CoA') && domainType.endsWith('middle domain') ||\n    domainType.includes('(COR)') ||\n    domainType === 'K Homology domain, type 2' ||\n    domainType.includes('Phox') ||\n    domainType.includes('PB1') ||\n    domainType.includes('multifunctional domain') ||\n    domainType.includes('MutS, core') ||\n    domainType === 'RAP domain' || // RNA-binding, e.g. FASTK\n    domainType.endsWith('CC5') || // e.g. PRKDC\n    domainType.includes('first molybdopterin') // e.g. XDH\n  ) {\n    return [seafoam, seafoamLine];\n  } else if (\n    // Immunoglobulin domains are colored in the pink-purple spectrum\n    domainType === 'Immunoglobulin-like domain' ||\n    domainType.toLowerCase().endsWith('immunoglobulin-like domain') ||\n    domainType.endsWith('Ig domain') ||\n    domainType.endsWith('Ig-like domain') ||\n    domainType === 'Major facilitator superfamily domain' ||\n    domainType.includes('interface') ||\n    domainType === 'Class I myosin tail homology domain' ||\n    domainType === 'Myosin tail' ||\n    domainType === 'Acyl transferase' ||\n    domainType.endsWith('transferase') ||\n    domainType.startsWith('Acyl-CoA') ||\n    domainType === 'JAK, FERM F2 lobe domain' ||\n    domainType === 'Sodium/solute symporter' ||\n    domainType.includes('foci domain') ||\n    domainType.includes('Receptor L-domain') ||\n    domainType === 'Wnt' ||\n    domainType === 'R-spondin, Fu-CRD domain' ||\n    domainType.endsWith('merisation domain') || // e.g. di- / tetramerisation\n    domainType.endsWith('merization domain') ||\n    domainType.endsWith('merisation motif') || // e.g. di- / tetramerisation\n    domainType.endsWith('merization motif') ||\n    domainType.endsWith('BTB/POZ domain') || // homodimerization domain\n    domainType.includes('CBS domain') || // these domains homo-dimerize\n    domainType === 'DZF domain' || // domain associated with zinc fingers; dimerisation domain\n    domainType === 'GS domain' || // in kinase superfamily\n    domainType.includes('kinase domain') ||\n    domainType.includes('FAT') ||\n    domainType.startsWith('von Willebrand factor, type A') ||\n    domainType.includes('VWA') ||\n    domainType === 'Reeler domain' ||\n    domainType === 'BMP/retinoic acid-inducible neural-specific protein' ||\n    domainType === 'Low-density lipoprotein (LDL) receptor class A repeat' ||\n    domainType === 'TILa domain' ||\n    domainType.includes('chromosome condensation') ||\n    domainType === 'Immunoglobulin I-set' || // e.g. MYBPC3\n    domainType === 'Kinesin-associated' ||\n    domainType === 'SMCs flexible hinge' || // e.g. SMC1A\n    domainType.includes('Cys-His rich domain') // e.g. NSD2\n  ) {\n    return [pink, pinkLine];\n  } else if (\n    domainType === 'Immunoglobulin' ||\n    domainType === 'Immunoglobulin domain' ||\n    domainType === 'CD20-like family' ||\n    domainType === 'Calponin homology domain' ||\n    domainType.endsWith('Calponin-homology domain') ||\n    domainType.includes('ATPase') ||\n    domainType.includes('ATP coupling domain') ||\n    domainType.includes('globular domain') ||\n    domainType === 'Mitochondrial substrate/solute carrier' ||\n    domainType === 'Major facilitator,  sugar transporter-like' ||\n    domainType === 'Major facilitator, sugar transporter-like' ||\n    domainType === 'Sodium:neurotransmitter symporter' ||\n    domainType.toLowerCase().includes('methyltransferase') ||\n    domainType === 'Rhodanese-like domain' ||\n    domainType.startsWith('Thyroglobulin') ||\n    domainType === 'Retinoblastoma-associated protein, B-box' ||\n    domainType === 'C-type lectin-like' ||\n    domainType === 'Galectin, carbohydrate recognition domain' ||\n    domainType === 'VWFC domain' || // von Willebrand\n    domainType.includes('CFC domain') ||\n    domainType === 'POLO box domain' ||\n    domainType.endsWith('domain 1') ||\n    domainType.endsWith('domain II') || // e.g. EEF2\n    domainType === 'Fibronectin, type I' ||\n    domainType === 'Cadherin-like' ||\n    domainType === 'G-protein gamma-like domain' ||\n    domainType === 'GoLoco motif' ||\n    domainType === 'MyTH4 domain' ||\n    domainType.endsWith('isomerase') ||\n    domainType === ('BTB/Kelch-associated') || // associated with BTB/POZ\n    domainType === 'Stathmin family'\n  ) {\n    return [veryLightPurple, veryLightPurpleLine];\n  } else if (\n    domainType === 'Immunoglobulin C1-set' ||\n    domainType.includes('GTPase') ||\n    domainType === 'RGS domain' ||\n    domainType === 'Major facilitator superfamily' ||\n    domainType === 'Fibronectin type II domain' ||\n    domainType.includes('ectodomain') ||\n    domainType.endsWith('receptor domain') ||\n    domainType.endsWith('receptor domain 4') ||\n    domainType === 'MAM domain' ||\n    domainType === 'IPT domain' ||\n    domainType.endsWith('extracellular') ||\n    domainType === 'Link domain' ||\n    domainType.includes('connector domain') ||\n    domainType === 'WW domain' ||\n    domainType === 'WHIM1 domain' ||\n    domainType === 'TNFR/NGFR cysteine-rich region' ||\n    domainType === 'Frizzled domain' ||\n    domainType === 'Netrin module, non-TIMP type' ||\n    domainType === 'CFTR regulator domain' ||\n    domainType.endsWith('domain 2') ||\n    domainType === 'GNAT domain' ||\n    domainType === 'NIDO domain' ||\n    domainType === 'Myosin head, motor domain' ||\n    domainType === 'von Willebrand domain, type D domain' ||\n    domainType === 'Kinesin-like KIF1-type' ||\n    domainType.includes('Paxillin') || // e.g. PXN, an ACMG gene\n    domainType === 'Clathrin, heavy chain/VPS, 7-fold repeat' ||\n    domainType === 'Collagen IV, non-collagenous'\n  ) {\n    return [lightPurple, lightPurpleLine];\n  } else if (\n    domainType === 'Fibronectin type III' ||\n    domainType === 'Tissue factor' ||\n    domainType === 'Immunoglobulin C2-set' ||\n    domainType.includes('immunoglobulin C2-set') ||\n    domainType.includes('protein interaction') ||\n    domainType === 'SWIRM domain' ||\n    domainType.includes('(DSL) protein') ||\n    domainType === 'Dishevelled protein domain' ||\n    domainType.endsWith('domain 3') ||\n    domainType === 'DnaJ domain' ||\n    domainType.toLowerCase().includes('nuclear receptor') ||\n    domainType === 'Gonadal family'\n  ) {\n    return [purple, purpleLine];\n  } else if (\n    domainType === 'Immunoglobulin V-set domain' ||\n    domainType.includes('V-set domain') ||\n    domainType.includes('V-like') ||\n    domainType === 'Frizzled/Smoothened, 7TM' ||\n    domainType.endsWith('domain 4') ||\n    domainType === 'Integrin alpha-2' ||\n    domainType === 'Calcium-activated potassium channel BK, alpha subunit' ||\n    domainType.includes('Dbl homology (DH) domain') ||\n    domainType.includes('Glycine rich') ||\n    domainType.toLowerCase().includes('exonuclease') ||\n    domainType === 'WHIM2 domain' ||\n    domainType.includes('Coactivator CBP') || // e.g. EP300\n    domainType.includes('cryptic polo') // e.g. PLK4\n  ) {\n    return [darkPurple, darkPurpleLine];\n  }\n  // Not great in MYBPC3, an AGMC gene\n  // else if (\n  //   domainType === 'Immunoglobulin I-set'\n  // ) {\n  //   return [purple2, purple2Line];\n  // }\n\n  else if (\n    domainType === 'Desmoplakin, spectrin-like domain' ||\n    domainType === 'Spectrin repeat' ||\n    domainType.endsWith('TED domain') ||\n    domainType === 'Polyadenylate-binding protein/Hyperplastic disc protein' ||\n    domainType.includes(' cap domain') ||\n    domainType.toLowerCase().includes('agenet') ||\n    domainType.includes('TATA') ||\n    domainType.includes('Citron') ||\n    domainType === 'RIH domain' ||\n    domainType.toLowerCase().includes('sclerostin') || // e.g. SOSTDC1\n    domainType === 'ZU5 domain' || // e.g. TJP1\n    domainType === 'Piezo domain' || // e.g. PIEZO1\n    domainType === 'Histone H2A/H2B/H3' // e.g. H2AZ1\n  ) {\n    return [yellow, yellowLine];\n  }\n\n  else if (\n    // Repeats, iron, some transmembrane\n    domainType === 'Armadillo' ||\n    domainType.includes('Apple domain') ||\n    domainType === 'Protocadherin' || // Cytoplasmic\n    domainType === 'DIX domain' ||\n    domainType === 'Ferritin-like diiron domain' ||\n    domainType === '4Fe-4S dicluster domain' ||\n    domainType === 'Transferrin-like domain' || // iron-related, e.g. MELTF\n    domainType === 'PAS domain' ||\n    domainType === 'PAS fold' ||\n    domainType === 'Polyketide synthase, dehydratase domain' ||\n    domainType === 'Flavodoxin/nitric oxide synthase' ||\n    domainType === 'Flavodoxin-like fold' ||\n    domainType === 'G-patch domain' ||\n    domainType === 'Chromo domain' ||\n    domainType.toLowerCase().includes('tudor') ||\n    domainType === 'Cytochrome P450' ||\n    domainType === 'Potassium channel domain' ||\n    domainType === 'G2 nidogen/fibulin G2F' ||\n    domainType.includes('bait region') ||\n    domainType === 'WWE domain' ||\n    domainType.endsWith('deiodinase') ||\n    domainType === 'Cobalamin (vitamin B12)-binding domain' ||\n    domainType === 'Laminin domain II' ||\n    domainType === 'Troponin I residues 1-32' || // e.g. TNNI3 in ACMG\n    domainType === 'KI67R' || // KI67 / Chmadrin repeat\n    domainType.includes('FAD-binding') ||\n    domainType.includes('Glucagon') // e.g. GCG, which encodes GLP-1\n  ) {\n    return [orange, orangeLines];\n  } else if (\n    domainType.includes('Kringle') ||\n    domainType.includes('Peptidase M12A') ||\n    domainType === 'TGF-beta, propeptide' ||\n    domainType.includes('autopeptidase') ||\n    domainType.includes('GAIN') ||\n    domainType === 'PIK-related kinase' ||\n    domainType.includes('(PIK) domain') ||\n    domainType === 'LDLR class B repeat' ||\n    domainType === 'Actin family' ||\n    domainType === 'Ferritin/DPS protein domain' ||\n    domainType === 'PAS fold-3' ||\n    domainType === 'Polyketide synthase, ketoreductase domain' ||\n    domainType.startsWith('Heat shock protein') && domainType.endsWith('family') ||\n    domainType === 'BAG domain' || // e.g. BAG3 in AGMC, a chaperone\n    domainType === 'MCM domain' ||\n    domainType.endsWith('reductase-like') ||\n    domainType === 'Lipase' ||\n    domainType === 'Phospholipase A2 domain' ||\n    domainType === 'Notch domain' ||\n    domainType.includes('LCCL domain') ||\n    domainType.includes('SANT-like') ||\n    domainType ===\n      'VWF/SSPO/Zonadhesin-like, cysteine-rich domain' || // E.g. VWF\n    domainType === 'Kappa casein' ||\n    domainType === 'Casein, alpha/beta' ||\n    domainType === 'Natriuretic peptide' ||\n    domainType === 'EMI domain' ||\n    domainType === 'Neurohypophysial hormone' ||\n    domainType === 'Synuclein' ||\n    domainType.includes('Hydroxymethylglutaryl-CoA reductase') ||\n    domainType.includes('Perilipin') ||\n    domainType.includes('lipase') ||\n    domainType.includes('CRAL') || // e.g. NF1\n    domainType.includes('SAND') ||\n    domainType.toLowerCase().includes('hsp') ||\n    domainType.toLowerCase().includes('bombesin') // e.g. GRP\n  ) {\n    return [lightBrown, lightBrownLine];\n  } else if (\n    domainType === 'Notch, NOD domain' ||\n    domainType === 'Cadherin, Y-type LIR-motif' ||\n    domainType === 'Protein patched/dispatched' ||\n    domainType.includes('membrane-proximal') ||\n    domainType === 'LicD family' ||\n    domainType.includes('MoaB/Mog')\n  ) {\n    return [brown, brownLine];\n  } else if (\n    // Transmembrane, etc.\n    domainType.includes('transmembrane domain') ||\n    domainType.includes('trans-membrane domain') ||\n    domainType.includes('Transmembrane protein') ||\n    domainType.includes('7TM') || // e.g. TMEM63A\n    domainType === 'Major intrinsic protein' || // e.g. AQP1\n    domainType.includes('Triadin') ||\n    domainType.includes('Collectrin') ||\n    domainType.includes('membrane glycoprotein') ||\n    domainType === 'SEA domain' ||\n    domainType === 'CD36 family' ||\n    domainType.includes('CD34') ||\n    domainType === 'Hypoxia-inducible factor, alpha subunit' ||\n    domainType === 'Hypoxia-inducible factor, alpha subunit-like' ||\n    domainType === 'PKD domain' ||\n    domainType.includes('regulatory domain') ||\n    domainType.endsWith('E2 domain') ||\n    domainType === 'PLAT/LH2 domain' ||\n    domainType === 'Notch, NODP domain' ||\n    domainType === 'Syndecan/Neurexin domain' ||\n    domainType === 'Zona pellucida domain' ||\n    domainType.includes('Ion transport domain') ||\n    domainType.endsWith('Membrane transport protein MMPL domain') ||\n    domainType.includes('Caveolin') ||\n    domainType === 'Band 7 domain' ||\n    domainType.includes('Shisa') ||\n    domainType === 'ABC-2 family transporter protein' ||\n    domainType === 'Anoctamin' ||\n    domainType === 'Sodium-dependent phosphate transport protein' || // SLC34A2\n    domainType.includes('MHC II-interacting') // e.g. CD74\n  ) {\n    return [darkBrown, darkBrownLine];\n  } else if (\n    // Death, ubiquitination, apoptosis, etc.\n    domainType === 'DAPIN domain' ||\n    domainType === 'Death effector domain' ||\n    domainType === 'Death domain' ||\n    domainType.includes('death protein') ||\n    domainType.toLowerCase().includes('lethal') ||\n    domainType.includes('UBA domain') ||\n    domainType.includes('HECT domain') ||\n    domainType.toLowerCase().includes('ubiquitin') ||\n    domainType.includes('necrosis') ||\n    domainType.toLowerCase().includes('death') ||\n    domainType.includes('Bcl-2') ||\n    domainType.includes('CIDE-N') ||\n    domainType === 'Disintegrin domain' ||\n    domainType.includes('TRAF') ||\n    domainType.includes('TIR') ||\n    domainType.toLowerCase().includes('caspase') ||\n    domainType === 'Pellino family'\n  ) {\n    return [darkGrey, darkGreyLine];\n  } else if (\n    domainType.includes('unknown function') ||\n    domainType.toLowerCase().includes('unstructured') ||\n    domainType.startsWith('Uncharacterised')\n  ) {\n    return [grey, greyLine];\n  } else if (\n    domainType.toLowerCase().includes('leucine rich repeat') ||\n    domainType.includes('HIN') ||\n    domainType.includes('calcium') ||\n    domainType.toLowerCase().includes('calreticulin') ||\n    domainType.includes('cytokine receptor') ||\n    domainType.includes('pore forming') ||\n    domainType.includes('RHIM') ||\n    domainType.includes('SWIB') ||\n    domainType === 'Ryanodine receptor Ryr' ||\n\n    // Associated with repeats\n    domainType.includes('Armadillo') || // e.g. APC\n    domainType === 'UME domain' || // overlaps Armadillo-type fold, e.g. ATR\n    domainType.includes('WD40 domain') ||\n\n    domainType === 'WSTF/Acf1/Cbp146' || // ATP-utilising chromatin assembly and remodeling factor\n    domainType === 'BCL7' || // e.g. BCL7A\n    domainType.endsWith('repeat ring region') || // e.g. TRRAP\n\n    domainType.includes('PANDER') || // e.g. FAM3C\n\n    // GPCRs\n    domainType === 'GPCR, rhodopsin-like, 7TM' ||\n    domainType === 'GPCR, family 2, secretin-like' ||\n    domainType === 'GPCR, family 3, nine cysteines domain' ||\n    domainType === 'G-protein coupled receptor' ||\n    domainType.toLowerCase().includes('orexin') || // e.g. HCRTR2\n\n    domainType === '[2Fe-2S]-binding'\n  ) {\n    return [darkOrange, darkOrangeLines];\n  } else if (\n    domainType.includes('repeat') ||\n    domainType === 'Vitellinogen, open beta-sheet' ||\n    domainType.includes('Interleukin') && domainType.includes('family') ||\n    /Interleukin-\\d+$/.test(domainType) ||\n    domainType === 'Chemokine interleukin-8-like domain' ||\n    domainType.includes('beta-ribbon') ||\n    domainType.includes('cytoplasmic domain') ||\n    domainType.toLowerCase().includes('interleukin') ||\n    domainType === 'Citrate transporter-like domain' ||\n    domainType.toLowerCase().includes('calsequestrin')\n  ) {\n    return [orange, orangeLines];\n  } else if (\n    domainType.includes('inhibit') ||\n    domainType.includes('central') ||\n    domainType.endsWith('tail') ||\n    domainType.endsWith('helical domain') ||\n    domainType.endsWith('helical domain HD2') ||\n    domainType.endsWith('coiled-coil domain') ||\n    domainType.endsWith('coiled-coil region') ||\n    domainType.includes('zinc ribbon fold') ||\n    domainType.includes('zinc-ribbon') ||\n    domainType.toLowerCase().includes('anhydrase') || // e.g. CA6\n    domainType === 'Macroglobulin domain' ||\n    domainType.includes('KH0') ||\n    domainType.includes('EGF') ||\n    domainType.toLowerCase().includes('olfact') ||\n    domainType.toLowerCase().includes('mucin') // e.g. CEL\n  ) {\n    return [seafoam, seafoamLine];\n  } else if (\n    domainType.includes('Peptidase') ||\n    domainType.includes('Ras-binding') ||\n    domainType.includes('CRIB domain')\n  ) {\n    return [blue, blueLine];\n  } else if (\n    domainType.toLowerCase().includes('zinc finger') ||\n    domainType.toLowerCase().includes('zinc-finger') ||\n    domainType.includes('RING finger') ||\n    domainType.toLowerCase().includes('transcription factor') ||\n    domainType === 'Paired domain' || // found in eukaryotic transcription regulatory proteins involved in embryogenesis\n    domainType === 'JmjC domain' ||\n    domainType === 'BRK domain' ||\n    domainType.includes('MG3') ||\n    domainType.toLowerCase().includes('polycomb') ||\n    domainType.toLowerCase().includes('metallopeptidase') ||\n    domainType.toLowerCase().includes('metallo-peptidase') ||\n    domainType.toLowerCase().includes('metalloenzyme') ||\n    domainType === 'K Homology domain, type 1' ||\n    domainType.includes('winged helix') ||\n    domainType.toLowerCase().includes('dehydrogenase') ||\n    domainType.includes('BAR') ||\n    domainType.includes('metal') ||\n    domainType.includes('redoxin')\n  ) {\n    return [green, greenLine];\n  } else if (\n    domainType.startsWith('Tyrosine-protein kinase receptor') ||\n    domainType === 'PTB/PI domain' ||\n    domainType.endsWith('receptor') ||\n    domainType.includes('cysteine rich') ||\n    domainType.includes('cysteine-rich') ||\n    domainType === 'AWS domain' || // cysteine-rich, e.g. NSD2\n    domainType.toLowerCase().includes('somatomedin b') ||\n    domainType.includes('MHC class II') && !domainType.includes('C-terminal')\n  ) {\n    return [lightPurple, lightPurpleLine];\n  } else if (\n    domainType.toLowerCase().includes('golgi') ||\n    domainType === 'GOLD domain' ||\n    domainType.includes('deaminase') ||\n    domainType.includes('C-terminal core') ||\n    domainType.includes('nucleoside triphosphatase') ||\n    domainType.includes('globin') ||\n    domainType.includes('IspD/TarI') ||\n    domainType === 'Telethonin' ||\n    domainType.includes('Sarcoglycan') ||\n    domainType.includes('toxin') ||\n    domainType.includes('ShKT') ||\n    domainType.includes('SAM') ||\n    domainType.includes('Sterile alpha motif') ||\n    domainType.includes('Unconventional myosin-X') ||\n    domainType === 'CARD domain' ||\n    domainType.includes('endonuclease') ||\n    domainType.toLowerCase().includes('splicing factor') ||\n    domainType.toLowerCase().includes('interferon') ||\n    domainType === 'Tropomyosin' || // e.g. TPM1\n    domainType.includes('R1 domain') // e.g. MTA2\n  ) {\n    return [magenta, magentaLines];\n  } else if (\n    domainType.includes('TM') || // transmembrane, as in e.g. RYR1\n    domainType.toLowerCase().includes('transmembrane') ||\n    domainType.toLowerCase().includes('trans-membrane')\n  ) {\n    return [darkBrown, darkBrownLine];\n  } else if (\n    domainType.includes('binding domain') ||\n    domainType.includes('binding protein')\n  ) {\n    return [darkBlue, darkBlueLine];\n  } else if (\n    domainType.includes('Ribosomal protein') ||\n    domainType.toLowerCase().includes('ribosomal subunit') ||\n    domainType.toLowerCase().includes('ribosom') ||\n    domainType.toLowerCase().includes('ribonuclease')\n  ) {\n    return [darkGreen, darkGreenLine];\n  } else if (\n    domainType.includes('lectin') ||\n    domainType.includes('recognition') ||\n    domainType.toLowerCase().includes('solute carrier') ||\n    domainType.includes('isomerase') ||\n    domainType === 'Clathrin-H-link'\n  ) {\n    return [veryLightPurple, veryLightPurpleLine];\n  } else if (\n    domainType.startsWith('von Willebrand factor') ||\n    domainType.endsWith('receptor-binding') ||\n    domainType.toLowerCase().includes('link') ||\n    domainType.includes('basic domain') ||\n\n    domainType.includes('interacting') ||\n\n    domainType.includes('domain IV') || // e.g. EEF2\n\n    domainType.toLowerCase().includes('immunoglobulin domain')\n  ) {\n    return [purple, purpleLine];\n  } else if (\n    domainType.includes('transferase') ||\n    domainType.includes('merisation')\n  ) {\n    return [pink, pinkLine];\n  } else if (\n    domainType.includes('oxygenase')\n  ) {\n    return [red, redLine];\n  } else if (\n    domainType.includes('phosphatase') ||\n    domainType.includes('RNA polymerase') ||\n    domainType.includes('catenin') // e.g. VCL\n  ) {\n    return [seafoam, seafoamLine];\n  } else if (\n    domainType.includes('bind') ||\n    domainType.includes('EF')\n  ) {\n    return [blue, blueLine];\n  } else if (\n    // C-terminal regions are typically colored red in e.g. PyMol rainbow\n    domainType.includes('C-termin') ||\n    domainType.includes('C termin') ||\n    domainType.includes('kinase')\n  ) {\n    return [faintRed, faintRedLine];\n  } else if (\n    // N-terminal regions are typically colored blue in e.g. PyMol rainbow\n    domainType.includes('N-termin') ||\n    domainType.includes('N-teminal') || // Typo in \"CTNNB1 binding, N-teminal\"\n    domainType.includes('N termin') ||\n    domainType.toLowerCase().includes('decarboxylase') ||\n    domainType.toLowerCase().includes('hydrolase') ||\n    domainType.includes('PH domain') ||\n    domainType.includes('cytosolic') ||\n    domainType.toLowerCase().includes('homeobox')\n  ) {\n    return [lightBlue, lightBlueLine];\n  }\n\n  return [lightGrey, lightGreyLine];\n}\n","/**\n * @fileoverview Functions to render 2D protein structure, i.e. linear domains\n *\n * The protein diagrams are shown in the Gene Leads tooltip.\n */\n\nimport {addPositions, getGeneFromStructureName, pipe} from './gene-structure';\nimport {getColors} from './protein-color';\n\n/** Get subtle line to visually demarcate feature boundary */\nfunction getFeatureBorderLines(\n  x, y, width, baseHeight, lineColor, addTopBottom=false\n) {\n  const height = y + baseHeight;\n  const lineStroke = `stroke=\"${lineColor}\"`;\n  const leftLineAttrs =\n    `x1=\"${x}\" x2=\"${x}\" y1=\"${y}\" y2=\"${height}\" ${lineStroke}`;\n\n  const x2 = x + width;\n  const rightLineAttrs =\n    `x1=\"${x2}\" x2=\"${x2}\" y1=\"${y}\" y2=\"${height}\" ${lineStroke}`;\n\n  const startBorder = `<line class=\"subpart-line\" ${leftLineAttrs} />`;\n  const endBorder = `<line class=\"subpart-line\" ${rightLineAttrs} />`;\n\n  // Added to feature if any part of protein has topology data\n  let topBorder = '';\n  let bottomBorder = '';\n  if (addTopBottom) {\n    const topLineAttrs =\n      `x1=\"${x}\" x2=\"${x2}\" y1=\"${y}\" y2=\"${y}\" ${lineStroke}`;\n    const bottomLineAttrs =\n      `x1=\"${x}\" x2=\"${x2}\" y1=\"${height}\" y2=\"${height}\" ${lineStroke}`;\n    topBorder = `<line class=\"subpart-line\" ${topLineAttrs} />`;\n    bottomBorder = `<line class=\"subpart-line\" ${bottomLineAttrs} />`;\n  }\n\n  return startBorder + endBorder + topBorder + bottomBorder;\n}\n\n/** Get start and length for coding sequence (CDS), in pixels and base pairs */\nfunction getCdsCoordinates(subparts, isPositiveStrand) {\n  // Test case: XRCC3 (-, multiple 5'-UTRs), RAD51D (big 3'-UTR)\n  if (!isPositiveStrand) subparts = subparts.slice().reverse();\n\n  // Start of CDS is end of last 5'-UTR, for default case (positive strand)\n  const startUtr = isPositiveStrand ? \"5'-UTR\" : \"3'-UTR\";\n  const lastStartUtr = subparts.filter(s => s[0] === startUtr).slice(-1)[0];\n  let startPx, startBp;\n  if (lastStartUtr) {\n    startPx = lastStartUtr.slice(-1)[0].x + lastStartUtr.slice(-1)[0].width;\n    startBp = lastStartUtr[1] + lastStartUtr[2];\n  } else {\n    // For transcipts without an annotated start UTR, e.g. EGFR-205\n    startPx = 0;\n    startBp = 0;\n  }\n\n  // End of CDS is start of first 3'-UTR, for default case\n  const endUtr = isPositiveStrand ? \"3'-UTR\" : \"5'-UTR\";\n  const firstEndUtr = subparts.filter(s => s[0] === endUtr).slice(-1)[0];\n  let stopPx, stopBp;\n  if (firstEndUtr) {\n    stopPx = firstEndUtr.slice(-1)[0].x;\n    stopBp = firstEndUtr[1];\n  } else {\n    // For transcipts without an annotated last UTR, e.g. EGFR-205\n    const lastSubpart = subparts.slice(-1)[0];\n    stopPx = lastSubpart.slice(-1)[0].x + lastSubpart.slice(-1)[0].width;\n    stopBp = lastSubpart[1] + lastSubpart[2];\n  }\n\n  const lengthBp = stopBp - startBp;\n  const lengthPx = stopPx - startPx;\n\n  const cdsCoordinates = {\n    px: {start: startPx, length: lengthPx},\n    bp: {start: startBp, length: lengthBp}\n  };\n  return cdsCoordinates;\n}\n\nfunction isTopologyFeature(feature) {\n  return feature[0][0] === '_';\n}\n\nfunction isSignalPeptideFeature(feature) {\n  return feature[0] === 'S';\n}\n\nconst topologyFeatureMap = {\n  '_H': 'Helical',\n  '_E': 'Extracellular',\n  '_C': 'Cytoplasmic'\n};\nfunction decompressTopologyFeature(feature) {\n  if (feature in topologyFeatureMap) {\n    return topologyFeatureMap[feature];\n  } else {\n    return feature.slice(1);\n  }\n}\n\n/** Get SVG for an inidividual protein domain */\nfunction getFeatureSvg(feature, cds, isPositiveStrand, hasTopology) {\n  let featureType = feature[0];\n  const featurePx = feature.slice(-1)[0];\n\n  let x = cds.px.start + featurePx.x;\n  let width = featurePx.width;\n  if (!isPositiveStrand) {\n    x = cds.px.length + cds.px.start - (featurePx.x + featurePx.width);\n  };\n\n  // Perhaps make these configurable, later\n  let y = 30;\n  let height = 14;\n  const isTopology = isTopologyFeature(feature);\n  const isSignal = isSignalPeptideFeature(feature);\n  let topoAttr = '';\n  if (hasTopology) {\n    y = 38;\n    if (isTopology) {\n      featureType = decompressTopologyFeature(feature[0]);\n      y = 30;\n      height = 30;\n\n      const featureDigest = `${feature[0]} ${feature[1]} ${feature[2]}`;\n\n      if (\n        // E.g. EGF-206 alternative isoform, C-terminal cytoplasmic domain\n        isPositiveStrand && featurePx.x + featurePx.width > cds.px.length + 3 ||\n\n        // E.g. SCARB1-201 canonical isoform, C-terminal cytoplasmic domain\n        !isPositiveStrand && featurePx.x + featurePx.width > cds.px.length + 3\n      ) {\n        console.debug(`Truncate protein topology feature: ${featureDigest}`);\n        width -= (featurePx.x + featurePx.width) - cds.px.length;\n        if (!isPositiveStrand) {\n          x += width;\n        }\n      }\n      topoAttr = 'data-topology=\"true\"';\n\n      if (width < 0) {\n        // E.g. LDLR-202 alternative isoform, multiple features\n        const issue = 'Width < 0, omit protein topology feature';\n        console.debug(`${issue}: ${featureDigest}`);\n        return '';\n      };\n    }\n  }\n\n  const [color, lineColor] = getColors(featureType);\n\n  if (isSignal) {\n    featureType = 'Signal peptide';\n    height = 8;\n    y += 3;\n  }\n\n  if (isTopology) {\n    if (featureType === 'Helical') {\n      featureType = 'Transmembrane';\n    } else if (featureType.startsWith('Helical --- Name=')) {\n      featureType = featureType.replace('Helical --- Name=', 'Transmembrane: ');\n    }\n  }\n\n  const lengthAa = `${feature[2]}&nbsp;aa`;\n  const title = `data-subpart=\"${featureType} ${pipe} ${lengthAa}\"`;\n  const data = title;\n\n  const pos = `x=\"${x}\" width=\"${width}\" y=\"${y}\" height=\"${height}\"`;\n  const topoCls = isTopology ? ' topology' : '';\n  const cls = `class=\"subpart domain${topoCls}\" `;\n\n  const addTopBottom = !isTopology;\n  const line =\n    getFeatureBorderLines(x, y, width, height, lineColor, addTopBottom);\n  const domainSvg =\n    `<rect ${cls} rx=\"1.5\" fill=\"${color}\" ${pos} ${data} ${topoAttr}/>` +\n    line;\n\n  return domainSvg;\n}\n\n/** Return whether protein SVG should be shown */\nfunction isEligibleforProteinSvg(gene, ideo) {\n  return (\n    ideo.config.showProteinInTooltip &&\n    !(\n      'proteinCache' in Ideogram === false ||\n      gene in Ideogram.proteinCache === false ||\n      ('spliceExons' in Ideogram === false || Ideogram.spliceExons === false)\n    )\n  );\n}\n\nfunction getProteinRect(cds, hasTopology) {\n  const y = hasTopology ? '43' : '35';\n  const fill = hasTopology ? 'BBB' : 'DDD';\n  const stroke = hasTopology ? '555' : '777';\n  const proteinRect =\n    `<rect class=\"_ideoProteinLine\"` +\n      `x=\"${cds.px.start}\" width=\"${cds.px.length}\" ` +\n      `y=\"${y}\" height=\"4\" ` +\n      `fill=\"#${fill}\" ` +\n      `stroke=\"#${stroke}\" ` +\n    `/>`;\n  return proteinRect;\n}\n\n/**\n * Determine if any protein isoforms for this gene have topology features\n *\n * Helps ensure transcripts can be rapidly navigated via arrows in dropdown\n * menu, even when some proteins of the gene have topology and some do not.\n *\n * Example: LDLR\n */\nexport function getHasTopology(gene, ideo) {\n  const hasTopology = Ideogram.proteinCache[gene]?.some(entry => {\n    return entry.protein.some(\n      feature => isTopologyFeature(feature)\n    );\n  });\n  return hasTopology;\n}\n\n/** Get SVG showing 2D protein features, e.g. domains from InterPro */\nexport function getProtein(\n  structureName, subparts, isPositiveStrand, hasTopology, ideo\n) {\n  let features = [];\n  const gene = getGeneFromStructureName(structureName, ideo);\n\n  const isEligible = isEligibleforProteinSvg(gene, ideo);\n  if (!isEligible) return ['<br/>', null];\n\n  const entry = Ideogram.proteinCache[gene].find(d => {\n    return d.transcriptName === structureName;\n  });\n  if (!entry) return ['<br/>', null];\n  const protein = entry.protein;\n  const cds = getCdsCoordinates(subparts, isPositiveStrand);\n\n  // Number of amino acids in protein\n  //\n  // Some principles of molecular biology:\n  //   - Coding sequence (CDS) of mRNA specifies amino acids comprising protein\n  //   - Each amino acid is specified by 3 nucleotides (i.e. codon; 3 nt / aa)\n  //   - 1 codon -- the stop codon -- is not part of protein\n  //\n  // TODO: account for phase\n  //\n  // const proteinLengthAa = Math.floor(cds.bp.length/3) - 1;\n  const proteinLengthAa = null;\n\n  const domains = addPositions(subparts, protein);\n\n  const topologies = [];\n  for (let i = 0; i < domains.length; i++) {\n    const domain = domains[i];\n    const isTopology = isTopologyFeature(domain);\n    const svg = getFeatureSvg(domain, cds, isPositiveStrand, hasTopology);\n    if (isTopology) {\n      topologies.push(svg);\n    } else {\n      features.push(svg);\n    }\n  }\n\n  // Order SVG so protein domains, sites, etc. are in front,\n  // then unannotated protein,\n  // then protein topology features\n  const proteinRect = getProteinRect(cds, hasTopology);\n  topologies.push(proteinRect);\n  features = topologies.concat(features);\n\n  const proteinSvg =\n    `<g id=\"_ideoProtein\">${features.join('')}</g>`;\n\n  return [proteinSvg, proteinLengthAa];\n}\n","/**\n * @fileoverview Functions to render 2D protein structure, i.e. linear domains\n *\n * The protein diagrams are shown in the Gene Leads tooltip.\n */\n\nimport tippy from 'tippy.js';\n\nimport {\n  getBpPerPx, getGeneFromStructureName, pipe\n} from './gene-structure';\n\nfunction getReviewStars(reviewStatus, showEmptyStars=false) {\n  const fullStar = '<span style=\"color: #C89306\">&#9733;</span>';\n  const emptyStar = '<span style=\"color: #C89306\">&#9734;</span>';\n  const reviewStatuses = [\n    'criteria provided, multiple submitters, no conflicts',\n    'reviewed by expert panel',\n    'practice guideline'\n  ];\n  const numStars = reviewStatuses.indexOf(reviewStatus) + 2;\n  let stars = fullStar.repeat(numStars);\n\n  if (showEmptyStars) {\n    stars += emptyStar.repeat(4 - numStars);\n  }\n\n  const cleanStatus = reviewStatus[0].toUpperCase() + reviewStatus.slice(1);\n  const tippyContent = `data-tippy-content=\"${cleanStatus}\"`;\n  stars = `<span class=\"_ideoReviewStatus\" ${tippyContent}>${stars}</span>`;\n\n  return stars;\n}\n\nfunction getTippyConfig(fallbackPlacements) {\n  return {\n    theme: 'light-border',\n    popperOptions: { // Docs: https://atomiks.github.io/tippyjs/v6/all-props/#popperoptions\n      modifiers: [ // Docs: https://popper.js.org/docs/v2/modifiers\n        {\n          name: 'flip',\n          options: {\n            fallbackPlacements // Defined via argument to this function\n          }\n        }\n      ]\n    },\n    onShow: function() {\n      // Ensure only 1 tippy tooltip is displayed at a time\n      document.querySelectorAll('[data-tippy-root]')\n        .forEach(tippyNode => tippyNode.remove());\n    }\n  };\n}\n\nfunction initTippy(ideo) {\n  const toggle = getTippyConfig(['top-start', 'top']);\n  ideo.tippyVariant = tippy('._ideoSpliceToggle[data-tippy-content]', toggle);\n\n  const arrow = getTippyConfig(['bottom']);\n  const updownTips = tippy('._ideoReviewStatus[data-tippy-content]', arrow);\n  ideo.tippyVariant = ideo.tippyVariant.concat(updownTips);\n}\n\nfunction getVariantSummary(v, isFullDetail=false) {\n  const numDiseases = isFullDetail ? v.diseases.length : 1;\n\n  let diseases = v.diseases.slice(0, numDiseases)\n    .map(d => {\n      const id = d.id.replace(':', '_');\n      const url = `https://purl.obolibrary.org/obo/${id}`;\n      const link = `<a href=\"${url}\" target=_blank>${d.name}</a>`;\n      if (d.name === undefined) {\n        d.name = 'Not provided';\n      }\n      const isLinked = isFullDetail && d.name !== 'Not provided';\n      const value = isLinked ? link : d.name;\n      return `<div>-&nbsp;${value}</div>`;\n    }).join('');\n\n  if (!isFullDetail && v.diseases.length > 1) {\n    const numRemaining = v.diseases.length - 1;\n    let remaining = `- ${numRemaining} more condition`;\n    if (numRemaining > 1) remaining += 's';\n    diseases += `<div>${remaining}</div>`;\n  }\n\n  const positionalId =\n    `${v.chromosome}-${v.position}-${v.refAllele}-${v.altAllele}`;\n\n  let head = positionalId;\n  if (v.dbSnpId) {\n    head += ` ${pipe} ${v.dbSnpId}`;\n  };\n  const interestingOrigin = v.origin && v.origin !== 'germline';\n  if (v.rawReviewStatus !== 0 || interestingOrigin) {\n    head += ` ${pipe} `;\n    if (v.rawReviewStatus !== 0) {\n      const stars = getReviewStars(v.reviewStatus);\n      head += stars;\n    }\n    if (v.rawReviewStatus !== 0 && interestingOrigin) {\n      head += ' ';\n    }\n    if (interestingOrigin) {\n      head += v.origin;\n    }\n  }\n\n  const detailedStars = getReviewStars(v.reviewStatus, true);\n\n  let extraHeight = 0;\n  if (isFullDetail) {\n    extraHeight += Math.min(v.diseases.length, 5) * 13;\n    if (v.origin) extraHeight += 13;\n    if (v.afExac) extraHeight += 13;\n  }\n\n  const height = (isFullDetail ? 110 : 87) + extraHeight;\n  const style =\n    `height: ${height}px; ` +\n    'margin-top: 15px; ';\n\n  let supplementaryDetails;\n  if (!isFullDetail) {\n    supplementaryDetails = '<div><i>Click variant for more details</i></div>';\n  } else {\n    supplementaryDetails =\n    `<div>Variant type: ${v.variantType}</div>` +\n    `<div>Review status: ${detailedStars}</div>` +\n    (v.origin ? `<div>Origin: ${v.origin}</div>` : '') +\n    (v.afExac ? `<div>Allele frequency (ExAC): ${v.afExac}</div>` : '') +\n    `<div>ClinVar Variation ID: ${v.clinvarVariantId}</div>` +\n    `<br/>`;\n  }\n\n  const diseaseStyle =\n    'max-height: 70px; ' +\n    'overflow-y: scroll; ' +\n    'width: 275px; ' +\n    'margin: auto;'; // Center text even when long pathway or gene name\n\n  let diseaseBar = '';\n  if (isFullDetail && v.diseases.length >= 5) {\n    const diseaseBarStyle =\n      `width: 100px; ` +\n      'height: 5px; ' +\n      'position: relative; top: 6px; ' +\n      'box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.1); ' +\n      'margin: auto;';\n    diseaseBar = `<div style=\"${diseaseBarStyle}\"></div>`;\n  }\n\n  const variantSummary = `\n    <div class=\"_ideoVariantSummary\" style=\"${style}\">\n      <div>${head}</div>\n      <br/>\n      <div>${v.clinicalSignificance} in:</div>\n      <div style=\"${diseaseStyle}\">\n      ${diseases}\n      </div>\n      ${diseaseBar}\n      <br/>\n      ${supplementaryDetails}\n    </div>`;\n\n  return variantSummary;\n}\n\nfunction getContainers() {\n  const head = document.querySelector('._ideoGeneStructureContainerHead');\n  const tissuePlot = document.querySelector('._ideoTissueExpressionPlot')\n  const tissueContainer = document.querySelector('._ideoTissuePlotContainer');\n\n  return [head, tissuePlot, tissueContainer];\n}\n\nfunction writeVariantSummary(event, isFullDetail, ideo) {\n  const [head, tissuePlot, tissueContainer] = getContainers();\n\n  const isG = event.target.tagName === 'g';\n  const thisVariant = isG ? event.target : event.target.parentElement;\n\n  document.querySelectorAll('._ideoVariant').forEach(vd => {\n    vd.classList.remove('_ideoBackgroundVariant');\n  });\n\n  document.querySelectorAll('._ideoVariant').forEach(vd => {\n    if (vd.id !== thisVariant.id) {\n      vd.classList.add('_ideoBackgroundVariant');\n    }\n  });\n\n  document.querySelector('._ideoVariantSummary')?.remove();\n  const target = event.target;\n  const varId = isG ? target.id : target.parentElement.id;\n  const variant = ideo.variants.find(v => 'v' + v.clinvarVariantId === varId);\n  const variantSummary = getVariantSummary(variant, isFullDetail);\n  tissuePlot.style.display = 'none';\n  head.style.display = 'none';\n  tissueContainer.insertAdjacentHTML('beforeend', variantSummary);\n  initTippy(ideo);\n}\n\nfunction removeVariantSummary() {\n  const [head, tissuePlot, tissueContainer] = getContainers();\n\n  document.querySelectorAll('._ideoVariant').forEach(vd => {\n    vd.classList.remove('_ideoBackgroundVariant');\n  });\n\n  document.querySelector('._ideoVariantSummary')?.remove();\n  tissuePlot.style.display = '';\n  tissueContainer.style.display = '';\n  head.style.display = '';\n}\n\nexport function addVariantListeners(ideo) {\n  document.querySelectorAll('._ideoVariant').forEach(variantDom => {\n    variantDom.addEventListener('mouseover', (event) => {\n      const isFullDetail = false;\n      writeVariantSummary(event, isFullDetail, ideo);\n    });\n    variantDom.addEventListener('click', (event) => {\n      const isFullDetail = true;\n      writeVariantSummary(event, isFullDetail, ideo);\n      event.stopPropagation();\n      variantDom.removeEventListener('mouseout', removeVariantSummary);\n    });\n    variantDom.addEventListener('mouseout', removeVariantSummary);\n  });\n}\n\nfunction addSplicedPositions(subparts, rawVariants) {\n  const features = [];\n\n  const bpPerPx = getBpPerPx(subparts);\n\n  rawVariants = rawVariants.map(v => {\n\n    for (let i = 0; i < subparts.length; i++) {\n      const subpart = subparts[i];\n      const [subpartBpLength, subpartBpStart, subpartPx] = subpart.slice(-3);\n\n      const isRelative = (subpart.length === 5);\n\n      if (\n        subpartBpStart <= v.positionRelative &&\n        subpartBpStart + subpartBpLength >= v.positionRelative\n      ) {\n        const variantSubpartRelativePosition =\n          v.positionRelative - subpartBpStart;\n        let x = variantSubpartRelativePosition / bpPerPx;\n        if (isRelative) x += subpartPx.x;\n        // x += subpartPx.x;\n        const width = 0.5;\n        const feature = [\n          '', variantSubpartRelativePosition, 1, {\n            type: '',\n            x,\n            width\n          }\n        ];\n        features.push(feature);\n        break;\n      }\n    }\n    return v;\n  });\n\n  return features;\n}\n\n/** Get the highest-priority variants */\nfunction triageVariants(rawVariants, maxVariants) {\n  const tier1Variants = rawVariants\n    .filter(v => v.dbSnpId !== '' && v.afExac !== null)\n    .sort((a, b) => b.afExac - a.afExac)\n    .slice(0, maxVariants);\n\n  let selectedVariants = tier1Variants;\n  let selectedIds = selectedVariants.map(v => 'v' + v.clinvarVariantId);\n\n  if (selectedVariants.length < maxVariants) {\n    const tier2Variants = rawVariants\n      .filter(v => {\n        return (\n          (v.dbSnpId !== '' || v.afExac !== null) &&\n          !selectedIds.includes('v' + v.clinvarVariantId)\n        );\n      })\n      .sort((a, b) => b.rawOrigin - a.rawOrigin)\n      .sort((a, b) => b.rawClinicalSignifiance - a.rawClinicalSignifiance)\n      .sort((a, b) => b.rawReviewStatus - a.rawReviewStatus)\n      .sort((a, b) => b.afExac - a.afExac)\n      .slice(0, maxVariants - selectedVariants.length);\n\n    selectedIds =\n      selectedIds.concat(tier2Variants.map(v => 'v' + v.clinvarVariantId));\n\n    selectedVariants = selectedVariants.concat(tier2Variants);\n\n    if (selectedVariants.length < maxVariants) {\n      const tier3Variants = rawVariants\n        .filter(v => !selectedIds.includes('v' + v.clinvarVariantId))\n        .sort((a, b) => b.rawOrigin - a.rawOrigin)\n        .sort((a, b) => b.rawClinicalSignifiance - a.rawClinicalSignifiance)\n        .sort((a, b) => b.rawReviewStatus - a.rawReviewStatus)\n        .slice(0, maxVariants - selectedVariants.length);\n\n      selectedVariants = selectedVariants.concat(tier3Variants);\n    }\n  }\n\n  return selectedVariants;\n}\n\n/** Get SVG showing 2D variant features */\nexport async function getVariantsSvg(\n  geneStructure, subparts, ideo\n) {\n  const t0 = Date.now();\n\n  const structureName = geneStructure.name;\n  const startOffset = geneStructure.startOffset;\n\n  const gene = getGeneFromStructureName(structureName, ideo);\n\n  const cache = Ideogram.variantCache;\n  if (!cache) {\n    return null;\n  }\n\n  let rawVariants = await cache.getVariants(gene, ideo);\n\n  if (rawVariants.length === 0) {\n    return null;\n  }\n\n  const maxVariants = 10;\n  if (rawVariants.length > maxVariants) {\n    rawVariants = triageVariants(rawVariants, maxVariants);\n  }\n\n  console.log('updated rawVariants.length', rawVariants.length)\n\n  rawVariants = rawVariants.map(v => {\n    v.positionRelative -= startOffset;\n    return v;\n  });\n\n  const pxFeatures = addSplicedPositions(subparts, rawVariants);\n\n  const variants = pxFeatures.map((f, i) => {\n    const variant = rawVariants[i];\n    variant.x = f.slice(-1)[0].x;\n    variant.width = f.slice(-1)[0].width;\n    return variant;\n  });\n\n  const diseases = {};\n\n  // variants.map(v => sum += v.afExac)\n  variants.forEach(v => {\n    v.diseases.map(d => {\n      if (d.name in diseases == false) diseases[d.name] = 0;\n      diseases[d.name] += 1;\n    });\n  });\n\n  const lines = variants.reverse().map(v => {\n\n    let vClass = '_ideoPathogenic';\n    let bottomV = 13;\n    let topV = 1;\n    if (v.clinicalSignificance === 'Pathogenic/Likely pathogenic') {\n      vClass = '_ideoPathogenicLikelyPathogenic';\n      bottomV = 16;\n      topV = 4;\n    } else if (v.clinicalSignificance === 'Likely pathogenic') {\n      vClass = '_ideoLikelyPathogenic';\n      bottomV = 19;\n      topV = 7;\n    }\n\n    const triangle = {\n      bottom: `${v.x},${bottomV}`,\n      topLeft: `${v.x - 6.5},${topV}`,\n      topRight: `${v.x + 6.5},${topV}`\n    };\n\n    const points =\n     `${triangle.bottom} ${triangle.topLeft} ${triangle.topRight}`;\n\n    const polygonStyle = 'style=\"cursor: pointer;\"';\n    return `\n      <g class=\"_ideoVariant ${vClass}\" id=\"v${v.clinvarVariantId}\" ${polygonStyle}>\n        <line x1=\"${v.x}\" y1=\"10\" x2=\"${v.x}\" y2=\"25\" />\n        <polygon points=\"${points}\" />\n      </g>\n    `;\n  });\n\n  const style =\n    '<style>' +\n      '._ideoPathogenic {stroke: #D00; fill: #FBB;} ' +\n      '._ideoPathogenicLikelyPathogenic {stroke: #F55; fill: #FDD;} ' +\n      '._ideoLikelyPathogenic {stroke: #F99500; fill: #FEC;} ' +\n      '._ideoVariant._ideoBackgroundVariant {stroke: #BBB; fill: #EEE; opacity: 0.2;} ' +\n    '</style>';\n  const svg = style + lines.join('');\n\n  ideo.variants = variants;\n\n  return svg;\n}\n\nexport function writeVariantsSvg(geneStructure, ideo) {\n   getVariantsSvg(geneStructure, ideo).then(svg => {\n    // console.log('svg', svg)\n    const container = document.querySelector('._ideoGeneStructure')\n    container.insertAdjacentHTML('beforeend', svg);\n   })\n}\n\nwindow.getVariantsSvg = getVariantsSvg\nwindow.writeVariantsSvg = writeVariantsSvg\n","import tippy, {hideAll} from 'tippy.js';\nimport {tippyCss, tippyLightCss} from './tippy-styles';\n// import 'tippy.js/themes/light.css';\n\nimport {d3} from '../lib';\nimport {getIcon} from '../annotations/legend';\nimport {getProtein, getHasTopology} from './protein';\nimport {getVariantsSvg} from './variant';\n\nconst y = 5;\n\n// Subtle visual delimiter; separates horizontally adjacent fields in UI\nexport const pipe = `<span style='color: #CCC'>|</span>`;\n\nconst utr5 = \"5'-UTR\";\nconst utr3 = \"3'-UTR\";\n\nconst heights = {\n  \"5'-UTR\": 20,\n  'exon': 20,\n  'intron': 20,\n  \"3'-UTR\": 20\n};\n\nconst colors = {\n  \"5'-UTR\": '#155069',\n  'exon': '#DAA521',\n  \"intron\": '#FFFFFF00',\n  \"3'-UTR\": '#357089'\n};\n\nconst lineColors = {\n  \"5'-UTR\": '#70A099',\n  'exon': '#BA8501',\n  \"3'-UTR\": '#90C0B9'\n};\n\nconst subpartClasses = {\n  \"5'-UTR\": 'five-prime-utr',\n  'exon': 'exon',\n  \"3'-UTR\": 'three-prime-utr',\n  'intron': 'intron'\n};\n\nconst css =\n  `<style>\n  ._ideoGeneStructureContainerName {\n    position: relative;\n    left: 45px;\n    margin-right: 20px;\n  }\n  ._ideoGeneStructureContainerName.pre-mRNA {\n    left: 70px;\n    margin-right: 70px;\n  }\n  ._ideoGeneStructureContainer rect:hover + line {\n    visibility: hidden;\n  }\n  ._ideoGeneStructureContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: column;\n  }\n  ._ideoGeneStructureContainer:hover ._ideoSpliceToggle {\n    visibility: visible;\n  }\n  ._ideoGeneStructureContainer ._ideoSpliceToggle {\n    visibility: hidden;\n  }\n  ._ideoSpliceToggle {\n    margin-left: 53px; background-color: #EEE;\n  }\n  ._ideoSpliceToggle.pre-mRNA {\n    margin-left: 43px; background-color: #F8F8F8;\n  }\n  ._ideoHoveredSubpart {\n    stroke: #D0D0DD !important; stroke-width: 3px;\n  }\n  #_ideoGeneStructureTip {\n    font-style: italic;\n  }\n\n  ${tippyCss}\n\n  .tippy-box {\n    font-size: 12px;\n  }\n\n  .tippy-content {\n    padding: 3px 7px;\n  }\n  </style>`;\n\nconst hoverTip = '<span id=\"_ideoGeneStructureTip\">Hover for details</span>';\n\n/** Get DOM element for gene structure footer */\nfunction getFooter() {\n  return document.querySelector('._ideoGeneStructureFooter');\n}\n\n/** Write transcript details below the diagram */\nfunction writeFooter(container) {\n  const footer = getFooter();\n  const svgDOM = container.querySelector('svg');\n  const transcriptSummary = svgDOM.getAttribute('data-ideo-footer');\n  footer.innerHTML = `&nbsp;<br/>${transcriptSummary}`;\n}\n\n/** Write newly-selected gene structure diagram, header, and footer */\nasync function updateGeneStructure(ideo, offset=0) {\n  const [structure, selectedIndex] = getSelectedStructure(ideo, offset);\n  const isCanonical = (selectedIndex === 0);\n  const menu = document.querySelector('#_ideoGeneStructureMenu');\n  menu.options[selectedIndex].selected = true;\n  const svgResults = await getSvg(structure, ideo, Ideogram.spliceExons);\n  const svg = svgResults[0];\n  const container = document.querySelector('._ideoGeneStructureSvgContainer');\n  container.innerHTML = svg;\n  updateHeader(Ideogram.spliceExons, isCanonical);\n  writeFooter(container);\n  ideo.addedSubpartListeners = false;\n  addHoverListeners(ideo);\n  initTippy(ideo);\n}\n\n/** Get gene symbol from transcript / gene structure name */\nexport function getGeneFromStructureName(structureName) {\n  const gene = structureName.split('-').slice(0, -1).join('-');\n  return gene;\n}\n\n/** Get name of transcript currently selected in menu */\nfunction getSelectedStructure(ideo, offset=0) {\n  let selectedIndex, structureName;\n\n  const menu = document.querySelector('#_ideoGeneStructureMenu');\n  if (!menu) {\n    const svg = document.querySelector('._ideoGeneStructure');\n    if (!svg) return null; // No gene structure is available, e.g. for miRNA\n    structureName = svg.getAttribute('data-ideo-gene-structure-name');\n    selectedIndex = 0;\n  } else {\n    const numOptions = menu.options.length;\n    const baseIndex = menu.selectedIndex;\n    selectedIndex = baseIndex + offset;\n    if (selectedIndex >= numOptions) {\n      selectedIndex = 0;\n    } else if (selectedIndex < 0) {\n      selectedIndex = numOptions - 1;\n    }\n    structureName = menu.options[selectedIndex].value;\n  }\n  const gene = getGeneFromStructureName(structureName);\n  const geneStructure =\n    Ideogram.geneStructureCache[gene].find(gs => gs.name === structureName);\n\n\n  return [geneStructure, selectedIndex];\n}\n\n/**\n * Add event listeners to the transcript menu:\n * - On click, block upstream listeners from closing tooltip\n * - On change, write newly selected gene structure\n */\nfunction addMenuListeners(ideo) {\n  const menuId = '_ideoGeneStructureMenu';\n  const container = document.querySelector('._ideoGeneStructureContainer');\n\n  // Don't search this gene if clicking to expand the menu\n  container.addEventListener('click', async (event) => {\n    if (event.target.id === menuId) {\n      event.stopPropagation();\n    }\n\n    let svgMaybe = event.target;\n    if (svgMaybe.parentElement.tagName === 'svg') {\n      svgMaybe = svgMaybe.parentElement;\n    };\n\n    // Go to next transcript on clicking down arrow icon, previous on up\n    if (Array.from(svgMaybe.classList).includes('_ideoMenuArrow')) {\n      const menuArrow = svgMaybe;\n      const direction = menuArrow.getAttribute('data-dir');\n      const offset = direction === 'down' ? 1 : -1;\n      await updateGeneStructure(ideo, offset);\n      event.stopPropagation();\n    }\n  });\n\n  // // Go to next transcript on pressing down arrow key, previous on up\n  // document.addEventListener('keydown', (event) => {\n  //   const key = event.key;\n  //   if (['ArrowDown', 'ArrowUp'].includes(key)) {\n  //     const offset = key === 'ArrowDown' ? 1 : -1;\n  //     updateGeneStructure(ideo, offset);\n  //   }\n  // });\n}\n\nfunction toggleSpliceByKeyboard(event) {\n  if (event.key === 's') {\n    const spliceToggle = document.querySelector('._ideoSpliceToggle input');\n    if (!spliceToggle) return;\n\n    const subpartText = document.querySelector('#_ideoSubpartText');\n    if (subpartText) subpartText.innerHTML = '&nbsp;';\n    spliceToggle.dispatchEvent(new MouseEvent('click'));\n  }\n}\n\n/** Listen for keydown and click on / change to splice toggle input */\nfunction addSpliceToggleListeners(ideo) {\n  document.addEventListener('keydown', toggleSpliceByKeyboard);\n\n  const container = document.querySelector('._ideoGeneStructureContainer');\n  const toggler = document.querySelector('._ideoSpliceToggle');\n\n  if (!container) return;\n\n  toggler.addEventListener('change', async (event) => {\n    toggleSplice(ideo);\n    addHoverListeners(ideo);\n    event.stopPropagation();\n  });\n}\n\n/** Helper for keyboard navigation */\nfunction nextIsOutOfSubpartBounds(i, subparts, key) {\n  const isLeft = key === 'left';\n  return (\n    i === 0 && isLeft ||\n    i === subparts.length - 1 && !isLeft\n  );\n}\n\n/**\n * Swap genome-ordered subparts so they render with expected visual layering\n *\n * SVG elements render last-on-top, which often hides subparts UTRs at the\n * ends of transcripts when they're genomically ordered, as they are in e.g.\n * Ensembl.\n *\n * See also: swapUTRsBack\n */\nfunction swapUTRsForward(subparts, isPositiveStrand) {\n  const swappedSubparts = subparts.slice();\n\n  // Account for edge case in certain nonsense-mediated-decay transcripts\n  const utr = isPositiveStrand ? utr3 : utr5;\n  const hasUtr = subparts.some(subpart => subpart[0] === utr);\n\n  subparts.forEach((subpart, i) => {\n    if (i === 0) return;\n    const prevSubpart = subparts[i - 1];\n\n    const prevIsUtr3 = prevSubpart[0] === utr3;\n    const prevIsUtr5 = prevSubpart[0] === utr5;\n    const isExon = subpart[0] === 'exon';\n\n    if (\n      isExon && hasUtr && (\n        (\n          !isPositiveStrand && prevIsUtr3 ||\n          isPositiveStrand && prevIsUtr5\n        ) && (\n          // Account for splice toggle in multi-part UTRs, as in e.g.\n          // canonicals for FAM111B and SCARB1, and alternative MAOA-204\n          subpart[1] !== prevSubpart[1] + prevSubpart[2] - 1 &&\n          prevSubpart[2] !== 2 // Handle canonicals for RAD51 and RAD51B\n        )\n      )\n    ) {\n      swappedSubparts[i] = prevSubpart;\n      swappedSubparts[i - 1] = subpart;\n    }\n  });\n\n  return swappedSubparts;\n}\n\nwindow.swapUTRsForward = swapUTRsForward;\n\nfunction is(element, cls) {\n  return element.classList.contains(cls);\n}\n\n// isExon && (\n//   !isPositiveStrand && prevIsUtr3 ||\n//   isPositiveStrand && prevIsUtr5\n// )\n\nfunction shouldSwapBackDOM(subpart, nextSubpart, isPositiveStrand, hasUtr) {\n  const utr5 = 'five-prime-utr';\n  const utr3 = 'three-prime-utr';\n  const nextIsUtr5 = is(nextSubpart, utr5);\n  const nextIsUtr3 = is(nextSubpart, utr3);\n  const isNotUtr3 = !is(subpart, utr3);\n  const isNotUtr5 = !is(subpart, utr5);\n  return (\n    hasUtr && (\n      !isPositiveStrand && nextIsUtr3 && isNotUtr3 ||\n      isPositiveStrand && nextIsUtr5 && isNotUtr5\n    )\n  );\n}\n\nfunction shouldSwapBackData(subpart, nextSubpart, isPositiveStrand, hasUtr) {\n  const nextIsUtr5 = nextSubpart[0] === utr5;\n  const nextIsUtr3 = nextSubpart[0] === utr3;\n  const isNotUtr3 = subpart[0] !== utr3;\n  const isNotUtr5 = subpart[0] !== utr5;\n  return (\n    hasUtr && (\n      !isPositiveStrand && nextIsUtr3 && isNotUtr3 ||\n      isPositiveStrand && nextIsUtr5 && isNotUtr5\n    )\n  );\n}\n\n/**\n * Restore SVG subparts to genome order, for proper keyboard navigation\n *\n * See also: swapUTRsForward\n */\nfunction swapUTRsBack(subparts, isPositiveStrand) {\n  const swappedSubparts = subparts.slice();\n  const isRaw = Array.isArray(subparts[0]);\n\n  // Account for edge case in animating exon splice for\n  // nonsense-mediated-decay transcripts that lack an annotated UTR,\n  // e.g. SREBF-204\n  let hasUtr;\n  if (isRaw) {\n    const utr = isPositiveStrand ? utr3 : utr5;\n    hasUtr = subparts.some(subpart => subpart[0] === utr);\n  } else {\n    const utr5 = 'five-prime-utr';\n    const utr3 = 'three-prime-utr';\n    const utr = isPositiveStrand ? utr3 : utr5;\n    hasUtr = subparts.some(subpart => is(subpart, utr));\n  }\n\n  subparts.forEach((subpart, i) => {\n    if (i === swappedSubparts.length - 1) return;\n    const nextSubpart = subparts[i + 1];\n    const shouldSwapBackFn = isRaw ? shouldSwapBackData : shouldSwapBackDOM;\n    const shouldSwapBack =\n      shouldSwapBackFn(subpart, nextSubpart, isPositiveStrand, hasUtr);\n    if (shouldSwapBack) {\n      swappedSubparts.splice(i, 1, nextSubpart);\n      swappedSubparts.splice(i + 1, 1, subpart);\n    }\n  });\n  return swappedSubparts;\n}\n\n/**\n * Remove any hover stroke outlines, for subpart highlight edge cases like\n * mouseenter in subpart A while distant subpart B is navigated\n */\nfunction removeHighlights() {\n  const cls = '_ideoHoveredSubpart';\n  const hovereds = document.querySelectorAll(`.${cls}`);\n  hovereds.forEach(el => el.classList.remove(cls));\n}\n\n\n/** Go to previous subpart on left arrow; next on right */\nfunction navigateSubparts(event) {\n  const domSubparts = Array.from(document.querySelectorAll('rect.subpart'));\n\n  const structure = document.querySelector('._ideoGeneStructure');\n  const strand = structure.getAttribute('data-ideo-strand');\n  const isPositiveStrand = strand === '+';\n\n  const subparts = swapUTRsBack(domSubparts, isPositiveStrand);\n\n  if (subparts.length === 0) return; // E.g. paralog neighborhoods, lncRNA\n  const cls = '_ideoHoveredSubpart';\n  const subpart = document.querySelector(`.${cls}`);\n  if (!subpart) {\n    // Accounts for edge case when changing transcripts via menu\n    event.stopPropagation();\n    event.preventDefault();\n    return;\n  }\n  let i;\n  subparts.forEach((el, index) => {\n    if (el.classList.contains(cls)) {\n      i = index;\n    }\n  });\n\n  const options = {view: window, bubbles: false, cancelable: true};\n  const mouseEnter = new MouseEvent('mouseenter', options);\n  const mouseLeave = new MouseEvent('mouseleave', options);\n\n  // Account for strand, so left key always goes left; right always right\n  const left = isPositiveStrand ? 'ArrowLeft' : 'ArrowRight';\n  const right = isPositiveStrand ? 'ArrowRight' : 'ArrowLeft';\n  let key;\n  if (event.key === left) {\n    key = 'left';\n  } else if (event.key === right) {\n    key = 'right';\n  }\n\n  // Don't fall off the end\n  if (\n    typeof key === 'undefined' ||\n    nextIsOutOfSubpartBounds(i, subparts, key)\n  ) {\n    event.stopPropagation();\n    event.preventDefault();\n    return;\n  }\n\n  removeHighlights();\n  const alt = event.altKey;\n  const meta = event.metaKey;\n\n  // Jump forward or back by 1, 10, or all subparts\n  if (event.key === left) { // Jump back\n    subpart.dispatchEvent(mouseLeave);\n    let index = i - 1;\n    if (alt) index = i - 10 < 0 ? 0 : i - 10;\n    if (meta) index = 0;\n    const prevSubpart = subparts[index];\n    prevSubpart.dispatchEvent(mouseEnter);\n  } else if (event.key === right) { // Jump forward\n    subpart.dispatchEvent(mouseLeave);\n    const last = subparts.length - 1;\n    let index = i + 1;\n    if (alt) index = i + 10 > last ? last : i + 10;\n    if (meta) index = last;\n    const nextSubpart = subparts[index];\n    nextSubpart.dispatchEvent(mouseEnter);\n  }\n  event.stopPropagation();\n  event.preventDefault();\n}\n\nfunction getMenuContainer() {\n  return document.querySelector('#_ideoGeneStructureMenuContainer');\n}\n\nfunction updateFooter(content, ideo) {\n  const footer = getFooter();\n  footer.innerHTML = content;\n  initTippy(ideo);\n}\n\nfunction addSubpartHoverListener(subpartDOM, ideo) {\n  const subpart = subpartDOM;\n\n  // On hovering over subpart, highlight it and show details\n  subpart.addEventListener('mouseenter', event => {\n    removeHighlights();\n    // Highlight hovered subpart, adding an aura around it\n    event.target.classList.add('_ideoHoveredSubpart');\n    // Show details\n    const footer = getFooter();\n    ideo.originalTooltipFooter = footer.innerHTML;\n    const subpartText = subpart.getAttribute('data-subpart');\n    const trimmedFoot = footer.innerHTML.replace('&nbsp;', '');\n    const style = 'style=\"margin-bottom: -10px; max-width: 260px;\"';\n    const id = 'id=\"_ideoSubpartText\"';\n    const content = `<div ${id} ${style}\">${subpartText}</div>${trimmedFoot}`;\n    updateFooter(content, ideo);\n    const menuContainer = getMenuContainer();\n    if (menuContainer) menuContainer.style.marginTop = '';\n  });\n\n  // On hovering out, de-highlight and hide details\n  subpart.addEventListener('mouseleave', event => {\n    event.target.classList.remove('_ideoHoveredSubpart');\n    updateFooter(ideo.originalTooltipFooter, ideo);\n    const menuContainer = getMenuContainer();\n    if (menuContainer) menuContainer.style.marginTop = '4px';\n  });\n}\n\n/** Did the mouse event occur inside the tooltip area? */\nfunction isMouseEventInTooltip(event) {\n  const tooltip = document.querySelector('._ideogramTooltip');\n  const box = tooltip.getBoundingClientRect();\n  const x = event.screenX;\n  const y = event.screenY;\n  const inTooltip =\n    (x > box.left && x < box.right && y > box.top && y < box.bottom);\n  return inTooltip;\n}\n\n/**\n * Add handlers for hover events in transcript container and beneath, e.g.:\n *\n * - Show transcript details on hovering near transcript\n * - Show subpart (i.e. exon, 3'-UTR, 5'-UTR) details on hovering over subpart\n * - Highlight subpart on hovering over subpart\n * - Navigate to previous or next subpart on pressing left or right arrow keys\n */\nfunction addHoverListeners(ideo) {\n\n  const subparts = document.querySelectorAll('rect.subpart');\n  if (subparts.length === 0) return; // E.g. paralog neighborhoods, lncRNA\n\n  ideo.subparts = subparts;\n\n  const container = document.querySelector('._ideoGeneStructureContainer');\n\n  container.addEventListener('mouseenter', () => {\n    document.addEventListener('keydown', navigateSubparts);\n    if (ideo.addedMenuListeners) return;\n    ideo.addedMenuListeners = true;\n    writeFooter(container);\n\n    // Listen for change of selected option in transcript menu\n    const tooltip = document.querySelector('._ideogramTooltip');\n    tooltip.addEventListener('change', async () => {\n      await updateGeneStructure(ideo);\n\n      // Without this, selecting a new transcript will close the tooltip if\n      // the selected <option> screen position is outside the tooltip (as\n      // is often the case in genes with many transcripts, like TP53).\n      ideo.oneTimeDelayTooltipHideMs = 2000; // wait 2.0 s instead of 0.25 s\n    });\n\n    if (Ideogram.tissueCache) {\n      const tooltipFooter = document.querySelector('._ideoTooltipFooter');\n      tooltipFooter.style.display = 'none';\n    }\n  });\n  container.addEventListener('mouseleave', (event) => {\n    ideo.oneTimeDelayTooltipHideMs = 2000; // See \"Without this...\" note above\n\n    if (Ideogram.tissueCache) {\n      const tooltipFooter = document.querySelector('._ideoTooltipFooter');\n      tooltipFooter.style.display = '';\n    }\n\n    const inTooltip = isMouseEventInTooltip(event);\n    if (inTooltip === true) {\n      // Only remove transcript footer if `mouseleave` event is from footer to\n      // another part of the tooltip.  If `mouseleave`-ing from footer to\n      // *outside* the tooltip -- e.g. when selecting a new transcript as in\n      // the \"Without this...\" scenario noted above -- then do not remove the\n      // footer.  This lets users always see the details in the footer for the\n      // transcript they just selected, rather than having the details\n      // frustratingly disappear immediately upon transcript selection.\n\n      updateFooter(hoverTip, ideo);\n    }\n\n\n    ideo.addedMenuListeners = false;\n    document.removeEventListener('keydown', navigateSubparts);\n  });\n\n  if (ideo.addedSubpartListeners) return;\n  ideo.addedSubpartListeners = true;\n\n  subparts.forEach(subpart => {\n    addSubpartHoverListener(subpart, ideo);\n  });\n}\n\nfunction writeStrandInFooter(ideo) {\n  const strand = getSelectedStructure(ideo)[0].strand;\n  if (strand === '+') return; // Don't remark if strand is the default\n  const tooltipFooter = document.querySelector('._ideoTooltipFooter');\n  tooltipFooter.innerText =\n    tooltipFooter.innerText.replace(')', `, ${strand})`);\n}\n\nfunction getTippyConfig(fallbackPlacements) {\n  return {\n    theme: 'light-border',\n    popperOptions: { // Docs: https://atomiks.github.io/tippyjs/v6/all-props/#popperoptions\n      modifiers: [ // Docs: https://popper.js.org/docs/v2/modifiers\n        {\n          name: 'flip',\n          options: {\n            fallbackPlacements // Defined via argument to this function\n          }\n        }\n      ]\n    },\n    onShow: function() {\n      // Ensure only 1 tippy tooltip is displayed at a time\n      document.querySelectorAll('[data-tippy-root]')\n        .forEach(tippyNode => tippyNode.remove());\n    }\n  };\n}\n\nfunction initTippy(ideo) {\n  const toggle = getTippyConfig(['top-start', 'top']);\n  ideo.tippy = tippy('._ideoSpliceToggle[data-tippy-content]', toggle);\n\n  const arrow = getTippyConfig(['bottom']);\n  arrow.popperOptions.modifiers.push({\n    name: 'offset',\n    options: {\n      offset: [-5, 20]\n    }\n  });\n  const updownTips = tippy('._ideoMenuArrow[data-tippy-content]', arrow);\n  ideo.tippy = ideo.tippy.concat(updownTips);\n}\n\nexport function addGeneStructureListeners(ideo) {\n  const structure = getSelectedStructure(ideo);\n  if (structure === null) return; // Bail for e.g. miRNA\n  addSpliceToggleListeners(ideo);\n  addHoverListeners(ideo);\n  addMenuListeners(ideo);\n  writeStrandInFooter(ideo);\n  initTippy(ideo);\n}\n\nfunction getSpliceToggleHoverTitle(spliceExons) {\n  return spliceExons ? 'Unsplice exons (s)' : 'Splice exons (s)';\n}\n\nfunction getSpliceToggle(ideo) {\n  const spliceExons = Ideogram.spliceExons;\n  const modifier = spliceExons ? '' : 'pre-';\n  const cls = `class=\"_ideoSpliceToggle ${modifier}mRNA\"`;\n  const checked = spliceExons ? 'checked' : '';\n  const text = getSpliceToggleHoverTitle(spliceExons);\n  const tPlace = 'data-tippy-placement=\"right\"';\n  const title = `data-tippy-content=\"${text}\" ${tPlace}`;\n  const inputAttrs =\n    `type=\"checkbox\" ${checked} ` +\n    `style=\"display: none;\"`;\n  const style =\n    'style=\"position: relative; top: -10px; ' +\n    'user-select: none; ' + // Prevent distracting highlight on quick toggle\n    'float: right; cursor: pointer; font-size: 16px; ' +\n    'padding: 2px 4px; border: 1px solid #CCC; border-radius: 3px;\"';\n  const attrs = `${cls} ${style} ${title}`;\n\n  // Scissors icon\n  const label = `<label ${attrs}><input ${inputAttrs} />&#x2702;</label>`;\n  return label;\n}\n\n/** Splice exons in transcript, removing introns; add positions */\nfunction spliceOut(subparts) {\n  const splicedSubparts = [];\n  let prevEnd = 0;\n  let prevStart = 0;\n  for (let i = 0; i < subparts.length; i++) {\n    const subpart = subparts[i];\n    const [subpartType, start, length] = subpart;\n    const isSpliceOverlap = start === prevStart;\n    let prevRawStart, prevRawLength;\n    if (i > 0) {\n      [, prevRawStart, prevRawLength] = subparts[i - 1];\n    }\n\n    // e.g. 5'-UTRs of OXTR\n    const isOtherOverlap = i > 0 && start === prevRawStart;\n\n    // e.g. 3'-UTR of LDLR, or 3'-UTR of CD44\n    const isOther3UTROverlap = i > 0 && start <= prevRawStart + prevRawLength;\n\n    let splicedStart;\n    if (isSpliceOverlap) {\n      splicedStart = start;\n    } else if (isOtherOverlap) {\n      // e.g. 5'-UTRs of OXTR\n      splicedStart = prevStart;\n    } else if (isOther3UTROverlap) {\n      splicedStart = prevStart + prevRawLength - length;\n    } else {\n      splicedStart = prevEnd;\n    }\n    const splicedEnd = splicedStart + length;\n    const splicedSubpart = [\n      subpartType, splicedStart, length + 1, start\n    ];\n    splicedSubparts.push(splicedSubpart);\n    prevEnd = splicedEnd;\n    prevStart = splicedStart;\n  }\n  const splicedPositionedSubparts = addPositions(splicedSubparts);\n  return splicedPositionedSubparts;\n}\n\n/** Insert introns to transcript; add positions */\nfunction spliceIn(subparts) {\n  const splicedSubparts = [];\n  let prevEnd = 0;\n  for (let i = 0; i < subparts.length; i++) {\n    const subpart = subparts[i];\n    const [start, length] = subpart.slice(1);\n    if (start > prevEnd) {\n      const intronStart = prevEnd;\n      const intronLength = start - prevEnd - 1;\n      splicedSubparts.push(['intron', intronStart, intronLength]);\n    }\n    prevEnd = start + length;\n    splicedSubparts.push(subpart);\n  }\n  const splicedPositionedSubparts = addPositions(splicedSubparts);\n  return splicedPositionedSubparts;\n}\n\nfunction getSpliceStateText(spliceExons, isCanonical=true) {\n  let modifier = '';\n  let suffix = ' and protein';\n  let titleMod = 'without';\n  if (!spliceExons) {\n    modifier = 'pre-';\n    suffix = '';\n    titleMod = 'with';\n  }\n  const canonOrAlt = isCanonical ? 'Canonical' : 'Alternative';\n  const title = `${canonOrAlt} transcript per Ensembl, ${titleMod} introns`;\n  const name = `${canonOrAlt} ${modifier}mRNA ${suffix}`;\n  return {title, name};\n}\n\n/** Draw introns in initial splice toggle from mRNA to pre-mRNA */\nfunction drawIntrons(prelimSubparts, matureSubparts, ideo) {\n  // Hypothetical example data, in shorthand\n  // pres = [u5_1, e1, i1, e2, i2, e3, i3, e4, i4, e5, i5, e6, u3_1]\n  // mats = [u5_1, e1, e2, e3, e4, e5, e6, u3_1]\n\n  let numInserted = 0;\n  const subpartEls = document.querySelectorAll('.subpart');\n  prelimSubparts.forEach((prelimSubpart, i) => {\n    const matureIndex = i - numInserted;\n    const matureSubpart = matureSubparts[matureIndex];\n    if (matureSubpart[0] !== prelimSubpart[0]) {\n      const summary = prelimSubpart.slice(-1)[0].summary;\n      const otherAttrs = `y=\"${y}\" height=\"20\" fill=\"#FFFFFF00\" ${summary}`;\n      const intronRect =\n        `<rect class=\"subpart intron\" ${otherAttrs} />`;\n      subpartEls[matureIndex].insertAdjacentHTML('beforebegin', intronRect);\n      numInserted += 1;\n    }\n  });\n\n  document.querySelectorAll('.intron').forEach(subpartDOM => {\n    addSubpartHoverListener(subpartDOM, ideo);\n  });\n}\n\nfunction updateHeader(spliceExons, isCanonical) {\n  // Update title for gene structure diagram\n  const nameDOM =\n  document.querySelector('._ideoGeneStructureContainerName');\n  const toggleDOM = document.querySelector('._ideoSpliceToggle');\n\n  if (nameDOM && toggleDOM) {\n    [nameDOM, toggleDOM].forEach(el => el.classList.remove('pre-mRNA'));\n    if (!spliceExons) {\n      [nameDOM, toggleDOM].forEach(el => el.classList.add('pre-mRNA'));\n    }\n    const {title, name} = getSpliceStateText(spliceExons, isCanonical);\n    nameDOM.textContent = name;\n    nameDOM.title = title;\n  }\n}\n\nasync function toggleSplice(ideo) {\n  Ideogram.spliceExons = !Ideogram.spliceExons;\n  const spliceExons = Ideogram.spliceExons;\n  const [geneStructure, selectedIndex] = getSelectedStructure(ideo);\n  const isCanonical = (selectedIndex === 0);\n  const svgResult = await getSvg(geneStructure, ideo, spliceExons);\n  const [, prelimSubparts, matureSubparts] = svgResult;\n  const proteinSvg = document.querySelector('#_ideoProtein');\n\n  if (proteinSvg && !spliceExons) proteinSvg.style.display = 'none';\n\n  const addedIntrons = document.querySelectorAll('.intron').length > 0;\n\n  if (!spliceExons && !addedIntrons) {\n    drawIntrons(prelimSubparts, matureSubparts, ideo);\n  } else {\n    document.querySelectorAll('.intron').forEach(el => el.remove());\n  }\n  document.querySelectorAll('.subpart-line.rna').forEach(el => el.remove());\n\n  const subparts = spliceExons ? matureSubparts : prelimSubparts;\n\n  console.log('in toggleSplice, subparts', subparts)\n  d3.select('._ideoGeneStructure').selectAll('.subpart')\n    .data(subparts)\n    .transition()\n    .duration(750)\n    .attr('x', (d, i) => subparts[i].slice(-1)[0].x)\n    .attr('width', (d, i) => subparts[i].slice(-1)[0].width)\n    .on('end', async (d, i) => {\n      console.log('in end')\n      if (i !== subparts.length - 1) return;\n      if (proteinSvg && spliceExons) proteinSvg.style.display = '';\n\n      // Restore subpart boundary lines\n      const subpartDOMs = document.querySelectorAll('.subpart:not(.domain)');\n      subpartDOMs.forEach((subpartDOM, i) => {\n        const subpart = subparts[i];\n        const line = getSubpartBorderLine(subpart);\n        subpartDOM.insertAdjacentHTML('afterend', line);\n      });\n\n      updateHeader(spliceExons, isCanonical);\n\n      const tlbpDOM = document.querySelector('#_ideoTranscriptLengthBp');\n      if (!tlbpDOM) return;\n      const transcriptLengthBp = getTranscriptLengthBp(subparts, spliceExons);\n      const prettyLength = transcriptLengthBp.toLocaleString();\n      tlbpDOM.innerText = `${prettyLength} bp`;\n\n      const variantSvg = await getVariantsSvg(geneStructure, subparts, ideo);\n      console.log('toggled variantSvg.length', variantSvg.length)\n      document.querySelector('.variantsDiagrams').innerHTML = variantSvg;\n\n      ideo.tippy[0].show();\n    });\n}\n\nfunction getTranscriptLengthBp(subparts, spliceExons=false) {\n  const exons = subparts.filter(sp => sp[0] === 'exon');\n  if (spliceExons) subparts = exons;\n\n  const lastSubpart = subparts.slice(-1)[0];\n  const lastStart = lastSubpart[1];\n  const lastLength = lastSubpart[2];\n  const exonFill = spliceExons ? exons.length - 1 : 0;\n\n  const transcriptLengthBp = lastStart + lastLength + exonFill;\n  return transcriptLengthBp;\n}\n\nexport function getBpPerPx(subparts, projectedFeatures=null) {\n  const transcriptLengthPx = 250;\n  const totalLengthBp = getTranscriptLengthBp(subparts);\n  const isProtein = projectedFeatures;\n  const factor = isProtein ? 3 : 1; // 3 nt per aa\n  const bpPerPx = (totalLengthBp / transcriptLengthPx) / factor;\n\n  return bpPerPx;\n}\n\n/** Merge feature type, pixel-x position, and pixel width to each feature */\nexport function addPositions(subparts, projectedFeatures=null) {\n  const bpPerPx = getBpPerPx(subparts, projectedFeatures);\n\n  const features = projectedFeatures ?? subparts;\n\n  for (let i = 0; i < features.length; i++) {\n    const feature = features[i];\n    if (typeof feature.slice(-1)[0] === 'object') continue;\n    // Define subpart position, tooltip footer\n    const lengthBp = feature[2];\n    const x = feature[1] / bpPerPx;\n    const width = lengthBp / bpPerPx;\n    const type = feature[0];\n\n    features[i].push({type, x, width});\n  }\n\n  return features;\n}\n\n/** Get text shown below diagram upon hovering over an exon, intron, or UTR */\nfunction getSubpartSummary(subpartType, total, index, strand, lengthBp) {\n  if (strand === '-') index = total - index + 1;\n  const numOfTotal = total > 1 ? `${index} of ${total} ` : '';\n  const prettyType = subpartType[0].toUpperCase() + subpartType.slice(1);\n  const prettyLength = lengthBp.toLocaleString();\n  const html = `${prettyType} ${numOfTotal}${pipe} ${prettyLength} bp`;\n  const summary = `data-subpart=\"${html}\"`;\n  return summary;\n}\n\n/** Get subtle line to visually demarcate subpart boundary */\nfunction getSubpartBorderLine(subpart) {\n  const subpartType = subpart[0];\n  // Define subpart border\n  const x = subpart.slice(-1)[0].x;\n  const height = heights[subpartType];\n  const lineHeight = y + height;\n  const lineStroke = `stroke=\"${lineColors[subpartType]}\"`;\n  const lineAttrs = // \"\";\n    `x1=\"${x}\" x2=\"${x}\" y1=\"${y}\" y2=\"${lineHeight}\" ${lineStroke}`;\n  return `<line class=\"subpart-line rna\" ${lineAttrs} />`;\n}\n\n// function getSvgList(gene, ideo, spliceExons=false) {\n//   if (\n//     'geneStructureCache' in Ideogram === false ||\n//     gene in Ideogram.geneStructureCache === false\n//   ) {\n//     return [null];\n//   }\n\n//   const svgList = Ideogram.geneStructureCache[gene].map(geneStructure => {\n//     return getSvg(geneStructure, ideo, spliceExons);\n//   });\n\n//   return svgList;\n// }\n\n/** Get SVG, and prelimnary and mature subparts for given gene structure */\nasync function getSvg(geneStructure, ideo, spliceExons=false) {\n  const strand = geneStructure.strand;\n\n  const rawSubparts = geneStructure.subparts;\n  let subparts;\n\n  // Add pixel coordinates to subparts, and pre-mRNA and mRNA sets\n  let prelimSubparts = spliceIn(rawSubparts);\n  let matureSubparts = spliceOut(rawSubparts);\n  if (spliceExons) {\n    subparts = matureSubparts;\n  } else {\n    subparts = prelimSubparts;\n  }\n\n  const spliceToggle = document.querySelector('._ideoSpliceToggle');\n  if (spliceToggle) {\n    const title = getSpliceToggleHoverTitle(spliceExons);\n    spliceToggle.setAttribute('data-tippy-placement', 'right');\n    // spliceToggle.setAttribute('data-tippy-placement-fallback', 'top-end');\n    spliceToggle.setAttribute('data-tippy-content', title);\n    initTippy(ideo);\n  }\n\n  const featureLengthPx = 250 - 2; // Snip to avoid overextending\n\n  const intronHeight = 1;\n  const intronColor = 'black';\n  const geneStructureArray = [];\n\n  const intronPosAttrs =\n    `x=\"0\" width=\"${featureLengthPx}\" y=\"${y + 10}\" height=\"${intronHeight}\"`;\n  const intronRect =\n    `<rect fill=\"black\" ${intronPosAttrs}/>`;\n\n  geneStructureArray.push(intronRect);\n\n  // Set up counters for e.g. \"Exon 2 of 4\" (\"<subpart> <num> of <total>\")\n  const indexBySubpart = {\n    \"5'-UTR\": 0,\n    'exon': 0,\n    'intron': 0,\n    \"3'-UTR\": 0\n  };\n  const totalBySubpart = {\n    \"5'-UTR\": 0,\n    'exon': 0,\n    'intron': 0,\n    \"3'-UTR\": 0\n  };\n\n  const isPositiveStrand = strand === '+';\n  subparts = swapUTRsForward(subparts, isPositiveStrand);\n\n  prelimSubparts = swapUTRsForward(prelimSubparts, isPositiveStrand);\n  matureSubparts = swapUTRsForward(matureSubparts, isPositiveStrand);\n\n  // Container for positional data: x, width\n  // const prelimPositions = getPositions(prelimSubparts);\n  // const maturePositions = getPositions(matureSubparts);\n\n  // matureSubparts = matureSubparts.filter(p => p[0] !== 'intron');\n  // const positions = spliceExons ? trimmedMatures : prelimPositions;\n\n  // Get counts for e.g. \"4\" in \"Exon 2 of 4\"\n  for (let i = 0; i < subparts.length; i++) {\n    const subpart = subparts[i];\n    const subpartType = subpart[0];\n    if (subpartType in totalBySubpart) {\n      totalBySubpart[subpartType] += 1;\n    }\n  }\n\n  const structureName = geneStructure.name;\n  const gene = getGeneFromStructureName(structureName);\n\n  for (let i = 0; i < subparts.length; i++) {\n    const subpart = subparts[i];\n    // const position = positions[i];\n    const subpartType = subpart[0];\n    let color = intronColor;\n    if (subpartType in colors) {\n      color = colors[subpartType];\n    }\n\n    const height = heights[subpartType];\n\n    // Define subpart position, tooltip footer\n    const lengthBp = subpart[2];\n    const x = subpart.slice(-1)[0].x;\n    const width = subpart.slice(-1)[0].width;\n\n    const pos = `x=\"${x}\" width=\"${width}\" y=\"${y}\" height=\"${height}\"`;\n    const cls = `class=\"subpart ${subpartClasses[subpartType]}\" `;\n\n    // TODO: Handle introns better, refine CDS vs. UTR in exons\n    const total = totalBySubpart[subpartType];\n    indexBySubpart[subpartType] += 1;\n    const subpartIndex = indexBySubpart[subpartType];\n    const summary =\n      getSubpartSummary(subpartType, total, subpartIndex, strand, lengthBp);\n    if (!spliceExons) {\n      // console.log('prelimSubparts[i]', prelimSubparts[i])\n      prelimSubparts[i].slice(-1)[0].summary = summary;\n    } else if (subpartType !== 'intron') {\n      matureSubparts[i].slice(-1)[0].summary = summary;\n    }\n\n    const subpartSvg = (\n      `<rect ${cls} rx=\"1.5\" fill=\"${color}\" ${pos} ${summary}/>` +\n      getSubpartBorderLine(subpart)\n    );\n    geneStructureArray.push(subpartSvg);\n  }\n\n  const sharedStyle =\n    'position: relative; width: 274px; margin: auto;';\n  let transform = `style=\"${sharedStyle} left: 10px;\"`;\n  if (strand === '-') {\n    transform =\n      'transform=\"scale(-1 1)\" ' +\n      `style=\"${sharedStyle} left: -10px;\"`;\n  }\n\n  const menu = getMenu(gene, ideo, structureName).replaceAll('\"', '\\'');\n\n  const hasTopology = getHasTopology(gene, ideo);\n\n  const [proteinSvg, proteinLengthAa] =\n    getProtein(structureName, subparts, isPositiveStrand, hasTopology, ideo);\n\n  const variantSvg = await getVariantsSvg(geneStructure, subparts, ideo);\n\n  const transcriptLengthBp = getTranscriptLengthBp(subparts, spliceExons);\n  const prettyLength = transcriptLengthBp.toLocaleString();\n\n  const footerDetails = [\n    `${totalBySubpart['exon']} exons`,\n    `<span id='_ideoTranscriptLengthBp'>${prettyLength} bp</span> `\n  ];\n\n  // Note protein length in amino acids (aa)\n  // TODO: This is a no-op; see note about phase in protein.js\n  if (proteinLengthAa) {\n    const prettyLengthAa = proteinLengthAa.toLocaleString();\n    footerDetails.push(\n      `<span id='_ideoProteinLengthAa'>${prettyLengthAa} aa</span> `\n    );\n  }\n\n  // Note if transcript is unusual type, e.g. nonsense mediated decay (NMD)\n  const biotypeText = geneStructure.biotype.replace(/_/g, ' ');\n  if (biotypeText !== 'protein coding') {\n    footerDetails.push(biotypeText);\n  }\n  const footerData = menu + footerDetails.join(` ${pipe} `);\n\n  let svgHeight = proteinSvg === '' ? 30 : 50;\n  if (hasTopology) svgHeight = 60;\n\n  let translate = '';\n  if (variantSvg) {\n    const varHeight = 18;\n    svgHeight += varHeight;\n    translate = `transform=\"translate(0, ${varHeight})\"`;\n  }\n\n  const geneStructureSvg =\n    `<svg class=\"_ideoGeneStructure\" ` +\n      `data-ideo-gene-structure-name=\"${structureName}\" ` +\n      `data-ideo-strand=\"${strand}\" data-ideo-footer=\"${footerData}\" ` +\n      `width=\"${(featureLengthPx + 20)}\" height=\"${svgHeight}\" ${transform}` +\n    `>` +\n      `<g class=\"rnaProteinDiagrams\" ${translate}>` +\n        geneStructureArray.join('') +\n        proteinSvg +\n      `</g>` +\n      `<g class=\"variantsDiagrams\">` +\n        variantSvg +\n      `</g>` +\n    '</svg>';\n\n  return [geneStructureSvg, prelimSubparts, matureSubparts];\n}\n\n/** Get down and up arrows for one-click, carousel-like navigation for menu */\nfunction getMenuArrows() {\n\n  // Get attributes\n  const style =\n    'width: 12px; height: 12px; cursor: pointer;' +\n    'user-select: none;'; // Prevent distracting highlight on quick clicks\n  const downStyle = `style=\"${style}; margin-left: 5px;\"`;\n  const upStyle = `style=\"${style}; margin-left: 2px;\"`;\n  const cls = 'class=\"_ideoMenuArrow\"';\n  const tippyPlace = 'data-tippy-placement=\"bottom-start\"';\n  const downContent = 'Next transcript';\n  const downTippy = `data-tippy-content=\"${downContent}\" ${tippyPlace}`;\n  const upContent = 'Previous transcript';\n  const upTippy = `data-tippy-content=\"${upContent}\" ${tippyPlace}`;\n  const downAttrs = `${downStyle} ${cls} data-dir=\"down\" ${downTippy}`;\n  const upAttrs = `${upStyle} ${cls} data-dir=\"up\" ${upTippy}`;\n\n  // Get SVG polygon elements\n  const down = getIcon(\n    {shape: 'triangle', color: '#888'},\n    {config: {orientation: 'down'}}\n  );\n  const up = getIcon({shape: 'triangle', color: '#888'}, {config: ''});\n\n  const downArrow = `<svg ${downAttrs}>${down}</svg>`;\n  const upArrow = `<svg ${upAttrs}>${up}</svg>`;\n  const menuArrows = downArrow + upArrow;\n\n  return menuArrows;\n}\n\n/** Get menu for all transcripts for this gene */\nfunction getMenu(gene, ideo, selectedName) {\n  const containerId = '_ideoGeneStructureMenuContainer';\n  const style = 'margin-bottom: 4px; margin-top: 4px; clear: both;';\n\n  const structures = Ideogram.geneStructureCache[gene];\n\n  if (structures.length === 1) {\n    const name = structures[0].name;\n    const line =\n      `<div id=\"${containerId}\" style=\"${style}\">Transcript: ${name}</div>`;\n    return line;\n  }\n\n  const options = structures.map(structure => {\n    const name = structure.name;\n    let selected = '';\n    if (selectedName && selectedName === structure.name) {\n      selected = ' selected';\n    }\n    return `<option value=\"${name}\" ${selected}>${name}</option>`;\n  }).join('');\n\n  const id = '_ideoGeneStructureMenu';\n\n  const menuArrows = getMenuArrows();\n\n  const menu =\n    `<div id=\"${containerId}\" style=\"${style}\">` +\n      `<label for=\"${id}\">Transcript:</label> ` +\n      `<select id=\"${id}\" name=\"${id}\">${options}</select>` +\n      menuArrows +\n    `</div>`;\n  return menu;\n}\n\nexport async function getGeneStructureHtml(annot, ideo, isParalogNeighborhood) {\n  let geneStructureHtml = '';\n  const gene = annot.name;\n  if (\n    ideo.config.showGeneStructureInTooltip && !isParalogNeighborhood &&\n    !(\n      'geneStructureCache' in Ideogram === false ||\n      gene in Ideogram.geneStructureCache === false\n    )\n  ) {\n    ideo.addedSubpartListeners = false;\n    if ('spliceExons' in Ideogram === false) Ideogram.spliceExons = true;\n    const spliceExons = Ideogram.spliceExons;\n    const structure = Ideogram.geneStructureCache[gene][0];\n    const svgResults = await getSvg(structure, ideo, spliceExons);\n    const geneStructureSvg = svgResults[0];\n    const cls = 'class=\"_ideoGeneStructureContainer\"';\n    const toggle = getSpliceToggle(ideo);\n    const rnaClass = spliceExons ? '' : ' pre-mRNA';\n    const spanClass = `class=\"_ideoGeneStructureContainerName${rnaClass}\"`;\n    const {name, title} = getSpliceStateText(spliceExons);\n    const spanAttrs = `${spanClass} title=\"${title}\"`;\n    const divAttrs = 'class=\"_ideoGeneStructureContainerHead\"';\n    const containerStyle = '';\n    geneStructureHtml =\n      css +\n      `<div ${cls}>` +\n      `<div ${divAttrs}><span ${spanAttrs}>${name}</span>${toggle}</div>` +\n      `<span class=\"_ideoGeneStructureSvgContainer\" ${containerStyle}>` +\n        geneStructureSvg +\n      `</span>` +\n      `<div class=\"_ideoGeneStructureFooter\">` +\n        hoverTip +\n      `</div>` +\n      `</div>`;\n\n  }\n  return geneStructureHtml;\n}\n","import {decompressSync, strFromU8} from 'fflate';\nimport { sortAnnotsByRank } from '../annotations/annotations';\n\n// Definitions for ArrowHead values in WikiPathways GPML\n//\n// See also: https://discover.nci.nih.gov/mim/formal_mim_spec.pdf\nconst interactionArrowMap = {\n  'Arrow': ['acts on', 'acted on by'],\n  'TBar': ['inhibits', 'inhibited by'],\n  'mim-binding': ['binds', 'binds'],\n  'mim-catalysis': ['catalyzes', 'catalyzed by'],\n  'mim-cleavage': ['cleaves', 'cleaved by'],\n  'mim-conversion': ['converts', 'converted by'],\n  // 'mim-covalent-bond': ['covalently binds',\n  'mim-gap': ['interacts with', 'interacts with'],\n  'mim-inhibition': ['inhibits', 'inhibited by'],\n  'mim-modification': ['modifies', 'modified by'],\n  'mim-necessary-stimulation':\n    ['necessarily stimulates', 'necessarily stimulated by'],\n  'mim-stimulation': ['stimulates', 'stimulated by'],\n  'mim-transcription-translation':\n    ['transcribes / translates', 'transcribed / translated by']\n};\n\n// Which interactions types to show first, if showing multiple\nconst rankedInteractionTypes = [\n  'transcribe',\n  'cleave',\n  'convert',\n  'bind',\n  'modifie',\n  'catalyze',\n  'necessarily stimulate',\n  'inhibit',\n  'stimulate',\n  'act'\n];\n\nexport function sortInteractionTypes(a, b) {\n  const ranks = {};\n  for (let i = 0; i < rankedInteractionTypes.length; i++) {\n    const rankedIxnType = rankedInteractionTypes[i];\n    if (rankedIxnType.includes(a)) ranks.a = i;\n    if (rankedIxnType.includes(b)) ranks.b = i;\n  }\n  return ranks.b - ranks.a;\n}\n\n/** Determine if all given interactions in *one* pathway are same */\nfunction determineIxnsInPathwayAreSame(ixns, ixnTypeReference) {\n  let isRefMatch = true;\n  let thisIsSame = true;\n\n  if (ixns.length === 0) return {isRefMatch, thisIsSame};\n\n  const thisIxnTypeReference = ixns[0].ixnType.toLowerCase();\n  ixns.forEach(ixn => {\n    const ixnType = ixn.ixnType.toLowerCase();\n    if (ixnType !== ixnTypeReference) {\n      isRefMatch = false;\n    }\n    if (ixnType !== thisIxnTypeReference) {\n      thisIsSame = false;\n    }\n  });\n  return {isRefMatch, thisIsSame};\n}\n\n/**\n * Return first valid interaction type from interactions-by-pathway object\n */\nfunction getIxnTypeReference(ixnsByPwid) {\n  const ixnTypeReference = Object.values(ixnsByPwid).find(ixns => {\n    return ixns.length > 0 && 'ixnType' in ixns[0];\n  })[0].ixnType.toLowerCase();\n\n  return ixnTypeReference;\n}\n\n/**\n * Determine whether all given interactions in all given pathways are the same\n */\nfunction setIsSame(enrichedIxns) {\n  let isSame = true;\n  const ixnsByPwid = enrichedIxns.ixnsByPwid;\n\n  const ixnTypeReference = getIxnTypeReference(ixnsByPwid);\n\n  Object.entries(ixnsByPwid).map(([pwid, ixns]) => {\n    const {isRefMatch, thisIsSame} =\n      determineIxnsInPathwayAreSame(ixns, ixnTypeReference);\n    if (!thisIsSame || !isRefMatch) {\n      isSame = false;\n    }\n    enrichedIxns.isSameByPwid[pwid] = thisIsSame;\n  });\n  enrichedIxns.isSame = isSame;\n\n  return enrichedIxns;\n}\n\n/**\n * If interactions aren't all exactly the same, then they are often still\n * directionally equivalent.\n *\n * E.g. if gene A both \"modifies\" and \"converts\" gene B, then we can summarize\n * that as gene A \"acts on\" gene B, rather than completely reverting to saying\n * gene A \"interacts with\" gene B.\n *\n */\nfunction summarizeByDirection(enrichedIxns) {\n\n  let isDirectionSame = true;\n\n  const leftTypes = []; // \"Acts on\" types\n  const rightTypes = []; // \"Acted on by\" types\n  Object.values(interactionArrowMap).forEach(directedTypes => {\n    rightTypes.push(directedTypes[0]);\n    leftTypes.push(directedTypes[1]);\n  });\n\n  const right = 'Acts on';\n  const left = 'Acted on by';\n\n  const ixnsByPwid = enrichedIxns.ixnsByPwid;\n  const firstIxnType = getIxnTypeReference(ixnsByPwid);\n  const isRight = rightTypes.includes(firstIxnType);\n  const directionReference = isRight ? right : left;\n\n  Object.entries(ixnsByPwid).map(([pwid, ixns]) => {\n    let isPwDirectionSame = true;\n    if (ixns.length > 0) {\n      const pwFirstIxnType = ixns[0].ixnType.toLowerCase();\n      const pwIsRight = rightTypes.includes(pwFirstIxnType);\n      const pwDirectionReference = pwIsRight ? right : left;\n      ixns.forEach(ixn => {\n        const ixnType = ixn.ixnType.toLowerCase();\n        const thisIsRight = rightTypes.includes(ixnType);\n        const direction = thisIsRight ? right : left;\n        enrichedIxns.directionsByPwid[pwid] = direction;\n        if (direction !== directionReference) {\n          isDirectionSame = false;\n        }\n        if (direction !== pwDirectionReference) {\n          isPwDirectionSame = false;\n        }\n      });\n    }\n    enrichedIxns.isDirectionSameByPwid[pwid] = isPwDirectionSame;\n\n  });\n\n  enrichedIxns.isDirectionSame = isDirectionSame;\n  if (isDirectionSame === true) {\n    enrichedIxns.direction = directionReference;\n  }\n\n  return enrichedIxns;\n}\n\n/**\n * Summarize interactions by direction\n *\n * @param {String} gene Interacting gene\n * @param {String} searchedGene Searched gene\n * @param {Array} pathwayIds List of WikiPathways IDs\n * @param {Object} gpmls Object of parsed GPML XMLs values, by pathway ID key\n * @returns\n */\nexport function summarizeInteractions(gene, searchedGene, pathwayIds, gpmls) {\n  let summary = null;\n\n  // Coarse interactions are cached offline, so if not connected to Internet\n  // then fallback to generic summary.\n  if (!navigator.onLine) return 'Interacts with';\n\n  const ixnsByPwid =\n    detailAllInteractions(gene, searchedGene, pathwayIds, gpmls);\n\n  const ixns = ixnsByPwid[pathwayIds[0]];\n\n  if (ixns.length > 0) {\n    let enrichedIxns = {\n      ixnsByPwid,\n      isSameByPwid: {}, // If pathway has all same interaction types\n      isSame: null, // If above is true for all pathways\n      isDirectionSameByPwid: {}, // If pathway has same ixn direction\n      isDirectionSame: null, // If above is true for all pathways\n      directionsByPwid: {}\n    };\n    enrichedIxns = setIsSame(enrichedIxns);\n\n    if (enrichedIxns.isSame) {\n      const ixnType = ixns[0].ixnType;\n      const newIxn = ixnType;\n      summary = newIxn;\n    } else {\n\n      enrichedIxns = summarizeByDirection(enrichedIxns);\n\n      if (enrichedIxns.isDirectionSame) {\n        summary = enrichedIxns.direction;\n      } else {\n        summary = 'Interacts with';\n      }\n    }\n  }\n\n\n    // if (direction !== null) {\n    //   summary = direction;\n    // }\n    // const pwidsByIxnType = {};\n    // Object.entries(ixns).map(([k, v]) => {\n    //   if (!pwidsByIxnType[v.ixnType]) {\n    //     pwidsByIxnType[v.ixnType] = [v.pathwayId];\n    //   } else {\n    //     pwidsByIxnType[v.ixnType].push([v.pathwayId]);\n    //   }\n    // });\n\n    // console.log('pwidsByIxnType')\n    // console.log(pwidsByIxnType)\n    // const tpArray = Object.entries(pwidsByIxnType);\n    // const sortedIndices = sortInteractionTypes(tpArray.map(tp => tp[0]));\n    // const sortedTpArray =\n    //   sortedIndices.map(sortedIndex => tpArray[sortedIndex]);\n\n    // console.log('sortedTpArray')\n    // console.log(sortedTpArray)\n  return summary;\n}\n\n/**\n * Get detailInteractions results for multiple pathways\n *\n * @param gene Interacting gene\n * @param pathwayIds List of WikiPathways IDs\n * @ideo ideo Ideogram instance object\n */\nexport function detailAllInteractions(gene, searchedGene, pathwayIds, gpmls) {\n  const ixnsByPwid = {};\n\n  pathwayIds.map(pathwayId => {\n    const gpml = gpmls[pathwayId];\n    const ixns = detailInteractions(gene, searchedGene, gpml);\n\n    ixnsByPwid[pathwayId] = ixns;\n  });\n  return ixnsByPwid;\n}\n\n/** Get IDs and data element objects for searched or interacting gene */\nfunction getMatches(gpml, label) {\n  // Bail if GPML not yet fetched.  Sometimes occurs on hover immediately afters\n  // search.  This mitigation ensures at least a basic tooltip is shown.\n  if (typeof gpml === 'undefined' || gpml === '') return [[], []];\n\n  const nodes = Array.from(gpml.querySelectorAll(\n    `DataNode[TextLabel=\"${label}\"]`\n  ));\n\n  const genes = nodes.map(node => {\n    return {\n      type: 'node',\n      matchedLabel: label,\n      textLabel: node.getAttribute('TextLabel'),\n      graphId: node.getAttribute('GraphId'),\n      groupRef: node.getAttribute('GroupRef')\n    };\n  });\n\n  // Get group identifiers\n  const geneGraphIds = genes.map(g => g.graphId);\n  const geneGroupRefs = genes.map(g => g.groupRef);\n  const groupSelectors =\n    geneGroupRefs.map(ggr => `Group[GroupId=\"${ggr}\"]`).join(',');\n\n  let geneGroups = [];\n  if (groupSelectors !== '') {\n    const groups = gpml.querySelectorAll(groupSelectors);\n    geneGroups = Array.from(groups).map(group => {\n      return {\n        type: 'group',\n        matchedLabel: label,\n        graphId: group.getAttribute('GraphId'),\n        groupId: group.getAttribute('GroupId')\n      };\n    });\n  }\n\n  const geneGroupGraphIds = geneGroups.map(g => g.graphId);\n  const matchingGraphIds = geneGraphIds.concat(geneGroupGraphIds);\n\n  const elements = genes.concat(geneGroups);\n\n  return [matchingGraphIds, elements];\n}\n\nasync function fetchGpml(pathwayId) {\n  if (!navigator.onLine) return '';\n  const pathwayFile = `${pathwayId}.xml.gz`;\n  const gpmlUrl = `https://cdn.jsdelivr.net/npm/ixn2/${pathwayFile}`;\n  const response = await fetch(gpmlUrl);\n  if (!response.ok) {\n    console.log(`Gracefully degrading as request failed for: ${gpmlUrl}`);\n    return '';\n  }\n  const blob = await response.blob();\n  const uint8Array = new Uint8Array(await blob.arrayBuffer());\n  const rawGpml = strFromU8(decompressSync(uint8Array));\n\n  const gpml = new DOMParser().parseFromString(rawGpml, 'text/xml');\n\n  // console.log('gpml:')\n  // console.log(gpml)\n\n  return gpml;\n}\n\n/**\n * Request compressed GPML files, which contain detailed interaction data, e.g.\n * https://cdn.jsdelivr.net/npm/ixn/WP3982.xml.gz\n *\n * For more easily readable versions, see also:\n * - https://www.wikipathways.org/index.php?title=Pathway:WP3982&action=edit\n * - https://www.wikipathways.org//wpi/wpi.php?action=downloadFile&type=gpml&pwTitle=Pathway:WP3982\n *\n * GPML (Graphical Pathway Markup Language) data encodes detailed interaction\n * data for biochemical pathways.\n */\nexport function fetchGpmls(ideo) {\n  const pathwayIdsByInteractingGene = {};\n  Object.entries(ideo.annotDescriptions.annots)\n    .forEach(([annotName, descObj]) => {\n      if ('type' in descObj && descObj.type.includes('interacting gene')) {\n        pathwayIdsByInteractingGene[annotName] = descObj.pathwayIds;\n      }\n    });\n\n  const gpmlsByInteractingGene = {};\n  Object.entries(pathwayIdsByInteractingGene)\n    .forEach(([ixnGene, pathwayIds]) => {\n      gpmlsByInteractingGene[ixnGene] = {};\n      pathwayIds.map(async pathwayId => {\n        const gpml = await fetchGpml(pathwayId);\n        gpmlsByInteractingGene[ixnGene][pathwayId] = gpml;\n      });\n    });\n\n  ideo.gpmlsByInteractingGene = gpmlsByInteractingGene;\n}\n\n/**\n * Get interaction object from a GPML graphics XML element\n *\n * This interaction object connects the searched gene and interacting gene.\n */\nfunction parseInteractionGraphic(graphic, graphIds) {\n  let interaction = null;\n\n  const {searchedGeneGraphIds, matchingGraphIds} = graphIds;\n\n  const endGraphRefs = [];\n  let numMatchingPoints = 0;\n  let isConnectedToSourceGene = false;\n  let ixnType = null;\n  let searchedGeneIndex = null;\n\n  Array.from(graphic.children).forEach(child => {\n    if (child.nodeName !== 'Point') return;\n    const point = child;\n    const graphRef = point.getAttribute('GraphRef');\n    if (graphRef === null) return;\n\n    if (matchingGraphIds.includes(graphRef)) {\n      numMatchingPoints += 1;\n      endGraphRefs.push(graphRef);\n\n      if (searchedGeneGraphIds.includes(graphRef)) {\n        isConnectedToSourceGene = true;\n      }\n\n      if (point.getAttribute('ArrowHead')) {\n        const arrowHead = point.getAttribute('ArrowHead');\n        const isStart = searchedGeneGraphIds.includes(graphRef);\n        if (searchedGeneIndex === null) {\n          searchedGeneIndex = isStart ? 0 : 1;\n        }\n        try {\n          ixnType = interactionArrowMap[arrowHead][isStart ? 0 : 1];\n        } catch (e) {\n          // TODO: Handle e.g. HGF, where arrowHead is very rare ReceptorSquare\n        }\n      }\n    }\n  });\n\n  if (numMatchingPoints >= 2 && isConnectedToSourceGene) {\n    if (searchedGeneIndex === null || ixnType === null) {\n      ixnType = 'interacts with';\n    }\n    ixnType = ixnType[0].toUpperCase() + ixnType.slice(1);\n    const interactionGraphId = graphic.parentNode.getAttribute('GraphId');\n    interaction = {\n      'interactionId': interactionGraphId,\n      'endIds': endGraphRefs,\n      ixnType\n    };\n  }\n\n  return interaction;\n}\n\n/**\n * Get all genes in the given pathway GPML\n */\nexport async function fetchPathwayInteractions(searchedGene, pathwayId, ideo) {\n  const gpml = await fetchGpml(pathwayId);\n  // Gets IDs and elements for searched gene and interacting gene, and,\n  // if they're in any groups, the IDs of those groups\n  const genes = {};\n\n  const nodes = Array.from(gpml.querySelectorAll('DataNode'));\n  nodes.forEach(node => {\n    const label = node.getAttribute('TextLabel');\n    const normLabel = label.toLowerCase();\n    const isKnownGene = normLabel in Ideogram.geneCache.nameCaseMap;\n    if (isKnownGene) {\n      genes[label] = 1;\n    }\n  });\n\n  const pathwayGenes = Object.keys(genes);\n  const pathwayIxns = {};\n  pathwayGenes.map(gene => {\n    if (gene === searchedGene) return;\n    const gpmls = {};\n    gpmls[pathwayId] = gpml;\n    const summary = summarizeInteractions(\n      gene, searchedGene, [pathwayId], gpmls\n    );\n    pathwayIxns[gene] = (summary ? summary : 'Shares pathway with');\n  });\n\n  return pathwayIxns;\n}\n\n/**\n * Fetch GPML for pathway and find ID of Interaction between two genes,\n * and the ID of the two DataNodes for each of those interactions.\n *\n * WikiPathways SVG isn't detailed enough to reliably determine the specific\n * interaction elements relating two genes, given only the gene symbols.  This\n * fetches augmented GPML data for the pathway, and queries it to get only\n * interactions between the two genes.\n */\nfunction detailInteractions(interactingGene, searchedGene, gpml) {\n  if (typeof gpml === 'undefined' || gpml === '') {\n    return []; // Bail if GPML not yet fetched\n  }\n\n  // Gets IDs and elements for searched gene and interacting gene, and,\n  // if they're in any groups, the IDs of those groups\n  const [searchedGeneGraphIds, se] = getMatches(gpml, searchedGene);\n  const [interactingGeneGraphIds, ie] = getMatches(gpml, interactingGene);\n\n  const elements = {\n    searchedGene: se,\n    interactingGene: ie\n  };\n\n  const matchingGraphIds =\n    searchedGeneGraphIds.concat(interactingGeneGraphIds);\n  const graphIds = {searchedGeneGraphIds, matchingGraphIds};\n\n  // Get interaction objects that connect the searched and interacting genes\n  const interactions = [];\n  const graphicsXml = gpml.querySelectorAll('Interaction Graphics');\n  Array.from(graphicsXml).forEach(graphic => {\n    const interaction = parseInteractionGraphic(graphic, graphIds);\n    if (interaction !== null) {\n      interaction.elements = elements;\n      interactions.push(interaction);\n    }\n  });\n\n  return interactions;\n}\n\n// export async function fetchInteractionDiagram(annot, descObj, ideo) {\n//   // Fetch raw SVG for pathway diagram\n//   const pathwayId = descObj.pathwayIds[0];\n//   // const baseUrl = 'https://eweitz.github.io/cachome/wikipathways/';\n//   const baseUrl = 'https://cachome.github.io/wikipathways/';\n//   // const baseUrl = 'http://localhost/wikipathways/data/';\n//   const diagramUrl = baseUrl + pathwayId + '.svg';\n//   const response = await fetch(diagramUrl);\n//   if (response.ok) {\n\n//     // console.log('searchedGene', searchedGene)\n\n//     const ixns = await detailInteractions(annot.name, pathwayId, ideo);\n\n//     let selectors = `[name=${annot.name}]`;\n//     let searchedGeneIndex = 0;\n//     let interactingGeneIndex;\n//     if (ixns.length > 0) {\n//       selectors = ixns[0].endIds.map(id => '#' + id).join(',');\n//       searchedGeneIndex = ixns[0].searchedGeneIndex;\n//       interactingGeneIndex = (searchedGeneIndex === 0) ? 1 : 0;\n//     }\n//     // https://webservice.wikipathways.org/findInteractions?query=ACE2&format=json\n\n//     const rawDiagram = await response.text();\n\n//     const pathwayDiagram =\n//       `<div class=\"pathway-diagram\">${rawDiagram}</div>`;\n\n//     annot.displayName += pathwayDiagram;\n\n//     document.querySelector('._ideogramTooltip').innerHTML =\n//       annot.displayName;\n\n//     Ideogram.d3.select('svg.Diagram')\n//       .attr('width', 350)\n//       .attr('height', 300);\n\n//     const viewport = document.querySelector('.svg-pan-zoom_viewport');\n//     viewport.removeAttribute('style');\n//     viewport.removeAttribute('transform');\n\n//     const matches = document.querySelectorAll(selectors);\n//     console.log('matches', matches)\n//     const match0 = matches[searchedGeneIndex]\n//     const m0 = match0.getCTM();\n//     const m0Rect = match0.getBoundingClientRect();\n//     const m0Box = match0.getBBox();\n//     const m0MinX = m0.e/m0.a;\n//     const m0MinY = m0.f/m0.d;\n\n//     let minX = m0MinX;\n//     let minY = m0MinY;\n//     let width;\n//     let height;\n\n//     width = 350;\n//     height = 300;\n\n//     // matches[0].children[0].setAttribute('fill', '#F55');\n//     match0.children[0].style.fill = '#f55';\n\n//     if (matches.length > 1) {\n//       // console.log('matches.length > 1')\n//       // matches[1].children[0].setAttribute('fill', '#C4C');\n//       const match1 = matches[interactingGeneIndex];\n//       // console.log('match1')\n//       // console.log(match1)\n//       match1.children[0].style.fill = '#c4c';\n//       const m1 = matches[1].getCTM();\n//       const m1Rect = matches[1].getBoundingClientRect();\n//       const m1Box = matches[1].getBBox();\n//       console.log('m0', m0)\n//       console.log('m1', m1)\n//       const m1MinX = m1.e/m1.a;\n//       const m1MinY = m1.f/m1.d;\n//       // const m1MinX = m1.e/m1.a + m1Rect.width;\n//       // const m1MinY = m1.f/m1.d - m1Rect.height;\n//       if (m1MinX < m0MinX) minX = m1MinX;\n//       if (m1MinY < m0MinY) minY = m1MinY;\n\n//       let pairWidth = 0;\n//       if (m0Rect.left < m1Rect.left) {\n//         // pairWidth = m1Rect.right - m0Rect.left;\n//         width += m1Box.width + 40;\n//       }\n\n//       // width += pairWidth;\n\n//       // console.log('m0Rect', m0Rect)\n//       // console.log('m1Rect', m1Rect)\n//       // console.log('m1MinX', m1MinX)\n//       // console.log('m0MinX', m0MinX)\n//       // console.log('m1MinY', m1MinY)\n//       // console.log('m0MinY', m0MinY)\n//       // console.log('pairWidth', pairWidth)\n//       // console.log('width', width)\n//       // width += Math.abs(m1MinX - m0MinX);\n//       // height += Math.abs(m1MinY - m0MinY);\n\n//       // minX -= 100;\n//       // minY -= 100;\n\n//       // minX -= 150;\n//       // minY -= 150;\n//     } else {\n//       minX -= 150;\n//       minY -= 150;\n//     }\n\n//     minX = Math.round(minX);\n//     minY = Math.round(minY);\n//     width = Math.round(width);\n//     height = Math.round(height);\n\n//     const viewBox = `${minX} ${minY} ${width} ${height}`;\n//     console.log('viewBox', viewBox);\n//     document.querySelector('svg.Diagram').setAttribute('viewBox', viewBox);\n\n//   }\n// }\n","export function accessor(x, fallback) {\n  return x == null ? fallback\n    : typeof x === 'function' ? x\n    : d => d[x];\n}\n","export function bin1d(data, x, weight, lo, hi, n) {\n  const grid = new Float64Array(n);\n  const delta = (n - 1) / (hi - lo);\n\n  for (let i = 0; i < data.length; ++i) {\n    const d = data[i];\n    const xi = x(d, i, data);\n    const wi = weight(d, i, data);\n\n    // skip NaN and Infinite values\n    if (!(Number.isFinite(xi) && Number.isFinite(wi))) {\n      continue;\n    }\n\n    const p = (xi - lo) * delta;\n    const u = Math.floor(p);\n    const v = u + 1;\n\n    if (0 <= u && v < n) {\n      grid[u] += (v - p) * wi;\n      grid[v] += (p - u) * wi;\n    } else if (u === -1) {\n      grid[v] += (p - u) * wi;\n    } else if (v === n) {\n      grid[u] += (v - p) * wi;\n    }\n  }\n\n  return grid;\n}\n","// Deriche's approximation of Gaussian smoothing\n// Adapted from Getreuer's C implementation (BSD license)\n// https://www.ipol.im/pub/art/2013/87/gaussian_20131215.tgz\n// http://dev.ipol.im/~getreuer/code/doc/gaussian_20131215_doc/gaussian__conv__deriche_8c.html\n\nexport function dericheConfig(sigma, negative = false) {\n  // compute causal filter coefficients\n  const a = new Float64Array(5);\n  const bc = new Float64Array(4);\n  dericheCausalCoeff(a, bc, sigma);\n\n  // numerator coefficients of the anticausal filter\n  const ba = Float64Array.of(\n    0,\n    bc[1] - a[1] * bc[0],\n    bc[2] - a[2] * bc[0],\n    bc[3] - a[3] * bc[0],\n    -a[4] * bc[0]\n  );\n\n  // impulse response sums\n  const accum_denom = 1.0 + a[1] + a[2] + a[3] + a[4];\n  const sum_causal = (bc[0] + bc[1] + bc[2] + bc[3]) / accum_denom;\n  const sum_anticausal = (ba[1] + ba[2] + ba[3] + ba[4]) / accum_denom;\n\n  // coefficients object\n  return {\n    sigma,\n    negative,\n    a,\n    b_causal: bc,\n    b_anticausal: ba,\n    sum_causal,\n    sum_anticausal\n  };\n}\n\nfunction dericheCausalCoeff(a_out, b_out, sigma) {\n  const K = 4;\n\n  const alpha = Float64Array.of(\n    0.84, 1.8675,\n    0.84, -1.8675,\n    -0.34015, -0.1299,\n    -0.34015, 0.1299\n  );\n\n  const x1 = Math.exp(-1.783 / sigma);\n  const x2 = Math.exp(-1.723 / sigma);\n  const y1 = 0.6318 / sigma;\n  const y2 = 1.997 / sigma;\n  const beta = Float64Array.of(\n    -x1 * Math.cos( y1), x1 * Math.sin( y1),\n    -x1 * Math.cos(-y1), x1 * Math.sin(-y1),\n    -x2 * Math.cos( y2), x2 * Math.sin( y2),\n    -x2 * Math.cos(-y2), x2 * Math.sin(-y2)\n  );\n\n  const denom = sigma * 2.5066282746310007;\n\n  // initialize b/a = alpha[0] / (1 + beta[0] z^-1)\n  const b = Float64Array.of(alpha[0], alpha[1], 0, 0, 0, 0, 0, 0);\n  const a = Float64Array.of(1, 0, beta[0], beta[1], 0, 0, 0, 0, 0, 0);\n\n  let j, k;\n\n  for (k = 2; k < 8; k += 2) {\n    // add kth term, b/a += alpha[k] / (1 + beta[k] z^-1)\n    b[k]     = beta[k] * b[k - 2] - beta[k + 1] * b[k - 1];\n    b[k + 1] = beta[k] * b[k - 1] + beta[k + 1] * b[k - 2];\n    for (j = k - 2; j > 0; j -= 2) {\n      b[j]     += beta[k] * b[j - 2] - beta[k + 1] * b[j - 1];\n      b[j + 1] += beta[k] * b[j - 1] + beta[k + 1] * b[j - 2];\n    }\n    for (j = 0; j <= k; j += 2) {\n      b[j]     += alpha[k] * a[j]     - alpha[k + 1] * a[j + 1];\n      b[j + 1] += alpha[k] * a[j + 1] + alpha[k + 1] * a[j];\n    }\n\n    a[k + 2] = beta[k] * a[k]     - beta[k + 1] * a[k + 1];\n    a[k + 3] = beta[k] * a[k + 1] + beta[k + 1] * a[k];\n    for (j = k; j > 0; j -= 2) {\n      a[j]     += beta[k] * a[j - 2] - beta[k + 1] * a[j - 1];\n      a[j + 1] += beta[k] * a[j - 1] + beta[k + 1] * a[j - 2];\n    }\n  }\n\n  for (k = 0; k < K; ++k) {\n    j = k << 1;\n    b_out[k] = b[j] / denom;\n    a_out[k + 1] = a[j + 2];\n  }\n}\n\nexport function dericheConv2d(cx, cy, grid, [nx, ny]) {\n  // allocate buffers\n  const yc = new Float64Array(Math.max(nx, ny)); // causal\n  const ya = new Float64Array(Math.max(nx, ny)); // anticausal\n  const h = new Float64Array(5);\n  const d = new Float64Array(grid.length);\n\n  // convolve rows\n  for (let row = 0, r0 = 0; row < ny; ++row, r0 += nx) {\n    const dx = d.subarray(r0);\n    dericheConv1d(cx, grid.subarray(r0), nx, 1, yc, ya, h, dx);\n  }\n\n  // convolve columns\n  for (let c0 = 0; c0 < nx; ++c0) {\n    const dy = d.subarray(c0);\n    dericheConv1d(cy, dy, ny, nx, yc, ya, h, dy);\n  }\n\n  return d;\n}\n\nexport function dericheConv1d(\n  c, src, N,\n  stride = 1,\n  y_causal = new Float64Array(N),\n  y_anticausal = new Float64Array(N),\n  h = new Float64Array(5),\n  d = y_causal,\n  init = dericheInitZeroPad\n) {\n  const stride_2 = stride * 2;\n  const stride_3 = stride * 3;\n  const stride_4 = stride * 4;\n  const stride_N = stride * N;\n  let i, n;\n\n  // initialize causal filter on the left boundary\n  init(\n    y_causal, src, N, stride,\n    c.b_causal, 3, c.a, 4, c.sum_causal, h, c.sigma\n  );\n\n  // filter the interior samples using a 4th order filter. Implements:\n  // for n = K, ..., N - 1,\n  //   y^+(n) = \\sum_{k=0}^{K-1} b^+_k src(n - k)\n  //          - \\sum_{k=1}^K a_k y^+(n - k)\n  // variable i tracks the offset to the nth sample of src, it is\n  // updated together with n such that i = stride * n.\n  for (n = 4, i = stride_4; n < N; ++n, i += stride) {\n    y_causal[n] = c.b_causal[0] * src[i]\n      + c.b_causal[1] * src[i - stride]\n      + c.b_causal[2] * src[i - stride_2]\n      + c.b_causal[3] * src[i - stride_3]\n      - c.a[1] * y_causal[n - 1]\n      - c.a[2] * y_causal[n - 2]\n      - c.a[3] * y_causal[n - 3]\n      - c.a[4] * y_causal[n - 4];\n  }\n\n  // initialize the anticausal filter on the right boundary\n  init(\n    y_anticausal, src, N, -stride,\n    c.b_anticausal, 4, c.a, 4, c.sum_anticausal, h, c.sigma\n  );\n\n  // similar to the causal filter above, the following implements:\n  // for n = K, ..., N - 1,\n  //   y^-(n) = \\sum_{k=1}^K b^-_k src(N - n - 1 - k)\n  //          - \\sum_{k=1}^K a_k y^-(n - k)\n  // variable i is updated such that i = stride * (N - n - 1).\n  for (n = 4, i = stride_N - stride * 5; n < N; ++n, i -= stride) {\n    y_anticausal[n] = c.b_anticausal[1] * src[i + stride]\n      + c.b_anticausal[2] * src[i + stride_2]\n      + c.b_anticausal[3] * src[i + stride_3]\n      + c.b_anticausal[4] * src[i + stride_4]\n      - c.a[1] * y_anticausal[n - 1]\n      - c.a[2] * y_anticausal[n - 2]\n      - c.a[3] * y_anticausal[n - 3]\n      - c.a[4] * y_anticausal[n - 4];\n  }\n\n  // sum the causal and anticausal responses to obtain the final result\n  if (c.negative) {\n    // do not threshold if the input grid includes negatively weighted values\n    for (n = 0, i = 0; n < N; ++n, i += stride) {\n      d[i] = y_causal[n] + y_anticausal[N - n - 1];\n    }\n  } else {\n    // threshold to prevent small negative values due to floating point error\n    for (n = 0, i = 0; n < N; ++n, i += stride) {\n      d[i] = Math.max(0, y_causal[n] + y_anticausal[N - n - 1]);\n    }\n  }\n\n  return d;\n}\n\nexport function dericheInitZeroPad(dest, src, N, stride, b, p, a, q, sum, h) {\n  const stride_N = Math.abs(stride) * N;\n  const off = stride < 0 ? stride_N + stride : 0;\n  let i, n, m;\n\n  // compute the first q taps of the impulse response, h_0, ..., h_{q-1}\n  for (n = 0; n < q; ++n) {\n    h[n] = (n <= p) ? b[n] : 0;\n    for (m = 1; m <= q && m <= n; ++m) {\n      h[n] -= a[m] * h[n - m];\n    }\n  }\n\n  // compute dest_m = sum_{n=1}^m h_{m-n} src_n, m = 0, ..., q-1\n  // note: q == 4\n  for (m = 0; m < q; ++m) {\n    for (dest[m] = 0, n = 1; n <= m; ++n) {\n      i = off + stride * n;\n      if (i >= 0 && i < stride_N) {\n        dest[m] += h[m - n] * src[i];\n      }\n    }\n  }\n\n  // dest_m = dest_m + h_{n+m} src_{-n}\n  const cur = src[off];\n  if (cur > 0) {\n    for (m = 0; m < q; ++m) {\n      dest[m] += h[m] * cur;\n    }\n  }\n\n  return;\n}\n","export function extent(data, x, pad = 0) {\n  const n = data.length;\n  let lo;\n  let hi;\n  for (let i = 0; i < n; ++i) {\n    const v = x(data[i], i, data);\n    if (v != null) {\n      if (lo === undefined) {\n        if (v >= v) lo = hi = v;\n      } else {\n        if (v < lo) lo = v;\n        if (v > hi) hi = v;\n      }\n    }\n  }\n  return [lo - pad, hi + pad];\n}\n","// Scott, D. W. (1992) Multivariate Density Estimation:\n// Theory, Practice, and Visualization. Wiley.\nexport function nrd(data, x) {\n  const values = data.map(x).filter(v => v != null && v >= v);\n  values.sort((a, b) => a - b);\n  const sd = stdev(values);\n  const q1 = quantile(values, 0.25);\n  const q3 = quantile(values, 0.75);\n\n  const n = values.length,\n        h = (q3 - q1) / 1.34,\n        v = Math.min(sd, h) || sd || Math.abs(q1) || 1;\n\n  return 1.06 * v * Math.pow(n, -0.2);\n}\n\nfunction stdev(values) {\n  const n = values.length;\n  let count = 0;\n  let delta;\n  let mean = 0;\n  let sum = 0;\n  for (let i = 0; i < n; ++i) {\n    const value = values[i];\n    delta = value - mean;\n    mean += delta / ++count;\n    sum += delta * (value - mean);\n  }\n  return count > 1 ? Math.sqrt(sum / (count - 1)) : NaN;\n}\n\nfunction quantile(values, p) {\n  const n = values.length;\n\n  if (!n) return NaN;\n  if ((p = +p) <= 0 || n < 2) return values[0];\n  if (p >= 1) return values[n - 1];\n\n  const i = (n - 1) * p;\n  const i0 = Math.floor(i);\n  const v0 = values[i0];\n  return v0 + (values[i0 + 1] - v0) * (i - i0);\n}\n","import { accessor } from './accessor.js';\nimport { bin1d } from './bin1d.js';\nimport { dericheConfig, dericheConv1d } from './deriche.js';\nimport { extent as densityExtent } from './extent.js';\nimport { nrd } from './nrd.js';\n\nexport function density1d(data, options = {}) {\n  const { adjust = 1, pad = 3, bins = 512 } = options;\n  const x = accessor(options.x, x => x);\n  const w = accessor(options.weight, () => 1 / data.length);\n\n  let bandwidth = options.bandwidth ?? adjust * nrd(data, x);\n\n  const [lo, hi] = options.extent ?? densityExtent(data, x, pad * bandwidth);\n  const grid = bin1d(data, x, w, lo, hi, bins);\n  const delta = (hi - lo) / (bins - 1);\n  const neg = grid.some(v => v < 0);\n\n  let config = dericheConfig(bandwidth / delta, neg);\n  let result;\n\n  function* points(x = 'x', y = 'y') {\n    const result = estimator.grid();\n    const scale = 1 / delta;\n    for (let i = 0; i < bins; ++i) {\n      yield {\n        [x]: lo + i * delta,\n        [y]: result[i] * scale\n      };\n    }\n  }\n\n  const estimator = {\n    [Symbol.iterator]: points,\n    points,\n    grid: () => result || (result = dericheConv1d(config, grid, bins)),\n    extent: () => [lo, hi],\n    bandwidth(_) {\n      if (arguments.length) {\n        if (_ !== bandwidth) {\n          bandwidth = _;\n          result = null;\n          config = dericheConfig(bandwidth / delta, neg);\n        }\n        return estimator;\n      } else {\n        return bandwidth;\n      }\n    }\n  };\n\n  return estimator;\n}\n","import {\n  adjustBrightness, ensureContrast, getTextSize, d3\n} from '../lib';\nimport {density1d} from 'fast-kde';\n\nconst MINI_CURVE_HEIGHT = 12;\nconst MINI_CURVE_WIDTH = 48;\n\n/** Copyedit machine-friendly tissue name to human-friendly GTEx convention */\nfunction refineTissueName(rawName) {\n  let name = rawName.replace(/_/g, ' ').toLowerCase();\n\n  // Style abbreviations of \"Brodmann area\", and other terms\n  // per GTEx conventions\n  [\n    'ba24', 'ba9', 'basal ganglia', 'omentum', 'suprapubic', 'lower leg',\n    'cervical c-1'\n  ].forEach(term => name = name.replace(term, '(' + term + ')'));\n  ['ba24', 'ba9', 'ebv'].forEach(term => {\n    name = name.replace(term, term.toUpperCase());\n  });\n  [\n    'adipose', 'artery', 'brain', 'breast', 'cells', 'cervix', 'colon',\n    'heart', 'kidney', 'muscle', 'nerve', 'skin', 'small intestine'\n  ].forEach(term => {\n    name = name.replace(term, term + ' -');\n  });\n\n  // Shorten from long full name to brief (but also standard) abbreviation\n  name = name.replace('basal ganglia', 'BG');\n\n  name = name[0].toUpperCase() + name.slice(1);\n  return name;\n}\n\n/** Get maximum expression among tissues, or for an optional reference */\nfunction getMaxExpression(tissueExpressions, refTissue) {\n  let maxExpression = 0;\n\n  for (let i = 0; i < tissueExpressions.length; i++) {\n    const teObject = tissueExpressions[i];\n    const thisMaxExp = teObject.expression.max;\n\n    if (!refTissue) {\n      // For default display of mini-curves\n      if (thisMaxExp > maxExpression) {\n        maxExpression = thisMaxExp;\n      }\n    } else {\n      // Set a non-default tissue as reference, e.g. to frame other\n      // mini-curves relative to hovered mini-curve.\n      if (teObject.tissue === refTissue) {\n        maxExpression = thisMaxExp;\n        break;\n      }\n    }\n  }\n\n  return maxExpression;\n}\n\n/**\n * Set a `px` property in each item of tissueExpressions for key metrics\n *\n * @param {List<Object>} tissueExpressions\n * @param {Number} maxPx Maximum width\n * @param {Boolean} relative Whether offsets are relative to highest-median\n *   expression tissue (e.g. multiple mini-curves) or not (e.g. detail curve)\n * @param {Number} leftPx How much to much curves over from the left\n * @param {String} refTissue Tissue used as reference for maximum expression.\n *   refTissue maxExp becomes px.max, any greater exp. in other tissues gets\n *   truncated at right in its curve.\n * @returns {List<Object>} tissueExpressions, with a new `px` property in each\n *   for max, q3, median, q1, and min.\n */\nfunction setPxOffset(\n  tissueExpressions, maxPx, relative=true, leftPx=0, refTissue=null\n) {\n  const maxExpression = getMaxExpression(tissueExpressions, refTissue);\n  let refMinExp = 0;\n  if (refTissue) {\n    const refTeObject =\n      tissueExpressions.find(teObject => teObject.tissue === refTissue);\n    refMinExp = refTeObject.expression.min;\n  }\n\n  const metrics = ['max', 'q3', 'median', 'q1', 'min'];\n\n  tissueExpressions.map(teObject => {\n    teObject.px = {};\n    if (relative) {\n      for (let i = 0; i < metrics.length; i++) {\n        const metric = metrics[i];\n        const exp = teObject.expression[metric];\n        let px =\n          maxPx * (exp - refMinExp)/(maxExpression - refMinExp) + leftPx;\n        if (Math.round(px) > maxPx) {\n          // Often occurs when `refTissue` is specified\n          teObject.px[metric + 'Raw'] = px;\n          px += (maxPx - px);\n        }\n        px += leftPx;\n        teObject.px[metric] = px;\n      }\n    } else {\n      // min = 50,   med = 100,    max = 200\n      // px.min = 0, px.med = 250 * 100-50/(200 - 50), px.max = 250\n      const minExp = teObject.expression.min;\n      const maxExp = teObject.expression.max;\n      for (let i = 0; i < metrics.length; i++) {\n        const metric = metrics[i];\n        const exp = teObject.expression[metric];\n        const px = maxPx * (exp - minExp)/(maxExp - minExp) + leftPx;\n        teObject.px[metric] = px;\n      }\n    }\n    return teObject;\n  });\n\n  return tissueExpressions;\n}\n\n/** Get link to full detail about gene on GTEx */\nfunction getFullDetail(gene) {\n  const gtexUrl = `https://www.gtexportal.org/home/gene/${gene}`;\n  const cls = 'class=\"_ideoGtexLink\"';\n  const gtexLink =\n    `<a href=\"${gtexUrl}\" ${cls} target=\"_blank\">GTEx</a>`;\n  const fullDetail = `<i>Full detail: ${gtexLink}</i>`;\n  return fullDetail;\n}\n\nfunction getMoreOrLessToggle(gene, height, tissueExpressions, ideo) {\n\n  const fullDetail = getFullDetail(gene);\n\n  if (tissueExpressions.length <= 3) {\n    return `<br/>${fullDetail}<br/><br/>`;\n  }\n\n  const pipeStyle =\n    'style=\"margin: 0 6px; color: #CCC;\"';\n  const details =\n    `<span ${pipeStyle}>|</span>${fullDetail}`;\n  const moreOrLess =\n    !ideo.showTissuesMore ? `Less...` : 'More...';\n  const mlStyle = 'style=\"cursor: pointer;px;\"';\n  const left = `left: ${!ideo.showTissuesMore ? 1 : -50}px;`;\n  const top = 'top: -1px;';\n  const mltStyle =\n    `style=\"position: relative; ${left} ${top} font-size: ${height}px\"`\n  const moreOrLessToggleHtml =\n    `<div ${mltStyle}>` +\n      `<a class=\"_ideoMoreOrLessTissue\" ${mlStyle}>${moreOrLess}</a>` +\n      `${!ideo.showTissuesMore ? details : ''}` +\n    `</div>`;\n\n  return moreOrLessToggleHtml;\n}\n\n/** Get x, y1, y2, and style for a metric line */\nfunction getMetricLineAttrs(offsets, metric, y, height, isShifted=false) {\n  let x = offsets[metric];\n  let isTruncated = false;\n  if (isShifted && x > MINI_CURVE_WIDTH) {\n    x = MINI_CURVE_WIDTH + 1;\n    isTruncated = true;\n  }\n  let metricHeight =\n    !isTruncated ? offsets[metric + 'Height'] : MINI_CURVE_HEIGHT;\n\n  if (isNaN(metricHeight)) {\n    // Seen upon e.g. hovering over \"Artery - Coronary\" in STAT1\n    metricHeight = MINI_CURVE_HEIGHT;\n  }\n\n  const top = height - metricHeight;\n  const y1 = top + y + 0.5;\n  const y2 = top + y + metricHeight;\n\n  // E.g. brain mini-curve in AGT\n  const isNarrow = offsets.max - offsets.min <= 8;\n  const isMedian = metric === 'median';\n  const isNarrowMedian = isNarrow && isMedian;\n  const style = isNarrowMedian ? 'display: none' : '';\n\n  // Whether to hide median at end of transition, e.g. when focus is\n  // esophagus in ACE2 and testis median should be hidden\n  const isTruncatedMedian = isTruncated && isMedian;\n\n  const endStyle =\n    isTruncatedMedian || isNarrowMedian ? 'display: none;' : '';\n\n  return {x, y1, y2, style, endStyle};\n}\n\n/** Get a vertical line to show in distribution curve for median, Q1, or Q2 */\nfunction getMetricLine(\n  metric, offsets, color, y, height,\n  dash=false\n) {\n  const classMetric = metric[0].toUpperCase() + metric.slice(1);\n  const {x, y1, y2, style} = getMetricLineAttrs(offsets, metric, y, height);\n  const styleAttr = style === '' ? '' : `style=\"${style}\"`;\n  const baseColor = adjustBrightness(color, 0.55);\n  const strokeColor = ensureContrast(baseColor, color);\n  const dasharray = dash ? 'stroke-dasharray=\"3\" ' : '';\n  const attrs =\n    `x1=\"${x}\" y1=\"${y1}\" x2=\"${x}\" y2=\"${y2}\" ${styleAttr} ` +\n    dasharray +\n    `class=\"_ideoExpression${classMetric}\" `;\n  const metricLine = `<line stroke=\"${strokeColor}\" ${attrs} />`;\n  return metricLine;\n}\n\n/**\n * Get vertical lines for median, Q1, Q3, to overlay in distribution curve plot\n *\n * Median line is solid, and shown in both mini-curve and detailed curve.\n * Q1 and Q3 lines are dashed, and only shown in detailed curve.\n */\nfunction getMetricLines(offsets, y, height, color) {\n  const medianLine = getMetricLine('median', offsets, color, y, height, false);\n  const q1Line = getMetricLine('q1', offsets, color, y, height, true);\n  const q3Line = getMetricLine('q3', offsets, color, y, height, true);\n\n  return [medianLine, q1Line, q3Line];\n}\n\nfunction getCurveShape(teObject, y, height, numKdeBins=64, isShifted=false) {\n  const quantiles = teObject.expression.quantiles;\n  const offsets = teObject.px;\n  const samples = teObject.samples;\n  const spreadQuantiles = [];\n\n  // `quantiles` is an array encoding a histogram.\n  // To get a kernel density estimation (KDE) -- i.e., a curve that smooths the\n  // crude bars of the histogram -- we need to \"spread\" or \"flatten\" the\n  // histogram array so e.g.\n  // [0, 5, 4, 1] (= 0 samples in quantile 1, 5 samples in quantile 2, etc.)\n  // becomes\n  // [0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3]\n  quantiles.map((quantileCount, j) => {\n    for (let k = 0; k < quantileCount; k++) {\n      spreadQuantiles.push(j);\n    }\n  });\n\n  const sampleThreshold = 70; // GTEx sample threshold\n\n  // Small bandwidth : sharp curve :: large bandwidth : smooth curve\n  //\n  // Increasing bandwidth when there are few samples helps avoid sharp curves\n  // that are mere artifacts of having few points, which would be problematic\n  // as it almost certainly misrepresents the underlying population.\n  const bandwidth = samples >= sampleThreshold ? 0.7 : 1.5;\n\n  const numBins = numKdeBins; // The number of lines in the KDE curve\n  const kde = density1d(\n    spreadQuantiles, {bins: numBins, bandwidth}\n  );\n  const rawKdeArray = Array.from(kde);\n  const kdeArray = rawKdeArray\n    .filter(point => 0 <= point.x && point.x <= 10);\n\n  if (kdeArray.length === 0) return '';\n\n  // Get scaling factor to convert kernel coordinates to pixels\n  const maxKernelY = Math.max(...kdeArray.map(p => p.y));\n  const minKernelX = kdeArray[0].x;\n  const maxKernelX = kdeArray.slice(-1)[0].x;\n  const kdeWidth = maxKernelX - minKernelX;\n  const thisMax = ('maxRaw' in offsets) ? offsets.maxRaw : offsets.max;\n  const offsetsWidth = thisMax - offsets.min;\n  const pixelsPerKernel = offsetsWidth/kdeWidth;\n\n  const bottom = height + y;\n\n  // Convert KDE x,y points to pixel coordinates, each a segment of the curve;\n  // and set heights for each metric plotted in detailed distribution\n  let prevPixelX = 0;\n  const rawPoints = kdeArray.map((point, i) => {\n    let pixelX = (point.x - minKernelX) * pixelsPerKernel + offsets.min;\n    if (isShifted && pixelX > MINI_CURVE_WIDTH) {\n      pixelX = MINI_CURVE_WIDTH;\n    }\n    const segmentHeight = height * (point.y / maxKernelY);\n    const pixelY = bottom - segmentHeight;\n\n    if (i > 0) {\n      ['q1', 'median', 'q3'].forEach(metric => {\n        const metricX = offsets[metric];\n        if (prevPixelX < metricX && metricX <= pixelX) {\n          offsets[metric + 'Height'] = segmentHeight;\n        }\n      });\n    }\n\n    prevPixelX = pixelX;\n\n    return `${pixelX},${pixelY}`;\n  });\n\n  let refinedMax = offsets.max;\n  let refinedMin = offsets.min;\n  if (isShifted) {\n    if (offsets.max > MINI_CURVE_WIDTH) refinedMax = MINI_CURVE_WIDTH;\n    if (offsets.min > MINI_CURVE_WIDTH) refinedMin = MINI_CURVE_WIDTH;\n  }\n\n  // Tie up loose ends of the curved diagram\n  rawPoints.push(refinedMax + ',' + bottom);\n  rawPoints.push(refinedMin + ',' + bottom);\n  const originPoint = rawPoints[0];\n  rawPoints.push(originPoint);\n  const points = rawPoints.join(' ');\n\n  return [points, offsets];\n}\n\n/**\n * Get a distribution curve of expression, via kernel density estimation (KDE)\n */\nfunction getCurve(teObject, y, height, color, borderColor, numKdeBins=64) {\n  const [points, offsets] = getCurveShape(teObject, y, height, numKdeBins);\n\n  const curveAttrs =\n    `fill=\"${color}\" ` +\n    `stroke=\"${borderColor}\" ` +\n    `points=\"${points}\" ` +\n    'class=\"tissue-curve\" ' +\n    `data-tissue-curve=\"${teObject.tissue}\"`;\n\n  const curve = `<polyline ${curveAttrs} />`;\n\n  return [curve, offsets];\n}\n\n/**\n * Remove detailed distribution curve; unhide RNA & protein diagrams, footer\n */\nfunction removeDetailedCurve() {\n  const container = document.querySelector('._ideoDistributionContainer');\n  if (!container) return;\n  container.remove();\n\n  const structureDom = document.querySelector('._ideoGeneStructureContainer');\n  if (structureDom) {\n    structureDom.style.display = '';\n  }\n  const footer = document.querySelector('._ideoTooltipFooter');\n  footer.style.display = '';\n}\n\n/**\n * Get small vertical lines (\"ticks\") for min, max, and median in detailed\n * distribution curve\n */\nfunction getMetricTicks(teObject, height) {\n  const min = teObject.px.min;\n  const minExp = teObject.expression.min;\n  const max = teObject.px.max;\n  const maxExp = teObject.expression.max;\n  const median = teObject.px.median;\n  const medianExp = teObject.expression.median;\n  const mid = max/2;\n  const y = height + 5;\n  const stroke = `stroke=\"#CCC\" stroke-width=\"1px\"`;\n\n  const fontObject = {\n    config: {weight: 400, annotLabelSize: 12}\n  };\n\n  const textY = y + 16;\n  const expTextY = y + 27;\n  const tickY1 = y - 3;\n  const tickY2 = y + 5;\n\n  const maxRawText = 'Max';\n  const maxTextWidth = getTextSize(maxRawText, fontObject).width;\n  const maxExpTextWidth = getTextSize(maxExp, fontObject).width;\n  const maxTextX = max - maxTextWidth / 2;\n  const maxExpTextX = max - maxExpTextWidth / 2;\n  const maxTickAttrs =\n    `x1=\"${max}\" x2=\"${max}\" y1=\"${tickY1}\" y2=\"${tickY2}\" ${stroke}`;\n  const maxText =\n    `<line ${maxTickAttrs} />` +\n    `<text x=\"${maxTextX}\" y=\"${textY}\">${maxRawText}.</text>` +\n    `<text x=\"${maxExpTextX}\" y=\"${expTextY}\">${maxExp}</text>`;\n\n  const minRawText = 'Min';\n  const minTextWidth = getTextSize(minRawText, fontObject).width;\n  const minExpTextWidth = getTextSize(minExp, fontObject).width;\n  let minTextX = min - minTextWidth / 2;\n  let minExpTextX = min - minExpTextWidth / 2;\n  const minTextEndX = min + minTextWidth;\n  const minTickAttrs =\n    `x1=\"${min}\" x2=\"${min}\" y1=\"${tickY1}\" y2=\"${tickY2}\" ${stroke}`;\n\n  const medianRawText = 'Median';\n  const medianTextWidth = getTextSize(medianRawText, fontObject).width;\n  const medianExpTextWidth = getTextSize(medianExp, fontObject).width;\n  const medianTextX = median - medianTextWidth / 2;\n  const medianExpTextX = median - medianExpTextWidth / 2;\n  const medianTickAttrs =\n    `x1=\"${median}\" x2=\"${median}\" y1=\"${tickY1}\" y2=\"${tickY2}\" ${stroke}`;\n\n  let medianX = medianTextX;\n  let medianExpX = medianExpTextX;\n\n  // Align \"Median\" to right of tick if text would clash with \"Min.\"\n  const isMinMedSoftCollide = minTextEndX >= medianX;\n  if (isMinMedSoftCollide) {\n    medianX = median;\n    medianExpX = median;\n  }\n\n  // If right-aligning \"Median\" doesn't fix clash,\n  // then left-align \"Min.\" and nudge \"Median\" right\n  const isMinMedCollide = minTextEndX >= medianX;\n\n  // Examples: \"More...\" tissues in PCSK9 and (especially) TTN\n  if (isMinMedCollide) {\n    medianX += 1.5;\n    medianExpX += 1.5;\n    minTextX = min - minTextWidth - 1.5;\n    minExpTextX = min - minExpTextWidth - 1.5;\n  }\n\n  const medianText =\n    `<line ${medianTickAttrs} />` +\n    `<text x=\"${medianX}\" y=\"${textY}\">Median</text>` +\n    `<text x=\"${medianExpX}\" y=\"${expTextY}\">${medianExp}</text>`;\n\n  const minText =\n    `<line ${minTickAttrs} />` +\n    `<text x=\"${minTextX}\" y=\"${textY}\" >${minRawText}.</text>` +\n    `<text x=\"${minExpTextX}\" y=\"${expTextY}\" >${minExp}</text>`;\n\n  const nameAttrs =\n    `x=\"${mid - 40}\" y=\"${y + 46}\"`;\n  const sampleAttrs =\n    `x=\"${mid - 70}\" y=\"${y + 59}\"`;\n\n  return (\n    `<g>` +\n    minText +\n    maxText +\n    medianText +\n    `<text ${nameAttrs}>Expression (TPM)</text>` +\n    `<text ${sampleAttrs}>Samples: ${teObject.samples} | Source: GTEx</text>` +\n    `</g>`\n  );\n}\n\n/**\n * Write a large, detailed distribution curve to the DOM.\n *\n * This is shown upon hovering over a mini-curve.  The detailed curve shows\n * more metrics than the mini-curve, in a zoomed-in view that makes it easier\n * to discern the overall shape and local features of gene expression\n * distribution in the tissue.\n */\nfunction addDetailedCurve(traceDom, ideo) {\n  const gene = traceDom.getAttribute('data-gene');\n  const tissue = traceDom.getAttribute('data-tissue');\n  const tissueExpressions = Ideogram.tissueExpressionsByGene[gene];\n\n  let teObject = tissueExpressions.find(t => t.tissue === tissue);\n  const maxWidthPx = 225; // Same width as RNA & protein diagrams\n  const leftPx = 35;\n  teObject = setPxOffset(\n    [teObject], maxWidthPx, false, leftPx\n  )[0];\n\n  const y = 0;\n  const height = 50;\n\n  const color = `#${teObject.color}`;\n  const borderColor = adjustBrightness(color, 0.85);\n\n  const numBins = 256;\n  const [distributionCurve, offsetsWithHeight] = getCurve(\n    teObject, y + 1, height, color, borderColor, numBins\n  );\n\n  const [medianLine, q1Line, q3Line] = getMetricLines(\n    offsetsWithHeight, y, height, color\n  );\n  const metricTicks = getMetricTicks(teObject, height);\n\n  // Hide RNA & protein diagrams, footer\n  let ledgeDom;\n  const structureDom = document.querySelector('._ideoGeneStructureContainer');\n  const footer = document.querySelector('._ideoTooltipFooter');\n  if (structureDom) { // Account for e.g. ncRNA, like MALAT1\n    ledgeDom = structureDom;\n    structureDom.style.display = 'none';\n    footer.style.display = 'none';\n  } else {\n    ledgeDom = footer;\n    const plotContainer = document.querySelector('._ideoTissuePlotContainer');\n    plotContainer.setAttribute('style', 'margin-bottom: 20px');\n  }\n\n  const svgHeight = 119.5; // Keeps tooltip bottom flush with prior state\n  const style = `style=\"position: relative; height: ${svgHeight}px\"`;\n  const svgStyle = 'style=\"position: absolute; top: 2px; left: -5px;\"';\n  const container =\n    `<div class=\"_ideoDistributionContainer\" ${style}>` +\n    `<svg width=\"280px\" height=\"${svgHeight}px\" ${svgStyle}>` +\n    metricTicks +\n    distributionCurve +\n    medianLine +\n    q1Line +\n    q3Line +\n    `</svg>` +\n    '</div>';\n\n  ledgeDom.insertAdjacentHTML('beforebegin', container);\n}\n\nfunction getMiniCurveY(i, height) {\n  const y = 1 + i * (height + 2);\n  return y;\n}\n\n/** Get mini distribution curves and  */\nfunction getExpressionPlotHtml(gene, tissueExpressions, ideo) {\n  const maxWidth = MINI_CURVE_WIDTH;\n  tissueExpressions = setPxOffset(tissueExpressions, maxWidth, true, 0);\n\n  const height = MINI_CURVE_HEIGHT;\n\n  const moreOrLessToggleHtml =\n    getMoreOrLessToggle(gene, height, tissueExpressions, ideo);\n  const numTissues = !ideo.showTissuesMore ? 10 : 3;\n\n  let y;\n  const rects = tissueExpressions.slice(0, numTissues).map((teObject, i) => {\n    y = getMiniCurveY(i, height);\n    const tissue = refineTissueName(teObject.tissue);\n    const color = `#${teObject.color}`;\n    const borderColor = adjustBrightness(color, 0.85);\n\n    const [distributionCurve, offsetsWithHeight] = getCurve(\n      teObject, y, height, color, borderColor\n    );\n\n    const [medianLine] = getMetricLines(offsetsWithHeight, y, height, color);\n\n    const dataTissue = `data-tissue=\"${teObject.tissue}\"`;\n\n    // Invisible; enables tooltip upon hover anywhere in diagram area,\n    // not merely the (potentially very small) diagram itself\n    const containerAttrs =\n      `height=\"${height + 2}\" ` +\n      `width=\"${maxWidth}px\" ` +\n      'fill=\"#FFF\" ' +\n      'opacity=\"0\" ' +\n      `x=\"0\" ` +\n      `y=\"${y}\" ` +\n      `data-gene=\"${gene}\" ` +\n      dataTissue;\n\n    const textAttrs =\n      `y=\"${y + height}\" ` +\n      `style=\"font-size: ${height}px;\" ` +\n      `x=\"${maxWidth + 10}\" ` +\n      dataTissue;\n\n    return (\n      `<g data-group-tissue=\"${teObject.tissue}\">` +\n      `<text ${textAttrs}>${tissue}</text>` +\n      distributionCurve +\n      medianLine +\n      `<rect ${containerAttrs} class=\"_ideoExpressionTrace\" />` +\n      '</g>'\n    );\n  }).join('');\n\n  let containerStyle = 'style=\"margin-bottom: 30px;\"';\n  const hasStructure = gene in Ideogram.geneStructureCache;\n  if (!hasStructure) { // e.g. MALAT1\n    containerStyle = 'style=\"margin-bottom: 10px;\"';\n  }\n\n  const plotAttrs = `style=\"margin-top: 15px; margin-bottom: -15px;\"`;\n  const cls = 'class=\"_ideoTissuePlotTitle\"';\n  const titleAttrs = `${cls} style=\"margin-bottom: 4px;\"`;\n  const style = `style=\"position: relative; left: 10px\"`;\n  const plotHtml =\n    `<div class=\"_ideoTissuePlotContainer\" ${containerStyle}>` +\n      `<div class=\"_ideoTissueExpressionPlot\" ${plotAttrs}>\n        <div ${titleAttrs}>Reference expression by tissue</div>\n        <svg width=\"275\" height=\"${y + height + 2}\" ${style}>${rects}</svg>\n        ${moreOrLessToggleHtml}\n      </div>` +\n    '</div>';\n  return plotHtml;\n}\n\nfunction updateTissueExpressionPlot(ideo) {\n  const plot = document.querySelector('._ideoTissueExpressionPlot');\n  const plotParent = plot.parentElement;\n\n  const gene = document.querySelector('#ideo-related-gene').innerText;\n  const tissueExpressions = Ideogram.tissueExpressionsByGene[gene];\n\n  const newPlotHtml = getExpressionPlotHtml(gene, tissueExpressions, ideo);\n\n  plotParent.innerHTML = newPlotHtml;\n  addTissueListeners(ideo);\n}\n\nfunction colorTissueText(traceDom, color) {\n  const tissue = traceDom.getAttribute('data-tissue');\n  const tissueTextDom = document.querySelector(`text[data-tissue=\"${tissue}\"]`);\n  tissueTextDom.setAttribute('fill', color);\n}\n\nexport function addTissueListeners(ideo) {\n  const moreOrLess = document.querySelector('._ideoMoreOrLessTissue');\n  if (moreOrLess) {\n    moreOrLess.addEventListener('click', (event) => {\n      event.stopPropagation();\n      event.preventDefault();\n      ideo.showTissuesMore = !ideo.showTissuesMore;\n      updateTissueExpressionPlot(ideo);\n    });\n  }\n\n  const traces = document.querySelectorAll('._ideoExpressionTrace')\n  traces.forEach(trace => {\n    trace.addEventListener('mouseenter', () => {\n      colorTissueText(trace, '#338');\n      focusMiniCurve(trace, ideo);\n      addDetailedCurve(trace, ideo);\n    });\n    trace.addEventListener('mouseleave', () => {\n      colorTissueText(trace, '#000');\n      focusMiniCurve(traces[0], ideo, true);\n      removeDetailedCurve(trace, ideo);\n    });\n  });\n}\n\n/**\n * Update mini-curve shapes to focus on hovered tissue\n *\n * This helps compare the focused tissue to other tissues.  Without this,\n * often almost all curves are too small, and their distributions can't be\n * richly compared, because one or a few tissues have a maximum drastically\n * larger than others.  With this feature, expression in those non-dominant\n * tissues (which are often the majority, and biologically relevant) can be\n * compared in detail.\n *\n * The focused tissue becomes the new coordinate reference for all mini-curves.\n * The new reference tissue (refTissue) gets scaled and translated to occupy\n * the full width available to mini-curves (MINI_CURVE_WIDTH).  Other curves get\n * transformed to be viewed from the perspective of the focused tissue.\n **/\nfunction focusMiniCurve(traceDom, ideo, reset=false) {\n  const gene = traceDom.getAttribute('data-gene');\n  const refTissue = reset ? null : traceDom.getAttribute('data-tissue');\n\n  const numTissues = !ideo.showTissuesMore ? 10 : 3;\n  let tissueExpressions = Ideogram.tissueExpressionsByGene[gene];\n\n  const maxPx = MINI_CURVE_WIDTH;\n  const relative = true;\n  const leftPx = 0;\n  tissueExpressions =\n    setPxOffset(tissueExpressions, maxPx, relative, leftPx, refTissue)\n      .slice(0, numTissues);\n\n  const height = MINI_CURVE_HEIGHT;\n  tissueExpressions.forEach((teObject, i) => {\n    const thisTissue = teObject.tissue;\n    const thisTeObject = tissueExpressions.find(te => te.tissue === thisTissue);\n    const y = getMiniCurveY(i, height);\n\n    const isShifted = !reset;\n    const [newPoints, newOffsets] =\n      getCurveShape(thisTeObject, y, height, 64, isShifted);\n    tissueExpressions[i].points = newPoints;\n\n    const medianLineAttrs =\n      getMetricLineAttrs(newOffsets, 'median', y, height, isShifted);\n    tissueExpressions[i].medianLine = medianLineAttrs;\n  });\n\n  d3.select('._ideoTissueExpressionPlot').selectAll('polyline')\n    .data(tissueExpressions)\n    .transition()\n    .duration(500)\n    .attr('points', (_, i) => tissueExpressions[i].points);\n\n  d3.select('._ideoTissueExpressionPlot').selectAll('._ideoExpressionMedian')\n    .data(tissueExpressions)\n    .attr('style', (_, i) => tissueExpressions[i].medianLine.style)\n    .transition()\n    .duration(500)\n    .attr('x1', (_, i) => tissueExpressions[i].medianLine.x)\n    .attr('x2', (_, i) => tissueExpressions[i].medianLine.x)\n    .attr('y1', (_, i) => tissueExpressions[i].medianLine.y1)\n    .attr('y2', (_, i) => tissueExpressions[i].medianLine.y2)\n    .attr('style', (_, i) => tissueExpressions[i].medianLine.endStyle);\n}\n\nexport function getTissueHtml(annot, ideo) {\n  if (\n    !Ideogram.tissueCache ||\n    !(annot.name in Ideogram.tissueCache.byteRangesByName)\n  ) {\n    // e.g. MIR23A\n    return '<br/>';\n  }\n\n  if (ideo.showTissuesMore === undefined) {\n    ideo.showTissuesMore = true;\n  }\n\n  const gene = annot.name;\n  const tissueExpressions = Ideogram.tissueExpressionsByGene[gene];\n  if (!tissueExpressions) return;\n  const tissueHtml =\n    getExpressionPlotHtml(gene, tissueExpressions, ideo);\n\n  return tissueHtml;\n}\n","/**\n * @fileoverview Kit used in \"Related genes\" example\n *\n * This file simplifies client code for reusing a \"related genes\" ideogram --\n * which finds and displays related genes for a searched gene.\n *\n * Related genes here are either \"interacting genes\" or \"paralogs\".\n * Interacting genes are genes immediately upstream or downstream of the\n * searched gene in a biochemical pathway. Paralogs are evolutionarily\n * similar genes in the same species.\n *\n * Data sources:\n *   - Interacting genes: WikiPathways\n *   - Paralogs: Ensembl\n *   - Genomic coordinates: Ensembl, via MyGene.info\n *\n * Features provided by this module help users discover and explore genes\n * related to their gene of interest.\n *\n * The reference implementation is available at:\n * https://eweitz.github.io/ideogram/related-genes\n */\n\nimport {decompressSync, strFromU8} from 'fflate';\nimport tippy, {hideAll} from 'tippy.js';\nimport {tippyCss, tippyLightCss} from './tippy-styles';\n// import {Pvjs} from 'eweitz-pvjs';\nimport { drawPathway } from './pathway-viewer';\n\n\nimport {\n  initAnalyzeRelatedGenes, analyzePlotTimes, analyzeRelatedGenes, timeDiff,\n  getRelatedGenesByType, getRelatedGenesTooltipAnalytics\n} from './analyze-related-genes';\nimport {\n  getGeneStructureHtml, addGeneStructureListeners\n} from './gene-structure';\n\nimport {\n  sortAnnotsByRank, applyRankCutoff, setAnnotRanks\n} from '../annotations/annotations';\nimport {writeLegend} from '../annotations/legend';\nimport {getAnnotDomId} from '../annotations/process';\nimport {\n  getDir, pluralize, getTextSize, getTippyConfig\n} from '../lib';\nimport {\n  fetchGpmls, summarizeInteractions, fetchPathwayInteractions\n} from './wikipathways';\nimport {getTissueHtml, addTissueListeners} from './tissue';\nimport { addVariantListeners } from './variant';\n// import {drawAnnotsByLayoutType} from '../annotations/draw';\n// import {organismMetadata} from '../init/organism-metadata';\n\n\n/** Sets DOM IDs for ideo.relatedAnnots; needed to associate labels */\nfunction setRelatedAnnotDomIds(ideo) {\n  const updated = [];\n\n  const sortedChrNames = ideo.chromosomesArray.map((chr) => {\n    return chr.name;\n  });\n\n  if ('relatedAnnots' in ideo) {\n    ideo.relatedAnnots = applyAnnotsIncludeList(ideo.relatedAnnots, ideo);\n\n    // Count two related annots for same gene as one.\n    // E.g. gene Foo can both interact with and be paralog of gene Bar\n    // Instead of count Foo interacting annot and Foo paralog annot as two,\n    // only count it as one as they are merged in downstream UI.\n    //\n    // Searching STAT3 without this block shows the problem this fixes.\n    const seenNames = {};\n    ideo.relatedAnnots = ideo.relatedAnnots.filter(annot => {\n      if (annot.name in seenNames) {\n        return false;\n      }\n      seenNames[annot.name] = 1;\n      return true;\n    });\n  }\n\n  // Arrange related annots by chromosome\n  const annotsByChr = {};\n  ideo.annots.forEach((annot) => {\n    const relevanceSortedAnnots = annot.annots.sort((a, b) => {\n      return -ideo.annotSortFunction(a, b);\n    });\n    annotsByChr[annot.chr] = relevanceSortedAnnots;\n    // }\n  });\n\n\n  // // Sort related annots by relevance within each chromosome\n  // const relevanceSortedAnnotsNamesByChr = {};\n  // Object.entries(annotsByChr).map(([chr, annots]) => {\n\n  //   if ('annots' in annots) annots = annots.annots;\n  //   annots = setAnnotRanks(annots, ideo);\n\n  //   // Sort so first annots are drawn last, and thus at top layer\n  //   annots = annots.sort((a, b) => ideo.annotSortFunction(a, b));\n\n  //   const annotNames = annots.map((annot) => annot.name);\n  //   relevanceSortedAnnotsNamesByChr[chr] = annotNames;\n  // });\n\n  // annotsByChr.annots.sort((a, b) => {\n  //   // Reverse-sort, so first annots are drawn last, and thus at top layer\n  //   return -ideo.annotSortFunction(a, b);\n  // });\n\n  const updatedAnnots = {};\n  Object.entries(annotsByChr).forEach(([chr, annots]) => {\n    updatedAnnots[chr] = {chr, annots: []};\n    annots.forEach((annot, annotIndex) => {\n\n      // Annots have DOM IDs keyed by chromosome index and annotation index.\n      // We reconstruct those here using structures built in two blocks above.\n      const chrIndex = sortedChrNames.indexOf(chr);\n      // const annotIndex =\n      //   relevanceSortedAnnotsNamesByChr[chr].indexOf(annot.name);\n\n      annot.domId = getAnnotDomId(chrIndex, annotIndex);\n      updatedAnnots[chr].annots.push(annot);\n    });\n    updated.push(updatedAnnots[chr]);\n  });\n\n  ideo.annots = updated;\n}\n\n/**\n * Determines if interaction node might be a gene\n *\n * Some interaction nodes are biological processes; this filters out many.\n * Filtering these out makes downstream queries faster.\n *\n * ixn {Object} Interaction from WikiPathways\n * gene {Object} Gene from MyGene.info\n */\nfunction maybeGeneSymbol(ixn, gene) {\n  return (\n    ixn !== '' &&\n    !ixn.includes(' ') &&\n    !ixn.includes('/') && // e.g. Akt/PKB\n    ixn.toLowerCase() !== gene.name.toLowerCase()\n  );\n}\n\n// /** Helpful for debugging race conditions caused by concurrency */\n// const sleep = (delay) => {\n//  new Promise((resolve) => setTimeout(resolve, delay));\n// }\n\n/** Reports if interaction node is a gene and not previously seen */\nfunction isInteractionRelevant(rawIxn, gene, nameId, seenNameIds, ideo) {\n  let isGeneSymbol;\n  if ('geneCache' in Ideogram && gene.name) {\n    isGeneSymbol = rawIxn.toLowerCase() in Ideogram.geneCache.nameCaseMap;\n  } else {\n    isGeneSymbol = maybeGeneSymbol(rawIxn, gene);\n  }\n\n  const isNewNameId = !(nameId in seenNameIds);\n\n  return isGeneSymbol && isNewNameId;\n}\n\n/**\n * Retrieves interacting genes from WikiPathways API\n *\n * Docs:\n * https://webservice.wikipathways.org/ui/\n * https://www.wikipathways.org/index.php/Help:WikiPathways_Webservice/API\n *\n * Examples:\n * https://webservice.wikipathways.org/findInteractions?query=ACE2&format=json\n * https://webservice.wikipathways.org/findInteractions?query=RAD51&format=json\n */\nasync function fetchInteractions(gene, ideo) {\n  const ixns = {};\n  const seenNameIds = {};\n  const orgNameSimple = ideo.config.organism.replace(/-/g, ' ');\n  const upperGene = gene.name.toUpperCase();\n\n  let data = {result: []};\n\n  if (Ideogram.interactionCache) {\n    if (upperGene in Ideogram.interactionCache) {\n      data = Ideogram.interactionCache[upperGene];\n    }\n  } else {\n\n    // const queryString = `?query=${gene.name}&format=json`;\n    // const url =\n    //   `https://webservice.wikipathways.org/findInteractions${queryString}`;\n    // const url = `http://localhost:8080/dist/data/cache/${gene.name}.json.gz`;\n    const url = `https://cdn.jsdelivr.net/npm/ixn2/${upperGene}.json.gz`;\n\n    // await sleep(3000);\n\n    const response = await fetch(url);\n    // const data = await response.json();\n\n    if (response.ok) {\n      const blob = await response.blob();\n      const uint8Array = new Uint8Array(await blob.arrayBuffer());\n      data = JSON.parse(strFromU8(decompressSync(uint8Array)));\n    }\n  }\n\n  // For each interaction, get nodes immediately upstream and downstream.\n  // Filter out pathway nodes that are definitely not gene symbols, then\n  // group pathways by gene symbol. Each interacting gene can have\n  // multiple pathways.\n  data.result.forEach(interaction => {\n    if (interaction.species.toLowerCase() === orgNameSimple) {\n      const right = interaction.fields.right.values;\n      const left = interaction.fields.left.values;\n      // let mediator = [];\n      // if ('mediator' in interaction.fields) {\n      //   mediator = interaction.fields.mediator.values;\n      //   console.log('mediator', mediator)\n      // }\n      // const rawIxns = right.concat(left, mediator);\n      const rawIxns = right.concat(left);\n      const name = interaction.name;\n      const id = interaction.id;\n\n      // rawIxns can contain multiple genes, e.g. when\n      // a group (i.e. a complex or a set of paralogs)\n      // interacts with the searched gene\n      const wrappedRawIxns = rawIxns.map(rawIxn => {\n        return {name: rawIxn, color: ''};\n      });\n\n      const sortedRawIxns =\n        sortAnnotsByRank(wrappedRawIxns, ideo).map(i => i.name);\n\n      sortedRawIxns.forEach(rawIxn => {\n\n        const normRawIxn = rawIxn.toLowerCase();\n\n        // Prevent overwriting searched gene.  Occurs with e.g. human CD4\n        if (normRawIxn.includes(gene.name.toLowerCase())) return;\n\n        // if (rawIxn === '') return; // Avoid oddly blank placeholders\n\n        const nameId = name + id + normRawIxn;\n\n        const isRelevant =\n          isInteractionRelevant(normRawIxn, gene, nameId, seenNameIds, ideo);\n\n        if (isRelevant) {\n          seenNameIds[nameId] = 1;\n          const ixn = {name, pathwayId: id};\n          if (normRawIxn in ixns) {\n            ixns[normRawIxn].push(ixn);\n          } else {\n            ixns[normRawIxn] = [ixn];\n          }\n        }\n      });\n    }\n  });\n\n  const limitIxns = 20; // Maximum number of interacting genes to show\n  const ixnEntries = Object.entries(ixns);\n  const numIxns = ixnEntries.length;\n\n  let filteredIxns = {};\n  if (numIxns > limitIxns) {\n    // Only show up to 20 interacting genes,\n    // ordered by interest rank of interacting gene.\n    const ranks = Ideogram.geneCache.interestingNames.map(g => g.toLowerCase());\n    const ixnGenes = Object.keys(ixns);\n    const rankedIxnGenes = ixnGenes\n      .map(gene => {\n        let rank = 1E10; // Big number, so these rank last\n        if (ranks.includes(gene)) {\n          rank = ranks.indexOf(gene) + 1;\n        }\n        return [gene, rank];\n      })\n      .filter(([gene, _rank]) => gene in ixns)\n      .sort((a, b) => a[1] - b[1]); // Ascending gene rank order\n\n    rankedIxnGenes\n      .slice(0, limitIxns)\n      .forEach(([gene, _rank]) => filteredIxns[gene] = ixns[gene]);\n\n  } else {\n    filteredIxns = ixns;\n  }\n\n  return filteredIxns;\n}\n\n/**\n * Queries MyGene.info API, returns parsed JSON\n *\n * Docs:\n * https://docs.mygene.info/en/v3/\n *\n * Example:\n * https://mygene.info/v3/query?q=symbol:cdk2%20OR%20symbol:brca1&species=9606&fields=symbol,genomic_pos,name\n */\nasync function fetchMyGeneInfo(queryString) {\n  const myGeneBase = 'https://mygene.info/v3/query';\n  const response = await fetch(myGeneBase + queryString + '&size=400');\n  const data = await response.json();\n  return data;\n}\n\nfunction parseNameAndEnsemblIdFromMgiGene(gene) {\n  const name = gene.name;\n  const id = gene.genomic_pos.ensemblgene;\n  let ensemblId = id;\n  if (typeof id === 'undefined') {\n    // Encountered in AKT3, when querying related genes for MTOR\n    // A 'chr'omosome value containing _ indicates an alt loci scaffold,\n    // so ignore that and take the Ensembl ID associated with the\n    // first position of a primary chromosome.\n    ensemblId =\n      gene.genomic_pos.filter(pos => !pos.chr.includes('_'))[0].ensemblgene;\n  }\n  return {name, ensemblId};\n}\n\n// /**\n//  * Summarizes genes in a pathway\n//  *\n//  * This comprises most of the content for tooltips for pathway genes.\n//  */\n//  function describePathwayGene(pathwayGene, searchedGene, pathway, summary) {\n//   let ixnsDescription = '';\n\n//   const pathwaysBase = 'https://www.wikipathways.org/index.php/Pathway:';\n//   const url = `${pathwaysBase}${pathway.id}`;\n//   const attrs =\n//     `href=\"${url}\" ` +\n//     `target=\"_blank\" ` +\n//     `title=\"See pathway diagram in WikiPathways\"`;\n//   ixnsDescription =\n//     `${summary} ${searchedGene.name} in:</br/>` +\n//     `<a ${attrs}>${pathway.name}</a>`;\n\n//   const {name, ensemblId} = parseNameAndEnsemblIdFromMgiGene(pathwayGene);\n//   const type = 'pathway gene';\n//   const descriptionObj = {\n//     description: ixnsDescription,\n//     ixnsDescription, ensemblId, name, type\n//   };\n//   return descriptionObj;\n// }\n\n// /** Limit number of shown interaction links, and enable toggling full list */\n// function limitInteractionLinks(links) {\n//   if (links.length > 5) {\n//     // Seen in e.g. interacting gene AKT1 for MTOR searched gene\n//     const numMore = links.length - 5;\n//     links = links.slice(0, 5);\n//     const moreText = `${numMore} more ${pluralize('pathway', numMore)}`;\n//     const attrs = 'id=\"_ideoIxnLinkToggler\" style=\"font-style: italic\"';\n//     const toggler = `<span ${attrs}>${moreText}</span>`;\n//     links.push(`<span ${attrs}>${moreText}</span>`);\n//   }\n//   return links;\n// }\n\n// function toggleInteractionLinks() {\n//   const ixnLinkToggler = document.querySelector('._ideoIxnLinkToggler');\n// }\n\n/**\n * Summarizes interactions for a gene\n *\n * This comprises most of the content for tooltips for interacting genes.\n */\nfunction describeInteractions(gene, ixns, searchedGene) {\n  const pathwayIds = [];\n  const pathwayNames = [];\n  let ixnsDescription = '';\n\n  if (typeof ixns !== 'undefined') {\n    // ixns is undefined when querying e.g. CDKN1B in human\n    let links = ixns.map(ixn => {\n      // pathwayIds.push(ixn.pathwayId);\n      // pathwayNames.push(ixn.name);\n      // const attrs =\n      //   `class=\"ideo-pathway-link\" ` +\n      //   `title=\"Click to search for other genes in this pathway\" ` +\n      //   `style=\"cursor: pointer\" ` +\n      //   `data-pathway-id=\"${ixn.pathwayId}\" ` +\n      //   `data-pathway-name=\"${ixn.name}\"`;\n      // return `<a ${attrs}>${ixn.name}</a>`;\n\n      const pathwaysBase = 'https://classic.wikipathways.org/index.php/Pathway:';\n      const url = `${pathwaysBase}${ixn.pathwayId}`;\n      pathwayIds.push(ixn.pathwayId);\n      pathwayNames.push(ixn.name);\n      const attrs =\n        `class=\"ideo-pathway-link\" ` +\n        `style=\"cursor: pointer\" ` +\n        `title=\"View pathway diagram from WikiPathways\" ` +\n        `data-pathway-id=\"${ixn.pathwayId}\"`;\n      return `<a ${attrs}>${ixn.name}</a>`;\n    });\n\n    // links = limitInteractionLinks(links);\n\n    links = links.join('<br/>');\n\n    ixnsDescription =\n      `Interacts with ${searchedGene.name} in:<br/>${links}`;\n  }\n\n  const {name, ensemblId} = parseNameAndEnsemblIdFromMgiGene(gene);\n  const type = 'interacting gene';\n  const descriptionObj = {\n    description: ixnsDescription,\n    ixnsDescription, ensemblId, name, type, pathwayIds, pathwayNames\n  };\n  return descriptionObj;\n}\n\n/** Throw error when searched gene (e.g. \"Foo\") isn't found */\nfunction throwGeneNotFound(geneSymbol, ideo) {\n  const organism = ideo.organismScientificName;\n  throw Error(`\"${geneSymbol}\" is not a known gene in ${organism}`);\n}\n\n/**\n * Lookup genes by synonym, a.k.a. alias\n *\n * E.g. getGeneBySynonym(\"p53\", ideo) returns \"TP53\"\n */\nfunction getGeneBySynonym(name, ideo) {\n  if (!Ideogram.synonymCache) return null;\n\n  const nameLc = name.toLowerCase();\n\n  if (!Ideogram.synonymCache?.nameCaseMap) {\n    // JIT initialization of canonicalized synonym lookup data.\n    // Done only once.\n    const nameCaseMap = {};\n    for (const gene in Ideogram.synonymCache.byGene) {\n      const synonyms = Ideogram.synonymCache.byGene[gene];\n      nameCaseMap[gene.toLowerCase()] = synonyms.map(s => s.toLowerCase());\n    }\n    Ideogram.synonymCache.nameCaseMap = nameCaseMap;\n  }\n\n  const nameCaseMap = Ideogram.synonymCache.nameCaseMap;\n  for (const geneLc in nameCaseMap) {\n    const synonymsLc = nameCaseMap[geneLc];\n    if (synonymsLc.includes(nameLc)) {\n      // Got a hit!  Return standard gene symbol, e.g. \"tp53\" -> \"TP53\".\n      return Ideogram.geneCache.nameCaseMap[geneLc];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Fetch genes from cache\n * Construct objects that match format of MyGene.info API response\n */\nfunction fetchGenesFromCache(names, type, ideo) {\n  const cache = Ideogram.geneCache;\n  const isSymbol = (type === 'symbol');\n  const locusMap = isSymbol ? cache.lociByName : cache.lociById;\n  const nameMap = isSymbol ? cache.idsByName : cache.namesById;\n\n  const ensemblGeneIdRegex = /ENS[A-Z]{0,3}G\\d{11}/;\n\n  const hits = names.map(name => {\n\n    let isSynonym = false;\n    let synonym = null;\n\n    if (ensemblGeneIdRegex.test(name)) {\n      // Omit version if given Ensembl gene ID + version, e.g.\n      // ENSG00000010404.11 -> ENSG00000010404\n      name = name.split('.')[0];\n    }\n    const isIdentifier = name in cache.namesById;\n    if (isIdentifier && isSymbol) {\n      name = cache.namesById[name];\n    } else {\n      const nameLc = name.toLowerCase();\n\n      if (\n        !locusMap[name] &&\n        !cache.nameCaseMap[nameLc] &&\n        !getGeneBySynonym(name, ideo)\n      ) {\n        if (isSymbol) {\n          throwGeneNotFound(name, ideo);\n        } else {\n          return;\n        }\n      }\n\n      // Canonicalize name if it is mistaken in upstream data source.\n      // This can sometimes happen in WikiPathways, e.g. when searching\n      // interactions for rat Pten, it includes a result for \"PIK3CA\".\n      // In that case, this would correct PIK3CA to be Pik3ca.\n      if (isSymbol && !locusMap[name]) {\n        if (cache.nameCaseMap[nameLc]) {\n          name = cache.nameCaseMap[nameLc];\n        } else {\n          synonym = name;\n          name = getGeneBySynonym(synonym, ideo);\n          isSynonym = true;\n        }\n      }\n    }\n\n    const locus = locusMap[name];\n    const symbol = isSymbol ? name : nameMap[name];\n    const ensemblId = isSymbol ? nameMap[name] : name;\n    const fullName = cache.fullNamesById[ensemblId];\n\n    const hit = {\n      symbol,\n      name: fullName,\n      source: 'cache',\n      genomic_pos: {\n        chr: locus[0],\n        start: locus[1],\n        end: locus[2],\n        ensemblgene: ensemblId\n      },\n      isSynonym,\n      isIdentifier,\n      synonym\n    };\n\n    return hit;\n  });\n\n  const hitsWithGenomicPos = hits.filter(hit => hit !== undefined);\n\n  return hitsWithGenomicPos;\n}\n\n/** Wait for a certain time (delay) in milliseconds */\nfunction wait(delay) {\n  return new Promise((resolve) => setTimeout(resolve, delay));\n}\n\n/**\n * Get time to wait before retrying a fail service, gracefully\n *\n * The returned wait time helps avoid flooding the server\n */\nfunction exponentialBackoffWithJitter(numFailures, baseWaitMs) {\n  const jitter = 10 * Math.random();\n  return Math.round(baseWaitMs + jitter) * (numFailures ** 2);\n}\n\nasync function retryFetch(requestedThing, numLimit, fn, args) {\n\n  const numFailed = numFailedFetches[requestedThing];\n  if (numFailed > numLimit) {\n    const preamble = 'Failed to fetch from Ideogram third-party service for: ';\n    throw new TypeError(preamble + requestedThing);\n  }\n\n  numFailedFetches[requestedThing] += 1;\n\n  // Exponential backoff\n  const baseWaitMs = 500;\n  const waitMilliseconds = exponentialBackoffWithJitter(numFailed, baseWaitMs);\n\n  console.log(\n    `Failed fetch for ${requestedThing} ${numFailed} times, ` +\n    `retrying in ${waitMilliseconds} ms`\n  );\n\n  await wait(waitMilliseconds);\n  return await fn(...args);\n}\n\n/** Number of times fetches for various things have consecutively failed */\nconst numFailedFetches = {\n  genes: 0\n};\n\n/** Fetch genes from cache, or, if needed, from MyGene.info API */\nasync function fetchGenes(names, type, ideo) {\n\n  let data;\n\n  // Account for single-gene fetch\n  if (typeof names === 'string') names = [names];\n\n  // Query parameter for MyGene.info API\n  const qParam = names.map(name => `${type}:${name.trim()}`).join(' OR ');\n  const taxid = ideo.config.taxid;\n\n  const queryStringBase = `?q=${qParam}&species=${taxid}&fields=`;\n\n  if (Ideogram.geneCache) {\n    const hits = fetchGenesFromCache(names, type, ideo);\n\n    // Asynchronously fetch full name, but don't await the response, because\n    // full names are only shown upon hovering over an annotation.\n    hits.forEach((hit) => {\n      const symbol = hit.symbol;\n      const fullName = hit.name;\n      const isSynonym = hit.isSynonym;\n      const synonym = hit.synonym;\n      if (symbol in ideo.annotDescriptions.annots) {\n        ideo.annotDescriptions.annots[symbol].name = fullName;\n        ideo.annotDescriptions.annots[symbol].isSynonym = hit.isSynonym;\n        ideo.annotDescriptions.annots[symbol].synonym = hit.synonym;\n      } else {\n        ideo.annotDescriptions.annots[symbol] = {\n          name: fullName,\n          isSynonym,\n          synonym\n        };\n      }\n    });\n\n    data = {hits, fromGeneCache: true};\n  } else {\n    // Fetch gene data from MyGene.info\n    const queryString = `${queryStringBase}symbol,genomic_pos,name`;\n    try {\n      data = await fetchMyGeneInfo(queryString);\n    } catch (error) {\n      const isFailedFetch = (error.message === 'Failed to fetch');\n      if (isFailedFetch && navigator.onLine) {\n        // Retry fetching 3 times, waiting longer each time\n        data = await retryFetch('genes', 3, fetchGenes, [names, type, ideo]);\n      }\n    }\n  }\n\n  return data;\n}\n\n/**\n * Retrieves position and other data on interacting genes from MyGene.info\n */\nasync function fetchInteractionAnnots(interactions, searchedGene, ideo) {\n\n  const annots = [];\n  const symbols = Object.keys(interactions);\n\n  if (symbols.length === 0) return annots;\n\n  const data = await fetchGenes(symbols, 'symbol', ideo);\n\n  data.hits.forEach(gene => {\n    // If hit lacks position\n    // or is same as searched gene (e.g. search for human SRC),\n    // then skip processing\n    if (\n      'genomic_pos' in gene === false ||\n      gene.symbol === searchedGene.name\n    ) {\n      return;\n    }\n\n    const annot = parseAnnotFromMgiGene(gene, ideo, 'purple');\n    annots.push(annot);\n\n    const ixns = interactions[gene.symbol.toLowerCase()];\n\n    const descriptionObj = describeInteractions(gene, ixns, searchedGene);\n\n    mergeDescriptions(annot, descriptionObj, ideo);\n  });\n\n  // Fetch GPML files to use when updating interaction descriptions with\n  // refined direction.\n  fetchGpmls(ideo);\n\n  return annots;\n}\n\n/** Fetch paralog positions from MyGeneInfo */\nasync function fetchParalogPositionsFromMyGeneInfo(\n  homologs, searchedGene, ideo\n) {\n  const annots = [];\n\n  const cached = homologs.length && typeof homologs[0] === 'string';\n  console.log('cached', cached)\n  const ensemblIds = cached ? homologs : homologs.map(homolog => homolog.id);\n  const data = await fetchGenes(ensemblIds, 'ensemblgene', ideo);\n\n  data.hits.forEach(gene => {\n\n    // If hit lacks position, skip processing\n    if ('genomic_pos' in gene === false) return;\n    if ('name' in gene === false) return;\n\n    const annot = parseAnnotFromMgiGene(gene, ideo, 'pink');\n    annots.push(annot);\n\n    const description =\n      Ideogram.tissueCache ? '' : `Paralog of ${searchedGene.name}`;\n\n    const {name, ensemblId} = parseNameAndEnsemblIdFromMgiGene(gene);\n    const type = 'paralogous gene';\n    const descriptionObj = {description, ensemblId, name, type};\n    mergeDescriptions(annot, descriptionObj, ideo);\n  });\n\n  return annots;\n}\n\nfunction drawNeighborhoods(neighborhoodAnnots, ideo) {\n  neighborhoodAnnots = applyAnnotsIncludeList(neighborhoodAnnots, ideo);\n  ideo.drawAnnots(neighborhoodAnnots, 'overlay', true, true);\n  moveLegend(ideo);\n}\n\n/** Plot paralog neighborhoods */\nfunction plotParalogNeighborhoods(annots, ideo) {\n  if (!ideo.config.showParalogNeighborhoods) return;\n\n  if (ideo.neighborhoodAnnots?.length > 0) {\n    ideo.neighborhoodAnnots.forEach(annot => {\n      ideo.annotDescriptions.annots[annot.name] = annot;\n    });\n\n    drawNeighborhoods(ideo.neighborhoodAnnots, ideo);\n    return;\n  }\n\n  const searchedAnnot = ideo.relatedAnnots[0];\n  annots = applyAnnotsIncludeList(annots, ideo);\n\n  annots.unshift(searchedAnnot);\n\n  if (annots.length < 2) return;\n\n  // Arrays of paralogs within 10 Mbp of each other\n  const neighborhoods = {};\n\n  neighborhoods[annots[0].chr] = {};\n  neighborhoods[annots[0].chr][annots[0].start] = [annots[0]];\n\n  const windowInt = 2_000_000;\n  const windowProse = '2 Mbp';\n\n  for (let i = 1; i < annots.length; i++) {\n    const annot = annots[i];\n    const chr = annot.chr;\n    const start = annot.start;\n    if (chr in neighborhoods) {\n      const starts = Object.keys(neighborhoods[chr]);\n      for (let j = 0; j < starts.length; j++) {\n        const startJInt = parseInt(starts[j]);\n        if (Math.abs(start - startJInt) < windowInt) {\n          neighborhoods[chr][startJInt].push(annot);\n        } else {\n          neighborhoods[chr][start] = [annot];\n        }\n      }\n    } else {\n      neighborhoods[chr] = {};\n      neighborhoods[chr][start] = [annot];\n    }\n  }\n\n  // Big enough to see and hover\n  const overlayAnnotLength = 15_000_000;\n\n  const searchedGene = searchedAnnot.name;\n\n  const neighborhoodAnnots =\n    Object.entries(neighborhoods).map(([chr, neighborhood], index) => {\n      const start = parseInt(Object.keys(neighborhood)[0]);\n      let paralogs = Object.values(neighborhood)[0];\n\n      if (paralogs.length < 2) {\n        return {paralogs};\n      }\n\n      let includesSearched = false;\n      if (paralogs[0].name === searchedAnnot.name) {\n        paralogs = paralogs.slice(1);\n        includesSearched = true;\n      }\n\n      // paralogs.map(paralog => {\n      //   console.log(paralog);\n      // })\n\n      const paralogsText = pluralize('paralog', paralogs.length)\n      const description =\n        `${paralogs.length} nearby ${paralogsText} of ${searchedGene}`;\n\n      const chrLength = ideo.chromosomes[ideo.config.taxid][chr].bpLength;\n      let annotStart = start - overlayAnnotLength/2;\n      let annotStop = start + overlayAnnotLength/2;\n      if (annotStop > chrLength) {\n        annotStart = start - overlayAnnotLength;\n        annotStop = chrLength;\n      } else if (annotStart < 1) {\n        annotStart = 1;\n        annotStop = overlayAnnotLength;\n      };\n\n      if ('geneCache' in Ideogram) {\n        paralogs = paralogs.map(paralog => {\n          paralog.fullName = Ideogram.geneCache.fullNamesById[paralog.id];\n\n          const ranks = Ideogram.geneCache.interestingNames;\n          if (ranks.includes(paralog.name)) {\n            paralog.rank = ranks.indexOf(paralog.name) + 1;\n          } else {\n            paralog.rank = 1E10;\n          }\n\n          return paralog;\n        });\n      }\n\n      const key = 'paralogNeighborhood-' + index;\n      const fStart = start.toLocaleString(); // Format for readability\n      const displayCoordinates = `chr${chr}:${fStart}  ${windowProse}`;\n\n      const annot = {\n        name: key,\n        chr,\n        start: annotStart,\n        stop: annotStop,\n        color: 'pink',\n        description,\n        paralogs,\n        type: 'paralog neighborhood',\n        displayCoordinates,\n        includesSearched\n      };\n\n      ideo.annotDescriptions.annots[annot.name] = annot;\n      return annot;\n    }).filter(n => n.paralogs.length > 1 || n.includesSearched);\n\n  ideo.neighborhoodAnnots = neighborhoodAnnots;\n\n  if (neighborhoodAnnots.length > 0) {\n    drawNeighborhoods(neighborhoodAnnots, ideo);\n  }\n}\n\n/**\n * Fetch paralogs of searched gene\n */\nasync function fetchParalogs(annot, ideo) {\n  const taxid = ideo.config.taxid;\n\n  let homologs;\n  // Fetch paralogs\n  if (Ideogram.paralogCache) {\n    // const baseUrl = 'http://localhost:8080/dist/data/cache/paralogs/';\n    // const url = `${baseUrl}homo-sapiens/${annot.name}.tsv`;\n    // const response = await fetch(url);\n    // const oneRowTsv = await response.text();\n    // const rawHomologEnsemblIds = oneRowTsv.split('\\t');\n    // homologs = rawHomologEnsemblIds.map(r => getEnsemblId('ENSG', r));\n    const paralogsByName = Ideogram.paralogCache.paralogsByName;\n    const nameUc = annot.name.toUpperCase();\n    const hasParalogs = nameUc in paralogsByName;\n    homologs = hasParalogs ? paralogsByName[nameUc] : [];\n  } else {\n    const params = `&format=condensed&type=paralogues&target_taxon=${taxid}`;\n    const organismUnderscore = ideo.config.organism.replace('-', '_');\n    const path = `/homology/id/${organismUnderscore}/${annot.id}?${params}`;\n    const ensemblHomologs = await Ideogram.fetchEnsembl(path);\n    homologs = ensemblHomologs.data[0].homologies;\n  }\n\n  // Fetch positions of paralogs\n  let annots =\n    await fetchParalogPositionsFromMyGeneInfo(homologs, annot, ideo);\n\n  // Omit genes named like \"AC113554.1\", which is an \"accession.version\".\n  // Such accVers are raw and poorly suited here.\n  annots = annots.filter(annot => {\n    const isAccVer = annot.name.match(/^AC[0-9.]+$/);\n    return !isAccVer;\n  });\n\n  return annots;\n}\n\n/**\n * Filters out placements on alternative loci scaffolds, an advanced\n * genome assembly feature we are not concerned with in ideograms.\n *\n * Example:\n * https://mygene.info/v3/query?q=symbol:PTPRC&species=9606&fields=symbol,genomic_pos,name\n */\nfunction getGenomicPos(gene, ideo) {\n  let genomicPos = null;\n  if (Array.isArray(gene.genomic_pos)) {\n    genomicPos = gene.genomic_pos.filter(pos => {\n      return pos.chr in ideo.chromosomes[ideo.config.taxid];\n    })[0];\n  } else {\n    genomicPos = gene.genomic_pos;\n  }\n  return genomicPos;\n}\n\n/**\n * Transforms MyGene.info (MGI) gene into Ideogram annotation\n */\nfunction parseAnnotFromMgiGene(gene, ideo, color='red') {\n  const genomicPos = getGenomicPos(gene, ideo);\n\n  const annot = {\n    name: gene.symbol,\n    chr: genomicPos.chr,\n    start: genomicPos.start,\n    stop: genomicPos.end,\n    id: genomicPos.ensemblgene,\n    color\n  };\n\n  return annot;\n}\n\n/** Return type (interacting, paralogous, or searched) of legend entry */\nfunction getLegendType(li) {\n  const lcText = li.innerText.toLowerCase();\n\n  let type;\n  if (lcText.includes('interacting')) type = 'interacting';\n  if (lcText.includes('paralogous')) type = 'paralogous';\n  if (lcText.includes('searched')) type = 'searched';\n\n  return type;\n}\n\n/** Return color (purple, pink, or red) of legend entry */\nfunction getLegendEntryColor(li) {\n  const type = getLegendType(li);\n\n  const colorMap = {\n    'interacting': 'purple',\n    'paralogous': 'pink',\n    'searched': 'red'\n  };\n  const color = colorMap[type];\n\n  return color;\n}\n\n/** Highlight / filter upon hovering over legend entry */\nfunction highlightByType(li, ideo) {\n  li.classList += ' active';\n\n  const selectedColor = getLegendEntryColor(li);\n\n  if (ideo.config.showAnnotLabels) {\n    ideo.clearAnnotLabels();\n\n    ideo.flattenAnnots().forEach(annot => {\n      if (annot.color !== selectedColor) {\n        document.getElementById(annot.domId).style.display = 'none';\n      }\n    });\n\n    const sortedAnnots = ideo.flattenAnnots().sort((a, b) => {\n      return ideo.annotSortFunction(a, b);\n    }).filter(annot => annot.color === selectedColor);\n\n    const numLabels = Math.min(sortedAnnots.length, 20);\n    ideo.fillAnnotLabels(sortedAnnots, numLabels);\n  }\n}\n\n/** Remove highlight / filter upon hovering out of legend entry */\nfunction dehighlightAll(ideo) {\n  document.querySelectorAll('#_ideogramLegend li').forEach(li => {\n    li.classList.remove('active');\n  });\n\n  ideo.flattenAnnots().forEach(annot => {\n    document.getElementById(annot.domId).style.display = null;\n  });\n\n  if (ideo.config.showAnnotLabels) {\n    const sortedAnnots = ideo.flattenAnnots().sort((a, b) => {\n      return ideo.annotSortFunction(a, b);\n    });\n\n    ideo.fillAnnotLabels(sortedAnnots);\n  }\n}\n\nfunction initInteractiveLegend(ideo) {\n  // Highlight and filter annotations by type on hovering over legend entries\n  function highlight(event) {\n    const li = event.target;\n    highlightByType(li, ideo);\n    if (ideo.onHoverLegendCallback) {\n      ideo.onHoverLegendCallback();\n    }\n  }\n  // // Highlight and filter annotations by type on hovering over legend entries\n  // WIP: 14373b18319e99febd91816fbc0c1b2e0f20f277\n  // function toggleHighlight(event) {\n  //   const li = event.target;\n  //   return toggleHighlightByType(li, ideo);\n  // }\n  function dehighlight() {\n    dehighlightAll(ideo);\n  }\n  const entrySelector = '#_ideogramLegend li._ideoLegendEntry';\n  document.querySelectorAll(entrySelector).forEach(li => {\n    // li.addEventListener('click', toggleHighlight);\n    // WIP: 14373b18319e99febd91816fbc0c1b2e0f20f277\n    li.addEventListener('mouseenter', highlight);\n    li.addEventListener('mouseleave', dehighlight);\n\n    const legendType = getLegendType(li);\n    const tippyContentMap = {\n      'interacting':\n        'Adjacent to searched gene in a biochemical pathway, ' +\n        'per WikiPathways',\n      'paralogous':\n        'Evolutionarily related to searched gene ' +\n        'by a duplication event, per Ensembl'\n    };\n    // const placement = 'data-tippy-placement=\"top-end\"';\n    const placement = '';\n    const tippy =\n      `data-tippy-content=\"${tippyContentMap[legendType]}\" ${placement}`;\n    const reset = 'position: inherit; left: inherit';\n    // const glossary = 'text-decoration: underline dashed;';\n    // const style = `style=\"${glossary} ${reset}`;\n    const style = `style=\"${reset}\"`;\n    const attrs = `class=\"_ideoLegendEntry\" ${style} ${tippy}`;\n    if (legendType === 'paralogous') {\n      li.innerHTML = `<span ${attrs}>Paralogous genes</span>`;\n    } else if (legendType === 'interacting') {\n      li.innerHTML = `<span ${attrs}>Interacting genes</span>`;\n    }\n  });\n\n  const css =\n    `<style>\n    ${tippyCss}\n\n    .tippy-box {\n      font-size: 12px;\n    }\n\n    .tippy-content {\n      padding: 3px 7px;\n    }\n\n    #_ideogramLegend li {\n      padding-left: 5px;\n      border-radius: 2px;\n    }\n\n    #_ideogramLegend li.active {\n      color: #00C;\n      background-color: #EEF;\n    }\n    </style>`;\n  const legendDom = document.querySelector('#_ideogramLegend');\n  legendDom.insertAdjacentHTML('afterBegin', css);\n  const tippyConfig = getTippyConfig();\n  tippyConfig.maxWidth = 180;\n  tippyConfig.offset = [-30, 10];\n  ideo.legendTippy =\n    tippy('._ideoLegendEntry[data-tippy-content]', tippyConfig);\n}\n\nfunction moveLegend(ideo, extraPad=0) {\n  const ideoInnerDom = document.querySelector('#_ideogramInnerWrap');\n  const decorPad = setRelatedDecorPad({}).legendPad;\n  const left = decorPad + 20 + extraPad;\n  const legendStyle = `position: absolute; top: 15px; left: ${left}px`;\n\n  const legend = document.querySelector('#_ideogramLegend');\n  ideoInnerDom.prepend(legend);\n  legend.style = legendStyle;\n\n  initInteractiveLegend(ideo);\n}\n\n/**\n * Filter annotations to only include those in configured list\n *\n * @return {List<Object>} includedAnnots List of filtered annots objects\n */\nfunction applyAnnotsIncludeList(annots, ideo) {\n  if (ideo.config.annotsInList === 'all') return annots;\n\n  const includedAnnots = [];\n  annots.forEach(annot => {\n    if (ideo.config.annotsInList.includes(annot.name.toLowerCase())) {\n      includedAnnots.push(annot);\n    }\n  });\n  return includedAnnots;\n}\n\nfunction filterByAnnotsIncludeList(annots, ideo) {\n  if (ideo.config.annotsInList === 'all') return annots;\n\n  const annotsInList = ideo.config.annotsInList;\n\n  const updated = [];\n  const updatedAnnots = {};\n  ideo.annots.forEach(chrAnnots => {\n    const {chr, annots} = chrAnnots;\n    updatedAnnots[chr] = {chr, annots: []};\n    annots.forEach((annot) => {\n\n      const lcAnnotName = annot.name.toLowerCase();\n      if (\n        'relatedAnnots' in ideo &&\n        !annotsInList.includes(lcAnnotName)\n      ) {\n        return;\n      }\n\n      updatedAnnots[chr].annots.push(annot);\n    });\n    updated.push(updatedAnnots[chr]);\n  });\n  return updated;\n}\n\n/** Fetch and draw interacting genes, return Promise for annots */\nfunction processInteractions(annot, ideo) {\n  return new Promise(async (resolve) => {\n    const t0 = performance.now();\n\n    const interactions = await fetchInteractions(annot, ideo);\n    const annots = await fetchInteractionAnnots(interactions, annot, ideo);\n\n    ideo.relatedAnnots.push(...annots);\n    finishPlotRelatedGenes('interacting', ideo);\n\n    ideo.time.rg.interactions = timeDiff(t0);\n    plotParalogNeighborhoods(annots, ideo);\n\n    resolve();\n  });\n}\n\n/** Find and draw paralogs, return Promise for annots */\nfunction processParalogs(annot, ideo) {\n  return new Promise(async (resolve) => {\n    const t0 = performance.now();\n\n    const annots = await fetchParalogs(annot, ideo);\n    ideo.relatedAnnots.push(...annots);\n    finishPlotRelatedGenes('paralogous', ideo);\n    plotParalogNeighborhoods(annots, ideo);\n\n    ideo.time.rg.paralogs = timeDiff(t0);\n\n    resolve();\n  });\n}\n\n// /**\n//  * Sorts gene names consistently.\n//  *\n//  * Might also loosely rank by first-discovered or most prominent\n//  */\n// function sortGeneNames(aName, bName) {\n//   // Rank shorter names above longer names\n//   if (bName.length !== aName.length) return bName.length - aName.length;\n\n//   // Rank names of equal length alphabetically\n//   return [aName, bName].sort().indexOf(aName) === 0 ? 1 : -1;\n// }\n\n/** Sorts by relevance of related type, then rank */\nexport function sortByRelatedType(a, b) {\n  var aName, bName, aColor, bColor;\n  if ('name' in a) {\n    // Locally processed annotations\n    aName = a.name;\n    bName = b.name;\n    aColor = a.color;\n    bColor = b.color;\n  } else {\n    // Raw annotations\n    [aName, aColor] = [a[0], a[3]];\n    [bName, bColor] = [b[0], b[3]];\n  }\n\n  if ('initRank' in a === false) {\n    // Rank red (searched gene) highest\n    if (aColor === 'red') return -1;\n    if (bColor === 'red') return 1;\n\n    // Rank purple (interacting gene) above pink (paralogous gene)\n    if (aColor === 'purple' && bColor === 'pink') return -1;\n    if (bColor === 'purple' && aColor === 'pink') return 1;\n  }\n\n  return a.rank - b.rank;\n\n  // return sortGeneNames(aName, bName);\n}\n\nfunction mergeDescriptions(annot, desc, ideo) {\n  let mergedDesc;\n  const descriptions = ideo.annotDescriptions.annots;\n\n  if (annot.name in descriptions) {\n    const otherDesc = descriptions[annot.name];\n    mergedDesc = desc;\n    if (desc.type === otherDesc.type) return;\n    Object.keys(otherDesc).forEach(function(key) {\n      if (key in mergedDesc === false) {\n        mergedDesc[key] = otherDesc[key];\n      }\n    });\n    // Object.assign({}, descriptions[annot.name]);\n    if ('type' in otherDesc && !Ideogram.tissueCache) {\n      mergedDesc.type += ', ' + otherDesc.type;\n      mergedDesc.description += `<br/><br/>${otherDesc.description}`;\n    }\n  } else {\n    mergedDesc = desc;\n  }\n\n  ideo.annotDescriptions.annots[annot.name] = mergedDesc;\n}\n\n/** Combines paralogs and interacting gene, if name matches */\nfunction mergeAnnots(unmergedAnnots) {\n  const seenAnnots = {};\n  let mergedAnnots = [];\n\n  unmergedAnnots.forEach((annot) => {\n    if (annot.name in seenAnnots === false) {\n      mergedAnnots.push(annot);\n      seenAnnots[annot.name] = 1;\n    } else {\n      if (annot.color === 'purple') {\n        mergedAnnots = mergedAnnots.map((mergedAnnot) => {\n          return (annot.name === mergedAnnot.name) ? annot : mergedAnnot;\n        });\n      }\n    }\n  });\n\n  return mergedAnnots;\n}\n\nfunction hasTissueCache() {\n  return Ideogram.tissueCache && Object.keys(Ideogram.tissueCache).length > 0;\n}\n\n/**\n * Prevents bug when showing gene leads instantly on page load,\n * then hovering over an annotation, as in e.g.\n * https://eweitz.github.io/ideogram/gene-leads\n */\nfunction waitForTissueCache(geneNames, config, n) {\n  setTimeout(() => {\n    if (n < 40) { // 40 * 50 ms = 2 s\n      if (!hasTissueCache()) {\n        waitForTissueCache(geneNames, config, n + 1);\n      } else {\n        setTissueExpressions(geneNames, config);\n      }\n    }\n  }, 50);\n}\n\nasync function setTissueExpressions(geneNames, config) {\n  if (\n    !hasTissueCache()\n    // || !(annot.name in Ideogram.tissueCache.byteRangesByName)\n  ) {\n    waitForTissueCache(geneNames, config, 0);\n    return;\n  }\n\n  const tissueExpressionsByGene = {};\n  const cache = Ideogram.tissueCache;\n\n  const promises = [];\n  geneNames.forEach(async gene => {\n    const promise = new Promise(async (resolve) => {\n      const tissueExpressions = await cache.getTissueExpressions(gene, config);\n      tissueExpressionsByGene[gene] = tissueExpressions;\n      resolve();\n    });\n    promises.push(promise);\n  });\n\n  await Promise.all(promises);\n\n  Ideogram.tissueExpressionsByGene = tissueExpressionsByGene;\n}\n\nfunction onBeforeDrawAnnots() {\n  const ideo = this;\n  setRelatedAnnotDomIds(ideo);\n\n  const geneNames = [];\n\n  // Handle differential expression extension\n  const chrAnnots = ideo.annots;\n  for (let i = 0; i < chrAnnots.length; i++) {\n    const annots = chrAnnots[i].annots;\n\n    for (let j = 0; j < annots.length; j++) {\n      const annot = annots[j];\n\n      geneNames.push(annot.name);\n\n      if (ideo.config.colorMap && annot.differentialExpression?.length) {\n        const colorMap = ideo.config.colorMap;\n        const group = annot.differentialExpression[0].group;\n        annot.color = colorMap[group];\n        ideo.annots[i].annots[j] = annot;\n      }\n    }\n  }\n\n  setTissueExpressions(geneNames, ideo.config);\n}\n\nfunction filterAndDrawAnnots(annots, ideo) {\n  annots = applyAnnotsIncludeList(annots, ideo);\n  ideo.drawAnnots(annots);\n}\n\n/** Filter, sort, draw annots.  Move legend. */\nfunction finishPlotRelatedGenes(type, ideo) {\n\n  let annots = ideo.relatedAnnots;\n\n  if (annots.length > 1 && ideo.onFindGenesCallback) {\n    ideo.onFindGenesCallback();\n  }\n\n  annots = mergeAnnots(annots);\n\n  filterAndDrawAnnots(annots, ideo);\n\n  if (ideo.config.showAnnotLabels) {\n    const sortedAnnots = ideo.flattenAnnots().sort((a, b) => {\n      return ideo.annotSortFunction(a, b);\n    });\n    ideo.fillAnnotLabels(sortedAnnots);\n  }\n\n  moveLegend(ideo);\n\n  analyzePlotTimes(type, ideo);\n}\n\n/** Fetch position of searched gene, return corresponding annotation */\nasync function processSearchedGene(geneSymbol, ideo) {\n  const t0 = performance.now();\n\n  const data = await fetchGenes(geneSymbol, 'symbol', ideo);\n\n  if (data.hits.length === 0) {\n    return;\n  }\n  const gene = data.hits.find(hit => {\n    const genomicPos = getGenomicPos(hit, ideo); // omits alt loci\n    return genomicPos && genomicPos.ensemblgene;\n  });\n  const ensemblId = gene.genomic_pos.ensemblgene;\n\n  // Assign tooltip content.  Much of the content is often retrieved from\n  // the gene cache.  In that case, all fields except `name` are fetched\n  // from cache.  Occasionally, e.g. often upon the very first search, no\n  // content is yet available from cache.\n  let desc = {description: '', ensemblId, type: 'searched gene'};\n  if (gene.symbol in ideo.annotDescriptions.annots) {\n    // Most content already set via cache.\n    // `name` will be set via non-blocking part of `fetchGenes`.\n    const oldDesc = ideo.annotDescriptions.annots[gene.symbol];\n    desc = Object.assign(oldDesc, desc);\n  } else {\n    // No content has been set yet via cache.  In this case, `gene` already\n    // has all the data needed for the searched gene's tooltip content.\n    desc.name = gene.name;\n  }\n\n  ideo.annotDescriptions.annots[gene.symbol] = desc;\n\n  const annot = parseAnnotFromMgiGene(gene, ideo);\n\n  ideo.relatedAnnots.push(annot);\n\n  ideo.time.rg.searchedGene = timeDiff(t0);\n\n  return annot;\n}\n\nfunction adjustPlaceAndVisibility(ideo) {\n  var ideoContainerDom = document.querySelector(ideo.config.container);\n\n  ideoContainerDom.style.visibility = '';\n  ideoContainerDom.style.position = 'absolute';\n  ideoContainerDom.style.width = '100%';\n\n  var ideoInnerDom = document.querySelector('#_ideogramInnerWrap');\n  ideoInnerDom.style.position = 'relative';\n  ideoInnerDom.style.marginLeft = 'auto';\n  ideoInnerDom.style.marginRight = 'auto';\n  ideoInnerDom.style.overflowY = 'hidden';\n  document.querySelector('#_ideogramMiddleWrap').style.overflowY = 'hidden';\n\n  const legendPad = ideo.config.legendPad;\n\n  if (typeof ideo.didAdjustIdeogramLegend === 'undefined') {\n    // Accounts for moving legend when external content at left or right\n    // is variable upon first rendering plotted genes\n\n    var ideoDom = document.querySelector('#_ideogram');\n    const legendWidth = 160;\n    ideoInnerDom.style.maxWidth =\n      (\n        parseInt(ideoInnerDom.style.maxWidth) +\n        legendWidth +\n        legendPad\n      ) + 'px';\n\n    ideoDom.style.minWidth =\n      (parseInt(ideoDom.style.minWidth) + legendPad) + 'px';\n    ideoDom.style.maxWidth =\n      (parseInt(ideoDom.style.minWidth) + legendPad) + 'px';\n    ideoDom.style.position = 'relative';\n    ideoDom.style.left = legendWidth + 'px';\n\n    ideo.didAdjustIdeogramLegend = true;\n  }\n}\n\n// function sortByPathwayIxn(a, b) {\n//   const aColor = a.color;\n//   const bColor = b.color;\n\n//   // Rank red (searched gene) highest\n//   if (aColor === 'red') return -1;\n//   if (bColor === 'red') return 1;\n\n//   // Rank not grey above grey\n//   if (aColor === 'grey' && bColor !== 'grey') return 1;\n//   if (bColor === 'grey' && aColor !== 'grey') return -1;\n\n//   return a.rank - b.rank;\n// }\n\n// async function fetchPathwayGeneAnnots(searchedGene, pathway, ideo) {\n//   const annots = [];\n\n//   const pathwayIxns =\n//     await fetchPathwayInteractions(searchedGene.name, pathway.id, ideo);\n\n//   const pathwayGenes = Object.keys(pathwayIxns);\n//   const data = await fetchGenes(pathwayGenes, 'symbol', ideo);\n\n//   const ixnColors = {\n//     'Stimulates': 'green',\n//     'Stimulated by': 'green',\n//     'Necessarily stimulates': 'green',\n//     'Necessarily stimulated by': 'green',\n//     'Transcribes / translates': 'brown',\n//     'Transcribed / translated by': 'brown',\n//     'Inhibits': 'red',\n//     'Inhibited by': 'red',\n//     'Modifies': 'blue',\n//     'Modified by': 'blue',\n//     'Acts on': 'blue',\n//     'Acted on by': 'blue',\n//     'Catalyzes': 'orange',\n//     'Catalyzed by': 'orange',\n//     'Converts': 'orange',\n//     'Converted by': 'orange',\n//     'Binds': 'black',\n//     'Shares pathway with': 'grey'\n//   };\n\n//   data.hits.forEach(gene => {\n//     // If hit lacks position\n//     // or is same as searched gene (e.g. search for human SRC),\n//     // then skip processing\n//     if (\n//       'genomic_pos' in gene === false ||\n//       gene.symbol === searchedGene.name\n//     ) {\n//       return;\n//     }\n\n//     // Account for edge case: cyclic AMP (cAMP) is not \"CAMP\" gene\n//     if (gene.symbol === 'cAMP') return;\n\n//     const summary = pathwayIxns[gene.symbol];\n//     const color = ixnColors[summary];\n//     // if (color !== 'blue') console.log(gene);\n\n//     const annot = parseAnnotFromMgiGene(gene, ideo, color);\n//     annots.push(annot);\n\n//     const descriptionObj =\n//       describePathwayGene(gene, searchedGene, pathway, summary);\n\n//     mergeDescriptions(annot, descriptionObj, ideo);\n//   });\n\n//   ideo.annotSortFunction = sortByPathwayIxn;\n\n//   const sortedAnnots = annots.sort(sortByPathwayIxn).slice(0, 40);\n\n//   return sortedAnnots;\n// }\n\n// /**\n//  *\n//  */\n// async function plotPathwayGenes(searchedGene, pathway, ideo) {\n//   const headerTitle = 'Genes in pathway';\n//   initAnnotDescriptions(ideo, headerTitle);\n\n//   legendPathwayName = pathway.name;\n//   ideo.config.legend = pathwayLegend;\n//   writeLegend(ideo);\n//   moveLegend(ideo);\n\n//   ideo.relatedAnnots = [];\n\n//   await processSearchedGene(searchedGene.name, ideo);\n\n//   const annots = await fetchPathwayGeneAnnots(searchedGene, pathway, ideo);\n//   ideo.relatedAnnots.push(...annots);\n//   finishPlotRelatedGenes('pathway', ideo);\n// }\n\nfunction initAnnotDescriptions(ideo, headerTitle) {\n  const organism = ideo.getScientificName(ideo.config.taxid);\n  const version = Ideogram.version;\n  const headers = [\n    `# ${headerTitle}`,\n    `# Organism: ${organism}`,\n    `# Generated by Ideogram.js version ${version}, https://github.com/eweitz/ideogram`,\n    `# Generated at ${window.location.href}`\n  ].join('\\n');\n\n  delete ideo.annotDescriptions;\n  ideo.annotDescriptions = {headers, annots: {}};\n\n}\n\n/**\n * For given gene, finds and draws interacting genes and paralogs\n *\n * @param geneSymbol {String} Gene symbol, e.g. RAD51\n */\nasync function plotRelatedGenes(geneSymbol=null) {\n\n  const ideo = this;\n\n  if (!geneSymbol) {\n    return plotGeneHints(ideo);\n  }\n\n  ideo.clearAnnotLabels();\n  const legend = document.querySelector('#_ideogramLegend');\n  if (legend) legend.remove();\n\n  ideo.config = setRelatedDecorPad(ideo.config);\n\n  initAnnotDescriptions(ideo, `Related genes for ${geneSymbol}`);\n\n  const ideoSel = ideo.selector;\n  const annotSel = ideoSel + ' .annot';\n  document.querySelectorAll(annotSel).forEach(el => el.remove());\n\n  ideo.startHideAnnotTooltipTimeout();\n\n  // Refine style\n  document.querySelectorAll('.chromosome').forEach(chromosome => {\n    chromosome.style.cursor = '';\n  });\n\n  adjustPlaceAndVisibility(ideo);\n\n  ideo.relatedAnnots = [];\n  ideo.neighborhoodAnnots = [];\n\n  // Fetch positon of searched gene\n  const annot = await processSearchedGene(geneSymbol, ideo);\n\n  if (typeof annot === 'undefined') throwGeneNotFound(geneSymbol, ideo);\n\n  ideo.config.legend = relatedLegend;\n  writeLegend(ideo);\n  moveLegend(ideo);\n\n  await Promise.all([\n    processInteractions(annot, ideo),\n    processParalogs(annot, ideo)\n  ]);\n\n  ideo.time.rg.total = timeDiff(ideo.time.rg.t0);\n\n  analyzeRelatedGenes(ideo);\n\n  if (ideo.onPlotFoundGenesCallback) ideo.onPlotFoundGenesCallback();\n}\n\nfunction getAnnotByName(annotName, ideo) {\n  var annotByName;\n  ideo.annots.forEach(annotsByChr => {\n    annotsByChr.annots.forEach(annot => {\n      if (annotName === annot.name) {\n        annotByName = annot;\n      }\n    });\n  });\n\n  if (annotByName === null) {\n    annotByName = ideo.annotDescriptions.annots[annotName];\n  }\n  return annotByName;\n}\n\n/**\n * Manage click on pathway links in annotation tooltips\n */\nfunction addPathwayListeners(ideo) {\n  const pathways = document.querySelectorAll('.ideo-pathway-link');\n  if (pathways.length > 0 && !ideo.addedPathwayClickHandler) {\n    pathways.forEach(pathway => {\n      // pathway.removeEventListener('click', handlePathwayClick);\n      pathway.addEventListener('click', function(event) {\n        const target = event.target;\n        const pathwayId = target.getAttribute('data-pathway-id');\n\n        const searchedGene = getSearchedFromDescriptions(ideo);\n        const interactingGene =\n          document.querySelector('#ideo-related-gene').textContent;\n        // const pathwayName = target.getAttribute('data-pathway-name');\n        // const pathway = {id: pathwayId, name: pathwayName};\n        // plotPathwayGenes(searchedGene, pathway, ideo);\n        function geneNodeHoverFn(event, geneName) {\n          console.log('in geneNodeHoverFn')\n          return '<div>ok ' + geneName + '</div><div>1234</div>';\n        }\n\n        function pathwayNodeClickFn(event, pathwayId) {\n          const pathwayNode = event.target;\n          console.log('in pathwayNodeClickFn, pathwayNode', pathwayNode);\n          console.log('in pathwayNodeClickFn, pathwayId', pathwayId);\n        }\n\n        drawPathway(pathwayId, searchedGene, interactingGene,\n          undefined, undefined, undefined,\n          geneNodeHoverFn, pathwayNodeClickFn);\n        event.stopPropagation();\n      });\n    });\n  }\n}\n\n/** Move tooltip mass to vertical center of viewport */\nfunction centralizeTooltipPosition() {\n  const tooltip = document.querySelector('._ideogramTooltip');\n  const tooltipTop = tooltip.getBoundingClientRect().top;\n  const ideoDom = document.querySelector('#_ideogram');\n  const ideogramTop = ideoDom.getBoundingClientRect().top;\n  if (tooltipTop > ideogramTop) {\n    tooltip.style.top = ideogramTop + 'px';\n  }\n}\n\nfunction onDidShowAnnotTooltip() {\n  const ideo = this;\n  if (Ideogram.tissueCache) {\n    centralizeTooltipPosition();\n  }\n  handleTooltipClick(ideo);\n  addGeneStructureListeners(ideo);\n  addTissueListeners(ideo);\n  addPathwayListeners(ideo);\n  addVariantListeners(ideo);\n  ideo.tissueTippy =\n    tippy('._ideoGeneTissues[data-tippy-content]', getTippyConfig());\n}\n\n/**\n * Handles click within annotation tooltip\n *\n * Makes clicking link in tooltip behave same as clicking annotation\n */\nexport function handleTooltipClick(ideo) {\n  // const tooltip = document.querySelector('._ideogramTooltip');\n  // if (!ideo.addedTooltipClickHandler) {\n  //   tooltip.addEventListener('click', () => {\n  //     const geneDom = document.querySelector('#ideo-related-gene');\n  //     const annotName = geneDom.textContent;\n  //     const annot = getAnnotByName(annotName, ideo);\n  //     ideo.onClickAnnot(annot);\n  //   });\n\n  //   // Ensures handler isn't added redundantly.  This is used because\n  //   // addEventListener options like {once: true} don't suffice\n  //   ideo.addedTooltipClickHandler = true;\n  // }\n\n  const tooltip = document.querySelector('._ideogramTooltip');\n  if (!ideo.addedTooltipClickHandler) {\n    tooltip.addEventListener('click', (event) => {\n      if (['input', 'label'].includes(event.target.localName)) {\n        return;\n      }\n\n      let geneDom = document.querySelector('#ideo-related-gene');\n      if (!geneDom) {\n        geneDom = event.target;\n      }\n      const annotName = geneDom.textContent;\n      const annot = getAnnotByName(annotName, ideo);\n\n      ideo.onClickAnnot(annot);\n    });\n\n    // const ixnLinkToggler = document.querySelector('#_ideoIxnLinkToggler');\n    // if (ixnLinkToggler) {\n    //   ixnLinkToggler.addEventListener('click', (event) => {\n    //     const isOpen = !ixnLinkToggler.classList.contains('closed');\n    //     const newToggleClass = isOpen ? 'closed' : '';\n    //     if (isOpen) {\n    //       ixnLinkToggler\n    //     } else {\n\n    //     }\n    //   });\n    // }\n\n    // Ensures handler isn't added redundantly.  This is used because\n    // addEventListener options like {once: true} don't suffice\n    ideo.addedTooltipClickHandler = true;\n  }\n}\n\n/** Return searched gene from annotation descriptions in Ideogram object */\nfunction getSearchedFromDescriptions(ideo) {\n  return (\n    Object.entries(ideo.annotDescriptions.annots)\n      .find(([k, v]) => v.type === 'searched gene')[0]\n  );\n}\n\nfunction decorateInteractingGene(annot, descObj, ideo) {\n  if ('type' in descObj && descObj.type.includes('interacting gene')) {\n    const pathwayIds = descObj.pathwayIds;\n    // Get symbol of the searched gene, e.g. \"PTEN\"\n    const searchedGene = getSearchedFromDescriptions(ideo);\n\n    const gpmls = ideo.gpmlsByInteractingGene[annot.name];\n\n    const summary =\n      summarizeInteractions(annot.name, searchedGene, pathwayIds, gpmls);\n    if (summary !== null) {\n      const oldSummary = 'Interacts with';\n      descObj.description =\n        descObj.description.replace(oldSummary, summary);\n    }\n  }\n\n  return descObj;\n}\n\nfunction decorateParalogNeighborhood(annot, descObj, style) {\n  // Rank 1st highest, then put it last as it already has a triangle\n  // annotation, and is often also labeled.\n  const sortedParalogs =\n    descObj.paralogs.sort((a, b) => a.rank - b.rank);\n  // const firstRanked = sortedParalogs.shift(); // Take off first\n  // sortedParalogs.push(firstRanked); // Make it last\n\n  const originalDisplay =\n    'Paralog neighborhood<br/>' +\n    '<br/>' +\n    descObj.description + ':<br/>' +\n    `${sortedParalogs\n      .map(paralog => {\n        let title = '';\n        if (paralog.fullName) title = paralog.fullName;\n        if (paralog.rank) {\n          const rank = paralog.rank;\n          title += ` &#013;Ranked ${rank} in general or scholarly interest`;\n        }\n        if (title !== '') title = `title=\"${title}\"`;\n        return (\n          `<span class=\"ideo-paralog-neighbor\" ${title} style=\"${style}\"'>${\n            paralog.name\n          }</span>`\n        );\n      }).join('<br/>')}` +\n    '<br/>';\n  annot.displayCoordinates = descObj.displayCoordinates;\n\n  return [annot, originalDisplay];\n}\n\n/**\n * Enhance tooltip shown on hovering over gene annotation\n */\nasync function decorateAnnot(annot) {\n  const ideo = this;\n\n  if (\n    annot.name === ideo.prevClickedAnnot?.name &&\n    annot.name === ideo.prevShownAnnot?.name &&\n    !ideo.hasShownAnnotSinceClick &&\n    ideo.isTooltipCooling\n  ) {\n    ideo.prevShownAnnot = annot;\n    // Cancels showing tooltip immediately after clicking gene\n    return null;\n  }\n\n  ideo.prevShownAnnot = annot;\n  ideo.hasShownAnnotSinceClick = true;\n\n  let descObj = ideo.annotDescriptions.annots[annot.name];\n\n  if (ideo.config.relatedGenesMode === 'related') {\n    descObj = decorateInteractingGene(annot, descObj, ideo);\n  }\n\n  const description =\n    descObj.description.length > 0 ? `<br/>${descObj.description}` : '';\n  const fullName = descObj.name;\n  const style = 'color: #0366d6; cursor: pointer;';\n\n  let fullNameAndRank = fullName;\n  if ('rank' in annot) {\n    const rank = 'Ranked ' + annot.rank + ' in general or scholarly interest';\n    fullNameAndRank = `<span title=\"${rank}\">${fullName}</span>`;\n  }\n\n  let synonym = '';\n  if (descObj?.isSynonym) {\n    const queriedSynonym = descObj.synonym;\n    const synStyle = 'style=\"font-style: italic\"';\n    synonym = `<div ${synStyle}>Synonym: ${queriedSynonym}</div>`;\n    // const synList = Ideogram.synonymCache.byGene[annot.name];\n    // const litSyns = synList.map(s => {\n    //   // Emphasize (\"highlight\") any synonyms that match the user's query\n    //   if (s.toLowerCase() === queriedSynonym.toLowerCase()) {\n    //     const style =\n    //       'style=\"font-weight: bold; text-decoration: underline\"';\n    //     return `<span ${style}>${s}</span>`;\n    //   }\n    //   return s;\n    // });\n    // const synText = 'Synonyms: ' + litSyns.join(', ') + '<br/>';\n    // const synStyle =\n    //   'style=\"max-width: 300px; color: #666;\"'; // Minimum WCAG AA contrast\n    // synonyms = `<div ${synStyle}>${synText}</div>`;\n  }\n\n  const isParalogNeighborhood = annot.name.includes('paralogNeighborhood');\n\n  const geneStructureHtml = await getGeneStructureHtml(\n    annot, ideo, isParalogNeighborhood\n  );\n\n  const tissueHtml = getTissueHtml(annot, ideo);\n\n  const geneSymbolAndFullName =\n    `<span id=\"_ideoGeneSymbolAndFullName\">\n      <span id=\"ideo-related-gene\" style=\"${style}\">${annot.name}</span><br/>` +\n      `${fullNameAndRank}<br/>\n    </span>`;\n\n  let originalDisplay =\n    geneSymbolAndFullName +\n    synonym +\n    description +\n    tissueHtml +\n    geneStructureHtml;\n\n  if (isParalogNeighborhood) {\n    [annot, originalDisplay] =\n      decorateParalogNeighborhood(annot, descObj, style);\n  }\n\n  annot.displayName = originalDisplay;\n\n  return annot;\n}\n\nconst shape = 'triangle';\n\nfunction getLegendName(nameText, legendContent=null) {\n  const legendHeaderStyle =\n    `font-size: 14px; font-weight: bold; font-color: #333;`;\n\n  let content = `<div style=\"${legendHeaderStyle}\">${nameText}</div>`;\n  if (legendContent) content = legendContent;\n  return `\n    <div style=\"position: relative; left: 30px;\">\n      ${content}\n      <i>Click gene to search</i>\n    </div>\n  `;\n}\n\nconst relatedLegend = [{\n  name: getLegendName('Related genes'),\n  nameHeight: 50,\n  rows: [\n    {name: 'Interacting gene', color: 'purple', shape: shape},\n    {name: 'Paralogous gene', color: 'pink', shape: shape},\n    {name: 'Searched gene', color: 'red', shape: shape}\n  ]\n}];\n\nlet legendPathwayName = '';\n\nconst pathwayLegend = [{\n  name: getLegendName('Related genes'),\n  nameHeight: 50,\n  rows: [\n    {name: 'Pathway gene', color: 'blue', shape: shape},\n    {name: 'Searched gene', color: 'red', shape: shape}\n  ]\n}];\n\nconst citedLegend = [{\n  name: getLegendName('Highly cited genes'),\n  nameHeight: 30,\n  rows: []\n}];\n\n/** Sets legendPad for related genes view */\nfunction setRelatedDecorPad(kitConfig) {\n  kitConfig.legendPad = kitConfig.showAnnotLabels ? 70 : 30;\n  return kitConfig;\n}\n\nconst globalKitDefaults = {\n  chrWidth: 9,\n  chrHeight: 100,\n  chrLabelSize: 12,\n  annotationHeight: 7,\n  showFullyBanded: false,\n  rotatable: false,\n  legend: relatedLegend,\n  chrBorderColor: '#333',\n  chrLabelColor: '#333',\n  onBeforeDrawAnnots,\n  onWillShowAnnotTooltip: decorateAnnot,\n  onDidShowAnnotTooltip,\n  showTools: true,\n  showAnnotLabels: true,\n  showGeneStructureInTooltip: true,\n  showProteinInTooltip: true,\n  showVariantInTooltip: false,\n  chrFillColor: {centromere: '#DAAAAA'}\n};\n\n\nfunction plotGeneHints() {\n  const ideo = this;\n\n  if (!ideo || 'annotDescriptions' in ideo) return;\n\n  ideo.annotDescriptions = {annots: {}};\n\n  ideo.flattenAnnots().map((annot) => {\n    let description = [];\n    if ('significance' in annot && annot.significance !== 'n/a') {\n      description.push(annot.significance);\n    }\n    if ('citations' in annot && annot.citations !== undefined) {\n      description.push(annot.citations);\n    }\n    description = description.join('<br/><br/>');\n    ideo.annotDescriptions.annots[annot.name] = {\n      description,\n      name: decodeURIComponent(annot.fullName)\n    };\n  });\n\n  adjustPlaceAndVisibility(ideo);\n  moveLegend(ideo, -60);\n\n  const container = ideo.config.container;\n  document.querySelector(container).style.visibility = '';\n\n  if (ideo.config.showAnnotLabels) {\n    const sortedAnnots = ideo.flattenAnnots().sort((a, b) => {\n      return ideo.annotSortFunction(a, b);\n    });\n    ideo.fillAnnotLabels(sortedAnnots);\n  }\n}\n\n/**\n * Wrapper for Ideogram constructor, with generic \"Related genes\" options\n *\n * This function is made available as a static method on Ideogram.\n *\n * @param {Object} config Ideogram configuration object\n */\nfunction _initRelatedGenes(config, annotsInList) {\n  if (config.relatedGenesMode === 'leads') {\n    delete config.onDrawAnnots;\n    delete config.relatedGenesMode;\n  };\n\n  const kitDefaults = Object.assign({\n    showParalogNeighborhoods: true,\n    isLegendInteractive: true,\n    relatedGenesMode: 'related',\n    useCache: true,\n    awaitCache: true\n  }, globalKitDefaults);\n\n  return initSearchIdeogram(kitDefaults, config, annotsInList);\n}\n\n/**\n * Wrapper for Ideogram constructor, with generic \"Gene leads\" options\n *\n * This function is made available as a static method on Ideogram.\n *\n * @param {Object} config Ideogram configuration object\n */\n function _initGeneLeads(config, annotsInList) {\n  delete config.onPlotFoundGenes;\n\n  if (config.legendName) {\n    if (config.legendContent) {\n      citedLegend[0].name = getLegendName(\n        config.legendName, config.legendContent\n      );\n    } else if (config.geneLeadsDE) {\n      // citedLegend[0].name = getLegendName(config.legendName);\n      const content =\n        '<span style=\"font-size: 14px; font-weight: bold; left: 0\">Gene leads</span> from<br/>' +\n        // `<div style=\"margin-top: 10px; padding: 3px 6px; border: 1px solid #4D72AA; border-radius: 3px; color: #3D629A;\">${fileIcon} <span style=\"margin-left: 20px; position: relative; top: -1px;\">Publication</span></div>` +\n        // `<div style=\"margin-top: 5px; margin-bottom: 0px; padding: 3px 6px; border: 1px solid #4D72AA; border-radius: 3px; color: #3D629A;\">${deltaIcon} <span style=\"margin-left: 20px;\">Differential expression</span></div><br/>`;\n        `<div style=\"margin-top: 10px; padding: 3px 6px; font-size: 14px; font-weight: bold; color: #3D629A;\">${fileIcon} <span style=\"margin-left: 20px; position: relative; top: -1px;\">Publication</span></div>` +\n        // `<div style=\"margin-top: 5px; margin-bottom: -5px; font-size: 14px; font-weight: bold; padding: 3px 6px; color: #3D629A;\">${deltaIcon} <span style=\"margin-left: 20px;\">Differential expression</span></div><br/>`;\n        `<div style=\"margin-top: 3px; margin-bottom: -10px; font-size: 14px; padding: 3px 6px;\">${deltaIcon} <span style=\"margin-left: 20px;\">Differential expression</span></div><br/>`;\n        // `<div>Publication</div>` +\n        // `<div>Differential expression</div>`;\n\n      citedLegend[0].name = getLegendName(\n        config.legendName, content\n      );\n    } else {\n      citedLegend[0].name = getLegendName(config.legendName);\n    }\n  }\n\n  config.legend = citedLegend;\n\n  let rawPath, mode;\n  if (config.geneLeadsDE) {\n    mode = 'leads';\n    rawPath = 'annotations/gene_leads.tsv';\n  } else {\n    mode = 'hints';\n    rawPath = 'cache/homo-sapiens-top-genes.tsv';\n  }\n\n  const kitDefaults = Object.assign({\n    relatedGenesMode: mode,\n    chrMargin: -4,\n    // annotationsPath: getDir('cache/homo-sapiens-top-genes.tsv'),\n    annotationsPath: getDir(rawPath),\n    onDrawAnnots: plotGeneHints,\n    useCache: true\n  }, globalKitDefaults);\n\n  return initSearchIdeogram(kitDefaults, config, annotsInList);\n}\n\nfunction initSearchIdeogram(kitDefaults, config, annotsInList) {\n  if (annotsInList !== 'all') {\n    annotsInList = annotsInList.map(name => name.toLowerCase());\n  }\n  config.annotsInList = annotsInList;\n\n  kitDefaults.legendPad = kitDefaults.showAnnotLabels ? 80 : 30;\n\n  if ('onWillShowAnnotTooltip' in config) {\n    const key = 'onWillShowAnnotTooltip';\n    const clientFn = config[key];\n    const defaultFunction = kitDefaults[key];\n    const newFunction = function(annot) {\n      annot = defaultFunction.bind(this)(annot);\n      annot = clientFn.bind(this)(annot);\n      return annot;\n    };\n    kitDefaults[key] = newFunction;\n    delete config[key];\n  }\n\n  if ('onDidShowAnnotTooltip' in config) {\n    const key = 'onDidShowAnnotTooltip';\n    const clientFn = config[key];\n    const defaultFunction = kitDefaults[key];\n    const newFunction = function(annot) {\n      annot = defaultFunction.bind(this)(annot);\n      annot = clientFn.bind(this)(annot);\n      return annot;\n    };\n    kitDefaults[key] = newFunction;\n    delete config[key];\n  }\n\n  if ('onBeforeDrawAnnots' in config) {\n    const key = 'onBeforeDrawAnnots';\n    const clientFn = config[key];\n    const defaultFn = kitDefaults[key];\n    const newFunction = function() {\n      if (defaultFn) defaultFn.bind(this)();\n      clientFn.bind(this)();\n    };\n    kitDefaults[key] = newFunction;\n    delete config[key];\n  }\n\n  if ('onDrawAnnots' in config) {\n    const key = 'onDrawAnnots';\n    const clientFn = config[key];\n    const defaultFn = kitDefaults[key];\n    const newFunction = function() {\n      if (defaultFn) defaultFn.bind(this)();\n      clientFn.bind(this)();\n    };\n    kitDefaults[key] = newFunction;\n    delete config[key];\n  }\n\n  // Override kit defaults if client specifies otherwise\n  const kitConfig = Object.assign(kitDefaults, config);\n\n  const ideogram = new Ideogram(kitConfig);\n\n  // Called upon 1) finding paralogs, and 2) finding interacting genes\n  if (config.onFindGenes) {\n    ideogram.onFindGenesCallback = config.onFindGenes;\n  }\n\n  // Called upon completing last plot, including all related genes\n  if (config.onPlotFoundGenes) {\n    ideogram.onPlotFoundGenesCallback = config.onPlotFoundGenes;\n  }\n\n  // Called upon hovering over a legend entry, e.g. \"Interacting genes\"\n  if (config.onHoverLegend) {\n    ideogram.onHoverLegendCallback = config.onHoverLegend;\n  }\n\n  ideogram.getTooltipAnalytics = getRelatedGenesTooltipAnalytics;\n\n  ideogram.annotSortFunction = sortByRelatedType;\n\n  initAnalyzeRelatedGenes(ideogram);\n\n  return ideogram;\n}\n\nexport {\n  _initGeneLeads, _initRelatedGenes,\n  plotRelatedGenes, getRelatedGenesByType\n};\n","/**\n * @fileoverview Core module of Ideogram.js, links all other modules\n * This file defines the Ideogram class, its constructor method, and its\n * static methods.  All instance methods are defined in other modules.\n *\n */\n\nimport version from './version';\n\nimport {\n  configure, initDrawChromosomes, handleRotateOnClick, onLoad,\n  init, finishInit, writeContainer\n} from './init/init';\n\nimport {\n  onLoadAnnots, onDrawAnnots, processAnnotData, restoreDefaultTracks,\n  updateDisplayedTracks, initAnnotSettings, fetchAnnots, drawAnnots,\n  getHistogramBars, drawHeatmaps, deserializeAnnotsForHeatmap, fillAnnots,\n  drawProcessedAnnots, drawSynteny, startHideAnnotTooltipTimeout,\n  showAnnotTooltip, onWillShowAnnotTooltip, onDidShowAnnotTooltip,\n  setOriginalTrackIndexes,\n  afterRawAnnots, onClickAnnot, downloadAnnotations, addAnnotLabel,\n  removeAnnotLabel, fillAnnotLabels, clearAnnotLabels, flattenAnnots\n  // fadeOutAnnotLabels\n} from './annotations/annotations';\n\nimport {highlight, unhighlight} from './annotations/highlight';\n\nimport {\n  esearch, esummary, elink,\n  getOrganismFromEutils, getTaxids,\n  getAssemblyAndChromosomesFromEutils\n} from './services/services';\n\nimport {\n  drawBandLabels, getBandColorGradients, processBandData,\n  setBandsToShow, hideUnshownBandLabels, drawBandLabelText, drawBandLabelStalk\n} from './bands/bands';\n\nimport {onBrushMove, onBrushEnd, createBrush} from './brush';\nimport {onCursorMove, createClickCursor} from './cursor';\nimport {drawSexChromosomes, setSexChromosomes} from './sex-chromosomes';\nimport {convertBpToPx, convertPxToBp} from './coordinate-converters';\nimport {\n  unpackAnnots, packAnnots, initCrossFilter, filterAnnots\n} from './filter';\n\nimport {\n  assemblyIsAccession, getDataDir, round, onDidRotate, getSvg, d3,\n  getTaxid, getCommonName, getScientificName, fetch as _fetch,\n  isRoman, parseRoman\n} from './lib';\n\nimport {\n  getChromosomeModel, getChromosomePixels\n} from './views/chromosome-model';\n\nimport {\n  appendHomolog, drawChromosome, rotateAndToggleDisplay, setOverflowScroll\n} from './views/draw-chromosomes';\n\nimport {\n  drawChromosomeLabels, rotateChromosomeLabels\n} from './views/chromosome-labels.js';\n\nimport {\n  _initGeneLeads, _initRelatedGenes,\n  plotRelatedGenes, getRelatedGenesByType\n} from './kit/related-genes';\n\nimport {\n  drawPathway as _drawPathway,\n  getPathwayGenes as _getPathwayGenes,\n  getPathwayAnnotations\n} from './kit/pathway-viewer.js';\n\nimport {\n  initCaches as _initCaches\n} from './init/caches/cache';\n\nexport default class Ideogram {\n  constructor(config) {\n\n    // Functions from init.js\n    this.configure = configure;\n    this.initDrawChromosomes = initDrawChromosomes;\n    this.onLoad = onLoad;\n    this.handleRotateOnClick = handleRotateOnClick;\n    this.init = init;\n    this.finishInit = finishInit;\n    this.writeContainer = writeContainer;\n\n    // Functions from annotations.js\n    this.onLoadAnnots = onLoadAnnots;\n    this.onDrawAnnots = onDrawAnnots;\n    this.processAnnotData = processAnnotData;\n    this.restoreDefaultTracks = restoreDefaultTracks;\n    this.updateDisplayedTracks = updateDisplayedTracks;\n    this.initAnnotSettings = initAnnotSettings;\n    this.fetchAnnots = fetchAnnots;\n    this.drawAnnots = drawAnnots;\n    this.getHistogramBars = getHistogramBars;\n    this.drawHeatmaps = drawHeatmaps;\n    this.deserializeAnnotsForHeatmap = deserializeAnnotsForHeatmap;\n    this.fillAnnots = fillAnnots;\n    this.drawProcessedAnnots = drawProcessedAnnots;\n    this.drawSynteny = drawSynteny;\n    this.startHideAnnotTooltipTimeout = startHideAnnotTooltipTimeout;\n    this.showAnnotTooltip = showAnnotTooltip;\n    this.onWillShowAnnotTooltip = onWillShowAnnotTooltip;\n    this.onDidShowAnnotTooltip = onDidShowAnnotTooltip;\n    this.onClickAnnot = onClickAnnot;\n    this.setOriginalTrackIndexes = setOriginalTrackIndexes;\n    this.afterRawAnnots = afterRawAnnots;\n    this.downloadAnnotations = downloadAnnotations;\n    this.addAnnotLabel = addAnnotLabel;\n    this.removeAnnotLabel = removeAnnotLabel;\n    // this.fadeOutAnnotLabels = fadeOutAnnotLabels;\n    this.fillAnnotLabels = fillAnnotLabels;\n    this.clearAnnotLabels = clearAnnotLabels;\n    this.flattenAnnots = flattenAnnots;\n\n    this.highlight = highlight;\n    this.unhighlight = unhighlight;\n\n    // Variables and functions from services.js\n    this.esearch = esearch;\n    this.esummary = esummary;\n    this.elink = elink;\n    this.getOrganismFromEutils = getOrganismFromEutils;\n    this.getTaxids = getTaxids;\n    this.getAssemblyAndChromosomesFromEutils =\n      getAssemblyAndChromosomesFromEutils;\n\n    // Functions from bands.js\n    this.drawBandLabels = drawBandLabels;\n    this.getBandColorGradients = getBandColorGradients;\n    this.processBandData = processBandData;\n    this.setBandsToShow = setBandsToShow;\n    this.hideUnshownBandLabels = hideUnshownBandLabels;\n    this.drawBandLabelText = drawBandLabelText;\n    this.drawBandLabelStalk = drawBandLabelStalk;\n\n    // Functions from brush.js\n    this.onBrushMove = onBrushMove;\n    this.onBrushEnd = onBrushEnd;\n    this.createBrush = createBrush;\n\n    // Functions from cursor.js\n    this.createClickCursor = createClickCursor;\n    this.onCursorMove = onCursorMove;\n\n    // Functions from sex-chromosomes.js\n    this.drawSexChromosomes = drawSexChromosomes;\n    this.setSexChromosomes = setSexChromosomes;\n\n    // Functions from coordinate-converters.js\n    this.convertBpToPx = convertBpToPx;\n    this.convertPxToBp = convertPxToBp;\n\n    // Functions from filter.js\n    this.unpackAnnots = unpackAnnots;\n    this.packAnnots = packAnnots;\n    this.initCrossFilter = initCrossFilter;\n    this.filterAnnots = filterAnnots;\n\n    // Functions from lib\n    this.assemblyIsAccession = assemblyIsAccession;\n    this.getDataDir = getDataDir;\n    this.round = round;\n    this.onDidRotate = onDidRotate;\n    this.getSvg = getSvg;\n    this.fetch = _fetch;\n    this.getTaxid = getTaxid;\n    this.getCommonName = getCommonName;\n    this.getScientificName = getScientificName;\n\n    // Functions from views/chromosome-model.js\n    this.getChromosomeModel = getChromosomeModel;\n    this.getChromosomePixels = getChromosomePixels;\n\n    // Functions from views/chromosome-labels.js\n    this.drawChromosomeLabels = drawChromosomeLabels;\n    this.rotateChromosomeLabels = rotateChromosomeLabels;\n\n    // Functions from views/draw-chromosomes.js\n    this.appendHomolog = appendHomolog;\n    this.drawChromosome = drawChromosome;\n    this.rotateAndToggleDisplay = rotateAndToggleDisplay;\n    this.setOverflowScroll = setOverflowScroll;\n\n    this.plotRelatedGenes = plotRelatedGenes;\n    this.getRelatedGenesByType = getRelatedGenesByType;\n\n    this.configure(config);\n  }\n\n  /**\n   * Get the current version of Ideogram.js\n   */\n  static get version() {\n    return version;\n  }\n\n  /**\n  * Enable use of D3 in client apps, via \"d3 = Ideogram.d3\"\n  */\n  static get d3() {\n    return d3;\n  }\n\n  /**\n   * Request data from Ensembl REST API\n   * Docs: https://rest.ensembl.org/\n   *\n   * @param {String} path URL path\n   * @param {Object} body POST body\n   * @param {String} method HTTP method; 'GET' (default) or 'POST'\n   */\n  static async fetchEnsembl(path, body = null, method = 'GET') {\n    const init = {\n      method: method\n    };\n    if (body !== null) init.body = JSON.stringify(body);\n    if (method === 'GET') {\n      // Use HTTP parameter, not header, to avoid needless OPTIONS request\n      const delimiter = path.includes('&') ? '&' : '?';\n      path += delimiter + 'content-type=application/json';\n    } else {\n      // Method is POST, so content-type must be defined in header\n      init.headers = {'Content-Type': 'application/json'};\n    }\n\n    // const random = Math.random();\n    // console.log(random)\n    // if (random < 0.5) {\n    const response = await fetch(`https://rest.ensembl.org${path}`, init);\n    const json = await response.json();\n    return json;\n    // } else {\n    //   // Mock error\n    //   init.headers = {'Content-Type': 'application/json'};\n    //   const response = await fetch('https://httpstat.us/500/cors', init);\n    //   const json = await response.json();\n    //   return json;\n    // }\n  }\n\n  /**\n   * Helper for sortChromosomes().\n   * Gets names and biological types for diverse chromosome variables\n   */\n  static getChrSortNamesAndTypes(a, b) {\n    var chrAName, chrBName,\n      aIsCP, bIsCP, aIsMT, bIsMT, aIsAP, bIsAP, aIsNuclear, bIsNuclear;\n\n    if (typeof a === 'string' || 'chr' in a && 'annots' in a) {\n      // Chromosome data is from either:\n      //    - Ideogram static file cache (e.g. homo-sapiens.json)\n      //    - Ideogram raw annotations\n      chrAName = (typeof a === 'string') ? a : a.chr;\n      chrBName = (typeof b === 'string') ? b : b.chr;\n\n      aIsCP = chrAName === 'CP';\n      bIsCP = chrBName === 'CP';\n      aIsMT = chrAName === 'MT';\n      bIsMT = chrBName === 'MT';\n      aIsAP = chrAName === 'AP';\n      bIsAP = chrBName === 'AP';\n      aIsNuclear = (!aIsCP && !aIsMT && !aIsAP);\n      bIsNuclear = (!bIsCP && !bIsMT && !bIsAP);\n    } else {\n      // Chromosome data is from NCBI E-Utils web API\n      chrAName = a.name;\n      chrBName = b.name;\n\n      aIsCP = a.type === 'chloroplast';\n      bIsCP = b.type === 'chloroplast';\n      aIsMT = a.type === 'mitochondrion';\n      bIsMT = b.type === 'mitochondrion';\n      aIsAP = a.type === 'apicoplast';\n      bIsAP = b.type === 'apicoplast';\n      aIsNuclear = a.type === 'nuclear';\n      bIsNuclear = b.type === 'nuclear';\n    }\n\n    const chrTypes = {\n      aIsNuclear, bIsNuclear, aIsCP, bIsCP, aIsMT, bIsMT, aIsAP, bIsAP\n    };\n\n    return [chrAName, chrBName, chrTypes];\n  }\n\n  /**\n   * Sorts two chromosome objects by type and name\n   * - Nuclear chromosomes come before non-nuclear chromosomes.\n   * - Among nuclear chromosomes, use \"natural sorting\", e.g.\n   *   numbers come before letters\n   * - Among non-nuclear chromosomes, i.e. \"MT\" (mitochondrial DNA) and\n   *   \"CP\" (chromoplast DNA), MT comes first\n   *\n   * @param a Chromosome string or object \"A\"\n   * @param b Chromosome string or object \"B\"\n   * @returns {Number} JavaScript sort order indicator\n   */\n  static sortChromosomes(a, b) {\n\n    let [chrAName, chrBName, chrTypes] =\n      Ideogram.getChrSortNamesAndTypes(a, b);\n\n    const {\n      aIsNuclear, bIsNuclear, aIsCP, bIsCP, aIsMT, bIsMT, aIsAP, bIsAP\n    } = chrTypes;\n\n    if (aIsNuclear && bIsNuclear) {\n\n      if (isRoman(chrAName) && isRoman(chrBName)) {\n        // As in yeast genome\n        chrAName = parseRoman(chrAName).toString();\n        chrBName = parseRoman(chrBName).toString();\n      }\n\n      return chrAName.localeCompare(chrBName, 'en', {numeric: true});\n    } else if (!aIsNuclear && bIsNuclear) {\n      return 1;\n    } else if (aIsMT && bIsCP) {\n      return 1;\n    } else if (aIsCP && bIsMT) {\n      return -1;\n    } else if (!aIsAP && !aIsMT && !aIsCP && (bIsMT || bIsCP || bIsAP)) {\n      return -1;\n    }\n  }\n\n  /**\n   * Wrapper for Ideogram constructor, with generic \"Related genes\" options\n   *\n   * @param {Object} config Ideogram configuration object\n   */\n  static initRelatedGenes(config, annotsInList='all') {\n    return _initRelatedGenes(config, annotsInList);\n  }\n\n\n  /**\n   * Wrapper for Ideogram constructor, with generic \"Gene leads\" options\n   *\n   * @param {Object} config Ideogram configuration object\n  */\n  static initGeneLeads(config, annotsInList='all') {\n    return _initGeneLeads(config, annotsInList);\n  }\n\n  /**\n   * Wrapper for drawing biological pathways using cached WikiPathways data\n   *\n   * @param {String} pwId WikiPathways ID, e.g. \"WP5109\"\n   * @param {String} sourceGene Symbol of source gene, e.g. \"LDLR\"\n   * @param {String} destGene Symbol of destination gene, e.g. \"PCSK9\"\n   * @param {String} outerSelector DOM selector of container, e.g. \"#my-diagram\"\n   * @param {Object} dimensions Height and width of pathway diagram\n   * @param {Boolean} showClose Whether to show close button\n   * @param {Function} geneNodeHoverFn Function to call upon hovering gene\n   * @param {Function} pathwayNodeClickFn Function to call upon clicking pathway\n   * @param {Boolean} showDescription Whether to display pathway description\n   * @param {Boolean} showOntologies Whether to display ontology annotations\n   * @param {Boolean} showDefaultTooltips Whether to display default tooltips\n  */\n  static drawPathway(\n    pwId, sourceGene, destGene,\n    outerSelector,\n    dimensions={height: 440, width: 900},\n    showClose=true,\n    geneNodeHoverFn=undefined,\n    pathwayNodeClickFn=undefined,\n    showDescription=true,\n    showOntologies=true,\n    showDefaultTooltips=true\n  ) {\n    _drawPathway(\n      pwId, sourceGene, destGene,\n      outerSelector,\n      dimensions=dimensions,\n      showClose=showClose,\n      geneNodeHoverFn=geneNodeHoverFn,\n      pathwayNodeClickFn=pathwayNodeClickFn,\n      showDescription=showDescription,\n      showOntologies=showOntologies,\n      showDefaultTooltips=showDefaultTooltips\n    );\n  }\n\n  /**\n   * Wrapper for initializing cached data\n   *\n   * @param {Object} config Includes organism, useCache, etc.\n  */\n  static initCaches(config={\n    organism: 'homo-sapiens', useCache: true,\n    awaitCache: true,\n    showGeneStructureInTooltip: true\n  }) {\n    _initCaches(config);\n  }\n\n  /**\n   * Get list of gene names in pathway\n   *\n   * @param {Object} config Includes organism, useCache, etc.\n  */\n  static getPathwayGenes() {\n    return _getPathwayGenes();\n  }\n\n  static getPathwayOntologies(pathwayJson, selectedOntology) {\n    return getPathwayAnnotations(pathwayJson, selectedOntology);\n  }\n}\n","import Ideogram from './ideogram';\n\n// Enable references to Ideogram when loaded via traditional script tag\nwindow.Ideogram = Ideogram;\n\n// Enable references to Ideogram when imported as an ES6 module\nexport default Ideogram;\n","\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:core:7.0.0'] && _();\n}\ncatch (e) { }\n","\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:range-requests:7.0.0'] && _();\n}\ncatch (e) { }\n"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204]}