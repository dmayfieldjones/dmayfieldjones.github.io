{"version":3,"file":"static/chunks/7003.c796be7f4a447989.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-variants/esm/VariantFeatureWidget/BreakendSingleLevelOptionDialog.js","webpack://_N_E/./node_modules/@jbrowse/sv-core/esm/Checkbox2.js","webpack://_N_E/./node_modules/@jbrowse/sv-core/esm/util.js","webpack://_N_E/./node_modules/@jbrowse/sv-core/esm/BreakendMultiLevelOptionDialog.js","webpack://_N_E/./node_modules/@jbrowse/sv-core/esm/BreakendSingleLevelOptionDialog.js","webpack://_N_E/./node_modules/@jbrowse/sv-core/esm/index.js"],"sourcesContent":["export { BreakendSingleLevelOptionDialog as default } from '@jbrowse/sv-core';\n","import React from 'react';\nimport { Checkbox, FormControlLabel } from '@mui/material';\nimport { makeStyles } from 'tss-react/mui';\nconst useStyles = makeStyles()({\n    block: {\n        display: 'block',\n    },\n});\nexport default function Checkbox2({ checked, disabled, label, onChange, }) {\n    const { classes } = useStyles();\n    return (React.createElement(FormControlLabel, { disabled: disabled, className: classes.block, control: React.createElement(Checkbox, { checked: checked, onChange: onChange }), label: label }));\n}\n","import { parseBreakend } from '@gmod/vcf';\nimport { gatherOverlaps, getSession, when } from '@jbrowse/core/util';\nimport { transaction } from 'mobx';\nimport { getSnapshot } from 'mobx-state-tree';\nfunction stripIds(arr) {\n    return arr.map(({ id, displays, ...rest }) => ({\n        ...rest,\n        displays: displays.map(({ id, ...rest }) => rest),\n    }));\n}\nexport function getBreakendCoveringRegions({ feature, assembly, }) {\n    var _a;\n    const alt = (_a = feature.get('ALT')) === null || _a === void 0 ? void 0 : _a[0];\n    const bnd = alt ? parseBreakend(alt) : undefined;\n    const startPos = feature.get('start');\n    const refName = feature.get('refName');\n    const f = (ref) => assembly.getCanonicalRefName(ref) || ref;\n    if (alt === '<TRA>') {\n        const INFO = feature.get('INFO');\n        return {\n            pos: startPos,\n            refName: f(refName),\n            mateRefName: f(INFO.CHR2[0]),\n            matePos: INFO.END[0] - 1,\n        };\n    }\n    else if (bnd === null || bnd === void 0 ? void 0 : bnd.MatePosition) {\n        const matePosition = bnd.MatePosition.split(':');\n        return {\n            pos: startPos,\n            refName: f(refName),\n            mateRefName: f(matePosition[0]),\n            matePos: +matePosition[1] - 1,\n        };\n    }\n    else if (feature.get('mate')) {\n        const mate = feature.get('mate');\n        return {\n            pos: startPos,\n            refName: f(refName),\n            mateRefName: f(mate.refName),\n            matePos: mate.start,\n        };\n    }\n    else {\n        return {\n            pos: startPos,\n            refName: f(refName),\n            mateRefName: f(refName),\n            matePos: feature.get('end'),\n        };\n    }\n}\nexport function singleLevelSnapshotFromBreakendFeature({ feature, session, assemblyName, }) {\n    const { assemblyManager } = session;\n    const assembly = assemblyManager.get(assemblyName);\n    if (!assembly) {\n        throw new Error(`assembly ${assemblyName} not found`);\n    }\n    if (!assembly.regions) {\n        throw new Error(`assembly ${assemblyName} regions not loaded`);\n    }\n    const coverage = getBreakendCoveringRegions({\n        feature,\n        assembly,\n    });\n    const { refName, mateRefName } = coverage;\n    const topRegion = assembly.regions.find(f => f.refName === refName);\n    const bottomRegion = assembly.regions.find(f => f.refName === mateRefName);\n    return {\n        coverage,\n        snap: {\n            type: 'BreakpointSplitView',\n            views: [\n                {\n                    type: 'LinearGenomeView',\n                    displayedRegions: gatherOverlaps([\n                        { ...topRegion, assemblyName },\n                        { ...bottomRegion, assemblyName },\n                    ]),\n                },\n            ],\n            displayName: `${feature.get('name') || feature.get('id') || 'breakend'} split detail`,\n        },\n    };\n}\nexport async function navToSingleLevelBreak({ stableViewId, feature, assemblyName, session, tracks, windowSize = 0, }) {\n    var _a;\n    const { snap, coverage } = singleLevelSnapshotFromBreakendFeature({\n        feature,\n        assemblyName,\n        session,\n    });\n    const { refName, pos: startPos, mateRefName, matePos: endPos } = coverage;\n    let viewInStack = session.views.find(f => f.id === stableViewId);\n    if (!viewInStack) {\n        viewInStack = session.addView('BreakpointSplitView', {\n            ...snap,\n            views: [\n                {\n                    ...snap.views[0],\n                    tracks: tracks ? stripIds(getSnapshot(tracks)) : [],\n                },\n            ],\n        });\n    }\n    else {\n        (_a = viewInStack.views[0]) === null || _a === void 0 ? void 0 : _a.setDisplayedRegions(snap.views[0].displayedRegions);\n        viewInStack.setDisplayName(snap.displayName);\n    }\n    const lgv = viewInStack.views[0];\n    await when(() => lgv.initialized);\n    const l0 = lgv.bpToPx({\n        coord: Math.max(0, startPos - windowSize),\n        refName,\n    });\n    const r0 = lgv.bpToPx({\n        coord: endPos + windowSize,\n        refName: mateRefName,\n    });\n    if (l0 && r0) {\n        lgv.moveTo({ ...l0, offset: l0.offsetPx }, { ...r0, offset: r0.offsetPx });\n    }\n    else {\n        getSession(lgv).notify('Unable to navigate to breakpoint');\n    }\n}\nexport async function navToMultiLevelBreak({ stableViewId, feature, assemblyName, session, tracks, }) {\n    const bpPerPx = 10;\n    const { assemblyManager } = session;\n    const assembly = assemblyManager.get(assemblyName);\n    if (!assembly) {\n        throw new Error(`assembly ${assemblyName} not found`);\n    }\n    if (!assembly.regions) {\n        throw new Error(`assembly ${assemblyName} regions not loaded`);\n    }\n    const { refName, pos: startPos, mateRefName, matePos: endPos, } = getBreakendCoveringRegions({\n        feature,\n        assembly,\n    });\n    const topRegion = assembly.regions.find(f => f.refName === refName);\n    const bottomRegion = assembly.regions.find(f => f.refName === mateRefName);\n    const topMarkedRegion = [{ ...topRegion }, { ...topRegion }];\n    const bottomMarkedRegion = [{ ...bottomRegion }, { ...bottomRegion }];\n    topMarkedRegion[0].end = startPos;\n    topMarkedRegion[1].start = startPos;\n    bottomMarkedRegion[0].end = endPos;\n    bottomMarkedRegion[1].start = endPos;\n    const snap = {\n        type: 'BreakpointSplitView',\n        views: [\n            {\n                type: 'LinearGenomeView',\n                displayedRegions: topMarkedRegion,\n                hideHeader: true,\n                bpPerPx,\n                offsetPx: (topRegion.start + feature.get('start')) / bpPerPx,\n            },\n            {\n                type: 'LinearGenomeView',\n                displayedRegions: bottomMarkedRegion,\n                hideHeader: true,\n                bpPerPx,\n                tracks,\n                offsetPx: (bottomRegion.start + endPos) / bpPerPx,\n            },\n        ],\n        displayName: `${feature.get('name') || feature.get('id') || 'breakend'} split detail`,\n    };\n    let viewInStack = session.views.find(f => f.id === stableViewId);\n    if (!viewInStack) {\n        viewInStack = session.addView('BreakpointSplitView', {\n            ...snap,\n            id: stableViewId,\n            views: [\n                {\n                    ...snap.views[0],\n                    tracks: tracks ? stripIds(getSnapshot(tracks)) : [],\n                },\n                {\n                    ...snap.views[1],\n                    tracks: (tracks ? stripIds(getSnapshot(tracks)) : []).reverse(),\n                },\n            ],\n        });\n    }\n    else {\n        transaction(() => {\n            for (let i = 0; i < viewInStack.views.length; i++) {\n                const s = snap.views[i];\n                if (s) {\n                    viewInStack.views[i].setDisplayedRegions(s.displayedRegions);\n                    viewInStack.views[i].scrollTo(s.offsetPx - 800);\n                    viewInStack.views[i].zoomTo(s.bpPerPx);\n                }\n            }\n            viewInStack.setDisplayName(snap.displayName);\n        });\n    }\n}\n","import React, { useState } from 'react';\nimport { Dialog } from '@jbrowse/core/ui';\nimport { Button, DialogActions, DialogContent } from '@mui/material';\nimport { when } from 'mobx';\nimport { observer } from 'mobx-react';\nimport { getSnapshot } from 'mobx-state-tree';\nimport Checkbox2 from './Checkbox2';\nimport { getBreakendCoveringRegions } from './util';\nfunction stripIds(arr) {\n    return arr.map(({ id, displays, ...rest }) => ({\n        ...rest,\n        displays: displays.map(({ id, ...rest }) => rest),\n    }));\n}\nconst BreakendMultiLevelOptionDialog = observer(function ({ session, handleClose, feature, assemblyName, stableViewId, view, }) {\n    const [copyTracks, setCopyTracks] = useState(true);\n    const [mirror, setMirror] = useState(true);\n    return (React.createElement(Dialog, { open: true, onClose: handleClose, title: \"Multi-level breakpoint split view options\" },\n        React.createElement(DialogContent, null,\n            React.createElement(\"div\", null, \"Launch multi-level breakpoint split view\"),\n            view ? (React.createElement(React.Fragment, null,\n                React.createElement(Checkbox2, { checked: copyTracks, label: \"Copy tracks into the new view\", onChange: event => {\n                        setCopyTracks(event.target.checked);\n                    } }),\n                copyTracks ? (React.createElement(Checkbox2, { checked: mirror, disabled: !copyTracks, label: \"Mirror the copied tracks (only available if copying tracks and using two level)\", onChange: event => {\n                        setMirror(event.target.checked);\n                    } })) : null)) : null),\n        React.createElement(DialogActions, null,\n            React.createElement(Button, { onClick: () => {\n                    ;\n                    (async () => {\n                        try {\n                            const { assemblyManager } = session;\n                            const assembly = await assemblyManager.waitForAssembly(assemblyName);\n                            if (!assembly) {\n                                throw new Error(`assembly ${assemblyName} not found`);\n                            }\n                            const { refName, pos, mateRefName, matePos } = getBreakendCoveringRegions({\n                                feature,\n                                assembly: assembly,\n                            });\n                            const viewTracks = view\n                                ? getSnapshot(view.tracks)\n                                : [];\n                            let viewInStack = session.views.find(f => f.id === stableViewId);\n                            const displayName = `${feature.get('name') || feature.get('id') || 'breakend'} split detail`;\n                            if (!viewInStack) {\n                                viewInStack = session.addView('BreakpointSplitView', {\n                                    id: stableViewId,\n                                    type: 'BreakpointSplitView',\n                                    displayName,\n                                    views: [\n                                        {\n                                            type: 'LinearGenomeView',\n                                            hideHeader: true,\n                                            tracks: stripIds(viewTracks),\n                                        },\n                                        {\n                                            type: 'LinearGenomeView',\n                                            hideHeader: true,\n                                            tracks: stripIds(mirror ? [...viewTracks].reverse() : viewTracks),\n                                        },\n                                    ],\n                                });\n                            }\n                            viewInStack.setDisplayName(displayName);\n                            const r1 = assembly.regions.find(r => r.refName === refName);\n                            const r2 = assembly.regions.find(r => r.refName === mateRefName);\n                            if (!r1 || !r2) {\n                                throw new Error(\"can't find regions\");\n                            }\n                            await Promise.all([\n                                viewInStack.views[0].navToLocations([\n                                    {\n                                        refName,\n                                        start: r1.start,\n                                        end: pos,\n                                        assemblyName,\n                                    },\n                                    {\n                                        refName,\n                                        start: pos + 1,\n                                        end: r1.end,\n                                        assemblyName,\n                                    },\n                                ]),\n                                viewInStack.views[1].navToLocations([\n                                    {\n                                        refName: mateRefName,\n                                        start: r2.start,\n                                        end: matePos,\n                                        assemblyName,\n                                    },\n                                    {\n                                        refName: mateRefName,\n                                        start: matePos + 1,\n                                        end: r2.end,\n                                        assemblyName,\n                                    },\n                                ]),\n                            ]);\n                            await when(() => viewInStack.views[1].initialized &&\n                                viewInStack.views[0].initialized);\n                            viewInStack.views[1].zoomTo(10);\n                            viewInStack.views[0].zoomTo(10);\n                            viewInStack.views[1].centerAt(matePos, mateRefName);\n                            viewInStack.views[0].centerAt(pos, refName);\n                        }\n                        catch (e) {\n                            console.error(e);\n                            session.notifyError(`${e}`, e);\n                        }\n                    })();\n                    handleClose();\n                }, variant: \"contained\", color: \"primary\", autoFocus: true }, \"OK\"),\n            React.createElement(Button, { color: \"secondary\", variant: \"contained\", onClick: () => {\n                    handleClose();\n                } }, \"Cancel\"))));\n});\nexport default BreakendMultiLevelOptionDialog;\n","import React, { useState } from 'react';\nimport { Dialog } from '@jbrowse/core/ui';\nimport { useLocalStorage } from '@jbrowse/core/util';\nimport { Button, DialogActions, DialogContent, TextField } from '@mui/material';\nimport { observer } from 'mobx-react';\nimport Checkbox2 from './Checkbox2';\nimport { navToSingleLevelBreak } from './util';\nconst BreakendSingleLevelOptionDialog = observer(function ({ session, handleClose, feature, stableViewId, assemblyName, view, }) {\n    const [copyTracks, setCopyTracks] = useState(true);\n    const [windowSize, setWindowSize] = useLocalStorage('breakpointWindowSize', '5000');\n    return (React.createElement(Dialog, { open: true, onClose: handleClose, title: \"Single-level breakpoint split view options\" },\n        React.createElement(DialogContent, null,\n            view ? (React.createElement(Checkbox2, { checked: copyTracks, label: \"Copy tracks into the new view\", onChange: event => {\n                    setCopyTracks(event.target.checked);\n                } })) : null,\n            React.createElement(TextField, { label: \"Window size (bp)\", value: windowSize, onChange: event => {\n                    setWindowSize(event.target.value);\n                } })),\n        React.createElement(DialogActions, null,\n            React.createElement(Button, { onClick: () => {\n                    ;\n                    (async () => {\n                        try {\n                            const { assemblyManager } = session;\n                            const assembly = await assemblyManager.waitForAssembly(assemblyName);\n                            if (!assembly) {\n                                throw new Error(`assembly ${assemblyName} not found`);\n                            }\n                            await navToSingleLevelBreak({\n                                feature,\n                                assemblyName,\n                                session,\n                                stableViewId,\n                                tracks: view === null || view === void 0 ? void 0 : view.tracks,\n                                windowSize: +windowSize || 0,\n                            });\n                        }\n                        catch (e) {\n                            console.error(e);\n                            session.notifyError(`${e}`, e);\n                        }\n                    })();\n                    handleClose();\n                }, variant: \"contained\", color: \"primary\", autoFocus: true }, \"OK\"),\n            React.createElement(Button, { color: \"secondary\", variant: \"contained\", onClick: () => {\n                    handleClose();\n                } }, \"Cancel\"))));\n});\nexport default BreakendSingleLevelOptionDialog;\n","export { default as BreakendMultiLevelOptionDialog } from './BreakendMultiLevelOptionDialog';\nexport { default as BreakendSingleLevelOptionDialog } from './BreakendSingleLevelOptionDialog';\nexport * from './util';\n"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4,5]}