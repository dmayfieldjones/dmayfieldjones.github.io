{"version":3,"file":"static/chunks/454.ae0f33cdf7a9de46.js","mappings":"0HAAA,gBCCA,2BACA,8CACA,ODFO,WCEmB,CDFnB,IACP,kBACA,aACA,gCACA,sBACA,EACA,0BACA,qBACA,ECN0B,SAC1B,GAEA,2BACA,+CACA,ODEO,gBACP,uBACA,qBACA,cACA,aAIA,0BACA,eACA,ECZ2B,SAC3B,kBCPA,wBAEA,KACA,YAAoB,MAAa,IACjC,iBACA,UACA,UACA,QAEA,+BACe,SAOf,wBAAkB,SAAmB,EACrC,KACA,uBAEA,KACA,oBAAkC,WAAS,SAG3C,6CAEA,CACA,0BAEA,mBADA,kCACA,QAEA,gBADA,iBAEA,mCAGA,8BAEA,CACA,YAOA,OANA,cACA,0CAEA,MADA,oBACA,CACA,EAAa,EAEb,aAEA,mBACA,+BACA,uCAEA,+CACA,IACA,eAHA,IAKA,GADA,KACA,eACA,kCAAkD,EAAM,GAExD,mBARA,IASA,KACA,oBAVA,IAaA,OAFA,KAEA,CACA,UACA,QACA,gBACA,SALA,cAZA,GAkBA,CACA,CACA,WAOA,OANA,aACA,wCAEA,MADA,mBACA,CACA,EAAa,EAEb,YAEA,kBACA,6BACA,iDACA,kCAEA,+CACA,IACA,gBAHA,IAIA,KAEA,KACA,SACA,0BACA,YAAwB,IAAmB,KAC3C,oBACA,KACA,kCAEA,GADA,KACA,eACA,8BAfA,KAgBA,KACA,QAAiC,gBAA0B,CAC3D,KACA,CACA,oBApBA,IAqBA,KACA,QAAiC,gBAA0B,CAC3D,CACA,CACA,uCAAmD,WAAc,UACjE,CAIA,yBAEA,mBADA,sBAEA,CASA,yBACA,4BACA,iBACA,uEACA,KACA,2BACA,UAEA,QACA,CAMA,yBAEA,MADA,uBACA,IACA,wCACA,CACA,0BACA,0CACA,CACA,sBACA,sCAEA,IACA,+CACA,gBAHA,IAIA,KACA,oBALA,IAOA,OADA,KACA,SAAiB,gBACjB,CACA,oBACA,sCAEA,IACA,+CACA,gBAHA,IAIA,KACA,SACA,YAAwB,IAAiB,KACzC,oBAPA,IAQA,KACA,SACA,CACA,SACA,YAAwB,IAAiB,KACzC,oBAbA,IAcA,KACA,SACA,CAEA,OACA,eAFA,cAjBA,IAoBA,cACA,cACA,CACA,CACA,oBACA,sCAEA,IACA,+CACA,gBAHA,IAIA,KACA,SACA,YAAwB,IAAoB,KAC5C,oBAPA,IAQA,KACA,SACA,CACA,SACA,YAAwB,IAAoB,KAC5C,oBAbA,IAcA,KACA,SACA,CAEA,OACA,iBACA,iBACA,kBACA,SALA,aAjBA,GAuBA,CACA,CACA,4BACA,6BACA,oBACA,6BACA,uBACA,iCAaA,MAZA,CACA,kBACA,SACA,sBACA,oBACa,CACb,YACA,yBACA,uBACa,CACb,qBACA,CAEA,CAYA,oDAEA,MADA,uBACA,IACA,MACA,OAGA,uCACA,OACA,qDAGA,aACA,cAEA,uEACA,yEACA,uBACA,kBACA,gDACA,KACA,YAAgD,IAA6B,MAE7E,8BACA,UAEA,YACA,eACA,WAEA,SACA,eACA,YACA,gBACA,KAAuB,aAAoE,KAC3F,aAEA,IACA,KACA,CACA,wBACA,MACA,OACA,KACA,QACA,QAEA,CACA,QACA,CACA,mCAEA,EACA,EACA,2BAEA,QADA,MACA,KAEA,gBACA,IACA,KACA,OAEA,YACA,MAGA,cACA,QAGA,aACA,aAEA,iBACA,YAA2C,IAAwB,KACnE,QACA,WACA,cACA,WAGA,QACA,CACA,2DEpUe,iBAA4B,qBAAmB,CAC9D,uBACA,MAAqB,oBAAc,mCACnC,uDACA,MAAyB,kBAAY,uBAErC,0BADA,2BAEA,oBACA,sBACA,QACA,sBACA,aACa,EACb,CAEA,CACA,iBACA,OACA,WAAwB,EAAU,CAClC,OADkC,IACN,kBAAY,mDACxC,CAAa,EACb,0CACA,CACA,CACA,cAOA,OANA,aACA,uCAEA,MADA,mBACA,CACA,EAAa,EAEb,YAEA,oBACA,IAAgB,2BAAyB,mBACzC,SACA,eACA,oBACA,CACA,mBACA,mBAAgB,YAAyB,mBACzC,KACA,+BACA,UACA,QACA,SACA,CAAa,CAEb,EACA,iCACA,+BACA,UACA,QACA,QACA,CAAa,EACb,CACA,CACA,qBAAkB,gBAAqB,EACvC,MAAe,sBAAgB,WAC/B,WAAoB,GAAS,mBAC7B,6BACA,6BACA,6BACA,GACA,WAAkC,SAAa,EAC/C,MAA2B,GAAS,EAAE,EAAM,GAAG,EAAU,EACzD,cAA4B,sBAAqC,CAChD,GAEjB,YACA,CAAS,CACT,CACA,iBACA","sources":["webpack://_N_E/./node_modules/@gmod/twobit/esm/bigint-polyfill/pure.js","webpack://_N_E/./node_modules/@gmod/twobit/esm/bigint-polyfill/polyfill.js","webpack://_N_E/./node_modules/@gmod/twobit/esm/twoBitFile.js","webpack://_N_E/./node_modules/@gmod/twobit/esm/index.js","webpack://_N_E/./node_modules/@jbrowse/plugin-sequence/esm/TwoBitAdapter/TwoBitAdapter.js"],"sourcesContent":["const BigInt32 = BigInt(32);\nexport function getBigInt64(dataView, byteOffset, littleEndian) {\n    const littleEndianMask = Number(!!littleEndian);\n    const bigEndianMask = Number(!littleEndian);\n    return ((BigInt(dataView.getInt32(byteOffset, littleEndian) * bigEndianMask +\n        dataView.getInt32(byteOffset + 4, littleEndian) * littleEndianMask) <<\n        BigInt32) |\n        BigInt(dataView.getUint32(byteOffset, littleEndian) * littleEndianMask +\n            dataView.getUint32(byteOffset + 4, littleEndian) * bigEndianMask));\n}\nexport function getBigUint64(dataView, byteOffset, littleEndian) {\n    const a = dataView.getUint32(byteOffset, littleEndian);\n    const b = dataView.getUint32(byteOffset + 4, littleEndian);\n    const littleEndianMask = Number(!!littleEndian);\n    const bigEndianMask = Number(!littleEndian);\n    // This branch-less optimization is 77x faster than normal ternary operator.\n    // and only 3% slower than native implementation\n    // https://jsbench.me/p8kyhg1eqv/1\n    return ((BigInt(a * bigEndianMask + b * littleEndianMask) << BigInt32) |\n        BigInt(a * littleEndianMask + b * bigEndianMask));\n}\n//# sourceMappingURL=pure.js.map","import { getBigInt64, getBigUint64 } from './pure';\nif (!('getBigInt64' in DataView)) {\n    DataView.prototype.getBigInt64 = function (byteOffset, littleEndian) {\n        return getBigInt64(this, byteOffset, littleEndian);\n    };\n}\nif (!('getBigUint64' in DataView)) {\n    DataView.prototype.getBigUint64 = function (byteOffset, littleEndian) {\n        return getBigUint64(this, byteOffset, littleEndian);\n    };\n}\n//# sourceMappingURL=polyfill.js.map","import { LocalFile } from 'generic-filehandle2';\nconst TWOBIT_MAGIC = 0x1a412743;\nconst twoBit = ['T', 'C', 'A', 'G'];\n// byteTo4Bases is an array of byteValue -> 'ACTG'\nconst byteTo4Bases = [];\nfor (let index = 0; index < 256; index++) {\n    byteTo4Bases.push(twoBit[(index >> 6) & 3] +\n        twoBit[(index >> 4) & 3] +\n        twoBit[(index >> 2) & 3] +\n        twoBit[index & 3]);\n}\nconst maskedByteTo4Bases = byteTo4Bases.map(bases => bases.toLowerCase());\nexport default class TwoBitFile {\n    /**\n     * @param {object} args\n     * @param {string} [args.path] filesystem path for the .2bit file to open\n     * @param {Filehandle} [args.filehandle] node fs.promises-like filehandle for the .2bit file.\n     *  Only needs to support `filehandle.read(buffer, offset, length, position)`\n     */\n    constructor({ filehandle, path, }) {\n        if (filehandle) {\n            this.filehandle = filehandle;\n        }\n        else if (path) {\n            this.filehandle = new LocalFile(path);\n        }\n        else {\n            throw new Error('must supply path or filehandle');\n        }\n    }\n    async _detectEndianness() {\n        const buffer = await this.filehandle.read(8, 0);\n        const dataView = new DataView(buffer.buffer);\n        const magic = dataView.getInt32(0, true);\n        if (magic === TWOBIT_MAGIC) {\n            this.version = dataView.getInt32(0, true);\n        }\n        else {\n            throw new Error('not a 2bit file');\n        }\n    }\n    getHeader() {\n        if (!this.headerP) {\n            this.headerP = this._getHeader().catch((error) => {\n                this.headerP = undefined;\n                throw error;\n            });\n        }\n        return this.headerP;\n    }\n    async _getHeader() {\n        await this._detectEndianness();\n        const b = await this.filehandle.read(16, 0);\n        const le = true;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        let offset = 0;\n        const magic = dataView.getInt32(offset, le);\n        offset += 4;\n        if (magic !== 0x1a412743) {\n            throw new Error(`Wrong magic number ${magic}`);\n        }\n        const version = dataView.getInt32(offset, le);\n        offset += 4;\n        const sequenceCount = dataView.getUint32(offset, le);\n        offset += 4;\n        const reserved = dataView.getUint32(offset, le);\n        return {\n            version,\n            magic,\n            sequenceCount,\n            reserved,\n        };\n    }\n    getIndex() {\n        if (!this.indexP) {\n            this.indexP = this._getIndex().catch((error) => {\n                this.indexP = undefined;\n                throw error;\n            });\n        }\n        return this.indexP;\n    }\n    async _getIndex() {\n        const header = await this.getHeader();\n        const maxIndexLength = 8 + header.sequenceCount * (1 + 256 + (this.version === 1 ? 8 : 4));\n        const b = await this.filehandle.read(maxIndexLength, 8);\n        const le = true;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        let offset = 0;\n        const sequenceCount = dataView.getUint32(offset, le);\n        offset += 4;\n        // const reserved = dataView.getUint32(offset, le)\n        offset += 4;\n        const indexData = [];\n        const decoder = new TextDecoder('utf8');\n        for (let i = 0; i < sequenceCount; i++) {\n            const nameLength = dataView.getUint8(offset);\n            offset += 1;\n            const name = decoder.decode(b.subarray(offset, offset + nameLength));\n            offset += nameLength;\n            if (header.version === 1) {\n                const dataOffset = Number(dataView.getBigUint64(offset, le));\n                offset += 8;\n                indexData.push({ offset: dataOffset, name });\n            }\n            else {\n                const dataOffset = dataView.getUint32(offset, le);\n                offset += 4;\n                indexData.push({ offset: dataOffset, name });\n            }\n        }\n        return Object.fromEntries(indexData.map(({ name, offset }) => [name, offset]));\n    }\n    /**\n     * @returns for an array of string sequence names that are found in the file\n     */\n    async getSequenceNames() {\n        const index = await this.getIndex();\n        return Object.keys(index);\n    }\n    /**\n     * @returns object listing the lengths of all sequences like `{seqName:\n     * length, ...}`.\n     *\n     * note: this is a relatively slow operation especially if there are many\n     * refseqs in the file, if you can get this information from a different file\n     * e.g. a chrom.sizes file, it will be much faster\n     */\n    async getSequenceSizes() {\n        const index = await this.getIndex();\n        const seqNames = Object.keys(index);\n        const sizes = await Promise.all(Object.values(index).map(offset => this._getSequenceSize(offset)));\n        const returnObject = {};\n        for (const [index_, seqName] of seqNames.entries()) {\n            returnObject[seqName] = sizes[index_];\n        }\n        return returnObject;\n    }\n    /**\n     * @param seqName name of the sequence\n     *\n     * @returns sequence length, or undefined if it is not in the file\n     */\n    async getSequenceSize(seqName) {\n        const index = await this.getIndex();\n        const offset = index[seqName];\n        return offset ? this._getSequenceSize(offset) : undefined;\n    }\n    async _getSequenceSize(offset) {\n        return this._record1(offset).then(f => f.dnaSize);\n    }\n    async _record1(offset2, len = 8) {\n        const b = await this.filehandle.read(len, offset2);\n        const le = true;\n        let offset = 0;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        const dnaSize = dataView.getUint32(offset, le);\n        offset += 4;\n        const nBlockCount = dataView.getUint32(offset, le);\n        offset += 4;\n        return { dnaSize, nBlockCount };\n    }\n    async _record2(offset2, len) {\n        const b = await this.filehandle.read(len, offset2);\n        const le = true;\n        let offset = 0;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        const nBlockCount = dataView.getUint32(offset, le);\n        offset += 4;\n        const nBlockStarts = [];\n        for (let i = 0; i < nBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            nBlockStarts.push(elt);\n        }\n        const nBlockSizes = [];\n        for (let i = 0; i < nBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            nBlockSizes.push(elt);\n        }\n        const maskBlockCount = dataView.getUint32(offset, le);\n        return {\n            maskBlockCount,\n            nBlockSizes,\n            nBlockStarts,\n        };\n    }\n    async _record3(offset2, len) {\n        const b = await this.filehandle.read(len, offset2);\n        const le = true;\n        let offset = 0;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        const maskBlockCount = dataView.getUint32(offset, le);\n        offset += 4;\n        const maskBlockStarts = [];\n        for (let i = 0; i < maskBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            maskBlockStarts.push(elt);\n        }\n        const maskBlockSizes = [];\n        for (let i = 0; i < maskBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            maskBlockSizes.push(elt);\n        }\n        const reserved = dataView.getInt32(offset, le);\n        return {\n            maskBlockCount,\n            maskBlockSizes,\n            maskBlockStarts,\n            reserved,\n        };\n    }\n    async _getSequenceRecord(offset) {\n        const rec1 = await this._record1(offset);\n        const rec2DataLen = rec1.nBlockCount * 8 + 8;\n        const rec2 = await this._record2(offset + 4, rec2DataLen);\n        const rec3DataLen = rec2.maskBlockCount * 8 + 8;\n        const rec3 = await this._record3(offset + 4 + rec2DataLen - 4, rec3DataLen);\n        const rec = {\n            dnaSize: rec1.dnaSize,\n            nBlocks: {\n                starts: rec2.nBlockStarts,\n                sizes: rec2.nBlockSizes,\n            },\n            maskBlocks: {\n                starts: rec3.maskBlockStarts,\n                sizes: rec3.maskBlockSizes,\n            },\n            dnaPosition: offset + 4 + rec2DataLen - 4 + rec3DataLen,\n        };\n        return rec;\n    }\n    /**\n     * @param seqName name of the sequence you want\n     *\n     * @param [regionStart] optional 0-based half-open start of the sequence\n     * region to fetch.\n     *\n     * @param [regionEnd] optional 0-based half-open end of the sequence region\n     * to fetch. defaults to end of the sequence\n     *\n     * @returns for a string of sequence bases\n     */\n    async getSequence(seqName, regionStart = 0, regionEnd = Number.POSITIVE_INFINITY) {\n        const index = await this.getIndex();\n        const offset = index[seqName];\n        if (!offset) {\n            return undefined;\n        }\n        // fetch the record for the seq\n        const record = await this._getSequenceRecord(offset);\n        if (regionStart < 0) {\n            throw new TypeError('regionStart cannot be less than 0');\n        }\n        // end defaults to the end of the sequence\n        if (regionEnd > record.dnaSize) {\n            regionEnd = record.dnaSize;\n        }\n        const nBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.nBlocks.starts, record.nBlocks.sizes);\n        const maskBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.maskBlocks.starts, record.maskBlocks.sizes);\n        const baseBytesLen = Math.ceil((regionEnd - regionStart) / 4) + 1;\n        const baseBytesOffset = Math.floor(regionStart / 4);\n        const buffer = await this.filehandle.read(baseBytesLen, record.dnaPosition + baseBytesOffset);\n        let sequenceBases = '';\n        for (let genomicPosition = regionStart; genomicPosition < regionEnd; genomicPosition += 1) {\n            // check whether we are currently masked\n            while (maskBlocks.length > 0 && maskBlocks[0].end <= genomicPosition) {\n                maskBlocks.shift();\n            }\n            const baseIsMasked = maskBlocks[0] &&\n                maskBlocks[0].start <= genomicPosition &&\n                maskBlocks[0].end > genomicPosition;\n            // process the N block if we have one\n            if (nBlocks[0] &&\n                genomicPosition >= nBlocks[0].start &&\n                genomicPosition < nBlocks[0].end) {\n                const currentNBlock = nBlocks.shift();\n                for (; genomicPosition < currentNBlock.end && genomicPosition < regionEnd; genomicPosition += 1) {\n                    sequenceBases += baseIsMasked ? 'n' : 'N';\n                }\n                genomicPosition -= 1;\n            }\n            else {\n                const bytePosition = Math.floor(genomicPosition / 4) - baseBytesOffset;\n                const subPosition = genomicPosition % 4;\n                const byte = buffer[bytePosition];\n                sequenceBases += baseIsMasked\n                    ? maskedByteTo4Bases[byte][subPosition]\n                    : byteTo4Bases[byte][subPosition];\n            }\n        }\n        return sequenceBases;\n    }\n    _getOverlappingBlocks(regionStart, regionEnd, blockStarts, blockSizes) {\n        // find the start and end indexes of the blocks that match\n        let startIndex;\n        let endIndex;\n        for (const [index, blockStart] of blockStarts.entries()) {\n            const blockSize = blockSizes[index];\n            if (regionStart >= blockStart + blockSize || regionEnd <= blockStart) {\n                // block does not overlap the region\n                if (startIndex !== undefined) {\n                    endIndex = index;\n                    break;\n                }\n            }\n            else if (startIndex === undefined) {\n                startIndex = index;\n            } // block does overlap the region, record this if it is the first\n        }\n        if (startIndex === undefined) {\n            return [];\n        }\n        // now format some block objects to return\n        if (endIndex === undefined) {\n            endIndex = blockStarts.length;\n        }\n        const blocks = new Array(endIndex - startIndex);\n        for (let blockNumber = startIndex; blockNumber < endIndex; blockNumber += 1) {\n            blocks[blockNumber - startIndex] = {\n                start: blockStarts[blockNumber],\n                end: blockStarts[blockNumber] + blockSizes[blockNumber],\n                size: blockSizes[blockNumber],\n            };\n        }\n        return blocks;\n    }\n}\n//# sourceMappingURL=twoBitFile.js.map","import './bigint-polyfill/polyfill';\nexport { default as TwoBitFile } from './twoBitFile';\n//# sourceMappingURL=index.js.map","import { TwoBitFile } from '@gmod/twobit';\nimport { readConfObject } from '@jbrowse/core/configuration';\nimport { BaseSequenceAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nexport default class TwoBitAdapter extends BaseSequenceAdapter {\n    async initChromSizes() {\n        const conf = readConfObject(this.config, 'chromSizesLocation');\n        if (conf.uri !== '/path/to/default.chrom.sizes' && conf.uri !== '') {\n            const file = openLocation(conf, this.pluginManager);\n            const data = await file.readFile('utf8');\n            return Object.fromEntries(data\n                .split(/\\n|\\r\\n|\\r/)\n                .filter(line => !!line.trim())\n                .map(line => {\n                const [name, length] = line.split('\\t');\n                return [name, +length];\n            }));\n        }\n        return undefined;\n    }\n    async setupPre() {\n        return {\n            twobit: new TwoBitFile({\n                filehandle: openLocation(this.getConf('twoBitLocation'), this.pluginManager),\n            }),\n            chromSizesData: await this.initChromSizes(),\n        };\n    }\n    async setup() {\n        if (!this.setupP) {\n            this.setupP = this.setupPre().catch((e) => {\n                this.setupP = undefined;\n                throw e;\n            });\n        }\n        return this.setupP;\n    }\n    async getRefNames() {\n        const { chromSizesData, twobit } = await this.setup();\n        return chromSizesData\n            ? Object.keys(chromSizesData)\n            : twobit.getSequenceNames();\n    }\n    async getRegions() {\n        const { chromSizesData, twobit } = await this.setup();\n        if (chromSizesData) {\n            return Object.keys(chromSizesData).map(refName => ({\n                refName,\n                start: 0,\n                end: chromSizesData[refName],\n            }));\n        }\n        else {\n            const refSizes = await twobit.getSequenceSizes();\n            return Object.keys(refSizes).map(refName => ({\n                refName,\n                start: 0,\n                end: refSizes[refName],\n            }));\n        }\n    }\n    getFeatures({ refName, start, end }) {\n        return ObservableCreate(async (observer) => {\n            const { twobit } = await this.setup();\n            const size = await twobit.getSequenceSize(refName);\n            const regionEnd = size !== undefined ? Math.min(size, end) : end;\n            const seq = await twobit.getSequence(refName, start, regionEnd);\n            if (seq) {\n                observer.next(new SimpleFeature({\n                    id: `${refName} ${start}-${regionEnd}`,\n                    data: { refName, start, end: regionEnd, seq },\n                }));\n            }\n            observer.complete();\n        });\n    }\n    freeResources() { }\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4]}