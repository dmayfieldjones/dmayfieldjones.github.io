"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8698],{56317:(e,t,i)=>{i.r(t),i.d(t,{default:()=>w});let n=BigInt(32);"getBigInt64"in DataView||(DataView.prototype.getBigInt64=function(e,t){return function(e,t,i){let a=Number(!!i),r=Number(!i);return BigInt(e.getInt32(t,i)*r+e.getInt32(t+4,i)*a)<<n|BigInt(e.getUint32(t,i)*a+e.getUint32(t+4,i)*r)}(this,e,t)}),"getBigUint64"in DataView||(DataView.prototype.getBigUint64=function(e,t){return function(e,t,i){let a=e.getUint32(t,i),r=e.getUint32(t+4,i),s=Number(!!i),l=Number(!i);return BigInt(a*l+r*s)<<n|BigInt(a*s+r*l)}(this,e,t)});var a=i(82485),r=i(75927);let s=["T","C","A","G"],l=[];for(let e=0;e<256;e++)l.push(s[e>>6&3]+s[e>>4&3]+s[e>>2&3]+s[3&e]);let o=l.map(e=>e.toLowerCase());class h{constructor({filehandle:e,path:t}){if(e)this.filehandle=e;else if(t)this.filehandle=new a.LocalFile(t);else throw Error("must supply path or filehandle")}async _detectEndianness(){let{buffer:e}=await this.filehandle.read(r.Buffer.allocUnsafe(8),0,8,0);if(0x1a412743===e.readInt32LE(0))this.version=e.readInt32LE(4);else if(0x1a412743===e.readInt32BE(0))throw Error("big endian not supported");else throw Error("not a 2bit file")}getHeader(){return this.headerP||(this.headerP=this._getHeader().catch(e=>{throw this.headerP=void 0,e})),this.headerP}async _getHeader(){await this._detectEndianness();let{buffer:e}=await this.filehandle.read(r.Buffer.allocUnsafe(16),0,16,0),t=new DataView(e.buffer,e.byteOffset,e.length),i=0,n=t.getInt32(i,!0);if(i+=4,0x1a412743!==n)throw Error(`Wrong magic number ${n}`);let a=t.getInt32(i,!0);i+=4;let s=t.getUint32(i,!0);return i+=4,{version:a,magic:n,sequenceCount:s,reserved:t.getUint32(i,!0)}}getIndex(){return this.indexP||(this.indexP=this._getIndex().catch(e=>{throw this.indexP=void 0,e})),this.indexP}async _getIndex(){let e=await this.getHeader(),t=8+e.sequenceCount*(257+(1===this.version?8:4)),{buffer:i}=await this.filehandle.read(r.Buffer.allocUnsafe(t),0,t,8),n=new DataView(i.buffer,i.byteOffset,i.length),a=0,s=n.getUint32(a,!0);a+=4,a+=4;let l=[];for(let t=0;t<s;t++){let t=n.getUint8(a);a+=1;let r=i.subarray(a,a+t).toString();if(a+=t,1===e.version){let e=Number(n.getBigUint64(a,!0));a+=8,l.push({offset:e,name:r})}else{let e=n.getUint32(a,!0);a+=4,l.push({offset:e,name:r})}}return Object.fromEntries(l.map(({name:e,offset:t})=>[e,t]))}async getSequenceNames(){return Object.keys(await this.getIndex())}async getSequenceSizes(){let e=await this.getIndex(),t=Object.keys(e),i=Object.values(e).map(e=>this._getSequenceSize(e)),n=await Promise.all(i),a={};for(let[e,i]of t.entries())a[i]=n[e];return a}async getSequenceSize(e){let t=(await this.getIndex())[e];if(t)return this._getSequenceSize(t)}async _getSequenceSize(e){return this._record1(e).then(e=>e.dnaSize)}async _record1(e,t=8){let{buffer:i}=await this.filehandle.read(r.Buffer.allocUnsafe(t),0,t,e),n=0,a=new DataView(i.buffer,i.byteOffset,i.length),s=a.getUint32(n,!0);n+=4;let l=a.getUint32(n,!0);return n+=4,{dnaSize:s,nBlockCount:l}}async _record2(e,t){let{buffer:i}=await this.filehandle.read(r.Buffer.allocUnsafe(t),0,t,e),n=0,a=new DataView(i.buffer,i.byteOffset,i.length),s=a.getUint32(n,!0);n+=4;let l=[];for(let e=0;e<s;e++){let e=a.getUint32(n,!0);n+=4,l.push(e)}let o=[];for(let e=0;e<s;e++){let e=a.getUint32(n,!0);n+=4,o.push(e)}return{maskBlockCount:a.getUint32(n,!0),nBlockSizes:o,nBlockStarts:l}}async _record3(e,t){let{buffer:i}=await this.filehandle.read(r.Buffer.allocUnsafe(t),0,t,e),n=0,a=new DataView(i.buffer,i.byteOffset,i.length),s=a.getUint32(n,!0);n+=4;let l=[];for(let e=0;e<s;e++){let e=a.getUint32(n,!0);n+=4,l.push(e)}let o=[];for(let e=0;e<s;e++){let e=a.getUint32(n,!0);n+=4,o.push(e)}return{maskBlockCount:s,maskBlockSizes:o,maskBlockStarts:l,reserved:a.getInt32(n,!0)}}async _getSequenceRecord(e){let t=await this._record1(e),i=8*t.nBlockCount+8,n=await this._record2(e+4,i),a=8*n.maskBlockCount+8,r=await this._record3(e+4+i-4,a);return{dnaSize:t.dnaSize,nBlocks:{starts:n.nBlockStarts,sizes:n.nBlockSizes},maskBlocks:{starts:r.maskBlockStarts,sizes:r.maskBlockSizes},dnaPosition:e+4+i-4+a}}async getSequence(e,t=0,i=Number.POSITIVE_INFINITY){let n=(await this.getIndex())[e];if(!n)return;let a=await this._getSequenceRecord(n);if(t<0)throw TypeError("regionStart cannot be less than 0");i>a.dnaSize&&(i=a.dnaSize);let s=this._getOverlappingBlocks(t,i,a.nBlocks.starts,a.nBlocks.sizes),h=this._getOverlappingBlocks(t,i,a.maskBlocks.starts,a.maskBlocks.sizes),f=r.Buffer.allocUnsafe(Math.ceil((i-t)/4)+1),c=Math.floor(t/4),{buffer:u}=await this.filehandle.read(f,0,f.length,a.dnaPosition+c),g="";for(let e=t;e<i;e+=1){for(;h.length>0&&h[0].end<=e;)h.shift();let t=h[0]&&h[0].start<=e&&h[0].end>e;if(s[0]&&e>=s[0].start&&e<s[0].end){let n=s.shift();for(;e<n.end&&e<i;e+=1)g+=t?"n":"N";e-=1}else{let i=Math.floor(e/4)-c,n=e%4,a=u[i];g+=t?o[a][n]:l[a][n]}}return g}_getOverlappingBlocks(e,t,i,n){let a,r;for(let[s,l]of i.entries())if(e>=l+n[s]||t<=l){if(void 0!==a){r=s;break}}else void 0===a&&(a=s);if(void 0===a)return[];void 0===r&&(r=i.length);let s=Array(r-a);for(let e=a;e<r;e+=1)s[e-a]={start:i[e],end:i[e]+n[e],size:n[e]};return s}}var f=i(53394),c=i(92766),u=i(31177),g=i(72471),d=i(61550);class w extends c.BaseSequenceAdapter{async initChromSizes(){let e=(0,f.readConfObject)(this.config,"chromSizesLocation");if("/path/to/default.chrom.sizes"!==e.uri&&""!==e.uri){let t=(0,u.openLocation)(e,this.pluginManager);return Object.fromEntries((await t.readFile("utf8")).split(/\n|\r\n|\r/).filter(e=>!!e.trim()).map(e=>{let[t,i]=e.split("	");return[t,+i]}))}}async setupPre(){return{twobit:new h({filehandle:(0,u.openLocation)(this.getConf("twoBitLocation"),this.pluginManager)}),chromSizesData:await this.initChromSizes()}}async setup(){return this.setupP||(this.setupP=this.setupPre().catch(e=>{throw this.setupP=void 0,e})),this.setupP}async getRefNames(){let{chromSizesData:e,twobit:t}=await this.setup();return e?Object.keys(e):t.getSequenceNames()}async getRegions(){let{chromSizesData:e,twobit:t}=await this.setup();if(e)return Object.keys(e).map(t=>({refName:t,start:0,end:e[t]}));{let e=await t.getSequenceSizes();return Object.keys(e).map(t=>({refName:t,start:0,end:e[t]}))}}getFeatures({refName:e,start:t,end:i}){return(0,g.ObservableCreate)(async n=>{let{twobit:a}=await this.setup(),r=await a.getSequenceSize(e),s=void 0!==r?Math.min(r,i):i,l=await a.getSequence(e,t,s);l&&n.next(new d.default({id:`${e} ${t}-${s}`,data:{refName:e,start:t,end:s,seq:l}})),n.complete()})}freeResources(){}}}}]);
//# sourceMappingURL=8698.c297e9180d806212.js.map