{"version":3,"file":"static/chunks/2438.c75fe385c8b18e27.js","mappings":"uNCGO,cACP,qDACA,CACO,oBACP,mBACA,OACA,YACA,aACA,iBACA,OACA,IACA,GACA,GAEA,eACA,MACA,CACO,sBACP,mBACA,OACA,YACA,aACA,iBACA,OACA,IACA,GACA,GAEA,eACA,wBACA,MACA,sCI5BO,gCAAsC,6BAAwC,EACrF,cAAY,aAAqB,EACjC,KACA,KACA,wBACA,YACA,oBACA,gBAUA,GATA,0BACY,oBAAc,IAC1B,sBLhBO,YKkBa,MLlBW,kBAAwB,EACvD,qBACA,eACA,kBACA,gBACA,YAAyB,MAAc,KACvC,gBACA,YACA,eACA,OACA,QACA,eACA,KACA,iBACA,aACA,OACA,IACA,GACA,CAAqB,CACrB,OAA4B,CAC5B,OAA4B,CAC5B,UAA+B,CAC/B,WAAgC,CAChC,SAA8B,CAC9B,EAEA,QACA,aACA,oBACA,sBACA,eAGA,CACA,EKhBoB,CACpB,UACA,OACA,QACA,CAAS,EACT,2CACA,eACA,KACA,QACA,WACA,CAAa,OACD,SF1BL,CAAgC,qDAAiD,EACxF,UACA,qBACA,kBACA,eACA,0EACA,6FACA,GAAU,OAA2B,mCAA8D,oBAAsB,MACzH,YACA,OAEA,kBACA,4BACA,eACA,OACA,QACA,eACA,OAA4B,CAC5B,KACA,iBACA,aACA,OACA,IACA,GACA,CAAqB,CACrB,OAA4B,CAC5B,UAA+B,CAC/B,WAAgC,CAChC,SAA8B,CAC9B,EAEA,QAA0B,SAAG,IAC7B,OACA,eACA,KAAgC,SAAG,IACnB,EAAoB,wBAAoC,EAAK,KAG7D,EAAoB,kBAA8B,EAAK,IAEvE,CACA,CAAK,CACL,EEhBgC,CAChC,UACA,UACA,OACA,SACA,yBACA,CAAa,CACb,MACA,4CACA,eACA,KACA,QACA,WACA,CAAa,ODtCN,kBAAgC,mCAAwC,EAC/E,MACA,qBACA,eACA,kBACA,eACA,kDACA,kBACA,MACA,MAAyB,QAAU,iBACnC,UAAgB,eAAsB,CAAE,OAAW,MACnD,mCACA,YAAwB,MAAmB,KAC3C,UACA,iBACA,iBACA,qBACA,mBACA,iBACA,OACA,SACA,OACA,SACA,uBACA,uBACA,IACwB,EAAoB,4BAC5C,mBACA,YAEA,IACwB,EAAoB,4BAC5C,mBACA,cAIA,GACA,WAA4C,oBAAc,wCAC9B,EAAoB,qCAChD,mBACA,YAGA,GACA,WAA4C,oBAAc,0CAC9B,EAAoB,qCAChD,mBACA,YAIA,CACA,CACA,CACA,EChBgC,CAChC,UACA,OACA,SACA,gBACA,CAAa,CACb,EHhDO,iBGiDkB,CHjDW,4BAAiC,MACrE,EACA,qBACA,kBAEA,aADA,gDACA,CACA,gBACA,EDPA,KCOqB,GDPrB,QCOgC,IDPhC,CCQA,MACA,YAA6B,MAAmB,KAChD,gBACA,qBACA,WACA,MAAwB,oBAAsB,EAC9C,EAAkC,EAAW,EAC7C,OAD6C,OAC7C,eACoB,EAAG,kBACvB,WAEA,EAOoB,EAAG,iBANH,EAAG,cACvB,mBACA,WACA,YAKA,CACA,CACA,oBACA,oBACA,+CACA,sBACA,UACA,EACA,QACA,GACA,2BACA,KAA4B,EAAO,GAAG,EAAK,GAAG,EAAgB,CAC9D,gBACA,OACA,UACA,QACA,MACA,SACA,kBACA,OACA,GAEA,YACA,CACA,CACA,EGJyB,SAAG,4BAAgC,CAC5D,CACA,eACA,IACA,8DACA,CACA,EACA,CACA,KACA,sCAC8B,SAAG,yCACjC,MACA,CAAqB,CACrB,GAEA,oEACA,CACA,EACA,CACA,KACA,sCAC8B,SAAG,yCACjC,MACA,CAAqB,CACrB,IAIA,OACA,OACA,SACA,CACA,CC3Ee,gBAAiC,wBAAsB,CACtE,kBACA,QACA,iCACA,oBACA,0EACA,IACA,wEACA,OACA,MACA,wCAEA,OACA,yBACA,6CAEA,CACA,uBACA,oBAAgB,GAAkB,uBAClC,KAGA,MAAe,QAAa,KAC5B,CACA,kBAAiC,EACjC,MAAe,sBAAgB,WAC/B,eAAoB,GAAa,uBACjC,QAAmC,OAAc,yBAA2C,OAAO,KACnG,CAAoB,kBAAgB,MAAQ,EAAoB,CAChE,WACA,MAFgE,CAEhE,EACA,OACA,sCACA,CAAa,EACb,kBACA,gBACA,WAAkC,SAAa,EAC/C,MAA2B,QAAQ,GAAG,EAAM,EAC5C,MACA,cACA,UACA,QACA,QACA,kBACqB,CACJ,EACjB,CAAa,EACb,oCACA,WAAkC,SAAa,EAC/C,KACA,MACA,YACA,cACA,UACA,gBACA,cACA,kCACqB,CACJ,EACjB,CAAa,EACb,YACA,CAAS,aACT,CACA,6CACA,eAAgB,GAAa,uBAC7B,+CACA,CACA,sBAA+B,EAC/B,eAAgB,GAAa,uBAC7B,uBACA,CACA,iBACA,oFC5EO,gBACP,sBACA,eACA,EAAe,QAAS,kBACxB,KAA4B,QAAU,iBACtC,MACA,MAA8B,QAAe,QAC7C,EAA8B,QAAmB,IACjD,KACA,IACA,aAAqB,eAAkB,KACvC,YAAyB,SAAW,CAAG,OAAa,OACpD,uDACA,QAOA,CACA,WACA,MACA,2BACA,wBACA,sBACA,CACA,MAbA,MACA,OACA,OACA,aAWA,CACA,YAEA,QACA,CAEA","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/processDepth.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/util.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/processMismatches.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/processModifications.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/processReferenceCpGs.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/generateCoverageBins.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/SNPCoverageAdapter.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/shared/getMaximumModificationAtEachPosition.js"],"sourcesContent":["export function processDepth({ feature, bins, region, }) {\n    const fstart = feature.get('start');\n    const fend = feature.get('end');\n    const fstrand = feature.get('strand');\n    const regionLength = region.end - region.start;\n    for (let j = fstart; j < fend + 1; j++) {\n        const i = j - region.start;\n        if (i >= 0 && i < regionLength) {\n            if (bins[i] === undefined) {\n                bins[i] = {\n                    depth: 0,\n                    readsCounted: 0,\n                    ref: {\n                        probabilities: [],\n                        entryDepth: 0,\n                        '-1': 0,\n                        0: 0,\n                        1: 0,\n                    },\n                    snps: {},\n                    mods: {},\n                    nonmods: {},\n                    delskips: {},\n                    noncov: {},\n                };\n            }\n            if (j !== fend) {\n                bins[i].depth++;\n                bins[i].readsCounted++;\n                bins[i].ref.entryDepth++;\n                bins[i].ref[fstrand]++;\n            }\n        }\n    }\n}\n","export function mismatchLen(mismatch) {\n    return !isInterbase(mismatch.type) ? mismatch.length : 1;\n}\nexport function isInterbase(type) {\n    return type === 'softclip' || type === 'hardclip' || type === 'insertion';\n}\nexport function inc(bin, strand, type, field) {\n    let thisBin = bin[type][field];\n    if (thisBin === undefined) {\n        thisBin = bin[type][field] = {\n            entryDepth: 0,\n            probabilities: [],\n            '-1': 0,\n            '0': 0,\n            '1': 0,\n        };\n    }\n    thisBin.entryDepth++;\n    thisBin[strand]++;\n}\nexport function incWithProbabilities(bin, strand, type, field, probability) {\n    let thisBin = bin[type][field];\n    if (thisBin === undefined) {\n        thisBin = bin[type][field] = {\n            entryDepth: 0,\n            probabilities: [],\n            '-1': 0,\n            '0': 0,\n            '1': 0,\n        };\n    }\n    thisBin.entryDepth++;\n    thisBin.probabilities.push(probability);\n    thisBin[strand]++;\n}\n","import { inc, isInterbase, mismatchLen } from './util';\nexport function processMismatches({ feature, region, bins, skipmap, }) {\n    var _a;\n    const fstart = feature.get('start');\n    const fstrand = feature.get('strand');\n    const mismatches = (_a = feature.get('mismatches')) !== null && _a !== void 0 ? _a : [];\n    for (const mismatch of mismatches) {\n        const mstart = fstart + mismatch.start;\n        const mlen = mismatchLen(mismatch);\n        const mend = mstart + mlen;\n        for (let j = mstart; j < mstart + mlen; j++) {\n            const epos = j - region.start;\n            if (epos >= 0 && epos < bins.length) {\n                const bin = bins[epos];\n                const { base, altbase, type } = mismatch;\n                const interbase = isInterbase(type);\n                if (type === 'deletion' || type === 'skip') {\n                    inc(bin, fstrand, 'delskips', type);\n                    bin.depth--;\n                }\n                else if (!interbase) {\n                    inc(bin, fstrand, 'snps', base);\n                    bin.ref.entryDepth--;\n                    bin.ref[fstrand]--;\n                    bin.refbase = altbase;\n                }\n                else {\n                    inc(bin, fstrand, 'noncov', type);\n                }\n            }\n        }\n        if (mismatch.type === 'skip') {\n            const tags = feature.get('tags');\n            const xs = (tags === null || tags === void 0 ? void 0 : tags.XS) || (tags === null || tags === void 0 ? void 0 : tags.TS);\n            const ts = tags === null || tags === void 0 ? void 0 : tags.ts;\n            const effectiveStrand = xs === '+'\n                ? 1\n                : xs === '-'\n                    ? -1\n                    : (ts === '+' ? 1 : xs === '-' ? -1 : 0) * fstrand;\n            const hash = `${mstart}_${mend}_${effectiveStrand}`;\n            if (skipmap[hash] === undefined) {\n                skipmap[hash] = {\n                    feature: feature,\n                    start: mstart,\n                    end: mend,\n                    strand: fstrand,\n                    effectiveStrand,\n                    score: 0,\n                };\n            }\n            skipmap[hash].score++;\n        }\n    }\n}\n","import { max, sum } from '@jbrowse/core/util';\nimport { incWithProbabilities } from './util';\nimport { getMaxProbModAtEachPosition } from '../shared/getMaximumModificationAtEachPosition';\nexport function processModifications({ feature, colorBy, region, bins, regionSequence, }) {\n    var _a, _b, _c;\n    const fstart = feature.get('start');\n    const fstrand = feature.get('strand');\n    const fend = feature.get('end');\n    const twoColor = (_a = colorBy === null || colorBy === void 0 ? void 0 : colorBy.modifications) === null || _a === void 0 ? void 0 : _a.twoColor;\n    const isolatedModification = (_b = colorBy === null || colorBy === void 0 ? void 0 : colorBy.modifications) === null || _b === void 0 ? void 0 : _b.isolatedModification;\n    (_c = getMaxProbModAtEachPosition(feature)) === null || _c === void 0 ? void 0 : _c.forEach(({ type, prob, allProbs }, pos) => {\n        if (isolatedModification && type !== isolatedModification) {\n            return;\n        }\n        const epos = pos + fstart - region.start;\n        if (epos >= 0 && epos < bins.length && pos + fstart < fend) {\n            if (bins[epos] === undefined) {\n                bins[epos] = {\n                    depth: 0,\n                    readsCounted: 0,\n                    snps: {},\n                    ref: {\n                        probabilities: [],\n                        entryDepth: 0,\n                        '-1': 0,\n                        0: 0,\n                        1: 0,\n                    },\n                    mods: {},\n                    nonmods: {},\n                    delskips: {},\n                    noncov: {},\n                };\n            }\n            const s = 1 - sum(allProbs);\n            const bin = bins[epos];\n            bin.refbase = regionSequence[epos];\n            if (twoColor && s > max(allProbs)) {\n                incWithProbabilities(bin, fstrand, 'nonmods', `nonmod_${type}`, s);\n            }\n            else {\n                incWithProbabilities(bin, fstrand, 'mods', `mod_${type}`, prob);\n            }\n        }\n    });\n}\n","import { doesIntersect2 } from '@jbrowse/core/util';\nimport { parseCigar } from '../MismatchParser';\nimport { getMethBins } from '../ModificationParser';\nimport { incWithProbabilities } from './util';\nexport function processReferenceCpGs({ feature, region, bins, regionSequence, }) {\n    var _a;\n    const fstart = feature.get('start');\n    const fend = feature.get('end');\n    const fstrand = feature.get('strand');\n    const seq = feature.get('seq');\n    const mismatches = (_a = feature.get('mismatches')) !== null && _a !== void 0 ? _a : [];\n    const r = regionSequence.toLowerCase();\n    if (seq) {\n        const cigarOps = parseCigar(feature.get('CIGAR'));\n        const { methBins, methProbs } = getMethBins(feature, cigarOps);\n        const dels = mismatches.filter(f => f.type === 'deletion');\n        for (let i = 0; i < fend - fstart; i++) {\n            const j = i + fstart;\n            const l1 = r[j - region.start + 1];\n            const l2 = r[j - region.start + 2];\n            if (l1 === 'c' && l2 === 'g') {\n                const bin0 = bins[j - region.start];\n                const bin1 = bins[j - region.start + 1];\n                const b0 = methBins[i];\n                const b1 = methBins[i + 1];\n                const p0 = methProbs[i];\n                const p1 = methProbs[i + 1];\n                if ((b0 && (p0 !== undefined ? p0 > 0.5 : true)) ||\n                    (b1 && (p1 !== undefined ? p1 > 0.5 : true))) {\n                    if (bin0) {\n                        incWithProbabilities(bin0, fstrand, 'mods', 'cpg_meth', p0 || 0);\n                        bin0.ref.entryDepth--;\n                        bin0.ref[fstrand]--;\n                    }\n                    if (bin1) {\n                        incWithProbabilities(bin1, fstrand, 'mods', 'cpg_meth', p1 || 0);\n                        bin1.ref.entryDepth--;\n                        bin1.ref[fstrand]--;\n                    }\n                }\n                else {\n                    if (bin0) {\n                        if (!dels.some(d => doesIntersect2(j, j + 1, d.start + fstart, d.start + fstart + d.length))) {\n                            incWithProbabilities(bin0, fstrand, 'nonmods', 'cpg_unmeth', 1 - (p0 || 0));\n                            bin0.ref.entryDepth--;\n                            bin0.ref[fstrand]--;\n                        }\n                    }\n                    if (bin1) {\n                        if (!dels.some(d => doesIntersect2(j + 1, j + 2, d.start + fstart, d.start + fstart + d.length))) {\n                            incWithProbabilities(bin1, fstrand, 'nonmods', 'cpg_unmeth', 1 - (p1 || 0));\n                            bin1.ref.entryDepth--;\n                            bin1.ref[fstrand]--;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n","import { sum } from '@jbrowse/core/util';\nimport { checkStopToken } from '@jbrowse/core/util/stopToken';\nimport { processDepth } from './processDepth';\nimport { processMismatches } from './processMismatches';\nimport { processModifications } from './processModifications';\nimport { processReferenceCpGs } from './processReferenceCpGs';\nexport async function generateCoverageBins({ fetchSequence, features, region, opts, }) {\n    const { stopToken, colorBy } = opts;\n    const skipmap = {};\n    const bins = [];\n    const start2 = Math.max(0, region.start - 1);\n    const diff = region.start - start2;\n    let start = performance.now();\n    for (const feature of features) {\n        if (performance.now() - start > 400) {\n            checkStopToken(stopToken);\n            start = performance.now();\n        }\n        processDepth({\n            feature,\n            bins,\n            region,\n        });\n        if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'modifications') {\n            const regionSequence = (await fetchSequence({\n                ...region,\n                start: start2,\n                end: region.end + 1,\n            })) || '';\n            processModifications({\n                feature,\n                colorBy,\n                bins,\n                region,\n                regionSequence: regionSequence.slice(diff),\n            });\n        }\n        else if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'methylation') {\n            const regionSequence = (await fetchSequence({\n                ...region,\n                start: start2,\n                end: region.end + 1,\n            })) || '';\n            processReferenceCpGs({\n                feature,\n                bins,\n                region,\n                regionSequence,\n            });\n        }\n        processMismatches({ feature, skipmap, bins, region });\n    }\n    for (const bin of bins) {\n        if (bin) {\n            bin.mods = Object.fromEntries(Object.entries(bin.mods).map(([key, val]) => {\n                return [\n                    key,\n                    {\n                        ...val,\n                        avgProbability: val.probabilities.length\n                            ? sum(val.probabilities) / val.probabilities.length\n                            : undefined,\n                    },\n                ];\n            }));\n            bin.nonmods = Object.fromEntries(Object.entries(bin.nonmods).map(([key, val]) => {\n                return [\n                    key,\n                    {\n                        ...val,\n                        avgProbability: val.probabilities.length\n                            ? sum(val.probabilities) / val.probabilities.length\n                            : undefined,\n                    },\n                ];\n            }));\n        }\n    }\n    return {\n        bins,\n        skipmap,\n    };\n}\n","import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { firstValueFrom } from 'rxjs';\nimport { toArray } from 'rxjs/operators';\nimport { fetchSequence } from '../util';\nimport { generateCoverageBins } from './generateCoverageBins';\nexport default class SNPCoverageAdapter extends BaseFeatureDataAdapter {\n    async configure() {\n        var _a, _b;\n        const subadapterConfig = this.getConf('subadapter');\n        const sequenceConf = subadapterConfig.sequenceAdapter;\n        const dataAdapter = await ((_a = this.getSubAdapter) === null || _a === void 0 ? void 0 : _a.call(this, subadapterConfig));\n        const sequenceAdapter = sequenceConf\n            ? await ((_b = this.getSubAdapter) === null || _b === void 0 ? void 0 : _b.call(this, sequenceConf))\n            : undefined;\n        if (!dataAdapter) {\n            throw new Error('Failed to get subadapter');\n        }\n        return {\n            subadapter: dataAdapter.dataAdapter,\n            sequenceAdapter: sequenceAdapter === null || sequenceAdapter === void 0 ? void 0 : sequenceAdapter.dataAdapter,\n        };\n    }\n    async fetchSequence(region) {\n        const { sequenceAdapter } = await this.configure();\n        if (!sequenceAdapter) {\n            return undefined;\n        }\n        return fetchSequence(region, sequenceAdapter);\n    }\n    getFeatures(region, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { subadapter } = await this.configure();\n            const features = await firstValueFrom(subadapter.getFeatures(region, opts).pipe(toArray()));\n            const { bins, skipmap } = await generateCoverageBins({\n                features,\n                region,\n                opts,\n                fetchSequence: (region) => this.fetchSequence(region),\n            });\n            bins.forEach((bin, index) => {\n                const start = region.start + index;\n                observer.next(new SimpleFeature({\n                    id: `${this.id}-${start}`,\n                    data: {\n                        score: bin.depth,\n                        snpinfo: bin,\n                        start,\n                        end: start + 1,\n                        refName: region.refName,\n                    },\n                }));\n            });\n            Object.entries(skipmap).forEach(([key, skip]) => {\n                observer.next(new SimpleFeature({\n                    id: key,\n                    data: {\n                        type: 'skip',\n                        start: skip.start,\n                        end: skip.end,\n                        strand: skip.strand,\n                        score: skip.score,\n                        effectiveStrand: skip.effectiveStrand,\n                    },\n                }));\n            });\n            observer.complete();\n        }, opts.stopToken);\n    }\n    async getMultiRegionFeatureDensityStats(regions, opts) {\n        const { subadapter } = await this.configure();\n        return subadapter.getMultiRegionFeatureDensityStats(regions, opts);\n    }\n    async getRefNames(opts = {}) {\n        const { subadapter } = await this.configure();\n        return subadapter.getRefNames(opts);\n    }\n    freeResources() { }\n}\n","import { getNextRefPos, parseCigar } from '../MismatchParser';\nimport { getModPositions, getModProbabilities } from '../ModificationParser';\nimport { getTagAlt } from '../util';\nexport function getMaxProbModAtEachPosition(feature, cigarOps) {\n    const fstrand = feature.get('strand');\n    const seq = feature.get('seq');\n    const mm = getTagAlt(feature, 'MM', 'Mm') || '';\n    const ops = cigarOps || parseCigar(feature.get('CIGAR'));\n    if (seq) {\n        const modifications = getModPositions(mm, seq, fstrand);\n        const probabilities = getModProbabilities(feature);\n        const maxProbModForPosition = [];\n        let probIndex = 0;\n        for (const { type, positions } of modifications) {\n            for (const { ref, idx } of getNextRefPos(ops, positions)) {\n                const prob = (probabilities === null || probabilities === void 0 ? void 0 : probabilities[probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)]) || 0;\n                if (!maxProbModForPosition[ref]) {\n                    maxProbModForPosition[ref] = {\n                        type,\n                        prob,\n                        allProbs: [prob],\n                    };\n                }\n                else {\n                    const old = maxProbModForPosition[ref];\n                    maxProbModForPosition[ref] = {\n                        allProbs: [...old.allProbs, prob],\n                        prob: Math.max(old.prob, prob),\n                        type: old.prob > prob ? old.type : type,\n                    };\n                }\n            }\n            probIndex += positions.length;\n        }\n        return maxProbModForPosition;\n    }\n    return undefined;\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4,5,6,7]}