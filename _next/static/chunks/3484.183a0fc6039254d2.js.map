{"version":3,"file":"static/chunks/3484.183a0fc6039254d2.js","mappings":"2MAOe,iBAA8B,wBAAsB,CACnE,sBACA,oCACA,qCACA,sCACA,EAA2B,kBAAY,uBACvC,YACA,MAAwB,IAAgB,EACxC,aACA,gBACkB,kBAAY,uBAC9B,OACA,gBAEA,OADkB,kBAAY,uBAE9B,wBACA,CAAS,EACT,OACA,MACA,WAAwB,GAAS,EACjC,0BACA,CAAa,CACb,CACA,CACA,sBAOA,OANA,iBACA,+CAEA,MADA,uBACA,CACA,EAAa,EAEb,eACA,CACA,mBACA,mBAAgB,UAA6B,MAC7C,MAAe,kBAAY,gDAC3B,CACA,sBAA+B,EAC/B,QAAgB,GAAM,wBACtB,qCACA,CACA,mBACA,QAAgB,GAAM,wBACtB,oBACA,CACA,qBACA,WAAgB,GAAS,wBACzB,sBACA,CACA,kBAAgC,EAChC,MAAe,sBAAgB,WAC/B,YAAoB,iBAAsB,EAC1C,gBAAoB,UAA6B,EACjD,KAAoB,YAAc,uBAClC,OAAkB,kBAAY,gDAC9B,qBACA,WAAsC,GAAU,EAChD,uBACA,SACA,MAA+B,QAAQ,OAAO,EAAW,EACpC,EACrB,CAAiB,CACjB,KACa,GACb,YACA,CAAS,aACT,CACA,mBACA,yCACA,+CACA,WAAoB,GAAS,uBAC7B,0BACA,MACA,EAAa,CACb,CACA,CAEA,MADA,OAA8B,4BAAsB,CAAC,kBAAY,yBACjE,oBACA,kBACA,QAAoB,GAAS,uBAC7B,qBACA,IACA,SACA,eACA,QACA,yBACA,OACA,gDACA,MACA,CACA,CAAa,EAKb,OAJA,4BACA,QACA,iFAEA,0BACA,CACA,CACA,iBACA","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-variants/esm/VcfTabixAdapter/VcfTabixAdapter.js"],"sourcesContent":["import { TabixIndexedFile } from '@gmod/tabix';\nimport VcfParser from '@gmod/vcf';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { fetchAndMaybeUnzipText, updateStatus } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport VcfFeature from '../VcfFeature';\nexport default class VcfTabixAdapter extends BaseFeatureDataAdapter {\n    async configurePre(_opts) {\n        const vcfGzLocation = this.getConf('vcfGzLocation');\n        const location = this.getConf(['index', 'location']);\n        const indexType = this.getConf(['index', 'indexType']);\n        const filehandle = openLocation(vcfGzLocation, this.pluginManager);\n        const isCSI = indexType === 'CSI';\n        const vcf = new TabixIndexedFile({\n            filehandle,\n            csiFilehandle: isCSI\n                ? openLocation(location, this.pluginManager)\n                : undefined,\n            tbiFilehandle: !isCSI\n                ? openLocation(location, this.pluginManager)\n                : undefined,\n            chunkCacheSize: 50 * 2 ** 20,\n        });\n        return {\n            vcf,\n            parser: new VcfParser({\n                header: await vcf.getHeader(),\n            }),\n        };\n    }\n    async configurePre2() {\n        if (!this.configured) {\n            this.configured = this.configurePre().catch((e) => {\n                this.configured = undefined;\n                throw e;\n            });\n        }\n        return this.configured;\n    }\n    async configure(opts) {\n        const { statusCallback = () => { } } = opts || {};\n        return updateStatus('Downloading index', statusCallback, () => this.configurePre2());\n    }\n    async getRefNames(opts = {}) {\n        const { vcf } = await this.configure(opts);\n        return vcf.getReferenceSequenceNames(opts);\n    }\n    async getHeader(opts) {\n        const { vcf } = await this.configure(opts);\n        return vcf.getHeader();\n    }\n    async getMetadata(opts) {\n        const { parser } = await this.configure(opts);\n        return parser.getMetadata();\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { refName, start, end } = query;\n            const { statusCallback = () => { } } = opts;\n            const { vcf, parser } = await this.configure(opts);\n            await updateStatus('Downloading variants', statusCallback, () => vcf.getLines(refName, start, end, {\n                lineCallback: (line, fileOffset) => {\n                    observer.next(new VcfFeature({\n                        variant: parser.parseLine(line),\n                        parser,\n                        id: `${this.id}-vcf-${fileOffset}`,\n                    }));\n                },\n                ...opts,\n            }));\n            observer.complete();\n        }, opts.stopToken);\n    }\n    async getSources() {\n        const conf = this.getConf('samplesTsvLocation');\n        if (conf.uri === '' || conf.uri === '/path/to/samples.tsv') {\n            const { parser } = await this.configure();\n            return parser.samples.map(name => ({\n                name,\n            }));\n        }\n        else {\n            const txt = await fetchAndMaybeUnzipText(openLocation(conf, this.pluginManager));\n            const lines = txt.split(/\\n|\\r\\n|\\r/);\n            const header = lines[0].split('\\t');\n            const { parser } = await this.configure();\n            const s = new Set(parser.samples);\n            const ret = lines\n                .slice(1)\n                .filter(f => !!f)\n                .map(line => {\n                const [name, ...rest] = line.split('\\t');\n                return {\n                    ...Object.fromEntries(rest.map((c, idx) => [header[idx + 1], c])),\n                    name: name,\n                };\n            });\n            const missing = ret.filter(f => !s.has(f.name));\n            if (missing.length) {\n                console.warn('Samples in metadata file not in VCF:', ret.filter(f => !s.has(f.name)));\n            }\n            return ret.filter(f => s.has(f.name));\n        }\n    }\n    freeResources() { }\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0]}