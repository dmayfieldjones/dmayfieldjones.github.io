{"version":3,"file":"static/chunks/5630.d5989459176cdd09.js","mappings":"wMAKA,+CACO,oBACP,mBACA,WACA,YACA,YACA,WACA,YACA,YACA,OACA,QACA,UACA,UACA,cACA,IACA,qDACA,EACA,kBAA4C,KAAS,UACrD,WAAe,eAAa,EAC5B,KACA,QACA,MACA,sBACA,UACA,SACA,OACA,QACA,WACA,MACA,UACA,QACA,MACA,QACA,CAAS,CACT,MAAoB,SAAa,EAAI,CAChC,CACL,CACA,oBACA,QACA,EAEA,QACA,GAEA,QACA,QAGA,CACA,gBAA2B,wBAAsB,CACjD,cACA,oBACA,qBACA,CACA,mBACA,yBACA,gCACA,EAAoB,kBAAY,MAChC,QAA6B,wBAAkB,MAC/C,uBACA,0DAGA,UADA,oBAA+C,SAAa,YAC5D,mCACA,KACA,IACA,KAAe,iCAA8C,IAC7D,aAEA,mBACA,KACA,KACA,KAAe,WAAkB,KACjC,WACA,eACA,OACA,MACA,OACA,UAEA,MACA,UAEA,aACA,YACA,CAEA,OACA,SACA,SACA,SACA,YALA,2BAMA,CACA,CACA,mBAA4B,EAO5B,OANA,oBACA,gDAEA,MADA,0BACA,CACA,EAAa,EAEb,mBAEA,sBAA+B,EAC/B,IAAgB,mBAAiB,uBACjC,0DAEA,oBAA6B,EAC7B,WAAgB,GAAS,uBACzB,QACA,CACA,iBACA,WAAgB,iBAAsB,sBACtC,YACA,SAGA,MADA,qCACA,OACA,uCACA,EACA,SACA,WACA,iBACA,MACA,CACA,0BACA,YACA,WAAgB,YAAiB,sBACjC,wBACA,MAAiC,IAAY,CAG7C,gBAFA,iEAA0H,QAAQ,GAAG,EAAQ,GAAG,EAAE,iCAClJ,iEAA0H,QAAQ,GAAG,EAAQ,GAAG,EAAE,8BAClJ,CACA,0CAEA,QACA,CACA,yBAOA,OANA,uBACA,0DAEA,MADA,6BACA,CACA,EAAa,EAEb,sBAEA,kBAAgC,EAChC,MAAe,sBAAgB,WAC/B,UAAoB,mBAAsB,EAC1C,+BACA,sCACA,SACA,CAAa,EACb,YACA,CAAS,aACT,CACA,iBACA,CACA,6CACA,MAAe","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-bed/esm/BedpeAdapter/BedpeAdapter.js"],"sourcesContent":["import IntervalTree from '@flatten-js/interval-tree';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { SimpleFeature, fetchAndMaybeUnzip } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nconst svTypes = new Set(['DUP', 'TRA', 'INV', 'CNV', 'DEL']);\nexport function featureData(line, uniqueId, flip, names) {\n    const l = line.split('\\t');\n    const ref1 = l[flip ? 3 : 0];\n    const start1 = +l[flip ? 4 : 1];\n    const end1 = +l[flip ? 5 : 2];\n    const ref2 = l[!flip ? 3 : 0];\n    const start2 = +l[!flip ? 4 : 1];\n    const end2 = +l[!flip ? 5 : 2];\n    const name = l[6];\n    const score = +l[7];\n    const strand1 = parseStrand(l[8]);\n    const strand2 = parseStrand(l[9]);\n    const extra = l.slice(10);\n    const rest = names\n        ? Object.fromEntries(names.slice(10).map((n, idx) => [n, extra[idx]]))\n        : extra;\n    const ALT = svTypes.has(extra[0]) ? `<${extra[0]}>` : undefined;\n    return new SimpleFeature({\n        ...rest,\n        start: start1,\n        end: end1,\n        type: 'paired_feature',\n        refName: ref1,\n        strand: strand1,\n        name,\n        score,\n        uniqueId,\n        mate: {\n            refName: ref2,\n            start: start2,\n            end: end2,\n            strand: strand2,\n        },\n        ...(ALT ? { ALT: [ALT] } : {}),\n    });\n}\nfunction parseStrand(strand) {\n    if (strand === '+') {\n        return 1;\n    }\n    if (strand === '-') {\n        return -1;\n    }\n    if (strand === '.') {\n        return 0;\n    }\n    return undefined;\n}\nclass BedpeAdapter extends BaseFeatureDataAdapter {\n    constructor() {\n        super(...arguments);\n        this.intervalTrees = {};\n    }\n    async loadDataP(opts) {\n        const pm = this.pluginManager;\n        const bedLoc = this.getConf('bedpeLocation');\n        const loc = openLocation(bedLoc, pm);\n        const buffer = await fetchAndMaybeUnzip(loc, opts);\n        if (buffer.length > 536870888) {\n            throw new Error('Data exceeds maximum string length (512MB)');\n        }\n        const data = new TextDecoder('utf8', { fatal: true }).decode(buffer);\n        const lines = data.split(/\\n|\\r\\n|\\r/).filter(f => !!f);\n        const headerLines = [];\n        let i = 0;\n        for (; i < lines.length && lines[i].startsWith('#'); i++) {\n            headerLines.push(lines[i]);\n        }\n        const header = headerLines.join('\\n');\n        const feats1 = {};\n        const feats2 = {};\n        for (; i < lines.length; i++) {\n            const line = lines[i];\n            const cols = line.split('\\t');\n            const r1 = cols[0];\n            const r2 = cols[3];\n            if (!feats1[r1]) {\n                feats1[r1] = [];\n            }\n            if (!feats2[r2]) {\n                feats2[r2] = [];\n            }\n            feats1[r1].push(line);\n            feats2[r2].push(line);\n        }\n        const columnNames = this.getConf('columnNames');\n        return {\n            header,\n            feats1,\n            feats2,\n            columnNames,\n        };\n    }\n    async loadData(opts = {}) {\n        if (!this.bedpeFeatures) {\n            this.bedpeFeatures = this.loadDataP(opts).catch((e) => {\n                this.bedpeFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.bedpeFeatures;\n    }\n    async getRefNames(opts = {}) {\n        const { feats1, feats2 } = await this.loadData(opts);\n        return [...new Set([...Object.keys(feats1), ...Object.keys(feats2)])];\n    }\n    async getHeader(opts = {}) {\n        const { header } = await this.loadData(opts);\n        return header;\n    }\n    async getNames() {\n        const { header, columnNames } = await this.loadData();\n        if (columnNames.length) {\n            return columnNames;\n        }\n        const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f);\n        const defline = defs.at(-1);\n        return (defline === null || defline === void 0 ? void 0 : defline.includes('\\t'))\n            ? defline\n                .slice(1)\n                .split('\\t')\n                .map(field => field.trim())\n            : undefined;\n    }\n    async loadFeatureTreeP(refName) {\n        var _a, _b, _c, _d;\n        const { feats1, feats2 } = await this.loadData();\n        const names = await this.getNames();\n        const intervalTree = new IntervalTree();\n        const ret1 = (_b = (_a = feats1[refName]) === null || _a === void 0 ? void 0 : _a.map((f, i) => featureData(f, `${this.id}-${refName}-${i}-r1`, false, names))) !== null && _b !== void 0 ? _b : [];\n        const ret2 = (_d = (_c = feats2[refName]) === null || _c === void 0 ? void 0 : _c.map((f, i) => featureData(f, `${this.id}-${refName}-${i}-r2`, true, names))) !== null && _d !== void 0 ? _d : [];\n        for (const obj of [...ret1, ...ret2]) {\n            intervalTree.insert([obj.get('start'), obj.get('end')], obj);\n        }\n        return intervalTree;\n    }\n    async loadFeatureTree(refName) {\n        if (!this.intervalTrees[refName]) {\n            this.intervalTrees[refName] = this.loadFeatureTreeP(refName).catch((e) => {\n                this.intervalTrees[refName] = undefined;\n                throw e;\n            });\n        }\n        return this.intervalTrees[refName];\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { start, end, refName } = query;\n            const intervalTree = await this.loadFeatureTree(refName);\n            intervalTree === null || intervalTree === void 0 ? void 0 : intervalTree.search([start, end]).forEach(f => {\n                observer.next(f);\n            });\n            observer.complete();\n        }, opts.stopToken);\n    }\n    freeResources() { }\n}\nBedpeAdapter.capabilities = ['getFeatures', 'getRefNames'];\nexport default BedpeAdapter;\n"],"names":[],"sourceRoot":"","ignoreList":[0]}