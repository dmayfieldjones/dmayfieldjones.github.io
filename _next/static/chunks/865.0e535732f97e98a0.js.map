{"version":3,"file":"static/chunks/865.0e535732f97e98a0.js","mappings":"+LAMe,iBAA8B,wBAAsB,CACnE,qBACA,yBACA,gCACA,qCACA,sCACA,EAA2B,kBAAY,MACvC,YACA,MAAwB,IAAgB,EACxC,aACA,gBAAmC,kBAAY,aAC/C,gBAAgD,OAAZ,kBAAY,MAChD,wBACA,CAAS,EACT,sBACA,OACA,MACA,WAAwB,GAAS,SAAG,EAAQ,CAC5C,CACA,CACA,kBAOA,OANA,iBACA,+CAEA,MADA,uBACA,CACA,EAAa,EAEb,gBAEA,sBAA+B,EAC/B,QAAgB,GAAM,uBACtB,qCACA,CACA,kBACA,QAAgB,GAAM,uBACtB,oBACA,CACA,oBACA,WAAgB,GAAS,uBACzB,sBACA,CACA,kBAAgC,EAChC,MAAe,sBAAgB,WAC/B,YAAoB,iBAAsB,EAC1C,KAAoB,YAAc,sBAClC,yBACA,qBACA,WAAsC,GAAU,EAChD,uBACA,SACA,MAA+B,QAAQ,OAAO,EAAW,EACpC,EACrB,CAAiB,CACjB,KACa,EACb,YACA,CAAS,aACT,CACA,mBACA,WAAgB,GAAS,uBACzB,0BACA,MACA,EAAS,CACT,CACA,iBACA","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-variants/esm/VcfTabixAdapter/VcfTabixAdapter.js"],"sourcesContent":["import { TabixIndexedFile } from '@gmod/tabix';\nimport VcfParser from '@gmod/vcf';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport VcfFeature from '../VcfFeature';\nexport default class VcfTabixAdapter extends BaseFeatureDataAdapter {\n    async configurePre() {\n        const pm = this.pluginManager;\n        const vcfGzLocation = this.getConf('vcfGzLocation');\n        const location = this.getConf(['index', 'location']);\n        const indexType = this.getConf(['index', 'indexType']);\n        const filehandle = openLocation(vcfGzLocation, pm);\n        const isCSI = indexType === 'CSI';\n        const vcf = new TabixIndexedFile({\n            filehandle,\n            csiFilehandle: isCSI ? openLocation(location, pm) : undefined,\n            tbiFilehandle: !isCSI ? openLocation(location, pm) : undefined,\n            chunkCacheSize: 50 * 2 ** 20,\n        });\n        const header = await vcf.getHeader();\n        return {\n            vcf,\n            parser: new VcfParser({ header }),\n        };\n    }\n    async configure() {\n        if (!this.configured) {\n            this.configured = this.configurePre().catch((e) => {\n                this.configured = undefined;\n                throw e;\n            });\n        }\n        return this.configured;\n    }\n    async getRefNames(opts = {}) {\n        const { vcf } = await this.configure();\n        return vcf.getReferenceSequenceNames(opts);\n    }\n    async getHeader() {\n        const { vcf } = await this.configure();\n        return vcf.getHeader();\n    }\n    async getMetadata() {\n        const { parser } = await this.configure();\n        return parser.getMetadata();\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { refName, start, end } = query;\n            const { vcf, parser } = await this.configure();\n            await vcf.getLines(refName, start, end, {\n                lineCallback: (line, fileOffset) => {\n                    observer.next(new VcfFeature({\n                        variant: parser.parseLine(line),\n                        parser,\n                        id: `${this.id}-vcf-${fileOffset}`,\n                    }));\n                },\n                ...opts,\n            });\n            observer.complete();\n        }, opts.stopToken);\n    }\n    async getSources() {\n        const { parser } = await this.configure();\n        return parser.samples.map(name => ({\n            name,\n        }));\n    }\n    freeResources() { }\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0]}