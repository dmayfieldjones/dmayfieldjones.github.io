{"version":3,"file":"static/chunks/2527.f498c00adc697f85.js","mappings":"yIACO,oBACP,IAAY,gBAA0B,CAAE,uBAAkB,IAC1D,YAAY,GAAe,gBAAU,IACrC,EAAiB,uBAAiB,IAClC,8DACA,OAEA,iBACA,wCACA,YACA,qCACA,8BACK,EACL,cAAqB,YAAM,eAC3B,gBACA,0BEdO,kBD4FA,MC3FU,UACjB,MAAc,EAAW,EACzB,CAAK,CDyFE,ECzFF,CAAI,EADgB,IAChB,IAAa,CD0FlB,iBAAW,CC5FE,ED4FK,aAAO,WAC7B,IACA,SACA,CACA,SACgB,aAAO,CCjGN,MDkGjB,WAEA,CACA,CAAK,IClGL","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-arc/esm/LinearPairedArcDisplay/fetchChains.js","webpack://_N_E/./node_modules/@jbrowse/plugin-arc/esm/LinearPairedArcDisplay/util.js","webpack://_N_E/./node_modules/@jbrowse/plugin-arc/esm/LinearPairedArcDisplay/afterAttach.js"],"sourcesContent":["import { dedupe, getContainingTrack, getContainingView, getSession, } from '@jbrowse/core/util';\nexport async function fetchChains(self) {\n    const { rpcSessionId: sessionId } = getContainingTrack(self);\n    const { rpcManager } = getSession(self);\n    const view = getContainingView(self);\n    if (!view.initialized || self.error || !self.statsReadyAndRegionNotTooLarge) {\n        return;\n    }\n    self.setLoading(true);\n    const ret = (await rpcManager.call(sessionId, 'CoreGetFeatures', {\n        sessionId,\n        regions: view.staticBlocks.contentBlocks,\n        adapterConfig: self.adapterConfig,\n    }));\n    self.setFeatures(dedupe(ret, r => r.id()));\n    self.setLoading(false);\n}\n","import { autorun } from 'mobx';\nimport { addDisposer, isAlive } from 'mobx-state-tree';\nimport { firstValueFrom } from 'rxjs';\nimport { toArray } from 'rxjs/operators';\nexport function getTag(feature, tag) {\n    return feature.get('tags')[tag];\n}\nexport function getTagAlt(feature, tag, alt) {\n    var _a;\n    return (_a = getTag(feature, tag)) !== null && _a !== void 0 ? _a : getTag(feature, alt);\n}\nexport const orientationTypes = {\n    fr: {\n        F1R2: 'LR',\n        F2R1: 'LR',\n        F1F2: 'LL',\n        F2F1: 'LL',\n        R1R2: 'RR',\n        R2R1: 'RR',\n        R1F2: 'RL',\n        R2F1: 'RL',\n    },\n    rf: {\n        R1F2: 'LR',\n        R2F1: 'LR',\n        R1R2: 'LL',\n        R2R1: 'LL',\n        F1F2: 'RR',\n        F2F1: 'RR',\n        F1R2: 'RL',\n        F2R1: 'RL',\n    },\n    ff: {\n        F2F1: 'LR',\n        R1R2: 'LR',\n        F2R1: 'LL',\n        R1F2: 'LL',\n        R2F1: 'RR',\n        F1R2: 'RR',\n        R2R1: 'RL',\n        F1F2: 'RL',\n    },\n};\nexport const pairMap = {\n    LR: 'color_pair_lr',\n    LL: 'color_pair_ll',\n    RR: 'color_pair_rr',\n    RL: 'color_pair_rl',\n};\nexport function getColorWGBS(strand, base) {\n    if (strand === 1) {\n        if (base === 'C') {\n            return '#f00';\n        }\n        if (base === 'T') {\n            return '#00f';\n        }\n    }\n    else if (strand === -1) {\n        if (base === 'G') {\n            return '#f00';\n        }\n        if (base === 'A') {\n            return '#00f';\n        }\n    }\n    return '#888';\n}\nexport async function fetchSequence(region, adapter) {\n    var _a;\n    const { start, end, originalRefName, refName } = region;\n    const feats = await firstValueFrom(adapter\n        .getFeatures({\n        ...region,\n        refName: originalRefName || refName,\n        end: end + 1,\n        start: Math.max(0, start - 1),\n    })\n        .pipe(toArray()));\n    return (_a = feats[0]) === null || _a === void 0 ? void 0 : _a.get('seq');\n}\nexport function shouldFetchReferenceSequence(type) {\n    return type === 'methylation';\n}\nexport const modificationColors = {\n    m: 'rgb(255,0,0)',\n    h: 'rgb(11, 132, 165)',\n    o: 'rgb(111, 78, 129)',\n    f: 'rgb(246, 200, 95)',\n    c: 'rgb(157, 216, 102)',\n    g: 'rgb(255, 160, 86)',\n    e: 'rgb(141, 221, 208)',\n    b: 'rgb(202, 71, 47)',\n};\nexport function createAutorun(self, cb, opts) {\n    addDisposer(self, autorun(async () => {\n        try {\n            await cb();\n        }\n        catch (e) {\n            if (isAlive(self)) {\n                self.setError(e);\n            }\n        }\n    }, opts));\n}\nexport function randomColor() {\n    return `hsl(${Math.random() * 200}, 50%, 50%)`;\n}\n","import { fetchChains } from './fetchChains';\nimport { createAutorun } from './util';\nexport function doAfterAttach(self) {\n    createAutorun(self, async () => {\n        await fetchChains(self);\n    }, { delay: 1000 });\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0,1,2]}