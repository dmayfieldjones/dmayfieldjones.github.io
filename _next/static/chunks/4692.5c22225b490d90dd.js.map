{"version":3,"file":"static/chunks/4692.5c22225b490d90dd.js","mappings":"4LASA,OACA,MACA,MACA,MACA,KACA,EAEO,sBACP,wBACA,aAAY,+EAAmF,4DAA4F,EAC3L,EAAkB,wBAAkB,IACpC,OACA,oBACA,EAAmB,IAAsB,CACzC,QACA,GAAmB,kBACnB,EAAsB,QAAQ,IAC9B,EAA+B,QAAQ,EACvC,KACA,cACA,kBACA,CAAK,EACL,EAAoB,QAAS,cAC7B,EAAyB,QAAS,WAClC,EAA+B,oBAAc,yBAC7C,EAAgC,oBAAc,0BAC9C,EAAqB,oBAAc,eACnC,EAAoC,oBAAc,8BAClD,mBACA,eACA,mBACA,eACA,OAAY,GAAQ,UACpB,GACA,WACA,WACA,WACA,WACA,mBACA,gBACA,eACA,MAAe,oBAAc,YAC7B,gBACA,eACA,iBACA,EACA,kBACA,oBACA,wBACA,gBACA,0BACA,SAEA,SAAkC,mBAAa,QAC/C,MAhDA,GAiDA,iBACA,0BACA,0BACY,oBAAc,IAC1B,oBAEA,CACA,QACA,oBACA,4BACA,0BACA,wEAEA,aADA,oBACA,IAKA,GAJA,kBACA,OACY,oBAAc,IAE1B,uBACA,SAEA,SAAkC,mBAAa,QAC/C,mBACA,kBACA,iBACA,OACA,QACA,0DACA,SAAoB,uBAA2B,EAC/C,8CACA,kCACA,wBACA,OACA,gBAAoC,GAAG,gBACvC,QACA,CACA,mBACA,SAEA,gBACA,eACA,EACA,4DACA,uDACA,sBACA,kBACA,eACA,EACA,4DACA,uDACA,4BACA,uBACA,YAAwB,sBAAiC,aACzD,YAEA,EAA0B,QAAU,CADpC,OACoC,GACpC,OACA,QACA,eACA,0CACA,MACA,CACA,8CACA,8BACA,OACA,gBAAoC,GAAG,gBACvC,QACA,CACA,mBACA,SAEA,gBACA,eACA,EACA,4DACA,uDACA,sBACA,kBACA,eACA,EACA,4DACA,uDACA,4BACA,uBACA,CAAwB,iCAAiC,KACzD,YACA,mBACA,EAA0B,QAAU,MACpC,OACA,QACA,eACA,0CACA,MACA,CACA,MACA,OACA,UAAoB,oBAAuB,EAC3C,IACA,8CACA,eAAwB,GAAa,KACrC,OACA,QACA,2BACA,8CACA,IACA,CACA,8CACA,eAAwB,GAAa,KACrC,OACA,QACA,2BACA,8CACA,IACA,CACA,KACA,CACA,UAAoB,UAAc,EAClC,IACA,8CACA,eAAwB,GAAa,KACrC,OACA,QACA,2BACA,8CACA,IACA,CACA,CACA,4BACA,MACA,QACA,gBACA,eAAwB,GAAa,YAErC,iBACA,aAFA,GAEA,GA/LA,IA+LA,eACA,IACA,CACA,CACA,MACA,QACA,IACA,KACA,gBACA,eAAwB,GAAa,YACrC,KACA,MACA,IACA,IAEA,CACA,oBACA,UACA,EAhNA,EAgNA,CACA,iBACA,cACA,WACA,kBACA,kBACA,WAvNA,KAwNA,QACA,CACA,CACA,GACA,CACA,KACA,gBACA,0BACA,SAEA,qBACA,eACA,MAAkC,cAAQ,UAC1C,cACA,8BAIA,OACA,cAJA,wBAMA,OACA,cANA,wBASA,cARA,wBAUA,uCACA,kBACA,iCACA,UACA,CAEA,KAGA,aAFA,cACA,sCACA,UACA,cACA,6BACA,6BACA,UAGA","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageRenderer/makeImage.js"],"sourcesContent":["import { readConfObject } from '@jbrowse/core/configuration';\nimport { createJBrowseTheme } from '@jbrowse/core/ui';\nimport { bpSpanPx, featureSpanPx } from '@jbrowse/core/util';\nimport { checkStopToken } from '@jbrowse/core/util/stopToken';\nimport { YSCALEBAR_LABEL_OFFSET, getOrigin, getScale, } from '@jbrowse/plugin-wiggle';\nimport { alphaColor } from '../shared/util';\nconst INTERBASE_INDICATOR_WIDTH = 7;\nconst INTERBASE_INDICATOR_HEIGHT = 4.5;\nconst MINIMUM_INTERBASE_INDICATOR_READ_DEPTH = 7;\nconst complementBase = {\n    C: 'G',\n    G: 'C',\n    A: 'T',\n    T: 'A',\n};\nconst fudgeFactor = 0.6;\nexport async function makeImage(ctx, props) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    const { features, regions, bpPerPx, colorBy, displayCrossHatches, visibleModifications = {}, scaleOpts, height: unadjustedHeight, theme: configTheme, config: cfg, ticks, stopToken, } = props;\n    const theme = createJBrowseTheme(configTheme);\n    const region = regions[0];\n    const width = (region.end - region.start) / bpPerPx;\n    const offset = YSCALEBAR_LABEL_OFFSET;\n    const height = unadjustedHeight - offset * 2;\n    const opts = { ...scaleOpts, range: [0, height] };\n    const viewScale = getScale(opts);\n    const indicatorViewScale = getScale({\n        ...opts,\n        range: [0, height / 2],\n        scaleType: 'linear',\n    });\n    const originY = getOrigin(scaleOpts.scaleType);\n    const originLinear = getOrigin('linear');\n    const indicatorThreshold = readConfObject(cfg, 'indicatorThreshold');\n    const showInterbaseCounts = readConfObject(cfg, 'showInterbaseCounts');\n    const showArcs = readConfObject(cfg, 'showArcs');\n    const showInterbaseIndicators = readConfObject(cfg, 'showInterbaseIndicators');\n    const toY = (n) => height - (viewScale(n) || 0) + offset;\n    const toHeight = (n) => toY(originY) - toY(n);\n    const toY2 = (n) => height - (indicatorViewScale(n) || 0) + offset;\n    const toHeight2 = (n) => toY2(originLinear) - toY2(n);\n    const { bases } = theme.palette;\n    const colorForBase = {\n        A: bases.A.main,\n        C: bases.C.main,\n        G: bases.G.main,\n        T: bases.T.main,\n        insertion: 'purple',\n        softclip: 'blue',\n        hardclip: 'red',\n        total: readConfObject(cfg, 'color'),\n        mod_NONE: 'blue',\n        cpg_meth: 'red',\n        cpg_unmeth: 'blue',\n    };\n    const feats = [...features.values()];\n    ctx.fillStyle = colorForBase.total;\n    let start = performance.now();\n    for (const feature of feats) {\n        if (feature.get('type') === 'skip') {\n            continue;\n        }\n        const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx);\n        const w = rightPx - leftPx + fudgeFactor;\n        const score = feature.get('score');\n        ctx.fillRect(leftPx, toY(score), w, toHeight(score));\n        if (performance.now() - start > 400) {\n            checkStopToken(stopToken);\n            start = performance.now();\n        }\n    }\n    let prevTotal = 0;\n    const extraHorizontallyFlippedOffset = region.reversed ? 1 / bpPerPx : 0;\n    const drawingModifications = colorBy.type === 'modifications';\n    const drawingMethylation = colorBy.type === 'methylation';\n    const isolatedModification = (_a = colorBy.modifications) === null || _a === void 0 ? void 0 : _a.isolatedModification;\n    start = performance.now();\n    for (const feature of feats) {\n        const now = performance.now();\n        if (now - start > 400) {\n            checkStopToken(stopToken);\n        }\n        if (feature.get('type') === 'skip') {\n            continue;\n        }\n        const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx);\n        const snpinfo = feature.get('snpinfo');\n        const w = Math.max(rightPx - leftPx, 1);\n        const score0 = feature.get('score');\n        if (drawingModifications) {\n            let curr = 0;\n            const refbase = (_b = snpinfo.refbase) === null || _b === void 0 ? void 0 : _b.toUpperCase();\n            const { nonmods, mods, snps, ref } = snpinfo;\n            for (const m of Object.keys(nonmods).sort().reverse()) {\n                const mod = visibleModifications[m.replace('nonmod_', '')] ||\n                    visibleModifications[m.replace('mod_', '')];\n                if (!mod) {\n                    console.warn(`${m} not known yet`);\n                    continue;\n                }\n                if (isolatedModification && mod.type !== isolatedModification) {\n                    continue;\n                }\n                const cmp = complementBase[mod.base];\n                const detectable = mod.base === 'N'\n                    ? score0\n                    : (((_c = snps[mod.base]) === null || _c === void 0 ? void 0 : _c.entryDepth) || 0) +\n                        (((_d = snps[cmp]) === null || _d === void 0 ? void 0 : _d.entryDepth) || 0) +\n                        (refbase === mod.base ? ref['1'] : 0) +\n                        (refbase === cmp ? ref['-1'] : 0);\n                const modifiable = mod.base === 'N'\n                    ? score0\n                    : (((_e = snps[mod.base]) === null || _e === void 0 ? void 0 : _e.entryDepth) || 0) +\n                        (((_f = snps[cmp]) === null || _f === void 0 ? void 0 : _f.entryDepth) || 0) +\n                        (refbase === mod.base ? ref.entryDepth : 0) +\n                        (refbase === cmp ? ref.entryDepth : 0);\n                const { entryDepth, avgProbability = 0 } = snpinfo.nonmods[m];\n                const modFraction = (modifiable / score0) * (entryDepth / detectable);\n                const nonModColor = 'blue';\n                const c = alphaColor(nonModColor, avgProbability);\n                const height = toHeight(score0);\n                const bottom = toY(score0) + height;\n                ctx.fillStyle = c;\n                ctx.fillRect(Math.round(leftPx), bottom - (curr + modFraction * height), w, modFraction * height);\n                curr += modFraction * height;\n            }\n            for (const m of Object.keys(mods).sort().reverse()) {\n                const mod = visibleModifications[m.replace('mod_', '')];\n                if (!mod) {\n                    console.warn(`${m} not known yet`);\n                    continue;\n                }\n                if (isolatedModification && mod.type !== isolatedModification) {\n                    continue;\n                }\n                const cmp = complementBase[mod.base];\n                const detectable = mod.base === 'N'\n                    ? score0\n                    : (((_g = snps[mod.base]) === null || _g === void 0 ? void 0 : _g.entryDepth) || 0) +\n                        (((_h = snps[cmp]) === null || _h === void 0 ? void 0 : _h.entryDepth) || 0) +\n                        (refbase === mod.base ? ref['1'] : 0) +\n                        (refbase === cmp ? ref['-1'] : 0);\n                const modifiable = mod.base === 'N'\n                    ? score0\n                    : (((_j = snps[mod.base]) === null || _j === void 0 ? void 0 : _j.entryDepth) || 0) +\n                        (((_k = snps[cmp]) === null || _k === void 0 ? void 0 : _k.entryDepth) || 0) +\n                        (refbase === mod.base ? ref.entryDepth : 0) +\n                        (refbase === cmp ? ref.entryDepth : 0);\n                const { entryDepth, avgProbability = 0 } = mods[m];\n                const modFraction = (modifiable / score0) * (entryDepth / detectable);\n                const baseColor = mod.color || 'black';\n                const c = alphaColor(baseColor, avgProbability);\n                const height = toHeight(score0);\n                const bottom = toY(score0) + height;\n                ctx.fillStyle = c;\n                ctx.fillRect(Math.round(leftPx), bottom - (curr + modFraction * height), w, modFraction * height);\n                curr += modFraction * height;\n            }\n        }\n        else if (drawingMethylation) {\n            const { depth, nonmods, mods } = snpinfo;\n            let curr = 0;\n            for (const base of Object.keys(mods).sort().reverse()) {\n                const { entryDepth } = mods[base];\n                const height = toHeight(score0);\n                const bottom = toY(score0) + height;\n                ctx.fillStyle = colorForBase[base] || 'black';\n                ctx.fillRect(Math.round(leftPx), bottom - ((entryDepth + curr) / depth) * height, w, (entryDepth / depth) * height);\n                curr += entryDepth;\n            }\n            for (const base of Object.keys(nonmods).sort().reverse()) {\n                const { entryDepth } = nonmods[base];\n                const height = toHeight(score0);\n                const bottom = toY(score0) + height;\n                ctx.fillStyle = colorForBase[base] || 'black';\n                ctx.fillRect(Math.round(leftPx), bottom - ((entryDepth + curr) / depth) * height, w, (entryDepth / depth) * height);\n                curr += entryDepth;\n            }\n        }\n        else {\n            const { depth, snps } = snpinfo;\n            let curr = 0;\n            for (const base of Object.keys(snps).sort().reverse()) {\n                const { entryDepth } = snps[base];\n                const height = toHeight(score0);\n                const bottom = toY(score0) + height;\n                ctx.fillStyle = colorForBase[base] || 'black';\n                ctx.fillRect(Math.round(leftPx), bottom - ((entryDepth + curr) / depth) * height, w, (entryDepth / depth) * height);\n                curr += entryDepth;\n            }\n        }\n        const interbaseEvents = Object.keys(snpinfo.noncov);\n        if (showInterbaseCounts) {\n            let curr = 0;\n            for (const base of interbaseEvents) {\n                const { entryDepth } = snpinfo.noncov[base];\n                const r = 0.6;\n                ctx.fillStyle = colorForBase[base];\n                ctx.fillRect(leftPx - r + extraHorizontallyFlippedOffset, INTERBASE_INDICATOR_HEIGHT + toHeight2(curr), r * 2, toHeight2(entryDepth));\n                curr += entryDepth;\n            }\n        }\n        if (showInterbaseIndicators) {\n            let accum = 0;\n            let max = 0;\n            let maxBase = '';\n            for (const base of interbaseEvents) {\n                const { entryDepth } = snpinfo.noncov[base];\n                accum += entryDepth;\n                if (entryDepth > max) {\n                    max = entryDepth;\n                    maxBase = base;\n                }\n            }\n            const indicatorComparatorScore = Math.max(score0, prevTotal);\n            if (accum > indicatorComparatorScore * indicatorThreshold &&\n                indicatorComparatorScore > MINIMUM_INTERBASE_INDICATOR_READ_DEPTH) {\n                ctx.fillStyle = colorForBase[maxBase];\n                ctx.beginPath();\n                const l = leftPx + extraHorizontallyFlippedOffset;\n                ctx.moveTo(l - INTERBASE_INDICATOR_WIDTH / 2, 0);\n                ctx.lineTo(l + INTERBASE_INDICATOR_WIDTH / 2, 0);\n                ctx.lineTo(l, INTERBASE_INDICATOR_HEIGHT);\n                ctx.fill();\n            }\n        }\n        prevTotal = score0;\n    }\n    if (showArcs) {\n        for (const f of feats) {\n            if (f.get('type') !== 'skip') {\n                continue;\n            }\n            const s = f.get('start');\n            const e = f.get('end');\n            const [left, right] = bpSpanPx(s, e, region, bpPerPx);\n            ctx.beginPath();\n            const effectiveStrand = f.get('effectiveStrand');\n            const pos = 'rgba(255,200,200,0.7)';\n            const neg = 'rgba(200,200,255,0.7)';\n            const neutral = 'rgba(200,200,200,0.7)';\n            if (effectiveStrand === 1) {\n                ctx.strokeStyle = pos;\n            }\n            else if (effectiveStrand === -1) {\n                ctx.strokeStyle = neg;\n            }\n            else {\n                ctx.strokeStyle = neutral;\n            }\n            ctx.lineWidth = Math.log(f.get('score') + 1);\n            ctx.moveTo(left, height - offset * 2);\n            ctx.bezierCurveTo(left, 0, right, 0, right, height - offset * 2);\n            ctx.stroke();\n        }\n    }\n    if (displayCrossHatches) {\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = 'rgba(140,140,140,0.8)';\n        for (const tick of ticks.values) {\n            ctx.beginPath();\n            ctx.moveTo(0, Math.round(toY(tick)));\n            ctx.lineTo(width, Math.round(toY(tick)));\n            ctx.stroke();\n        }\n    }\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0]}