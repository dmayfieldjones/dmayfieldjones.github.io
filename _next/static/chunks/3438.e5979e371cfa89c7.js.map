{"version":3,"file":"static/chunks/3438.e5979e371cfa89c7.js","mappings":"8KAiBO,gBACP,aAAY,8GAAkI,EAC9I,OACA,oBACA,QACA,EAAmB,oBAAc,aACjC,EAAsB,oBAAc,gBACpC,EAA6B,oBAAc,uBAC3C,EAAuB,oBAAc,wBACrC,EAAoB,oBAAc,cAClC,EAAkB,cAAQ,EAAG,iBAAkC,EAC/D,EAAoB,eAAS,cAC7B,aACA,OACA,OACA,KAAuB,WAAK,oBAC5B,eACA,0BACA,KACA,2BACA,KACA,WACA,oBACA,mBACA,MACA,EAEA,aADA,oBACA,aACA,0BACgB,oBAAc,GAC9B,qBAEA,SAAsC,mBAAa,QACnD,qBACA,mBApCA,GAoCA,GACA,oBACA,SACA,IACA,EACA,MACA,EACA,YArDA,KACA,gBACA,UACA,MAAW,YAAM,EAAG,OAAgB,WAAK,UAAa,CACtD,GAiD6C,YAAM,eACnC,iBAAW,oBAC3B,GACA,CACA,CAIA,aAHA,SACA,SACA,oBACA,aACA,0BACgB,oBAAc,GAC9B,qBAEA,SAAsC,mBAAa,QACnD,iBACA,oBACA,oBACA,mBACA,SACA,OACA,MACA,EACA,EAAiC,YAAM,SACvC,IAA6B,YAAM,UACnC,WACA,EACA,eArEA,GAqEA,GACA,gCACA,UACA,KAEA,cACY,iBAAW,oBACvB,GACA,CAIA,aAHA,SACA,SACA,oBACA,aACA,0BACgB,oBAAc,GAC9B,qBAEA,SAAsC,mBAAa,QACnD,qBACA,wBACA,SACA,eA1FA,GA0FA,GACA,IACA,EACA,MACA,EACA,GApGA,cACA,gBACA,SACA,MAAW,YAAM,EAAG,OAAgB,WAAK,UAAa,CACtD,GAgG4C,YAAM,eAClC,iBAAW,oBAC3B,GACA,CACA,CACA,MAGA,aADA,oBACA,aACA,0BACgB,oBAAc,GAC9B,qBAEA,SAAsC,mBAAa,QACnD,gCACA,UACA,KAEA,qBACA,SACA,cACA,mBApHA,GAoHA,GACA,cACA,2CACgB,iBAAW,mBAC3B,MACA,cACA,2CACgB,iBAAW,mBAC3B,KAEgB,iBAAW,mBAE3B,CAGA,GADA,SACA,EAGA,aAFA,cACA,oBACA,aACA,0BACgB,oBAAc,GAC9B,qBAEA,SAAsC,mBAAa,QACnD,MA5IA,GA6IA,gBACA,KACgB,iBAAW,OA9I3B,EA8I2B,GAE3B,0BACgB,iBAAW,OAjJ3B,EAiJ2B,EAE3B,CAaA,OAXA,YACA,IACA,cACA,sCACA,qBACA,cACA,6BACA,6BACA,UACA,CAAS,GAET,iBAAa,EACb","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-wiggle/esm/drawXY.js"],"sourcesContent":["import { readConfObject } from '@jbrowse/core/configuration';\nimport { clamp, featureSpanPx } from '@jbrowse/core/util';\nimport { colord } from '@jbrowse/core/util/colord';\nimport { checkStopToken } from '@jbrowse/core/util/stopToken';\nimport { fillRectCtx, getOrigin, getScale } from './util';\nfunction lighten(color, amount) {\n    const hslColor = color.toHsl();\n    const l = hslColor.l * (1 + amount);\n    return colord({ ...hslColor, l: clamp(l, 0, 100) });\n}\nfunction darken(color, amount) {\n    const hslColor = color.toHsl();\n    const l = hslColor.l * (1 - amount);\n    return colord({ ...hslColor, l: clamp(l, 0, 100) });\n}\nconst fudgeFactor = 0.3;\nconst clipHeight = 2;\nexport function drawXY(ctx, props) {\n    const { features, bpPerPx, regions, scaleOpts, height: unadjustedHeight, config, ticks, displayCrossHatches, offset = 0, colorCallback, } = props;\n    const region = regions[0];\n    const width = (region.end - region.start) / bpPerPx;\n    const height = unadjustedHeight - offset * 2;\n    const filled = readConfObject(config, 'filled');\n    const clipColor = readConfObject(config, 'clipColor');\n    const summaryScoreMode = readConfObject(config, 'summaryScoreMode');\n    const pivotValue = readConfObject(config, 'bicolorPivotValue');\n    const minSize = readConfObject(config, 'minSize');\n    const scale = getScale({ ...scaleOpts, range: [0, height] });\n    const originY = getOrigin(scaleOpts.scaleType);\n    const domain = scale.domain();\n    const niceMin = domain[0];\n    const niceMax = domain[1];\n    const toY = (n) => clamp(height - (scale(n) || 0), 0, height) + offset;\n    const toOrigin = (n) => toY(originY) - toY(n);\n    const getHeight = (n) => (filled ? toOrigin(n) : Math.max(minSize, 1));\n    let hasClipping = false;\n    let prevLeftPx = Number.NEGATIVE_INFINITY;\n    const reducedFeatures = [];\n    const crossingOrigin = niceMin < pivotValue && niceMax > pivotValue;\n    let start = performance.now();\n    if (summaryScoreMode === 'whiskers') {\n        let lastCol;\n        let lastMix;\n        start = performance.now();\n        for (const feature of features.values()) {\n            if (performance.now() - start > 400) {\n                checkStopToken();\n                start = performance.now();\n            }\n            const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx);\n            if (feature.get('summary')) {\n                const w = Math.max(rightPx - leftPx + fudgeFactor, minSize);\n                const max = feature.get('maxScore');\n                const c = colorCallback(feature, max);\n                const effectiveC = crossingOrigin\n                    ? c\n                    : c === lastCol\n                        ? lastMix\n                        : (lastMix = lighten(colord(c), 0.4).toHex());\n                fillRectCtx(leftPx, toY(max), w, getHeight(max), ctx, effectiveC);\n                lastCol = c;\n            }\n        }\n        lastMix = undefined;\n        lastCol = undefined;\n        start = performance.now();\n        for (const feature of features.values()) {\n            if (performance.now() - start > 400) {\n                checkStopToken();\n                start = performance.now();\n            }\n            const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx);\n            const score = feature.get('score');\n            const max = feature.get('maxScore');\n            const min = feature.get('minScore');\n            const summary = feature.get('summary');\n            const c = colorCallback(feature, score);\n            const effectiveC = crossingOrigin && summary\n                ? c === lastCol\n                    ? lastMix\n                    : (lastMix = colord(colorCallback(feature, max))\n                        .mix(colord(colorCallback(feature, min)))\n                        .toString())\n                : c;\n            const w = Math.max(rightPx - leftPx + fudgeFactor, minSize);\n            if (Math.floor(leftPx) !== Math.floor(prevLeftPx)) {\n                reducedFeatures.push(feature);\n                prevLeftPx = leftPx;\n            }\n            hasClipping = hasClipping || score < niceMin || score > niceMax;\n            fillRectCtx(leftPx, toY(score), w, getHeight(score), ctx, effectiveC);\n            lastCol = c;\n        }\n        lastMix = undefined;\n        lastCol = undefined;\n        start = performance.now();\n        for (const feature of features.values()) {\n            if (performance.now() - start > 400) {\n                checkStopToken();\n                start = performance.now();\n            }\n            const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx);\n            if (feature.get('summary')) {\n                const min = feature.get('minScore');\n                const c = colorCallback(feature, min);\n                const w = Math.max(rightPx - leftPx + fudgeFactor, minSize);\n                const effectiveC = crossingOrigin\n                    ? c\n                    : c === lastCol\n                        ? lastMix\n                        : (lastMix = darken(colord(c), 0.4).toHex());\n                fillRectCtx(leftPx, toY(min), w, getHeight(min), ctx, effectiveC);\n                lastCol = c;\n            }\n        }\n    }\n    else {\n        start = performance.now();\n        for (const feature of features.values()) {\n            if (performance.now() - start > 400) {\n                checkStopToken();\n                start = performance.now();\n            }\n            const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx);\n            if (Math.floor(leftPx) !== Math.floor(prevLeftPx)) {\n                reducedFeatures.push(feature);\n                prevLeftPx = leftPx;\n            }\n            const score = feature.get('score');\n            const c = colorCallback(feature, score);\n            hasClipping = hasClipping || score < niceMin || score > niceMax;\n            const w = Math.max(rightPx - leftPx + fudgeFactor, minSize);\n            if (summaryScoreMode === 'max') {\n                const s = feature.get('summary') ? feature.get('maxScore') : score;\n                fillRectCtx(leftPx, toY(s), w, getHeight(s), ctx, c);\n            }\n            else if (summaryScoreMode === 'min') {\n                const s = feature.get('summary') ? feature.get('minScore') : score;\n                fillRectCtx(leftPx, toY(s), w, getHeight(s), ctx, c);\n            }\n            else {\n                fillRectCtx(leftPx, toY(score), w, getHeight(score), ctx, c);\n            }\n        }\n    }\n    ctx.save();\n    if (hasClipping) {\n        ctx.fillStyle = clipColor;\n        start = performance.now();\n        for (const feature of features.values()) {\n            if (performance.now() - start > 400) {\n                checkStopToken();\n                start = performance.now();\n            }\n            const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx);\n            const w = rightPx - leftPx + fudgeFactor;\n            const score = feature.get('score');\n            if (score > niceMax) {\n                fillRectCtx(leftPx, offset, w, clipHeight, ctx);\n            }\n            else if (score < niceMin && scaleOpts.scaleType !== 'log') {\n                fillRectCtx(leftPx, unadjustedHeight, w, clipHeight, ctx);\n            }\n        }\n    }\n    ctx.restore();\n    if (displayCrossHatches) {\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = 'rgba(200,200,200,0.5)';\n        ticks.values.forEach(tick => {\n            ctx.beginPath();\n            ctx.moveTo(0, Math.round(toY(tick)));\n            ctx.lineTo(width, Math.round(toY(tick)));\n            ctx.stroke();\n        });\n    }\n    return { reducedFeatures };\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0]}