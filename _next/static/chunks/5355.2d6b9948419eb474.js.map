{"version":3,"file":"static/chunks/5355.2d6b9948419eb474.js","mappings":"qLAKe,iBAA8B,wBAAsB,CACnE,qBACA,yBACA,qCACA,qCACA,sCACA,EAA2B,kBAAY,MACvC,YACA,MAA6B,IAAgB,EAC7C,aACA,gBAAmC,kBAAY,aAC/C,gBAAgD,OAAZ,kBAAY,MAChD,wBACA,CAAS,EACT,8BACA,sBACA,OACA,cACA,WACA,QACA,CACA,CACA,kBAOA,OANA,iBACA,+CAEA,MADA,uBACA,CACA,EAAa,EAEb,gBAEA,iBACA,aAAgB,iBAAwB,uBACxC,YACA,SAIA,MAFA,sBACA,mCACA,OACA,uCACA,EACA,SACA,WACA,iBACA,MACA,CACA,sBAA+B,EAC/B,aAAgB,GAAW,uBAC3B,qCACA,CACA,kBACA,aAAgB,GAAW,uBAC3B,oBACA,CACA,kBAAgC,EAChC,MAAe,sBAAgB,WAC/B,MACA,aAAoB,GAAW,uBAE/B,eAAoB,GAAgB,MADpC,gBAEA,UACA,YACA,UACA,QACA,iFACA,6CACA,qBACA,mBACA,OACA,QACA,gBACA,eACA,oCACA,sCAAkE,EAAK,mBAAmB,GAAU,aAAa,EAAO,4CAExH,YAAoC,WAAiB,KACrD,SAA4C,QAAQ,GAAG,EAAW,GAAG,EAAE,EACvE,kBACA,cAAyD,EAAE,EAC3D,GACA,WAA8C,eAAa,EAC3D,KACA,MACA,UACA,QACA,MACA,QACA,QACA,CAAiC,CACJ,EAE7B,CACA,CAAiB,CACjB,KACa,EACb,YACA,CAAS,CACT,CACA,iBACA","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-bed/esm/BedGraphTabixAdapter/BedGraphTabixAdapter.js"],"sourcesContent":["import { TabixIndexedFile } from '@gmod/tabix';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { SimpleFeature } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nexport default class BedGraphAdapter extends BaseFeatureDataAdapter {\n    async configurePre() {\n        const pm = this.pluginManager;\n        const bedGraphGzLocation = this.getConf('bedGraphGzLocation');\n        const location = this.getConf(['index', 'location']);\n        const indexType = this.getConf(['index', 'indexType']);\n        const filehandle = openLocation(bedGraphGzLocation, pm);\n        const isCSI = indexType === 'CSI';\n        const bedGraph = new TabixIndexedFile({\n            filehandle,\n            csiFilehandle: isCSI ? openLocation(location, pm) : undefined,\n            tbiFilehandle: !isCSI ? openLocation(location, pm) : undefined,\n            chunkCacheSize: 50 * 2 ** 20,\n        });\n        const columnNames = this.getConf('columnNames');\n        const header = await bedGraph.getHeader();\n        return {\n            columnNames,\n            bedGraph,\n            header,\n        };\n    }\n    async configure() {\n        if (!this.configured) {\n            this.configured = this.configurePre().catch((e) => {\n                this.configured = undefined;\n                throw e;\n            });\n        }\n        return this.configured;\n    }\n    async getNames() {\n        const { bedGraph, columnNames } = await this.configure();\n        if (columnNames.length) {\n            return columnNames;\n        }\n        const header = await bedGraph.getHeader();\n        const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f);\n        const defline = defs.at(-1);\n        return (defline === null || defline === void 0 ? void 0 : defline.includes('\\t'))\n            ? defline\n                .slice(1)\n                .split('\\t')\n                .map(f => f.trim())\n            : undefined;\n    }\n    async getRefNames(opts = {}) {\n        const { bedGraph } = await this.configure();\n        return bedGraph.getReferenceSequenceNames(opts);\n    }\n    async getHeader() {\n        const { bedGraph } = await this.configure();\n        return bedGraph.getHeader();\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            var _a;\n            const { bedGraph } = await this.configure();\n            const meta = await bedGraph.getMetadata();\n            const { columnNumbers } = meta;\n            const colRef = columnNumbers.ref - 1;\n            const colStart = columnNumbers.start - 1;\n            const colEnd = columnNumbers.end - 1;\n            const same = colStart === colEnd;\n            const names = ((_a = (await this.getNames())) === null || _a === void 0 ? void 0 : _a.slice(same ? 2 : 3)) || [];\n            await bedGraph.getLines(query.refName, query.start + (same ? -1 : 0), query.end, {\n                lineCallback: (line, fileOffset) => {\n                    const cols = line.split('\\t');\n                    const refName = cols[colRef];\n                    const start = +cols[colStart];\n                    const end = +(same ? start + 1 : cols[colEnd]);\n                    const rest = cols.slice(colEnd + 1);\n                    if (Number.isNaN(start) || Number.isNaN(end)) {\n                        throw new Error(`start/end NaN on line \"${line}\", with colStart:${colStart} and colEnd:${colEnd}. run \"tabix -p bed\" to ensure bed preset`);\n                    }\n                    for (let j = 0; j < rest.length; j++) {\n                        const uniqueId = `${this.id}-${fileOffset}-${j}`;\n                        const score = Math.abs(+rest[j]);\n                        const source = names[j] || `col${j}`;\n                        if (score) {\n                            observer.next(new SimpleFeature({\n                                id: uniqueId,\n                                data: {\n                                    refName,\n                                    start,\n                                    end,\n                                    score,\n                                    source,\n                                },\n                            }));\n                        }\n                    }\n                },\n                ...opts,\n            });\n            observer.complete();\n        });\n    }\n    freeResources() { }\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0]}