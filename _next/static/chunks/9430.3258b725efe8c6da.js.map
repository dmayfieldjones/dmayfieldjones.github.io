{"version":3,"file":"static/chunks/9430.3258b725efe8c6da.js","mappings":"kKAEA,gBACA,gBACA,uCACA,eAEA,0BAMA,EALA,0BACA,8BACA,wDAEA,QAEA,IACA,iBACA,eACA,wBACA,qBACA,qBACA,QACA,mBACA,GAAwB,gBACxB,MAEA,CACA,QACA,UACA,aACA,QACA,UACA,aACA,iBACA,mBAGA,OACA,8CACA,yCACA,CACA,CACe,QACf,aAAkB,+BAA4B,EAC9C,KACA,kBAEA,KACA,eAA6B,WAAS,SAGtC,sEAEA,KACA,gBAEA,KACA,aAA2B,WAAS,SAEpC,KACA,aAA2B,WAAS,IAAI,EAAK,YAG7C,gEAEA,CACA,qBAIA,OAHA,cACA,6BAEA,aAQA,0BACA,oDACA,CAOA,0BACA,SAEA,2BADA,4BACA,IACA,mBAEA,QACA,CAOA,2BACA,MAEA,iBADA,4BACA,qCAOA,gCACA,4CAQA,+BACA,wCACA,KAGA,yCACA,CAMA,iCACA,0CACA,KAGA,yCACA,CAEA,2BACA,sCACA,CACA,sCACA,QACA,OACA,qDAKA,GAHA,0BACA,aAEA,KACA,SAEA,aACA,WACA,EAAyB,QAAM,gBAE/B,OADA,iCACA,qCACA,CACA,CC7Je,gBAAgC,EAC/C,UAD2D,EAC3D,OAAkB,yCAA0C,EAC5D,aAAgB,yBAA2B,EAC3C,KAEA,eAA6B,gBAAc,EAC3C,aACA,eACA,CAAa,EAEb,MAEA,gBAA6B,gBAAc,OAAG,aAAe,CAE7D,CACA,qFEde,iBAAgC,SAAY,CAC3D,iBACA,oCACA,8BACA,8BACA,GACA,MAAmB,kBAAY,uBAC/B,IAAiB,kBAAY,uBAC7B,IAAiB,kBAAY,sBAC7B,EACA,OAAiB,UAAW,IAAiB,IAC7C,CACA,4ICPe,iBAAkC,qBAAmB,CACpE,cACA,oBACA,kBAA4B,GAAqB,EACjD,UAAuB,SAAQ,EAAG,YAAc,EAChD,eACA,YAAwB,yBAA6B,EACrD,2BACA,CAAa,CACJ,CACT,CACA,qBACA,UAAgB,GAAQ,mBACxB,2BACA,CACA,oBACA,UAAgB,GAAQ,mBACxB,6BACA,+BACA,UACA,QACA,SACA,CAAS,CACT,CACA,iBACA,oCACA,8BACA,OACA,UAAuB,IAAY,EACnC,MAAuB,kBAAY,uBACnC,IAAqB,kBAAY,sBACjC,CAAa,CACb,CACA,CACA,kBACA,uCACA,sDACA,KACc,kBAAY,uCAC1B,CACA,cAOA,OANA,aACA,uCAEA,MADA,mBACA,CACA,EAAa,EAEb,YAEA,iBACA,mBAAgB,QAA0B,cAAc,MACxD,SAAgB,iBAAsB,EACtC,MAAe,sBAAgB,WAC/B,MAAkB,mBAAa,sCAC/B,UAAwB,GAAQ,mBAEhC,WADA,2BACA,GACA,KAEA,MADA,MAEA,KAFA,MAEA,EAFA,KAEA,EACA,YAAyC,IAAgB,GAHzD,MAGyD,CACzD,OACA,UACA,QACA,MAPA,KAQA,EACoB,oBAAc,IAClC,kDAA6E,aAAa,EAC1F,CACA,QACA,eACA,SACA,WACA,aACA,GACA,WAAsC,eAAa,EACnD,MAA+B,EAAQ,GAAG,EAAM,GAAG,EAAU,EAC7D,MACA,UACA,QACA,MACA,KACA,CAAyB,CACJ,EAErB,CAAa,EACb,YACA,CAAS,CACT,CACA,iBACA","sources":["webpack://_N_E/./node_modules/@gmod/indexedfasta/esm/indexedFasta.js","webpack://_N_E/./node_modules/@gmod/indexedfasta/esm/bgzipIndexedFasta.js","webpack://_N_E/./node_modules/@gmod/indexedfasta/esm/index.js","webpack://_N_E/./node_modules/@jbrowse/plugin-sequence/esm/BgzipFastaAdapter/BgzipFastaAdapter.js","webpack://_N_E/./node_modules/@jbrowse/plugin-sequence/esm/IndexedFastaAdapter/IndexedFastaAdapter.js"],"sourcesContent":["import { LocalFile } from 'generic-filehandle';\nimport { Buffer } from 'buffer';\nfunction _faiOffset(idx, pos) {\n    return (idx.offset +\n        idx.lineBytes * Math.floor(pos / idx.lineLength) +\n        (pos % idx.lineLength));\n}\nasync function readFAI(fai, opts) {\n    const text = await fai.readFile(opts);\n    if (!(text === null || text === void 0 ? void 0 : text.length)) {\n        throw new Error('No data read from FASTA index (FAI) file');\n    }\n    let idCounter = 0;\n    let currSeq;\n    const data = text\n        .toString('utf8')\n        .split(/\\r?\\n/)\n        .filter(line => /\\S/.test(line))\n        .map(line => line.split('\\t'))\n        .filter(row => row[0] !== '')\n        .map(row => {\n        if (!currSeq || currSeq.name !== row[0]) {\n            currSeq = { name: row[0], id: idCounter };\n            idCounter += 1;\n        }\n        return {\n            id: currSeq.id,\n            name: row[0],\n            length: +row[1],\n            start: 0,\n            end: +row[1],\n            offset: +row[2],\n            lineLength: +row[3],\n            lineBytes: +row[4],\n        };\n    });\n    return {\n        name: Object.fromEntries(data.map(entry => [entry.name, entry])),\n        id: Object.fromEntries(data.map(entry => [entry.id, entry])),\n    };\n}\nexport default class IndexedFasta {\n    constructor({ fasta, fai, path, faiPath, }) {\n        if (fasta) {\n            this.fasta = fasta;\n        }\n        else if (path) {\n            this.fasta = new LocalFile(path);\n        }\n        else {\n            throw new Error('Need to pass filehandle for fasta or path to localfile');\n        }\n        if (fai) {\n            this.fai = fai;\n        }\n        else if (faiPath) {\n            this.fai = new LocalFile(faiPath);\n        }\n        else if (path) {\n            this.fai = new LocalFile(`${path}.fai`);\n        }\n        else {\n            throw new Error('Need to pass filehandle for  or path to localfile');\n        }\n    }\n    async _getIndexes(opts) {\n        if (!this.indexes) {\n            this.indexes = readFAI(this.fai, opts);\n        }\n        return this.indexes;\n    }\n    /**\n     * @returns {array[string]} array of string sequence\n     * names that are present in the index, in which the\n     * array index indicates the sequence ID, and the value\n     * is the sequence name\n     */\n    async getSequenceNames(opts) {\n        return Object.keys((await this._getIndexes(opts)).name);\n    }\n    /**\n     * @returns {array[string]} array of string sequence\n     * names that are present in the index, in which the\n     * array index indicates the sequence ID, and the value\n     * is the sequence name\n     */\n    async getSequenceSizes(opts) {\n        const returnObject = {};\n        const idx = await this._getIndexes(opts);\n        for (const val of Object.values(idx.id)) {\n            returnObject[val.name] = val.length;\n        }\n        return returnObject;\n    }\n    /**\n     * @returns {array[string]} array of string sequence\n     * names that are present in the index, in which the\n     * array index indicates the sequence ID, and the value\n     * is the sequence name\n     */\n    async getSequenceSize(seqName, opts) {\n        var _a;\n        const idx = await this._getIndexes(opts);\n        return (_a = idx.name[seqName]) === null || _a === void 0 ? void 0 : _a.length;\n    }\n    /**\n     *\n     * @param {string} name\n     * @returns {Promise[boolean]} true if the file contains the given reference sequence name\n     */\n    async hasReferenceSequence(name, opts) {\n        return !!(await this._getIndexes(opts)).name[name];\n    }\n    /**\n     *\n     * @param {number} seqId\n     * @param {number} min\n     * @param {number} max\n     */\n    async getResiduesById(seqId, min, max, opts) {\n        const indexEntry = (await this._getIndexes(opts)).id[seqId];\n        if (!indexEntry) {\n            return undefined;\n        }\n        return this._fetchFromIndexEntry(indexEntry, min, max, opts);\n    }\n    /**\n     * @param {string} seqName\n     * @param {number} min\n     * @param {number} max\n     */\n    async getResiduesByName(seqName, min, max, opts) {\n        const indexEntry = (await this._getIndexes(opts)).name[seqName];\n        if (!indexEntry) {\n            return undefined;\n        }\n        return this._fetchFromIndexEntry(indexEntry, min, max, opts);\n    }\n    //alias for getResiduesByName\n    async getSequence(seqName, min, max, opts) {\n        return this.getResiduesByName(seqName, min, max, opts);\n    }\n    async _fetchFromIndexEntry(indexEntry, min = 0, max, opts) {\n        let end = max;\n        if (min < 0) {\n            throw new TypeError('regionStart cannot be less than 0');\n        }\n        if (end === undefined || end > indexEntry.length) {\n            end = indexEntry.length;\n        }\n        if (min >= end) {\n            return '';\n        }\n        const position = _faiOffset(indexEntry, min);\n        const readlen = _faiOffset(indexEntry, end) - position;\n        const residues = Buffer.allocUnsafe(readlen);\n        await this.fasta.read(residues, 0, readlen, position, opts);\n        return residues.toString('utf8').replace(/\\s+/g, '');\n    }\n}\n//# sourceMappingURL=indexedFasta.js.map","import { BgzfFilehandle } from '@gmod/bgzf-filehandle';\nimport IndexedFasta from './indexedFasta';\nexport default class BgzipIndexedFasta extends IndexedFasta {\n    constructor({ fasta, path, fai, faiPath, gzi, gziPath, }) {\n        super({ fasta, path, fai, faiPath });\n        if (fasta && gzi) {\n            // @ts-expect-error\n            this.fasta = new BgzfFilehandle({\n                filehandle: fasta,\n                gziFilehandle: gzi,\n            });\n        }\n        else if (path && gziPath) {\n            // @ts-expect-error\n            this.fasta = new BgzfFilehandle({ path, gziPath });\n        }\n    }\n}\n//# sourceMappingURL=bgzipIndexedFasta.js.map","import { LocalFile } from 'generic-filehandle';\nfunction parseSmallFasta(text) {\n    return text\n        .split('>')\n        .filter(t => /\\S/.test(t))\n        .map(entryText => {\n        const [defLine, ...seqLines] = entryText.split('\\n');\n        const [id, ...description] = defLine.split(' ');\n        const sequence = seqLines.join('').replace(/\\s/g, '');\n        return {\n            id,\n            description: description.join(' '),\n            sequence,\n        };\n    });\n}\n// memoized\nclass FetchableSmallFasta {\n    constructor({ fasta, path }) {\n        if (fasta) {\n            this.fasta = fasta;\n        }\n        else if (path) {\n            this.fasta = new LocalFile(path);\n        }\n        else {\n            throw new Error('Need to pass fasta or path');\n        }\n        this.data = this.fasta.readFile().then(buffer => {\n            const text = buffer.toString('utf8');\n            return parseSmallFasta(text);\n        });\n    }\n    async fetch(id, start, end) {\n        const data = await this.data;\n        const entry = data.find(iter => iter.id === id);\n        const length = end - start;\n        if (!entry) {\n            throw new Error(`no sequence with id ${id} exists`);\n        }\n        return entry.sequence.slice(start, length);\n    }\n    async getSequenceNames() {\n        const data = await this.data;\n        return data.map(entry => entry.id);\n    }\n}\nexport { parseSmallFasta, FetchableSmallFasta };\nexport { default as BgzipIndexedFasta } from './bgzipIndexedFasta';\nexport { default as IndexedFasta } from './indexedFasta';\n//# sourceMappingURL=index.js.map","import { BgzipIndexedFasta } from '@gmod/indexedfasta';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport IndexedFasta from '../IndexedFastaAdapter/IndexedFastaAdapter';\nexport default class BgzipFastaAdapter extends IndexedFasta {\n    async setupPre() {\n        const fastaLocation = this.getConf('fastaLocation');\n        const faiLocation = this.getConf('faiLocation');\n        const gziLocation = this.getConf('gziLocation');\n        const fastaOpts = {\n            fasta: openLocation(fastaLocation, this.pluginManager),\n            fai: openLocation(faiLocation, this.pluginManager),\n            gzi: openLocation(gziLocation, this.pluginManager),\n        };\n        return { fasta: new BgzipIndexedFasta(fastaOpts) };\n    }\n}\n","import AbortablePromiseCache from '@gmod/abortable-promise-cache';\nimport { IndexedFasta } from '@gmod/indexedfasta';\nimport { BaseSequenceAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { SimpleFeature, updateStatus2 } from '@jbrowse/core/util';\nimport QuickLRU from '@jbrowse/core/util/QuickLRU';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { checkStopToken } from '@jbrowse/core/util/stopToken';\nexport default class IndexedFastaAdapter extends BaseSequenceAdapter {\n    constructor() {\n        super(...arguments);\n        this.seqCache = new AbortablePromiseCache({\n            cache: new QuickLRU({ maxSize: 200 }),\n            fill: async (args) => {\n                const { refName, start, end, fasta } = args;\n                return fasta.getSequence(refName, start, end);\n            },\n        });\n    }\n    async getRefNames(_opts) {\n        const { fasta } = await this.setup();\n        return fasta.getSequenceNames();\n    }\n    async getRegions(_opts) {\n        const { fasta } = await this.setup();\n        const seqSizes = await fasta.getSequenceSizes();\n        return Object.keys(seqSizes).map(refName => ({\n            refName,\n            start: 0,\n            end: seqSizes[refName],\n        }));\n    }\n    async setupPre() {\n        const fastaLocation = this.getConf('fastaLocation');\n        const faiLocation = this.getConf('faiLocation');\n        return {\n            fasta: new IndexedFasta({\n                fasta: openLocation(fastaLocation, this.pluginManager),\n                fai: openLocation(faiLocation, this.pluginManager),\n            }),\n        };\n    }\n    async getHeader() {\n        const loc = this.getConf('metadataLocation');\n        return loc.uri === '' || loc.uri === '/path/to/fa.metadata.yaml'\n            ? null\n            : openLocation(loc, this.pluginManager).readFile('utf8');\n    }\n    async setup() {\n        if (!this.setupP) {\n            this.setupP = this.setupPre().catch((e) => {\n                this.setupP = undefined;\n                throw e;\n            });\n        }\n        return this.setupP;\n    }\n    getFeatures(region, opts) {\n        const { statusCallback = () => { }, stopToken } = opts || {};\n        const { refName, start, end } = region;\n        return ObservableCreate(async (observer) => {\n            await updateStatus2('Downloading sequence', statusCallback, stopToken, async () => {\n                const { fasta } = await this.setup();\n                const size = await fasta.getSequenceSize(refName);\n                const regionEnd = Math.min(size, end);\n                const chunks = [];\n                const chunkSize = 128000;\n                const s = start - (start % chunkSize);\n                const e = end + (chunkSize - (end % chunkSize));\n                for (let chunkStart = s; chunkStart < e; chunkStart += chunkSize) {\n                    const r = {\n                        refName,\n                        start: chunkStart,\n                        end: chunkStart + chunkSize,\n                    };\n                    checkStopToken(stopToken);\n                    chunks.push(await this.seqCache.get(JSON.stringify(r), { ...r, fasta }));\n                }\n                const seq = chunks\n                    .filter(f => !!f)\n                    .join('')\n                    .slice(start - s)\n                    .slice(0, end - start);\n                if (seq) {\n                    observer.next(new SimpleFeature({\n                        id: `${refName}-${start}-${regionEnd}`,\n                        data: {\n                            refName,\n                            start,\n                            end: regionEnd,\n                            seq,\n                        },\n                    }));\n                }\n            });\n            observer.complete();\n        });\n    }\n    freeResources() { }\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4]}