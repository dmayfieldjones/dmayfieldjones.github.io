{"version":3,"file":"static/chunks/5551.8a559136ca5a9af7.js","mappings":"gJAAO,wBACP,MACA,KACA,MAEA,MACA,KACA,MAEA,GACA,gBAEA,mBACA,CACO,wBACP,MACA,KACA,MAEA,MACA,KACA,MAEA,GACA,kBAEA,qBACA,2BGvBO,gBACP,cAAY,GAAY,EACxB,MACA,OAEA,oBAAY,GAAoB,gBAAU,IAC1C,EAAiB,uBAAiB,IAClC,qBACA,WACA,IAGsB,QAAc,IDZ7B,cCce,CDdW,iCAAkC,EACnE,kBACA,SACA,EAA0B,aAAO,oBACjC,+EACA,QAAY,WAAgB,EAC5B,eACA,eACA,WACA,OACA,8CACA,8CACA,sBAA4C,yBAA+B,gCAC3E,EAAyE,OAAzE,aAA4C,uBAA6B,gCACzE,EAA2E,OAA3E,aAA4C,yBAA+B,gCAC3E,sBAA4C,uBAA6B,gCACzE,IACA,eACA,YACA,YACA,YACA,0BACA,gCAEA,WADA,sBACA,EACA,CACA,QACA,MACA,MACA,MACA,MACA,KACA,KACA,UACA,CAAiB,CACjB,CACA,MACA,qBACA,WACA,8CACA,sBAA4C,yBAA+B,gCAC3E,sBAA4C,uBAA6B,gCACzE,2BACA,sBACgB,EAAW,6BACX,EAAa,4BAC7B,CACA,CAEA,eAA0B,SAAG,wBAC7B,oBAAmC,SAAG,6BACtC,sBACA,YAAiB,0CAAuC,KACxD,sBACA,kBACA,eAWO,MAA0B,oBAAsB,EACvD,kCACA,MAAe,QAAsC,QAErD,qBACA,MAAe,QAAyB,IAExC,oBACA,MAAe,QAAwB,QAEvC,mBACA,gCACA,wBACA,OACA,OAAmB,6BAAiC,WACpD,OAAmB,6BAAiC,WACpD,CAGA,EA9BA,CAAgD,yBAAqB,MACrE,oBACA,SACA,MACQ,EAAW,gCACX,EAAa,wBACb,EAAa,wBACb,EAAW,wBACX,EAAW,uBACnB,CACA,ECnDsB,MAAG,iCAAiC,EFdnD,cAA8B,IEiBX,GFjBW,2BAAkC,EACvE,cACA,SACA,KACA,QAAY,GAAS,EACrB,QAAY,GAAS,EACrB,EAA0B,aAAO,oBACjC,gBACA,uBACA,mBACA,gBACA,kDACA,8BAA2C,iBAA2B,gCACtE,8BAA2C,eAAyB,qCACpE,oBACA,gBACA,gBAEA,CACA,oBACA,UACA,SACA,CACA,eAA0B,SAAG,KAC7B,oBAAmC,SAAG,UACtC,eACA,SACA,YAAoB,WAAmB,SAOvC,EANA,WACA,OACA,oBAEQ,EADR,KACmB,8BACnB,WASA,aAFA,EALA,aAKA,MADA,8CAAqF,qBACrF,KAJA,SAMA,IACA,kDACA,sBAA2C,yBAA8B,gCACzE,EAAuE,OAAvE,aAA2C,uBAA4B,gCACvE,2BACA,sBACA,eAEA,MADA,WACA,sCACgB,EAAa,UAAgC,CAAhC,CAAgC,EAAW,KACxD,EAAW,UAAgC,IAAS,IACpE,CACA,CACA,CACA,EEvC0B,MAAG,iCAAiC,EAE9D,wFCtBO,OACP,sCACA,sCACA,2BACA,2BACA,iCACA,iCACA,0BACA,6BACA,wBACA,qBACA,qBACA,sBACA,yBACA,0BACA,uBACA,yBACA,oBACA,EACO,GACP,sCACA,sCACA,2BACA,2BACA,iCACA,iCACA,6BACA,6BACA,wBACA,wBACA,wBACA,wBACA,yBACA,2BACA,2BACA,4BACA,oBACA,EACO,kBACP,4BACA,6BACA,mCACA,wCAEA,mCACA,0CAEA,EAIA,OAHA,wCAMA,wCACO,kBACP,aACA,UACA,CACA,CACO,cAEP,MADiB,IAAgB,IACjC,wBACA,EAAkB,IAAO,IACzB,eACA,OACA,YAEO,cACP,cACA","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/LinearReadCloudDisplay/util.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/LinearReadCloudDisplay/drawLongReadChains.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/LinearReadCloudDisplay/drawPairChains.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/LinearReadCloudDisplay/drawFeats.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/shared/color.js"],"sourcesContent":["export function fillRectCtx(x, y, width, height, ctx, fillColor) {\n    if (width < 0) {\n        x += width;\n        width = -width;\n    }\n    if (height < 0) {\n        y += height;\n        height = -height;\n    }\n    if (fillColor) {\n        ctx.fillStyle = fillColor;\n    }\n    ctx.fillRect(x, y, width, height);\n}\nexport function strokeRectCtx(x, y, width, height, ctx, strokeColor) {\n    if (width < 0) {\n        x += width;\n        width = -width;\n    }\n    if (height < 0) {\n        y += height;\n        height = -height;\n    }\n    if (strokeColor) {\n        ctx.strokeStyle = strokeColor;\n    }\n    ctx.strokeRect(x, y, width, height);\n}\n","import { getConf } from '@jbrowse/core/configuration';\nimport { max, min } from '@jbrowse/core/util';\nimport { fillRectCtx, strokeRectCtx } from './util';\nimport { fillColor, strokeColor } from '../shared/color';\nexport function drawLongReadChains({ ctx, self, chainData, view, asm, }) {\n    var _a, _b, _c, _d, _e;\n    const distances = [];\n    const minXs = [];\n    const { chains } = chainData;\n    const { height } = self;\n    const featureHeight = getConf(self, 'featureHeight');\n    for (const chain of chains) {\n        let minX = Number.MAX_VALUE;\n        let maxX = Number.MIN_VALUE;\n        for (const elt of chain) {\n            const refName = asm.getCanonicalRefName(elt.refName) || elt.refName;\n            const rs = (_a = view.bpToPx({ refName, coord: elt.start })) === null || _a === void 0 ? void 0 : _a.offsetPx;\n            const re = (_b = view.bpToPx({ refName, coord: elt.end })) === null || _b === void 0 ? void 0 : _b.offsetPx;\n            if (rs !== undefined && re !== undefined) {\n                minX = Math.min(minX, rs);\n                maxX = Math.max(maxX, re);\n            }\n        }\n        const distance = Math.abs(maxX - minX);\n        distances.push(distance);\n        minXs.push(minX);\n    }\n    const maxD = Math.log(max(distances));\n    const minD = Math.max(Math.log(min(distances)) - 1, 0);\n    const scaler = (height - 20) / (maxD - minD);\n    const halfHeight = featureHeight / 2 - 0.5;\n    for (let i = 0; i < chains.length; i++) {\n        const chain = chains[i];\n        const w = distances[i];\n        const top = (Math.log(w) - minD) * scaler;\n        const min = minXs[i];\n        fillRectCtx(min - view.offsetPx, top + halfHeight, w, 1, ctx, 'black');\n        const c1 = chain[0];\n        let primaryStrand;\n        if (!(c1.flags & 2048)) {\n            primaryStrand = c1.strand;\n        }\n        else {\n            const res = (_c = c1.SA) === null || _c === void 0 ? void 0 : _c.split(';')[0].split(',')[2];\n            primaryStrand = res === '-' ? -1 : 1;\n        }\n        for (const v0 of chain) {\n            const ra = asm.getCanonicalRefName(v0.refName) || v0.refName;\n            const rs = (_d = view.bpToPx({ refName: ra, coord: v0.start })) === null || _d === void 0 ? void 0 : _d.offsetPx;\n            const re = (_e = view.bpToPx({ refName: ra, coord: v0.end })) === null || _e === void 0 ? void 0 : _e.offsetPx;\n            if (rs !== undefined && re !== undefined) {\n                const w = Math.max(re - rs, 2);\n                const l = rs - view.offsetPx;\n                const effectiveStrand = v0.strand * primaryStrand;\n                const c = effectiveStrand === -1 ? 'color_rev_strand' : 'color_fwd_strand';\n                strokeRectCtx(l, top, w, featureHeight, ctx, strokeColor[c]);\n                fillRectCtx(l, top, w, featureHeight, ctx, fillColor[c]);\n            }\n        }\n    }\n}\n","import { getConf } from '@jbrowse/core/configuration';\nimport { max, min } from '@jbrowse/core/util';\nimport { fillRectCtx, strokeRectCtx } from './util';\nimport { getPairedInsertSizeAndOrientationColor, getPairedInsertSizeColor, getPairedOrientationColor, } from '../shared/color';\nexport function drawPairChains({ ctx, self, chainData, view, asm, }) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const coords = [];\n    const featureHeight = getConf(self, 'featureHeight');\n    const type = ((_a = self.colorBy) === null || _a === void 0 ? void 0 : _a.type) || 'insertSizeAndOrientation';\n    const { chains, stats } = chainData;\n    for (const chain of chains) {\n        if (chain.length > 1) {\n            const v0 = chain[0];\n            const v1 = chain[1];\n            const ra1 = asm.getCanonicalRefName(v0.refName) || v0.refName;\n            const ra2 = asm.getCanonicalRefName(v1.refName) || v1.refName;\n            const r1s = (_b = view.bpToPx({ refName: ra1, coord: v0.start })) === null || _b === void 0 ? void 0 : _b.offsetPx;\n            const r1e = (_c = view.bpToPx({ refName: ra1, coord: v0.end })) === null || _c === void 0 ? void 0 : _c.offsetPx;\n            const r2s = (_d = view.bpToPx({ refName: ra2, coord: v1.start })) === null || _d === void 0 ? void 0 : _d.offsetPx;\n            const r2e = (_e = view.bpToPx({ refName: ra2, coord: v1.end })) === null || _e === void 0 ? void 0 : _e.offsetPx;\n            let distance = 0;\n            if (r1s !== undefined &&\n                r1e !== undefined &&\n                r2s !== undefined &&\n                r2e !== undefined) {\n                if (v0.refName === v1.refName) {\n                    const s = Math.min(v0.start, v1.start);\n                    const e = Math.max(v0.end, v1.end);\n                    distance = Math.abs(e - s);\n                }\n                coords.push({\n                    r1s,\n                    r1e,\n                    r2s,\n                    r2e,\n                    v0,\n                    v1,\n                    distance,\n                });\n            }\n        }\n        else if (self.drawSingletons) {\n            const v0 = chain[0];\n            const ra1 = asm.getCanonicalRefName(v0.refName) || v0.refName;\n            const r1s = (_f = view.bpToPx({ refName: ra1, coord: v0.start })) === null || _f === void 0 ? void 0 : _f.offsetPx;\n            const r1e = (_g = view.bpToPx({ refName: ra1, coord: v0.end })) === null || _g === void 0 ? void 0 : _g.offsetPx;\n            if (r1s !== undefined && r1e !== undefined) {\n                const w1 = Math.max(r1e - r1s, 2);\n                fillRectCtx(r1s - view.offsetPx, 0, w1, featureHeight, ctx, '#f00');\n                strokeRectCtx(r1s - view.offsetPx, 0, w1, featureHeight, ctx, '#a00');\n            }\n        }\n    }\n    const maxD = Math.log(max(coords.map(c => c.distance)));\n    const minD = Math.max(Math.log(min(coords.map(c => c.distance))) - 1, 0);\n    const scaler = (self.height - 20) / (maxD - minD);\n    for (const { r1e, r1s, r2e, r2s, distance, v0, v1 } of coords) {\n        const w1 = Math.max(r1e - r1s, 2);\n        const w2 = Math.max(r2e - r2s, 2);\n        const [fill, stroke] = getPairedColor({ type, v0, v1, stats }) || [];\n        const top = (Math.log(distance) - minD) * scaler;\n        const halfHeight = featureHeight / 2 - 0.5;\n        const w = r2s - r1e;\n        fillRectCtx(r1e - view.offsetPx, top + halfHeight, w, 1, ctx, 'black');\n        strokeRectCtx(r1s - view.offsetPx, top, w1, featureHeight, ctx, stroke);\n        strokeRectCtx(r2s - view.offsetPx, top, w2, featureHeight, ctx, stroke);\n        fillRectCtx(r1s - view.offsetPx, top, w1, featureHeight, ctx, fill);\n        fillRectCtx(r2s - view.offsetPx, top, w2, featureHeight, ctx, fill);\n    }\n}\nexport function getPairedColor({ type, v0, v1, stats, }) {\n    if (type === 'insertSizeAndOrientation') {\n        return getPairedInsertSizeAndOrientationColor(v0, v1, stats);\n    }\n    if (type === 'orientation') {\n        return getPairedOrientationColor(v0);\n    }\n    if (type === 'insertSize') {\n        return getPairedInsertSizeColor(v0, v1, stats);\n    }\n    if (type === 'gradient') {\n        const s = Math.min(v0.start, v1.start);\n        const e = Math.max(v0.end, v1.end);\n        return [\n            `hsl(${Math.log10(Math.abs(e - s)) * 10},50%,50%)`,\n            `hsl(${Math.log10(Math.abs(e - s)) * 10},50%,30%)`,\n        ];\n    }\n    return undefined;\n}\n","import { getContainingView, getSession } from '@jbrowse/core/util';\nimport { drawLongReadChains } from './drawLongReadChains';\nimport { drawPairChains } from './drawPairChains';\nimport { hasPairedReads } from '../shared/util';\nexport function drawFeats(self, ctx) {\n    const { chainData } = self;\n    if (!chainData) {\n        return;\n    }\n    const { assemblyManager } = getSession(self);\n    const view = getContainingView(self);\n    const assemblyName = view.assemblyNames[0];\n    const asm = assemblyManager.get(assemblyName);\n    if (!asm) {\n        return;\n    }\n    const hasPaired = hasPairedReads(chainData);\n    if (hasPaired) {\n        drawPairChains({ self, view, asm, ctx, chainData });\n    }\n    else {\n        drawLongReadChains({ self, view, asm, ctx, chainData });\n    }\n}\n","import { orientationTypes, pairMap } from '../util';\nexport const fillColor = {\n    color_fwd_strand_not_proper: '#ECC8C8',\n    color_rev_strand_not_proper: '#BEBED8',\n    color_fwd_strand: '#EC8B8B',\n    color_rev_strand: '#8F8FD8',\n    color_fwd_missing_mate: '#D11919',\n    color_rev_missing_mate: '#1919D1',\n    color_fwd_diff_chr: '#000',\n    color_rev_diff_chr: '#969696',\n    color_pair_lr: '#c8c8c8',\n    color_pair_rr: 'navy',\n    color_pair_rl: 'teal',\n    color_pair_ll: 'green',\n    color_nostrand: '#c8c8c8',\n    color_interchrom: 'purple',\n    color_longinsert: 'red',\n    color_shortinsert: 'pink',\n    color_unknown: 'grey',\n};\nexport const strokeColor = {\n    color_fwd_strand_not_proper: '#CA6767',\n    color_rev_strand_not_proper: '#7272AA',\n    color_fwd_strand: '#DC2A2A',\n    color_rev_strand: '#4141BA',\n    color_fwd_missing_mate: '#921111',\n    color_rev_missing_mate: '#111192',\n    color_fwd_diff_chr: '#000000',\n    color_rev_diff_chr: '#696969',\n    color_pair_lr: '#8C8C8C',\n    color_pair_rr: '#00005A',\n    color_pair_rl: '#005A5A',\n    color_pair_ll: '#005A00',\n    color_nostrand: '#8C8C8C',\n    color_interchrom: '#5A005A',\n    color_longinsert: '#B30000',\n    color_shortinsert: '#FF3A5C',\n    color_unknown: 'grey',\n};\nexport function getPairedInsertSizeColor(f1, f2, stats) {\n    const sameRef = f1.refName === f2.refName;\n    const tlen = Math.abs(f1.tlen || 0);\n    if (sameRef && tlen > ((stats === null || stats === void 0 ? void 0 : stats.upper) || 0)) {\n        return [fillColor.color_longinsert, strokeColor.color_longinsert];\n    }\n    else if (sameRef && tlen < ((stats === null || stats === void 0 ? void 0 : stats.lower) || 0)) {\n        return [fillColor.color_shortinsert, strokeColor.color_shortinsert];\n    }\n    else if (!sameRef) {\n        return [fillColor.color_interchrom, strokeColor.color_interchrom];\n    }\n    else {\n        return undefined;\n    }\n}\nconst defaultColor = [fillColor.color_unknown, fillColor.color_unknown];\nexport function getPairedInsertSizeAndOrientationColor(f1, f2, stats) {\n    return (getPairedOrientationColorOrDefault(f1) ||\n        getPairedInsertSizeColor(f1, f2, stats) ||\n        defaultColor);\n}\nexport function getPairedOrientationColorOrDefault(f) {\n    const type = orientationTypes.fr;\n    const r = type[f.pair_orientation || ''];\n    const type2 = pairMap[r];\n    return r === 'LR'\n        ? undefined\n        : [fillColor[type2], strokeColor[type2]];\n}\nexport function getPairedOrientationColor(f) {\n    return getPairedOrientationColorOrDefault(f) || defaultColor;\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4]}