{"version":3,"file":"static/chunks/1895.50f9595313d0dc97.js","mappings":"2MAOA,iBAAyB,wBAAsB,CAC/C,cACA,oBACA,iCACA,CACA,kBACA,WAAgB,GAAS,mBACzB,QACA,CACA,oBACA,IAAgB,UAAS,mBACzB,sBACA,CACA,gBACA,mBAAgB,UAA6B,MAC7C,EAAoB,kBAAY,iDAChC,QAA6B,wBAAkB,MAC/C,KACA,KACA,IACA,0BACA,IACA,kBACA,sBACA,uCACA,qBACA,MACA,qBACA,cAEA,CACA,qBACA,cACA,OACA,UAEA,YACA,EAEA,YACA,aAA0C,0CAAyD,GAAG,kDAA6D,KAEnK,KACA,CACA,mBACA,MAA2B,GAAS,SAAG,EAAQ,EAC/C,qDACA,EACA,IACA,uCACA,+BACA,QACA,MAA6C,IAAY,CACzD,gBACA,UAAsC,GAAU,EAChD,uBACA,SACA,MAAmC,QAAQ,GAAG,EAAQ,GAAG,IAAM,CAC/D,CAAyB,EACzB,yCACA,CACA,mCACA,CACA,yCACa,CACb,GACA,OACA,SACA,SACA,iBACA,CACA,CACA,cAOA,OANA,kBACA,0CAEA,MADA,wBACA,CACA,EAAa,EAEb,iBAEA,sBAA4B,EAC5B,oBAAgB,GAAkB,mBAClC,qBACA,CACA,kBAAiC,EACjC,MAAe,sBAAgB,WAC/B,MACA,IACA,UAAwB,mBAAsB,EAC9C,iBAAwB,GAAkB,kBAC1C,mFACA,SACA,CAAiB,EACjB,YACA,CACA,SACA,UACA,CACA,CAAS,aACT,CACA,mBACA,yCACA,+CACA,IAAoB,UAAS,mBAC7B,0BACA,MACA,EAAa,CACb,CACA,CAEA,MADA,OAA8B,kBAAY,sBAC1C,oBACA,kBACA,QAAoB,GAAS,mBAC7B,qBACA,SACA,SACA,QACA,mBACA,OACA,UACA,yDAEA,CAAa,EACb,wBACA,CACA,CACA,iBACA,CACA,6CACA,MAAe","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-variants/esm/VcfAdapter/VcfAdapter.js"],"sourcesContent":["import IntervalTree from '@flatten-js/interval-tree';\nimport VcfParser from '@gmod/vcf';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { fetchAndMaybeUnzip } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport VcfFeature from '../VcfFeature';\nclass VcfAdapter extends BaseFeatureDataAdapter {\n    constructor() {\n        super(...arguments);\n        this.calculatedIntervalTreeMap = {};\n    }\n    async getHeader() {\n        const { header } = await this.setup();\n        return header;\n    }\n    async getMetadata() {\n        const { parser } = await this.setup();\n        return parser.getMetadata();\n    }\n    async setupP(opts) {\n        const { statusCallback = () => { } } = opts || {};\n        const loc = openLocation(this.getConf('vcfLocation'), this.pluginManager);\n        const buffer = await fetchAndMaybeUnzip(loc, opts);\n        const headerLines = [];\n        const featureMap = {};\n        let blockStart = 0;\n        const decoder = new TextDecoder('utf8');\n        let i = 0;\n        while (blockStart < buffer.length) {\n            const n = buffer.indexOf(10, blockStart);\n            const b = n === -1 ? buffer.subarray(blockStart) : buffer.subarray(blockStart, n);\n            const line = decoder.decode(b).trim();\n            if (line) {\n                if (line.startsWith('#')) {\n                    headerLines.push(line);\n                }\n                else {\n                    const ret = line.indexOf('\\t');\n                    const refName = line.slice(0, ret);\n                    if (!featureMap[refName]) {\n                        featureMap[refName] = [];\n                    }\n                    featureMap[refName].push(line);\n                }\n            }\n            if (i++ % 10000 === 0) {\n                statusCallback(`Loading ${Math.floor(blockStart / 1000000).toLocaleString('en-US')}/${Math.floor(buffer.length / 1000000).toLocaleString('en-US')} MB`);\n            }\n            blockStart = n + 1;\n        }\n        const header = headerLines.join('\\n');\n        const parser = new VcfParser({ header });\n        const intervalTreeMap = Object.fromEntries(Object.entries(featureMap).map(([refName, lines]) => [\n            refName,\n            (sc) => {\n                if (!this.calculatedIntervalTreeMap[refName]) {\n                    sc === null || sc === void 0 ? void 0 : sc('Parsing VCF data');\n                    let idx = 0;\n                    const intervalTree = new IntervalTree();\n                    for (const line of lines) {\n                        const f = new VcfFeature({\n                            variant: parser.parseLine(line),\n                            parser,\n                            id: `${this.id}-${refName}-${idx++}`,\n                        });\n                        intervalTree.insert([f.get('start'), f.get('end')], f);\n                    }\n                    this.calculatedIntervalTreeMap[refName] = intervalTree;\n                }\n                return this.calculatedIntervalTreeMap[refName];\n            },\n        ]));\n        return {\n            header,\n            parser,\n            intervalTreeMap,\n        };\n    }\n    async setup() {\n        if (!this.vcfFeatures) {\n            this.vcfFeatures = this.setupP().catch((e) => {\n                this.vcfFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.vcfFeatures;\n    }\n    async getRefNames(_ = {}) {\n        const { intervalTreeMap } = await this.setup();\n        return Object.keys(intervalTreeMap);\n    }\n    getFeatures(region, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            var _a;\n            try {\n                const { start, end, refName } = region;\n                const { intervalTreeMap } = await this.setup();\n                (_a = intervalTreeMap[refName]) === null || _a === void 0 ? void 0 : _a.call(intervalTreeMap, opts.statusCallback).search([start, end]).forEach(f => {\n                    observer.next(f);\n                });\n                observer.complete();\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.stopToken);\n    }\n    async getSources() {\n        const conf = this.getConf('samplesTsvLocation');\n        if (conf.uri === '' || conf.uri === '/path/to/samples.tsv') {\n            const { parser } = await this.setup();\n            return parser.samples.map(name => ({\n                name,\n            }));\n        }\n        else {\n            const txt = await openLocation(conf).readFile('utf8');\n            const lines = txt.split(/\\n|\\r\\n|\\r/);\n            const header = lines[0].split('\\t');\n            const { parser } = await this.setup();\n            const s = new Set(parser.samples);\n            return lines\n                .slice(1)\n                .map(line => {\n                const cols = line.split('\\t');\n                return {\n                    name: cols[0],\n                    ...Object.fromEntries(cols.slice(1).map((c, idx) => [header[idx + 1], c])),\n                };\n            })\n                .filter(f => s.has(f.name));\n        }\n    }\n    freeResources() { }\n}\nVcfAdapter.capabilities = ['getFeatures', 'getRefNames'];\nexport default VcfAdapter;\n"],"names":[],"sourceRoot":"","ignoreList":[0]}