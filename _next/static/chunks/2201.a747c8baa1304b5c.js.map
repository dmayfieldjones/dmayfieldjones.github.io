{"version":3,"file":"static/chunks/2201.a747c8baa1304b5c.js","mappings":"iOASe,iBAA+B,wBAAsB,CACpE,mBACA,aACA,MAA8B,oBAAc,oBAC5C,EAA0B,oBAAc,0BACxC,EAAyB,oBAAc,yBACvC,EAA+B,oBAAc,oBAC7C,yDACA,aAAuB,IAAgB,EACvC,WAAwB,kBAAY,uBACpC,wBACkB,kBAAY,uBAC9B,OACA,wBACkB,kBAAY,uBAC9B,OACA,yBACA,kBACA,CAAS,CACT,CACA,sBAA+B,EAC/B,4CACA,CACA,kBACA,2BACA,CACA,kBAAgC,EAChC,MAAe,sBAAgB,WAC/B,kCACA,yCACA,CAAS,aACT,CACA,uCACA,QACA,IACA,SAIA,GAHA,wDACA,2CACA,CAAa,EACb,aACA,+BACA,2BACA,gBACA,kBACA,qCACA,gBACA,KACA,MAEA,SACA,SAEA,CACA,CACA,uBACA,8BAAmD,mBAAwC,aAC3F,MACA,CACA,CACA,QACA,QACA,+BACA,mCACA,gBAAkD,YAAY,YAAoB,EAIlF,yBAAwD,WAAoB,EAE5E,qBAEA,WACA,YAAsC,OAAe,IACrD,gBACA,UAAkC,SAAa,EAC/C,KAA8B,OAAW,IACzC,MAA+B,QAAQ,UAAU,0FAAiI,EAC7J,EACG,oBAAc,6CACtC,SAEA,CAEA,YACA,CACA,SACA,UACA,CACA,CACA,iBACA,mBACA,OACA,oBACA,gBACA,WACA,QACA,CACA,CACA,iBACA","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-gff3/esm/Gff3TabixAdapter/Gff3TabixAdapter.js"],"sourcesContent":["import { TabixIndexedFile } from '@gmod/tabix';\nimport { readConfObject } from '@jbrowse/core/configuration';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { doesIntersect2 } from '@jbrowse/core/util/range';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { parseStringSync } from 'gff-nostream';\nimport { featureData } from '../featureData';\nexport default class Gff3TabixAdapter extends BaseFeatureDataAdapter {\n    constructor(config, getSubAdapter, pluginManager) {\n        super(config, getSubAdapter, pluginManager);\n        const gffGzLocation = readConfObject(config, 'gffGzLocation');\n        const indexType = readConfObject(config, ['index', 'indexType']);\n        const location = readConfObject(config, ['index', 'location']);\n        const dontRedispatch = readConfObject(config, 'dontRedispatch');\n        this.dontRedispatch = dontRedispatch || ['chromosome', 'contig', 'region'];\n        this.gff = new TabixIndexedFile({\n            filehandle: openLocation(gffGzLocation, this.pluginManager),\n            csiFilehandle: indexType === 'CSI'\n                ? openLocation(location, this.pluginManager)\n                : undefined,\n            tbiFilehandle: indexType !== 'CSI'\n                ? openLocation(location, this.pluginManager)\n                : undefined,\n            chunkCacheSize: 50 * 2 ** 20,\n            renameRefSeqs: (n) => n,\n        });\n    }\n    async getRefNames(opts = {}) {\n        return this.gff.getReferenceSequenceNames(opts);\n    }\n    async getHeader() {\n        return this.gff.getHeader();\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const metadata = await this.gff.getMetadata();\n            await this.getFeaturesHelper(query, opts, metadata, observer, true);\n        }, opts.stopToken);\n    }\n    async getFeaturesHelper(query, opts, metadata, observer, allowRedispatch, originalQuery = query) {\n        var _a, _b;\n        try {\n            const lines = [];\n            await this.gff.getLines(query.refName, query.start, query.end, (line, fileOffset) => {\n                lines.push(this.parseLine(metadata.columnNumbers, line, fileOffset));\n            });\n            if (allowRedispatch && lines.length) {\n                let minStart = Number.POSITIVE_INFINITY;\n                let maxEnd = Number.NEGATIVE_INFINITY;\n                for (const line of lines) {\n                    const featureType = line.fields[2];\n                    if (!this.dontRedispatch.includes(featureType)) {\n                        const start = line.start - 1;\n                        if (start < minStart) {\n                            minStart = start;\n                        }\n                        if (line.end > maxEnd) {\n                            maxEnd = line.end;\n                        }\n                    }\n                }\n                if (maxEnd > query.end || minStart < query.start) {\n                    await this.getFeaturesHelper({ ...query, start: minStart, end: maxEnd }, opts, metadata, observer, false, query);\n                    return;\n                }\n            }\n            const gff3 = lines\n                .map(lineRecord => {\n                if (lineRecord.fields[8] && lineRecord.fields[8] !== '.') {\n                    if (!lineRecord.fields[8].includes('_lineHash')) {\n                        lineRecord.fields[8] += `;_lineHash=${lineRecord.lineHash}`;\n                    }\n                }\n                else {\n                    lineRecord.fields[8] = `_lineHash=${lineRecord.lineHash}`;\n                }\n                return lineRecord.fields.join('\\t');\n            })\n                .join('\\n');\n            for (const featureLocs of parseStringSync(gff3)) {\n                for (const featureLoc of featureLocs) {\n                    const f = new SimpleFeature({\n                        data: featureData(featureLoc),\n                        id: `${this.id}-offset-${(_b = (_a = featureLoc.attributes) === null || _a === void 0 ? void 0 : _a._lineHash) === null || _b === void 0 ? void 0 : _b[0]}`,\n                    });\n                    if (doesIntersect2(f.get('start'), f.get('end'), originalQuery.start, originalQuery.end)) {\n                        observer.next(f);\n                    }\n                }\n            }\n            observer.complete();\n        }\n        catch (e) {\n            observer.error(e);\n        }\n    }\n    parseLine(columnNumbers, line, fileOffset) {\n        const fields = line.split('\\t');\n        return {\n            start: +fields[columnNumbers.start - 1],\n            end: +fields[columnNumbers.end - 1],\n            lineHash: fileOffset,\n            fields,\n        };\n    }\n    freeResources() { }\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0]}