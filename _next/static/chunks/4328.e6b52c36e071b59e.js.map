{"version":3,"file":"static/chunks/4328.e6b52c36e071b59e.js","mappings":"iOASe,iBAA+B,wBAAsB,CACpE,sBACA,oCACA,sCACA,qCACA,mCACA,aACA,SACA,SACA,CACA,MAAwB,IAAgB,EACxC,WAAwB,kBAAY,uBACpC,wBAAiD,kBAAY,8BAC7D,wBAAiD,kBAAY,8BAC7D,yBACA,kBACA,CAAS,EACT,OACA,MACA,iBACA,0BACA,CACA,CACA,sBAOA,OANA,iBACA,+CAEA,MADA,uBACA,CACA,EAAa,EAEb,gBAEA,mBACA,mBAAgB,UAA6B,MAC7C,MAAe,kBAAY,gDAC3B,CACA,sBAA+B,EAC/B,QAAgB,GAAM,wBACtB,qCACA,CACA,oBAA6B,EAC7B,QAAgB,GAAM,wBACtB,oBACA,CACA,kBAAgC,EAChC,MAAe,sBAAgB,WAC/B,QAAoB,GAAM,wBAC1B,uBACA,yCACA,CAAS,aACT,CACA,uCACA,QACA,mBAAgB,UAA6B,EAC7C,IACA,SACA,gBAAoB,SAAsB,wBAI1C,GAHA,MAAkB,kBAAY,yEAC9B,2CACA,CAAa,GACb,aACA,+BACA,2BACA,gBACA,kBACA,mBACA,gBACA,KACA,MAEA,SACA,SAEA,CACA,CACA,uBACA,8BAAmD,mBAAwC,aAC3F,MACA,CACA,CACA,QACA,QACA,+BACA,mCACA,gBAAkD,YAAY,YAAoB,EAIlF,yBAAwD,WAAoB,EAE5E,qBAEA,WACA,YAAsC,OAAe,IACrD,gBACA,UAAkC,SAAa,EAC/C,KAA8B,OAAW,IACzC,MAA+B,QAAQ,UAAU,0FAAiI,EAC7J,EACG,oBAAc,6CACtC,SAEA,CAEA,YACA,CACA,SACA,UACA,CACA,CACA,iBACA,mBACA,OACA,oBACA,gBACA,WACA,QACA,CACA,CACA,iBACA","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-gff3/esm/Gff3TabixAdapter/Gff3TabixAdapter.js"],"sourcesContent":["import { TabixIndexedFile } from '@gmod/tabix';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { updateStatus } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { doesIntersect2 } from '@jbrowse/core/util/range';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { parseStringSync } from 'gff-nostream';\nimport { featureData } from '../featureData';\nexport default class Gff3TabixAdapter extends BaseFeatureDataAdapter {\n    async configurePre(_opts) {\n        const gffGzLocation = this.getConf('gffGzLocation');\n        const indexType = this.getConf(['index', 'indexType']);\n        const loc = this.getConf(['index', 'location']);\n        const dontRedispatch = this.getConf('dontRedispatch') || [\n            'chromosome',\n            'contig',\n            'region',\n        ];\n        const gff = new TabixIndexedFile({\n            filehandle: openLocation(gffGzLocation, this.pluginManager),\n            csiFilehandle: indexType === 'CSI' ? openLocation(loc, this.pluginManager) : undefined,\n            tbiFilehandle: indexType !== 'CSI' ? openLocation(loc, this.pluginManager) : undefined,\n            chunkCacheSize: 50 * 2 ** 20,\n            renameRefSeqs: (n) => n,\n        });\n        return {\n            gff,\n            dontRedispatch,\n            header: await gff.getHeader(),\n        };\n    }\n    async configurePre2() {\n        if (!this.configured) {\n            this.configured = this.configurePre().catch((e) => {\n                this.configured = undefined;\n                throw e;\n            });\n        }\n        return this.configured;\n    }\n    async configure(opts) {\n        const { statusCallback = () => { } } = opts || {};\n        return updateStatus('Downloading index', statusCallback, () => this.configurePre2());\n    }\n    async getRefNames(opts = {}) {\n        const { gff } = await this.configure(opts);\n        return gff.getReferenceSequenceNames(opts);\n    }\n    async getHeader(opts = {}) {\n        const { gff } = await this.configure(opts);\n        return gff.getHeader();\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { gff } = await this.configure(opts);\n            const metadata = await gff.getMetadata();\n            await this.getFeaturesHelper(query, opts, metadata, observer, true);\n        }, opts.stopToken);\n    }\n    async getFeaturesHelper(query, opts, metadata, observer, allowRedispatch, originalQuery = query) {\n        var _a, _b;\n        const { statusCallback = () => { } } = opts;\n        try {\n            const lines = [];\n            const { dontRedispatch, gff } = await this.configure(opts);\n            await updateStatus('Downloading features', statusCallback, () => gff.getLines(query.refName, query.start, query.end, (line, fileOffset) => {\n                lines.push(this.parseLine(metadata.columnNumbers, line, fileOffset));\n            }));\n            if (allowRedispatch && lines.length) {\n                let minStart = Number.POSITIVE_INFINITY;\n                let maxEnd = Number.NEGATIVE_INFINITY;\n                for (const line of lines) {\n                    const featureType = line.fields[2];\n                    if (!dontRedispatch.includes(featureType)) {\n                        const start = line.start - 1;\n                        if (start < minStart) {\n                            minStart = start;\n                        }\n                        if (line.end > maxEnd) {\n                            maxEnd = line.end;\n                        }\n                    }\n                }\n                if (maxEnd > query.end || minStart < query.start) {\n                    await this.getFeaturesHelper({ ...query, start: minStart, end: maxEnd }, opts, metadata, observer, false, query);\n                    return;\n                }\n            }\n            const gff3 = lines\n                .map(lineRecord => {\n                if (lineRecord.fields[8] && lineRecord.fields[8] !== '.') {\n                    if (!lineRecord.fields[8].includes('_lineHash')) {\n                        lineRecord.fields[8] += `;_lineHash=${lineRecord.lineHash}`;\n                    }\n                }\n                else {\n                    lineRecord.fields[8] = `_lineHash=${lineRecord.lineHash}`;\n                }\n                return lineRecord.fields.join('\\t');\n            })\n                .join('\\n');\n            for (const featureLocs of parseStringSync(gff3)) {\n                for (const featureLoc of featureLocs) {\n                    const f = new SimpleFeature({\n                        data: featureData(featureLoc),\n                        id: `${this.id}-offset-${(_b = (_a = featureLoc.attributes) === null || _a === void 0 ? void 0 : _a._lineHash) === null || _b === void 0 ? void 0 : _b[0]}`,\n                    });\n                    if (doesIntersect2(f.get('start'), f.get('end'), originalQuery.start, originalQuery.end)) {\n                        observer.next(f);\n                    }\n                }\n            }\n            observer.complete();\n        }\n        catch (e) {\n            observer.error(e);\n        }\n    }\n    parseLine(columnNumbers, line, fileOffset) {\n        const fields = line.split('\\t');\n        return {\n            start: +fields[columnNumbers.start - 1],\n            end: +fields[columnNumbers.end - 1],\n            lineHash: fileOffset,\n            fields,\n        };\n    }\n    freeResources() { }\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0]}