{"version":3,"file":"static/chunks/3734.638b5283201a7dd1.js","mappings":"0GAAO,kBAEP,EADA,QAAY,8GAAwG,CAEpH,SACA,IAEA,QACA,KAEA,SACA,MAEA,eACA,QACA,MACA,SACA,QACA,OACA,SACA,QACA,SACA,EACA,QACA,KACA,6BACA,sBAIA,GAHA,UACA,SAEA,uBACA,WACA,gCAEA,QAEA,MACA,CACA,CACA,OACA,KACA,UACA,MACA,SACA,OACA,SACA,UACA,mBACA,gCACA,wBACA,wCACA,CACA,qBC3CO,SAAS,EAAQ,GACxB,QADwB,CACxB,0BAA+C,EAAE,+CACjD,kBCTA,OACA,wBACA,+BACA,CACO,SACP,eACA,mBACA,2BACA,CACA,WACA,kCACA,GACA,cACA,sBAAqC,qBACrC,MACA,gDAGA,oCACA,uDAEA,CACA,SACA,sBACA,sCAEA,CACA,SACA,aACA,CACA,CACe,QACf,eACA,wBAIA,YACA,kBAGA,mCAEA,+BACA,6BAQA,kCAEA,YACA,2CACA,kCACA,0CACA,sCACA,8CACA,4CACA,kCACA,mCAEA,uDAEA,WAEA,qBACA,4BACA,MACA,CACA,YAEA,OAGA,GADA,mBACA,uBAEA,oBACA,MACA,CACA,6BACA,MAEA,UACA,QACA,gBAEA,8CAEA,iBACA,MDIO,YACP,ECLqD,EDKrD,IACA,sCACA,MACA,YAEA,UACA,QACA,GAAqB,aAMrB,GALA,WACA,yBACA,WAGA,uBACA,uBACA,OACA,KACA,YACA,gEACA,6DACA,CACA,CACA,uBACA,0BACA,OACA,KACA,SACA,WACA,CACA,CACA,QACA,ECpCqD,GACrD,IACA,uBACA,yCACA,YACA,+CAGA,kBAGA,MAEA,sBACA,gBAAiC,UAAmB,CAEpD,MACA,yBAGA,mBAEA,yCACA,YACA,8CACA,gCAEA,CAEA,iCACA,iDAAgE,EAAQ,IACxE,CACA,CACA,SACA,yCACA,kBACA,0BAEA,kBACA,CACA,aACA,iBACA,wBAEA,gBACA,0BAEA,eACA,uBAEA,CACA,6BACA,UACA,QACA,+GACA,mBACA,YACA,sCACA,oCACiB,EACjB,cACA,kBACA,kCAEA,oBACA,mCAEA,CAAiB,EAEjB,EACA,8CACA,kBACA,8CACA,IACA,kBACA,KAEA,CACA,CAKA,oCAOA,GANA,mEACA,mCACA,+BACA,6BAGA,iEACA,kHAAkI,sDAAsD,EAExL,CAEA,mBACA,UAoBA,EAlBA,OADgD,GDpHzC,YAEP,kDAaA,MAXA,CACA,aAAwB,EAAQ,MAChC,KADgC,EAChC,MAAwB,EAAQ,MAChC,KADgC,CAChC,KAAsB,EAAQ,MAC9B,KAD8B,CAC9B,mCACA,uCACA,wCACA,YACA,WACA,qCA9CO,GACP,sBACA,SAEA,SAqBA,OApBA,EACA,qBACA,QAAiB,GACjB,YACA,MACA,qBACA,kDACA,MAEA,kBACA,qBACA,IACA,KACA,WAEA,eACA,WACA,iBACA,IAAiB,GACjB,CAAK,EACL,CACA,EAoBA,KACA,CAEA,ECoGgD,EAEhD,CACA,kBACA,mBACA,EAGA,wDACA,4DACA,oCACA,GACA,gEACA,oCAGA,oBACA,MACA,CAEA,cACA,qCACA,GAEA,6BACA,wCAA4D,EAAG,6BAA6B,OAAiB,MAAM,mBAAmC,IAEtJ,UACA,MAKA,MACA,gCACA,oBACA,wCAEA,iCAEA,+BAEA,CAAS,EAET,oCAAgE,wBAAwC,GACxG,CACA,0BACA,wCAMA,IAGA,cACA,kCACA,CAAS,EACT,cACA,0CACA,CAAS,EACT,yCACA,CACA,eACA,YACA,sBAA8B,gBAAgB,IAAI,EAAQ,EAC1D,CACA,8BAEA,kBACA,WACA,IACA,KACA,QAEA,eAEA,OADA,QACA,CACA,CACA,qBACA,qCACA,MACA,eACA,oDAAuF,EAAK,YAC5F,cACA,YACA,CAAqB,CAErB,KACA,CACA,wCACA,IACA,GACA,UACA,iBAEA,qCAEA,gBACA,CACA,CAAS,EACT,2BACA,qCACA,MACA,qBACA,0DAA6F,EAAK,YAClG,cACA,YACA,CAAqB,CAErB,KACA,CACA,wCACA,IACA,GACA,UACA,iBAEA,qCAEA,sBACA,CACA,CAAS,CACT,CACA,CClTO,cACP,SACA,MAAuB,EAAM,CAC7B,GAD6B,aAC7B,aACA,gCACA,kBACA,OACA,CAAS,CACJ,EACL,8BACA,aAGA,OADA,WACA,CACA","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-gff3/esm/featureData.js","webpack://_N_E/./node_modules/gff-nostream/esm/util.js","webpack://_N_E/./node_modules/gff-nostream/esm/parse.js","webpack://_N_E/./node_modules/gff-nostream/esm/api.js","webpack://_N_E/./node_modules/gff-nostream/esm/index.js"],"sourcesContent":["export function featureData(data) {\n    const { end, start, child_features, derived_features, attributes, type, source, phase, seq_id, score, strand, } = data;\n    let strand2;\n    if (strand === '+') {\n        strand2 = 1;\n    }\n    else if (strand === '-') {\n        strand2 = -1;\n    }\n    else if (strand === '.') {\n        strand2 = 0;\n    }\n    const defaultFields = new Set([\n        'start',\n        'end',\n        'seq_id',\n        'score',\n        'type',\n        'source',\n        'phase',\n        'strand',\n    ]);\n    const dataAttributes = attributes || {};\n    const resultAttributes = {};\n    for (const a of Object.keys(dataAttributes)) {\n        let b = a.toLowerCase();\n        if (defaultFields.has(b)) {\n            b += '2';\n        }\n        if (dataAttributes[a] && a !== '_lineHash') {\n            let attr = dataAttributes[a];\n            if (Array.isArray(attr) && attr.length === 1) {\n                ;\n                [attr] = attr;\n            }\n            resultAttributes[b] = attr;\n        }\n    }\n    return {\n        ...resultAttributes,\n        start: start - 1,\n        end: end,\n        strand: strand2,\n        type,\n        source,\n        refName: seq_id,\n        derived_features,\n        phase: phase === null ? undefined : Number(phase),\n        score: score === null ? undefined : score,\n        subfeatures: child_features.flatMap(childLocs => childLocs.map(childLoc => featureData(childLoc))),\n    };\n}\n","// Fast, low-level functions for parsing and formatting GFF3.\n// JavaScript port of Robert Buels's Bio::GFF3::LowLevel Perl module.\n/**\n * Unescape a string value used in a GFF3 attribute.\n *\n * @param stringVal - Escaped GFF3 string value\n * @returns An unescaped string value\n */\nexport function unescape(stringVal) {\n    return stringVal.replaceAll(/%([0-9A-Fa-f]{2})/g, (_match, seq) => String.fromCharCode(parseInt(seq, 16)));\n}\nfunction _escape(regex, s) {\n    return String(s).replace(regex, ch => {\n        const hex = ch.charCodeAt(0).toString(16).toUpperCase().padStart(2, '0');\n        return `%${hex}`;\n    });\n}\n/**\n * Escape a value for use in a GFF3 attribute value.\n *\n * @param rawVal - Raw GFF3 attribute value\n * @returns An escaped string value\n */\nexport function escape(rawVal) {\n    return _escape(/[\\n;\\r\\t=%&,\\u0000-\\u001f\\u007f-\\u00ff]/g, rawVal);\n}\n/**\n * Escape a value for use in a GFF3 column value.\n *\n * @param rawVal - Raw GFF3 column value\n * @returns An escaped column value\n */\nexport function escapeColumn(rawVal) {\n    return _escape(/[\\n\\r\\t%\\u0000-\\u001f\\u007f-\\u00ff]/g, rawVal);\n}\n/**\n * Parse the 9th column (attributes) of a GFF3 feature line.\n *\n * @param attrString - String of GFF3 9th column\n * @returns Parsed attributes\n */\nexport function parseAttributes(attrString) {\n    if (!attrString.length || attrString === '.') {\n        return {};\n    }\n    const attrs = {};\n    attrString\n        .replace(/\\r?\\n$/, '')\n        .split(';')\n        .forEach(a => {\n        var _a;\n        const nv = a.split('=', 2);\n        if (!((_a = nv[1]) === null || _a === void 0 ? void 0 : _a.length)) {\n            return;\n        }\n        nv[0] = nv[0].trim();\n        let arec = attrs[nv[0].trim()];\n        if (!arec) {\n            arec = [];\n            attrs[nv[0]] = arec;\n        }\n        arec.push(...nv[1]\n            .split(',')\n            .map(s => s.trim())\n            .map(unescape));\n    });\n    return attrs;\n}\n/**\n * Parse a GFF3 feature line\n *\n * @param line - GFF3 feature line\n * @returns The parsed feature\n */\nexport function parseFeature(line) {\n    // split the line into columns and replace '.' with null in each column\n    const f = line.split('\\t').map(a => (a === '.' || a === '' ? null : a));\n    // unescape only the ref, source, and type columns\n    const parsed = {\n        seq_id: f[0] && unescape(f[0]),\n        source: f[1] && unescape(f[1]),\n        type: f[2] && unescape(f[2]),\n        start: f[3] === null ? null : parseInt(f[3], 10),\n        end: f[4] === null ? null : parseInt(f[4], 10),\n        score: f[5] === null ? null : parseFloat(f[5]),\n        strand: f[6],\n        phase: f[7],\n        attributes: f[8] === null ? null : parseAttributes(f[8]),\n    };\n    return parsed;\n}\n/**\n * Parse a GFF3 directive line.\n *\n * @param line - GFF3 directive line\n * @returns The parsed directive\n */\nexport function parseDirective(line) {\n    var _a, _b;\n    const match = /^\\s*##\\s*(\\S+)\\s*(.*)/.exec(line);\n    if (!match) {\n        return null;\n    }\n    const [, name] = match;\n    let [, , contents] = match;\n    const parsed = { directive: name };\n    if (contents.length) {\n        contents = contents.replace(/\\r?\\n$/, '');\n        parsed.value = contents;\n    }\n    // do a little additional parsing for sequence-region and genome-build directives\n    if (name === 'sequence-region') {\n        const c = contents.split(/\\s+/, 3);\n        return {\n            ...parsed,\n            seq_id: c[0],\n            start: (_a = c[1]) === null || _a === void 0 ? void 0 : _a.replaceAll(/\\D/g, ''),\n            end: (_b = c[2]) === null || _b === void 0 ? void 0 : _b.replaceAll(/\\D/g, ''),\n        };\n    }\n    else if (name === 'genome-build') {\n        const [source, buildName] = contents.split(/\\s+/, 2);\n        return {\n            ...parsed,\n            source,\n            buildName,\n        };\n    }\n    return parsed;\n}\n/**\n * Format an attributes object into a string suitable for the 9th column of GFF3.\n *\n * @param attrs - Attributes\n * @returns GFF3 9th column string\n */\nexport function formatAttributes(attrs) {\n    const attrOrder = [];\n    Object.entries(attrs).forEach(([tag, val]) => {\n        if (!val) {\n            return;\n        }\n        let valstring;\n        if (val.hasOwnProperty('toString')) {\n            valstring = escape(val.toString());\n            // } else if (Array.isArray(val.values)) {\n            //   valstring = val.values.map(escape).join(',')\n        }\n        else if (Array.isArray(val)) {\n            valstring = val.map(escape).join(',');\n        }\n        else {\n            valstring = escape(val);\n        }\n        attrOrder.push(`${escape(tag)}=${valstring}`);\n    });\n    return attrOrder.length ? attrOrder.join(';') : '.';\n}\nfunction _formatSingleFeature(f, seenFeature) {\n    const attrString = f.attributes === null || f.attributes === undefined\n        ? '.'\n        : formatAttributes(f.attributes);\n    const fields = [\n        f.seq_id === null ? '.' : escapeColumn(f.seq_id),\n        f.source === null ? '.' : escapeColumn(f.source),\n        f.type === null ? '.' : escapeColumn(f.type),\n        f.start === null ? '.' : escapeColumn(f.start),\n        f.end === null ? '.' : escapeColumn(f.end),\n        f.score === null ? '.' : escapeColumn(f.score),\n        f.strand === null ? '.' : escapeColumn(f.strand),\n        f.phase === null ? '.' : escapeColumn(f.phase),\n        attrString,\n    ];\n    const formattedString = `${fields.join('\\t')}\\n`;\n    // if we have already output this exact feature, skip it\n    if (seenFeature[formattedString]) {\n        return '';\n    }\n    seenFeature[formattedString] = true;\n    return formattedString;\n}\nfunction _formatFeature(feature, seenFeature) {\n    if (Array.isArray(feature)) {\n        return feature.map(f => _formatFeature(f, seenFeature)).join('');\n    }\n    const strings = [_formatSingleFeature(feature, seenFeature)];\n    if (_isFeatureLineWithRefs(feature)) {\n        strings.push(...feature.child_features.map(f => _formatFeature(f, seenFeature)), ...feature.derived_features.map(f => _formatFeature(f, seenFeature)));\n    }\n    return strings.join('');\n}\n/**\n * Format a feature object or array of feature objects into one or more lines of\n * GFF3.\n *\n * @param featureOrFeatures - A feature object or array of feature objects\n * @returns A string of one or more GFF3 lines\n */\nexport function formatFeature(featureOrFeatures) {\n    const seen = {};\n    return _formatFeature(featureOrFeatures, seen);\n}\n/**\n * Format a directive into a line of GFF3.\n *\n * @param directive - A directive object\n * @returns A directive line string\n */\nexport function formatDirective(directive) {\n    let str = `##${directive.directive}`;\n    if (directive.value) {\n        str += ` ${directive.value}`;\n    }\n    str += '\\n';\n    return str;\n}\n/**\n * Format a comment into a GFF3 comment.\n * Yes I know this is just adding a # and a newline.\n *\n * @param comment - A comment object\n * @returns A comment line string\n */\nexport function formatComment(comment) {\n    return `# ${comment.comment}\\n`;\n}\n/**\n * Format a sequence object as FASTA\n *\n * @param seq - A sequence object\n * @returns Formatted single FASTA sequence string\n */\nexport function formatSequence(seq) {\n    return `>${seq.id}${seq.description ? ` ${seq.description}` : ''}\\n${seq.sequence}\\n`;\n}\n/**\n * Format a directive, comment, sequence, or feature, or array of such items,\n * into one or more lines of GFF3.\n *\n * @param itemOrItems - A comment, sequence, or feature, or array of such items\n * @returns A formatted string or array of strings\n */\nexport function formatItem(itemOrItems) {\n    function formatSingleItem(item) {\n        if ('attributes' in item) {\n            return formatFeature(item);\n        }\n        if ('directive' in item) {\n            return formatDirective(item);\n        }\n        if ('sequence' in item) {\n            return formatSequence(item);\n        }\n        if ('comment' in item) {\n            return formatComment(item);\n        }\n        return '# (invalid item found during format)\\n';\n    }\n    if (Array.isArray(itemOrItems)) {\n        return itemOrItems.map(formatSingleItem);\n    }\n    return formatSingleItem(itemOrItems);\n}\nfunction _isFeatureLineWithRefs(featureLine) {\n    return (featureLine.child_features !== undefined &&\n        featureLine.derived_features !== undefined);\n}\n//# sourceMappingURL=util.js.map","import * as GFF3 from './util';\nconst containerAttributes = {\n    Parent: 'child_features',\n    Derives_from: 'derived_features',\n};\nexport class FASTAParser {\n    constructor(seqCallback) {\n        this.seqCallback = seqCallback;\n        this.currentSequence = undefined;\n    }\n    addLine(line) {\n        const defMatch = /^>\\s*(\\S+)\\s*(.*)/.exec(line);\n        if (defMatch) {\n            this._flush();\n            this.currentSequence = { id: defMatch[1], sequence: '' };\n            if (defMatch[2]) {\n                this.currentSequence.description = defMatch[2].trim();\n            }\n        }\n        else if (this.currentSequence && /\\S/.test(line)) {\n            this.currentSequence.sequence += line.replaceAll(/\\s/g, '');\n        }\n    }\n    _flush() {\n        if (this.currentSequence) {\n            this.seqCallback(this.currentSequence);\n        }\n    }\n    finish() {\n        this._flush();\n    }\n}\nexport default class Parser {\n    constructor(args) {\n        this.fastaParser = undefined;\n        // if this is true, the parser ignores the\n        // rest of the lines in the file.  currently\n        // set when the file switches over to FASTA\n        this.eof = false;\n        this.lineNumber = 0;\n        // features that we have to keep on hand for now because they\n        // might be referenced by something else\n        this._underConstructionTopLevel = [];\n        // index of the above by ID\n        this._underConstructionById = {};\n        this._completedReferences = {};\n        // features that reference something we have not seen yet\n        // structured as:\n        // {  'some_id' : {\n        //     'Parent' : [ orphans that have a Parent attr referencing it ],\n        //     'Derives_from' : [ orphans that have a Derives_from attr referencing it ],\n        //    }\n        // }\n        this._underConstructionOrphans = {};\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        const nullFunc = () => { };\n        this.featureCallback = args.featureCallback || nullFunc;\n        this.endCallback = args.endCallback || nullFunc;\n        this.commentCallback = args.commentCallback || nullFunc;\n        this.errorCallback = args.errorCallback || nullFunc;\n        this.directiveCallback = args.directiveCallback || nullFunc;\n        this.sequenceCallback = args.sequenceCallback || nullFunc;\n        this.disableDerivesFromReferences =\n            args.disableDerivesFromReferences || false;\n        // number of lines to buffer\n        this.bufferSize = args.bufferSize === undefined ? 1000 : args.bufferSize;\n    }\n    addLine(line) {\n        // if we have transitioned to a fasta section, just delegate to that parser\n        if (this.fastaParser) {\n            this.fastaParser.addLine(line);\n            return;\n        }\n        if (this.eof) {\n            // otherwise, if we are done, ignore this line\n            return;\n        }\n        this.lineNumber += 1;\n        if (/^\\s*[^#\\s>]/.test(line)) {\n            // feature line, most common case\n            this._bufferLine(line);\n            return;\n        }\n        const match = /^\\s*(#+)(.*)/.exec(line);\n        if (match) {\n            // directive or comment\n            const [, hashsigns] = match;\n            let [, , contents] = match;\n            if (hashsigns.length === 3) {\n                // sync directive, all forward-references are resolved.\n                this._emitAllUnderConstructionFeatures();\n            }\n            else if (hashsigns.length === 2) {\n                const directive = GFF3.parseDirective(line);\n                if (directive) {\n                    if (directive.directive === 'FASTA') {\n                        this._emitAllUnderConstructionFeatures();\n                        this.eof = true;\n                        this.fastaParser = new FASTAParser(this.sequenceCallback);\n                    }\n                    else {\n                        this._emitItem(directive);\n                    }\n                }\n            }\n            else {\n                contents = contents.replace(/\\s*/, '');\n                this._emitItem({ comment: contents });\n            }\n        }\n        else if (/^\\s*$/.test(line)) {\n            // blank line, do nothing\n        }\n        else if (/^\\s*>/.test(line)) {\n            // implicit beginning of a FASTA section\n            this._emitAllUnderConstructionFeatures();\n            this.eof = true;\n            this.fastaParser = new FASTAParser(this.sequenceCallback);\n            this.fastaParser.addLine(line);\n        }\n        else {\n            // it's a parse error\n            const errLine = line.replaceAll(/\\r?\\n?$/g, '');\n            throw new Error(`GFF3 parse error.  Cannot parse '${errLine}'.`);\n        }\n    }\n    finish() {\n        this._emitAllUnderConstructionFeatures();\n        if (this.fastaParser) {\n            this.fastaParser.finish();\n        }\n        this.endCallback();\n    }\n    _emitItem(i) {\n        if (Array.isArray(i)) {\n            this.featureCallback(i);\n        }\n        else if ('directive' in i) {\n            this.directiveCallback(i);\n        }\n        else if ('comment' in i) {\n            this.commentCallback(i);\n        }\n    }\n    _enforceBufferSizeLimit(additionalItemCount = 0) {\n        const _unbufferItem = (item) => {\n            var _a, _b;\n            if (item && Array.isArray(item) && ((_b = (_a = item[0].attributes) === null || _a === void 0 ? void 0 : _a.ID) === null || _b === void 0 ? void 0 : _b[0])) {\n                const ids = item[0].attributes.ID;\n                ids.forEach(id => {\n                    delete this._underConstructionById[id];\n                    delete this._completedReferences[id];\n                });\n                item.forEach(i => {\n                    if (i.child_features) {\n                        i.child_features.forEach(c => _unbufferItem(c));\n                    }\n                    if (i.derived_features) {\n                        i.derived_features.forEach(d => _unbufferItem(d));\n                    }\n                });\n            }\n        };\n        while (this._underConstructionTopLevel.length + additionalItemCount >\n            this.bufferSize) {\n            const item = this._underConstructionTopLevel.shift();\n            if (item) {\n                this._emitItem(item);\n                _unbufferItem(item);\n            }\n        }\n    }\n    /**\n     * return all under-construction features, called when we know\n     * there will be no additional data to attach to them\n     */\n    _emitAllUnderConstructionFeatures() {\n        this._underConstructionTopLevel.forEach(this._emitItem.bind(this));\n        this._underConstructionTopLevel = [];\n        this._underConstructionById = {};\n        this._completedReferences = {};\n        // if we have any orphans hanging around still, this is a\n        // problem. die with a parse error\n        if (Array.from(Object.values(this._underConstructionOrphans)).length) {\n            throw new Error(`some features reference other features that do not exist in the file (or in the same '###' scope). ${Object.keys(this._underConstructionOrphans).join(',')}`);\n        }\n    }\n    // do the right thing with a newly-parsed feature line\n    _bufferLine(line) {\n        var _a, _b, _c;\n        const rawFeatureLine = GFF3.parseFeature(line);\n        const featureLine = {\n            ...rawFeatureLine,\n            child_features: [],\n            derived_features: [],\n        };\n        // featureLine._lineNumber = this.lineNumber //< debugging aid\n        // NOTE: a feature is an arrayref of one or more feature lines.\n        const ids = ((_a = featureLine.attributes) === null || _a === void 0 ? void 0 : _a.ID) || [];\n        const parents = ((_b = featureLine.attributes) === null || _b === void 0 ? void 0 : _b.Parent) || [];\n        const derives = this.disableDerivesFromReferences\n            ? []\n            : ((_c = featureLine.attributes) === null || _c === void 0 ? void 0 : _c.Derives_from) || [];\n        if (!ids.length && !parents.length && !derives.length) {\n            // if it has no IDs and does not refer to anything, we can just\n            // output it\n            this._emitItem([featureLine]);\n            return;\n        }\n        let feature = undefined;\n        ids.forEach(id => {\n            const existing = this._underConstructionById[id];\n            if (existing) {\n                // another location of the same feature\n                if (existing[existing.length - 1].type !== featureLine.type) {\n                    this._parseError(`multi-line feature \"${id}\" has inconsistent types: \"${featureLine.type}\", \"${existing[existing.length - 1].type}\"`);\n                }\n                existing.push(featureLine);\n                feature = existing;\n            }\n            else {\n                // haven't seen it yet, so buffer it so we can attach\n                // child features to it\n                feature = [featureLine];\n                this._enforceBufferSizeLimit(1);\n                if (!parents.length && !derives.length) {\n                    this._underConstructionTopLevel.push(feature);\n                }\n                this._underConstructionById[id] = feature;\n                // see if we have anything buffered that refers to it\n                this._resolveReferencesTo(feature, id);\n            }\n        });\n        // try to resolve all its references\n        this._resolveReferencesFrom(feature || [featureLine], { Parent: parents, Derives_from: derives }, ids);\n    }\n    _resolveReferencesTo(feature, id) {\n        const references = this._underConstructionOrphans[id];\n        //   references is of the form\n        //   {\n        //     'Parent' : [ orphans that have a Parent attr referencing this feature ],\n        //     'Derives_from' : [ orphans that have a Derives_from attr referencing this feature ],\n        //    }\n        if (!references) {\n            return;\n        }\n        feature.forEach(loc => {\n            loc.child_features.push(...references.Parent);\n        });\n        feature.forEach(loc => {\n            loc.derived_features.push(...references.Derives_from);\n        });\n        delete this._underConstructionOrphans[id];\n    }\n    _parseError(message) {\n        this.eof = true;\n        this.errorCallback(`${this.lineNumber}: ${message}`);\n    }\n    _resolveReferencesFrom(feature, references, ids) {\n        // this is all a bit more awkward in javascript than it was in perl\n        function postSet(obj, slot1, slot2) {\n            let subObj = obj[slot1];\n            if (!subObj) {\n                subObj = {};\n                obj[slot1] = subObj;\n            }\n            const returnVal = subObj[slot2] || false;\n            subObj[slot2] = true;\n            return returnVal;\n        }\n        references.Parent.forEach(toId => {\n            const otherFeature = this._underConstructionById[toId];\n            if (otherFeature) {\n                const pname = containerAttributes.Parent;\n                if (!ids.filter(id => postSet(this._completedReferences, id, `Parent,${toId}`)).length) {\n                    otherFeature.forEach(location => {\n                        location[pname].push(feature);\n                    });\n                }\n            }\n            else {\n                let ref = this._underConstructionOrphans[toId];\n                if (!ref) {\n                    ref = {\n                        Parent: [],\n                        Derives_from: [],\n                    };\n                    this._underConstructionOrphans[toId] = ref;\n                }\n                ref.Parent.push(feature);\n            }\n        });\n        references.Derives_from.forEach(toId => {\n            const otherFeature = this._underConstructionById[toId];\n            if (otherFeature) {\n                const pname = containerAttributes.Derives_from;\n                if (!ids.filter(id => postSet(this._completedReferences, id, `Derives_from,${toId}`)).length) {\n                    otherFeature.forEach(location => {\n                        location[pname].push(feature);\n                    });\n                }\n            }\n            else {\n                let ref = this._underConstructionOrphans[toId];\n                if (!ref) {\n                    ref = {\n                        Parent: [],\n                        Derives_from: [],\n                    };\n                    this._underConstructionOrphans[toId] = ref;\n                }\n                ref.Derives_from.push(feature);\n            }\n        });\n    }\n}\n//# sourceMappingURL=parse.js.map","import Parser from './parse';\n/**\n * Synchronously parse a string containing GFF3 and return an array of the\n * parsed items.\n *\n * @param str - GFF3 string\n * @param inputOptions - Parsing options\n * @returns array of parsed features, directives, comments and/or sequences\n */\nexport function parseStringSync(str) {\n    const items = [];\n    const parser = new Parser({\n        featureCallback: arg => items.push(arg),\n        disableDerivesFromReferences: true,\n        errorCallback: err => {\n            throw err;\n        },\n    });\n    for (const line of str.split(/\\r?\\n/)) {\n        parser.addLine(line);\n    }\n    parser.finish();\n    return items;\n}\n//# sourceMappingURL=api.js.map","import { parseStringSync } from './api';\nexport { parseStringSync };\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4]}