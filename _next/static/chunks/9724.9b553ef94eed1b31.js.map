{"version":3,"file":"static/chunks/9724.9b553ef94eed1b31.js","mappings":"qKAMO,oBAWP,EAVA,aAAY,kDAA0E,SAAQ,wEAAuE,EACrK,OACA,oBACA,QACA,EAAsB,oBAAc,gBACpC,EAAkB,cAAQ,EAAG,iBAAkC,EAC/D,aACA,OACA,OACA,KAAuB,WAAK,oBAE5B,2BACA,KACA,oBACA,yBACA,0BACY,oBAAc,IAC1B,qBAEA,SAAkC,mBAAa,QAC/C,gCACA,UACA,KAEA,qBACA,MACA,MACA,MA9BA,GA+BA,SACA,cACA,gBACA,oBACA,aAMA,iBACA,iBACA,mBAPA,iBACA,iBACA,kBAOA,WACA,IACA,GACA,cACA,iBAhDA,IAkDA,yBACA,cACA,eApDA,EAoDA,KAEA,CACA,KAGA,aAFA,cACA,sCACA,GACA,cACA,6BACA,6BACA,WAGA,uBAAa,EACb","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-wiggle/esm/drawLine.js"],"sourcesContent":["import { readConfObject } from '@jbrowse/core/configuration';\nimport { clamp, featureSpanPx } from '@jbrowse/core/util';\nimport { checkStopToken } from '@jbrowse/core/util/stopToken';\nimport { getScale } from './util';\nconst fudgeFactor = 0.3;\nconst clipHeight = 2;\nexport function drawLine(ctx, props) {\n    const { features, regions, bpPerPx, scaleOpts, height: unadjustedHeight, ticks: { values }, displayCrossHatches, colorCallback, config, offset = 0, stopToken, } = props;\n    const region = regions[0];\n    const width = (region.end - region.start) / bpPerPx;\n    const height = unadjustedHeight - offset * 2;\n    const clipColor = readConfObject(config, 'clipColor');\n    const scale = getScale({ ...scaleOpts, range: [0, height] });\n    const domain = scale.domain();\n    const niceMin = domain[0];\n    const niceMax = domain[1];\n    const toY = (n) => clamp(height - (scale(n) || 0), 0, height) + offset;\n    let lastVal;\n    let prevLeftPx = Number.NEGATIVE_INFINITY;\n    const reducedFeatures = [];\n    let start = performance.now();\n    for (const feature of features.values()) {\n        if (performance.now() - start > 400) {\n            checkStopToken(stopToken);\n            start = performance.now();\n        }\n        const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx);\n        if (Math.floor(leftPx) !== Math.floor(prevLeftPx)) {\n            reducedFeatures.push(feature);\n            prevLeftPx = leftPx;\n        }\n        const score = feature.get('score');\n        const lowClipping = score < niceMin;\n        const highClipping = score > niceMax;\n        const w = rightPx - leftPx + fudgeFactor;\n        const c = colorCallback(feature, score);\n        ctx.beginPath();\n        ctx.strokeStyle = c;\n        const startPos = lastVal !== undefined ? lastVal : score;\n        if (!region.reversed) {\n            ctx.moveTo(leftPx, toY(startPos));\n            ctx.lineTo(leftPx, toY(score));\n            ctx.lineTo(rightPx, toY(score));\n        }\n        else {\n            ctx.moveTo(rightPx, toY(startPos));\n            ctx.lineTo(rightPx, toY(score));\n            ctx.lineTo(leftPx, toY(score));\n        }\n        ctx.stroke();\n        lastVal = score;\n        if (highClipping) {\n            ctx.fillStyle = clipColor;\n            ctx.fillRect(leftPx, offset, w, clipHeight);\n        }\n        else if (lowClipping && scaleOpts.scaleType !== 'log') {\n            ctx.fillStyle = clipColor;\n            ctx.fillRect(leftPx, height - clipHeight, w, height);\n        }\n    }\n    if (displayCrossHatches) {\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = 'rgba(200,200,200,0.5)';\n        for (const tick of values) {\n            ctx.beginPath();\n            ctx.moveTo(0, Math.round(toY(tick)));\n            ctx.lineTo(width, Math.round(toY(tick)));\n            ctx.stroke();\n        }\n    }\n    return { reducedFeatures };\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0]}