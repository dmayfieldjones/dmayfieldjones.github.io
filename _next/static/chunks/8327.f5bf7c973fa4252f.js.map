{"version":3,"file":"static/chunks/8327.f5bf7c973fa4252f.js","mappings":"qNAQe,iBAAkC,qBAAmB,CACpE,cACA,oBACA,kBAA4B,GAAqB,EACjD,UAAuB,SAAQ,EAAG,YAAc,EAChD,eACA,YAAwB,yBAA6B,EACrD,2BACA,CAAa,CACJ,CACT,CACA,qBACA,UAAgB,GAAQ,mBACxB,2BACA,CACA,oBACA,UAAgB,GAAQ,mBACxB,6BACA,+BACA,UACA,QACA,SACA,CAAS,CACT,CACA,iBACA,oCACA,8BACA,OACA,UAAuB,IAAY,EACnC,MAAuB,kBAAY,uBACnC,IAAqB,kBAAY,sBACjC,CAAa,CACb,CACA,CACA,kBACA,uCACA,sDACA,KACc,kBAAY,uCAC1B,CACA,cAOA,OANA,aACA,uCAEA,MADA,mBACA,CACA,EAAa,EAEb,YAEA,iBACA,mBAAgB,QAA0B,cAAc,MACxD,SAAgB,iBAAsB,EACtC,MAAe,sBAAgB,WAC/B,MAAkB,mBAAa,sCAC/B,UAAwB,GAAQ,mBAEhC,iBADA,sBACA,KACA,KAEA,MADA,MAEA,KAFA,MAEA,EAFA,KAEA,EACA,YAAyC,IAAgB,GAHzD,MAGyD,CACzD,OACA,UACA,QACA,MAPA,KAQA,EACoB,oBAAc,IAClC,kDAA6E,aAAa,EAC1F,CACA,QACA,eACA,SACA,WACA,YACA,IACA,WAAsC,eAAa,EACnD,MAA+B,EAAQ,GAAG,EAAM,GAAG,EAAU,EAC7D,MACA,UACA,QACA,MACA,KACA,CAAyB,CACJ,EAErB,CAAa,EACb,YACA,CAAS,CACT,CACA,iBACA,wEClGA,gBACA,gBACA,uCACA,eAEA,sBAEA,0BADA,wBAEA,4BACA,eACA,iBACA,eACA,qBACA,QACA,yBACA,4FAEA,OACA,KACA,CACA,UACA,aACA,QACA,UACA,aACA,iBACA,gBACa,CACb,CACK,EACL,CACe,QACf,mBAAkB,yBAA4B,EAC9C,KACA,kBAEA,KACA,eAA6B,WAAS,SAGtC,sEAEA,KACA,gBAEA,KACA,aAA2B,WAAS,SAEpC,KACA,aAA2B,WAAS,IAAI,EAAK,YAG7C,gEAEA,CACA,qBAOA,OANA,cACA,sCAEA,MADA,oBACA,CACA,EAAa,EAEb,YACA,CAMA,0BACA,6CACA,CAMA,0BACA,SAEA,2BADA,2BAEA,mBAEA,QACA,CAMA,2BACA,gCACA,mBACA,CAMA,gCACA,uCAOA,iCACA,qCACA,SACA,mCACA,MACA,CAEA,2BACA,sCACA,CACA,sCACA,QACA,OACA,qDAKA,GAHA,0BACA,aAEA,KACA,SAEA,aACA,WAEA,OADA,wBAEA,qCACA,kBACA,CACA,CCtIe,gBAAgC,EAC/C,UAD2D,EAC3D,CAAkB,+CAA0C,EAC5D,aAAgB,yBAA2B,EAC3C,KAEA,eAA6B,gBAAc,EAC3C,aACA,eACA,CAAa,EAEb,MAEA,gBAA6B,gBAAc,EAC3C,OACA,SACA,EAAa,CAEb,CACA","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-sequence/esm/IndexedFastaAdapter/IndexedFastaAdapter.js","webpack://_N_E/./node_modules/@gmod/indexedfasta/esm/indexedFasta.js","webpack://_N_E/./node_modules/@gmod/indexedfasta/esm/bgzipIndexedFasta.js","webpack://_N_E/./node_modules/@gmod/indexedfasta/esm/index.js"],"sourcesContent":["import AbortablePromiseCache from '@gmod/abortable-promise-cache';\nimport { IndexedFasta } from '@gmod/indexedfasta';\nimport { BaseSequenceAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { SimpleFeature, updateStatus2 } from '@jbrowse/core/util';\nimport QuickLRU from '@jbrowse/core/util/QuickLRU';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { checkStopToken } from '@jbrowse/core/util/stopToken';\nexport default class IndexedFastaAdapter extends BaseSequenceAdapter {\n    constructor() {\n        super(...arguments);\n        this.seqCache = new AbortablePromiseCache({\n            cache: new QuickLRU({ maxSize: 200 }),\n            fill: async (args) => {\n                const { refName, start, end, fasta } = args;\n                return fasta.getSequence(refName, start, end);\n            },\n        });\n    }\n    async getRefNames(_opts) {\n        const { fasta } = await this.setup();\n        return fasta.getSequenceNames();\n    }\n    async getRegions(_opts) {\n        const { fasta } = await this.setup();\n        const seqSizes = await fasta.getSequenceSizes();\n        return Object.keys(seqSizes).map(refName => ({\n            refName,\n            start: 0,\n            end: seqSizes[refName],\n        }));\n    }\n    async setupPre() {\n        const fastaLocation = this.getConf('fastaLocation');\n        const faiLocation = this.getConf('faiLocation');\n        return {\n            fasta: new IndexedFasta({\n                fasta: openLocation(fastaLocation, this.pluginManager),\n                fai: openLocation(faiLocation, this.pluginManager),\n            }),\n        };\n    }\n    async getHeader() {\n        const loc = this.getConf('metadataLocation');\n        return loc.uri === '' || loc.uri === '/path/to/fa.metadata.yaml'\n            ? null\n            : openLocation(loc, this.pluginManager).readFile('utf8');\n    }\n    async setup() {\n        if (!this.setupP) {\n            this.setupP = this.setupPre().catch((e) => {\n                this.setupP = undefined;\n                throw e;\n            });\n        }\n        return this.setupP;\n    }\n    getFeatures(region, opts) {\n        const { statusCallback = () => { }, stopToken } = opts || {};\n        const { refName, start, end } = region;\n        return ObservableCreate(async (observer) => {\n            await updateStatus2('Downloading sequence', statusCallback, stopToken, async () => {\n                const { fasta } = await this.setup();\n                const size = await fasta.getSequenceSize(refName);\n                const regionEnd = Math.min(size || 0, end);\n                const chunks = [];\n                const chunkSize = 128000;\n                const s = start - (start % chunkSize);\n                const e = end + (chunkSize - (end % chunkSize));\n                for (let chunkStart = s; chunkStart < e; chunkStart += chunkSize) {\n                    const r = {\n                        refName,\n                        start: chunkStart,\n                        end: chunkStart + chunkSize,\n                    };\n                    checkStopToken(stopToken);\n                    chunks.push(await this.seqCache.get(JSON.stringify(r), { ...r, fasta }));\n                }\n                const seq = chunks\n                    .filter(f => !!f)\n                    .join('')\n                    .slice(start - s)\n                    .slice(0, end - start);\n                if (seq) {\n                    observer.next(new SimpleFeature({\n                        id: `${refName}-${start}-${regionEnd}`,\n                        data: {\n                            refName,\n                            start,\n                            end: regionEnd,\n                            seq,\n                        },\n                    }));\n                }\n            });\n            observer.complete();\n        });\n    }\n    freeResources() { }\n}\n","import { LocalFile } from 'generic-filehandle2';\nfunction _faiOffset(idx, pos) {\n    return (idx.offset +\n        idx.lineBytes * Math.floor(pos / idx.lineLength) +\n        (pos % idx.lineLength));\n}\nasync function readFAI(fai, opts) {\n    const decoder = new TextDecoder('utf8');\n    return Object.fromEntries(decoder\n        .decode((await fai.readFile(opts)))\n        .split(/\\r?\\n/)\n        .map(r => r.trim())\n        .filter(f => !!f)\n        .map(line => line.split('\\t'))\n        .map(row => {\n        if (row[0]?.startsWith('>')) {\n            throw new Error('found > in sequence name, might have supplied FASTA file for the FASTA index');\n        }\n        return [\n            row[0],\n            {\n                name: row[0],\n                length: +row[1],\n                start: 0,\n                end: +row[1],\n                offset: +row[2],\n                lineLength: +row[3],\n                lineBytes: +row[4],\n            },\n        ];\n    }));\n}\nexport default class IndexedFasta {\n    constructor({ fasta, fai, path, faiPath, }) {\n        if (fasta) {\n            this.fasta = fasta;\n        }\n        else if (path) {\n            this.fasta = new LocalFile(path);\n        }\n        else {\n            throw new Error('Need to pass filehandle for fasta or path to localfile');\n        }\n        if (fai) {\n            this.fai = fai;\n        }\n        else if (faiPath) {\n            this.fai = new LocalFile(faiPath);\n        }\n        else if (path) {\n            this.fai = new LocalFile(`${path}.fai`);\n        }\n        else {\n            throw new Error('Need to pass filehandle for  or path to localfile');\n        }\n    }\n    async _getIndexes(opts) {\n        if (!this.indexes) {\n            this.indexes = readFAI(this.fai, opts).catch((e) => {\n                this.indexes = undefined;\n                throw e;\n            });\n        }\n        return this.indexes;\n    }\n    /**\n     * @returns array of string sequence names that are present in the index, in\n     * which the array index indicates the sequence ID, and the value is the\n     * sequence name\n     */\n    async getSequenceNames(opts) {\n        return Object.keys(await this._getIndexes(opts));\n    }\n    /**\n     * @returns array of string sequence names that are present in the index, in\n     * which the array index indicates the sequence ID, and the value is the\n     * sequence name\n     */\n    async getSequenceSizes(opts) {\n        const returnObject = {};\n        const idx = await this._getIndexes(opts);\n        for (const val of Object.values(idx)) {\n            returnObject[val.name] = val.length;\n        }\n        return returnObject;\n    }\n    /**\n     * @returns array of string sequence names that are present in the index, in\n     * which the array index indicates the sequence ID, and the value is the\n     * sequence name\n     */\n    async getSequenceSize(seqName, opts) {\n        const idx = await this._getIndexes(opts);\n        return idx[seqName]?.length;\n    }\n    /**\n     * @param name\n     *\n     * @returns true if the file contains the given reference sequence name\n     */\n    async hasReferenceSequence(name, opts) {\n        return !!(await this._getIndexes(opts))[name];\n    }\n    /**\n     * @param seqName\n     * @param min\n     * @param max\n     */\n    async getResiduesByName(seqName, min, max, opts) {\n        const indexEntry = (await this._getIndexes(opts))[seqName];\n        return indexEntry\n            ? this._fetchFromIndexEntry(indexEntry, min, max, opts)\n            : undefined;\n    }\n    //alias for getResiduesByName\n    async getSequence(seqName, min, max, opts) {\n        return this.getResiduesByName(seqName, min, max, opts);\n    }\n    async _fetchFromIndexEntry(indexEntry, min = 0, max, opts) {\n        let end = max;\n        if (min < 0) {\n            throw new TypeError('regionStart cannot be less than 0');\n        }\n        if (end === undefined || end > indexEntry.length) {\n            end = indexEntry.length;\n        }\n        if (min >= end) {\n            return '';\n        }\n        const position = _faiOffset(indexEntry, min);\n        const readlen = _faiOffset(indexEntry, end) - position;\n        const decoder = new TextDecoder('utf8');\n        return decoder\n            .decode(await this.fasta.read(readlen, position, opts))\n            .replace(/\\s+/g, '');\n    }\n}\n//# sourceMappingURL=indexedFasta.js.map","import { BgzfFilehandle } from '@gmod/bgzf-filehandle';\nimport IndexedFasta from './indexedFasta';\nexport default class BgzipIndexedFasta extends IndexedFasta {\n    constructor({ fasta, path, fai, faiPath, gzi, gziPath, }) {\n        super({ fasta, path, fai, faiPath });\n        if (fasta && gzi) {\n            // @ts-expect-error\n            this.fasta = new BgzfFilehandle({\n                filehandle: fasta,\n                gziFilehandle: gzi,\n            });\n        }\n        else if (path && gziPath) {\n            // @ts-expect-error\n            this.fasta = new BgzfFilehandle({\n                path,\n                gziPath,\n            });\n        }\n    }\n}\n//# sourceMappingURL=bgzipIndexedFasta.js.map","import { LocalFile } from 'generic-filehandle2';\nfunction parseSmallFasta(text) {\n    return text\n        .split('>')\n        .filter(t => /\\S/.test(t))\n        .map(entryText => {\n        const [defLine, ...seqLines] = entryText.split('\\n');\n        const [id, ...description] = defLine.split(' ');\n        const sequence = seqLines.join('').replace(/\\s/g, '');\n        return {\n            id: id,\n            description: description.join(' '),\n            sequence,\n        };\n    });\n}\nclass FetchableSmallFasta {\n    constructor({ fasta, path }) {\n        if (fasta) {\n            this.fasta = fasta;\n        }\n        else if (path) {\n            this.fasta = new LocalFile(path);\n        }\n        else {\n            throw new Error('Need to pass fasta or path');\n        }\n        this.data = this.fasta.readFile().then(buffer => {\n            const decoder = new TextDecoder('utf8');\n            const text = decoder.decode(buffer);\n            return parseSmallFasta(text);\n        });\n    }\n    async fetch(id, start, end) {\n        const data = await this.data;\n        const entry = data.find(iter => iter.id === id);\n        const length = end - start;\n        if (!entry) {\n            throw new Error(`no sequence with id ${id} exists`);\n        }\n        return entry.sequence.slice(start, length);\n    }\n    async getSequenceNames() {\n        const data = await this.data;\n        return data.map(entry => entry.id);\n    }\n}\nexport { parseSmallFasta, FetchableSmallFasta };\nexport { default as BgzipIndexedFasta } from './bgzipIndexedFasta';\nexport { default as IndexedFasta } from './indexedFasta';\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3]}