{"version":3,"file":"static/chunks/1502.197f60d5779bf2f7.js","mappings":"iOAQe,iBAA4B,wBAAsB,CACjE,sBACA,yBACA,MAA2B,GAAM,EACjC,WAAwB,kBAAY,kCACpC,CAAS,EACT,uBACA,MAA2B,GAAG,EAC9B,kBACS,EACT,OACA,SACA,SACA,QACA,CACA,CACA,mBAOA,OANA,cACA,6CAEA,MADA,oBACA,CACA,EAAa,EAEb,YACA,CACA,qBACA,WAAgB,GAAS,wBACzB,gCACA,CACA,gBACA,+BACA,KACA,gBACA,YAA4B,OAAc,mBAC1C,uBACA,UACA,QACA,4BACa,OAAO,OAAO,KAC3B,SACA,CACA,eACA,CACA,mBACA,WAAgB,YAAiB,wBACjC,SAAgB,cAAoB,EACpC,QAAgB,QAAkB,UAClC,OACA,UACA,WACA,SAAuB,KAAS,CAChC,kCAAqD,iBAAe,UACpE,CACA,CACA,+BAA8B,wDAAgE,EAC9F,MACA,cAAgB,GAAY,EAC5B,8BACA,iCACA,QAAgB,YAAiB,wBACjC,+CACA,YACA,2BACS,EACT,gBACA,+BACA,2BACA,eACA,WACA,YAEA,SACA,UAGA,uBACA,8BACA,OACA,KACA,QACA,KACA,CAAqB,CACrB,OACA,WACA,mBACA,eACA,CAAiB,EACjB,MACA,CACA,CACA,SACA,kCACA,wCAEA,gBACA,OACA,UACA,GAAmB,QAAW,EAC9B,GAAmB,MAAS,KAC5B,wDACA,CACA,iBAAuD,oBAAyB,EAChF,OACA,MACA,UAEA,aAAoB,4JAA4M,EAChO,EAAsB,QAAY,EAClC,KACA,cACA,YACA,SACA,WACA,cACA,UACA,kBACa,EACb,EACA,aAGoB,oBAAc,+BAClC,WAAsC,eAAa,EACnD,MAA+B,QAAQ,GAAG,EAAS,EACnD,MACA,CAAqB,EAGrB,CACA,gCACA,MAAsB,SAAG,oBACzB,EAAsB,SAAG,kBACzB,GAAgB,oBAAc,qBAC9B,aAAwB,YAAmB,KAC3C,WAAkC,eAAa,EAC/C,MAA2B,QAAQ,GAAG,EAAS,SAC/C,MACA,YACA,cACA,SACA,OACA,QACA,MACA,kBACqB,CACJ,EACjB,CACA,CAAS,EACT,YACA,CACA,kBAAgC,EAChC,MAAe,sBAAgB,WAC/B,IACA,8BACA,QACA,OACA,WACA,kBACA,CAAiB,CACjB,CACA,SACA,UACA,CACA,CAAS,aACT,CACA,iBACA","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-bed/esm/BigBedAdapter/BigBedAdapter.js"],"sourcesContent":["import { BigBed } from '@gmod/bbi';\nimport BED from '@gmod/bed';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { SimpleFeature, doesIntersect2, max, min } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { firstValueFrom, toArray } from 'rxjs';\nimport { featureData2 } from '../util';\nexport default class BigBedAdapter extends BaseFeatureDataAdapter {\n    async configurePre(opts) {\n        const pm = this.pluginManager;\n        const bigbed = new BigBed({\n            filehandle: openLocation(this.getConf('bigBedLocation'), pm),\n        });\n        const header = await bigbed.getHeader(opts);\n        const parser = new BED({\n            autoSql: header.autoSql,\n        });\n        return {\n            bigbed,\n            header,\n            parser,\n        };\n    }\n    async configure(opts) {\n        if (!this.cachedP) {\n            this.cachedP = this.configurePre(opts).catch((e) => {\n                this.cachedP = undefined;\n                throw e;\n            });\n        }\n        return this.cachedP;\n    }\n    async getRefNames(opts) {\n        const { header } = await this.configure(opts);\n        return Object.keys(header.refsByName);\n    }\n    async getData() {\n        const refNames = await this.getRefNames();\n        const features = [];\n        for (const refName of refNames) {\n            const f = await firstValueFrom(this.getFeatures({\n                assemblyName: 'unknown',\n                refName,\n                start: 0,\n                end: Number.MAX_SAFE_INTEGER,\n            }).pipe(toArray()));\n            features.push(f);\n        }\n        return features.flat();\n    }\n    async getHeader(opts) {\n        const { parser, header } = await this.configure(opts);\n        const { version, fileType } = header;\n        const { fields, ...rest } = parser.autoSql;\n        return {\n            version,\n            fileType,\n            autoSql: { ...rest },\n            fields: Object.fromEntries(fields.map(({ name, comment }) => [name, comment])),\n        };\n    }\n    async getFeaturesHelper({ query, opts, observer, allowRedispatch, originalQuery = query, }) {\n        var _a;\n        const { stopToken } = opts;\n        const scoreColumn = this.getConf('scoreColumn');\n        const aggregateField = this.getConf('aggregateField');\n        const { parser, bigbed } = await this.configure(opts);\n        const feats = await bigbed.getFeatures(query.refName, query.start, query.end, {\n            stopToken,\n            basesPerSpan: query.end - query.start,\n        });\n        if (allowRedispatch && feats.length) {\n            let minStart = Number.POSITIVE_INFINITY;\n            let maxEnd = Number.NEGATIVE_INFINITY;\n            for (const feat of feats) {\n                if (feat.start < minStart) {\n                    minStart = feat.start;\n                }\n                if (feat.end > maxEnd) {\n                    maxEnd = feat.end;\n                }\n            }\n            if (maxEnd > query.end || minStart < query.start) {\n                await this.getFeaturesHelper({\n                    query: {\n                        ...query,\n                        start: minStart,\n                        end: maxEnd,\n                    },\n                    opts,\n                    observer,\n                    allowRedispatch: false,\n                    originalQuery: query,\n                });\n                return;\n            }\n        }\n        const parentAggregation = {};\n        if (feats.some(f => f.uniqueId === undefined)) {\n            throw new Error('found uniqueId undefined');\n        }\n        for (const feat of feats) {\n            const splitLine = [\n                query.refName,\n                `${feat.start}`,\n                `${feat.end}`,\n                ...(((_a = feat.rest) === null || _a === void 0 ? void 0 : _a.split('\\t')) || []),\n            ];\n            const data = parser.parseLine(splitLine, { uniqueId: feat.uniqueId });\n            const aggr = data[aggregateField];\n            if (!parentAggregation[aggr]) {\n                parentAggregation[aggr] = [];\n            }\n            const { uniqueId, type, chrom, chromStart, chromEnd, description, chromStarts: chromStarts2, blockStarts: blockStarts2, blockSizes: blockSizes2, score: score2, blockCount, thickStart, thickEnd, strand, ...rest } = data;\n            const f = featureData2({\n                ...rest,\n                scoreColumn,\n                splitLine,\n                parser,\n                uniqueId,\n                start: feat.start,\n                end: feat.end,\n                refName: query.refName,\n            });\n            if (aggr) {\n                parentAggregation[aggr].push(f);\n            }\n            else {\n                if (doesIntersect2(f.start, f.end, originalQuery.start, originalQuery.end)) {\n                    observer.next(new SimpleFeature({\n                        id: `${this.id}-${uniqueId}`,\n                        data: f,\n                    }));\n                }\n            }\n        }\n        Object.entries(parentAggregation).map(([name, subfeatures]) => {\n            const s = min(subfeatures.map(f => f.start));\n            const e = max(subfeatures.map(f => f.end));\n            if (doesIntersect2(s, e, originalQuery.start, originalQuery.end)) {\n                const { uniqueId, strand } = subfeatures[0];\n                observer.next(new SimpleFeature({\n                    id: `${this.id}-${uniqueId}-parent`,\n                    data: {\n                        type: 'gene',\n                        subfeatures,\n                        strand,\n                        name,\n                        start: s,\n                        end: e,\n                        refName: query.refName,\n                    },\n                }));\n            }\n        });\n        observer.complete();\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            try {\n                await this.getFeaturesHelper({\n                    query,\n                    opts,\n                    observer,\n                    allowRedispatch: true,\n                });\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.stopToken);\n    }\n    freeResources() { }\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0]}