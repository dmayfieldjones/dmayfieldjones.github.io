{"version":3,"file":"static/chunks/4904.82dc0294d7527993.js","mappings":"qNAQe,iBAA0B,wBAAsB,CAC/D,cACA,oBACA,iCACA,CACA,mBACA,mBAAgB,UAA6B,MAC7C,QAA6B,wBAAkB,CAAC,kBAAY,kDAC5D,KACA,KACA,0BACA,IACA,IACA,kBACA,sBACA,uCACA,qBACA,KACA,qBACA,eAEA,qBACA,UAEA,CACA,qBACA,cACA,OACA,UAEA,SAA8C,KAAK;AAAA,CACnD,CAEA,YACA,aAA0C,2BAAqB,aAA4B,GAE3F,KACA,CACA,yDACA,EACA,IACA,uCACA,+BACA,UAA6C,IAAY,CACzD,YAAsC,OAAe,IACrD,OACA,eAA2C,SAAa,EACxD,KAA8B,OAAW,IACzC,MAA+B,QAAQ,GAAG,EAAQ,GAAG,EAAE,EAClC,GACrB,yCAEA,oCACA,CACA,yCACa,CACb,GACA,OACA,oBACA,iBACA,CACA,CACA,kBAOA,OANA,kBACA,8CAEA,MADA,wBACA,CACA,EAAa,EAEb,iBAEA,sBAA+B,EAC/B,oBAAgB,GAAkB,uBAClC,qBACA,CACA,oBAA6B,EAC7B,WAAgB,GAAS,uBACzB,QACA,CACA,kBAAgC,EAChC,MAAe,sBAAgB,WAC/B,MACA,IACA,UAAwB,mBAAsB,EAC9C,iBAAwB,GAAkB,uBAC1C,sEACA,EACA,EACA,OACA,UAEA,YACA,CACA,SACA,UACA,CACA,CAAS,aACT,CACA,iBACA","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-gff3/esm/Gff3Adapter/Gff3Adapter.js"],"sourcesContent":["import IntervalTree from '@flatten-js/interval-tree';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { fetchAndMaybeUnzip, getProgressDisplayStr } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { parseStringSync } from 'gff-nostream';\nimport { featureData } from '../featureData';\nexport default class Gff3Adapter extends BaseFeatureDataAdapter {\n    constructor() {\n        super(...arguments);\n        this.calculatedIntervalTreeMap = {};\n    }\n    async loadDataP(opts) {\n        const { statusCallback = () => { } } = opts || {};\n        const buffer = await fetchAndMaybeUnzip(openLocation(this.getConf('gffLocation'), this.pluginManager));\n        const headerLines = [];\n        const featureMap = {};\n        const decoder = new TextDecoder('utf8');\n        let blockStart = 0;\n        let i = 0;\n        while (blockStart < buffer.length) {\n            const n = buffer.indexOf(10, blockStart);\n            const b = n === -1 ? buffer.subarray(blockStart) : buffer.subarray(blockStart, n);\n            const line = decoder.decode(b).trim();\n            if (line) {\n                if (line.startsWith('#')) {\n                    headerLines.push(line);\n                }\n                else if (line.startsWith('>')) {\n                    break;\n                }\n                else {\n                    const ret = line.indexOf('\\t');\n                    const refName = line.slice(0, ret);\n                    if (!featureMap[refName]) {\n                        featureMap[refName] = '';\n                    }\n                    featureMap[refName] += `${line}\\n`;\n                }\n            }\n            if (i++ % 10000 === 0) {\n                statusCallback(`Loading ${getProgressDisplayStr(blockStart, buffer.length)}`);\n            }\n            blockStart = n + 1;\n        }\n        const intervalTreeMap = Object.fromEntries(Object.entries(featureMap).map(([refName, lines]) => [\n            refName,\n            (sc) => {\n                if (!this.calculatedIntervalTreeMap[refName]) {\n                    sc === null || sc === void 0 ? void 0 : sc('Parsing GFF data');\n                    const intervalTree = new IntervalTree();\n                    for (const obj of parseStringSync(lines)\n                        .flat()\n                        .map((f, i) => new SimpleFeature({\n                        data: featureData(f),\n                        id: `${this.id}-${refName}-${i}`,\n                    }))) {\n                        intervalTree.insert([obj.get('start'), obj.get('end')], obj);\n                    }\n                    this.calculatedIntervalTreeMap[refName] = intervalTree;\n                }\n                return this.calculatedIntervalTreeMap[refName];\n            },\n        ]));\n        return {\n            header: headerLines.join('\\n'),\n            intervalTreeMap,\n        };\n    }\n    async loadData(opts) {\n        if (!this.gffFeatures) {\n            this.gffFeatures = this.loadDataP(opts).catch((e) => {\n                this.gffFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.gffFeatures;\n    }\n    async getRefNames(opts = {}) {\n        const { intervalTreeMap } = await this.loadData(opts);\n        return Object.keys(intervalTreeMap);\n    }\n    async getHeader(opts = {}) {\n        const { header } = await this.loadData(opts);\n        return header;\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            var _a;\n            try {\n                const { start, end, refName } = query;\n                const { intervalTreeMap } = await this.loadData(opts);\n                for (const f of ((_a = intervalTreeMap[refName]) === null || _a === void 0 ? void 0 : _a.call(intervalTreeMap, opts.statusCallback).search([\n                    start,\n                    end,\n                ])) || []) {\n                    observer.next(f);\n                }\n                observer.complete();\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.stopToken);\n    }\n    freeResources() { }\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0]}