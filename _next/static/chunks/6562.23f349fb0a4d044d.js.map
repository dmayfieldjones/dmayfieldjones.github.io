{"version":3,"file":"static/chunks/6562.23f349fb0a4d044d.js","mappings":"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","sources":["webpack://_N_E/./node_modules/set-value/index.js","webpack://_N_E/./node_modules/is-primitive/index.js","webpack://_N_E/./node_modules/get-value/index.js","webpack://_N_E/./node_modules/is-plain-object/index.js","webpack://_N_E/./node_modules/isobject/index.js","webpack://_N_E/./node_modules/@jbrowse/plugin-legacy-jbrowse/esm/JBrowse1Connection/util.js","webpack://_N_E/./node_modules/@jbrowse/plugin-legacy-jbrowse/esm/JBrowse1Connection/jb1ConfigParse.js","webpack://_N_E/./node_modules/@jbrowse/plugin-legacy-jbrowse/esm/JBrowse1Connection/jb1ConfigLoad.js"],"sourcesContent":["/*!\n * set-value <https://github.com/jonschlinkert/set-value>\n *\n * Copyright (c) Jon Schlinkert (https://github.com/jonschlinkert).\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst { deleteProperty } = Reflect;\nconst isPrimitive = require('is-primitive');\nconst isPlainObject = require('is-plain-object');\n\nconst isObject = value => {\n  return (typeof value === 'object' && value !== null) || typeof value === 'function';\n};\n\nconst isUnsafeKey = key => {\n  return key === '__proto__' || key === 'constructor' || key === 'prototype';\n};\n\nconst validateKey = key => {\n  if (!isPrimitive(key)) {\n    throw new TypeError('Object keys must be strings or symbols');\n  }\n\n  if (isUnsafeKey(key)) {\n    throw new Error(`Cannot set unsafe key: \"${key}\"`);\n  }\n};\n\nconst toStringKey = input => {\n  return Array.isArray(input) ? input.flat().map(String).join(',') : input;\n};\n\nconst createMemoKey = (input, options) => {\n  if (typeof input !== 'string' || !options) return input;\n  let key = input + ';';\n  if (options.arrays !== undefined) key += `arrays=${options.arrays};`;\n  if (options.separator !== undefined) key += `separator=${options.separator};`;\n  if (options.split !== undefined) key += `split=${options.split};`;\n  if (options.merge !== undefined) key += `merge=${options.merge};`;\n  if (options.preservePaths !== undefined) key += `preservePaths=${options.preservePaths};`;\n  return key;\n};\n\nconst memoize = (input, options, fn) => {\n  const key = toStringKey(options ? createMemoKey(input, options) : input);\n  validateKey(key);\n\n  const value = setValue.cache.get(key) || fn();\n  setValue.cache.set(key, value);\n  return value;\n};\n\nconst splitString = (input, options = {}) => {\n  const sep = options.separator || '.';\n  const preserve = sep === '/' ? false : options.preservePaths;\n\n  if (typeof input === 'string' && preserve !== false && /\\//.test(input)) {\n    return [input];\n  }\n\n  const parts = [];\n  let part = '';\n\n  const push = part => {\n    let number;\n    if (part.trim() !== '' && Number.isInteger((number = Number(part)))) {\n      parts.push(number);\n    } else {\n      parts.push(part);\n    }\n  };\n\n  for (let i = 0; i < input.length; i++) {\n    const value = input[i];\n\n    if (value === '\\\\') {\n      part += input[++i];\n      continue;\n    }\n\n    if (value === sep) {\n      push(part);\n      part = '';\n      continue;\n    }\n\n    part += value;\n  }\n\n  if (part) {\n    push(part);\n  }\n\n  return parts;\n};\n\nconst split = (input, options) => {\n  if (options && typeof options.split === 'function') return options.split(input);\n  if (typeof input === 'symbol') return [input];\n  if (Array.isArray(input)) return input;\n  return memoize(input, options, () => splitString(input, options));\n};\n\nconst assignProp = (obj, prop, value, options) => {\n  validateKey(prop);\n\n  // Delete property when \"value\" is undefined\n  if (value === undefined) {\n    deleteProperty(obj, prop);\n\n  } else if (options && options.merge) {\n    const merge = options.merge === 'function' ? options.merge : Object.assign;\n\n    // Only merge plain objects\n    if (merge && isPlainObject(obj[prop]) && isPlainObject(value)) {\n      obj[prop] = merge(obj[prop], value);\n    } else {\n      obj[prop] = value;\n    }\n\n  } else {\n    obj[prop] = value;\n  }\n\n  return obj;\n};\n\nconst setValue = (target, path, value, options) => {\n  if (!path || !isObject(target)) return target;\n\n  const keys = split(path, options);\n  let obj = target;\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const next = keys[i + 1];\n\n    validateKey(key);\n\n    if (next === undefined) {\n      assignProp(obj, key, value, options);\n      break;\n    }\n\n    if (typeof next === 'number' && !Array.isArray(obj[key])) {\n      obj = obj[key] = [];\n      continue;\n    }\n\n    if (!isObject(obj[key])) {\n      obj[key] = {};\n    }\n\n    obj = obj[key];\n  }\n\n  return target;\n};\n\nsetValue.split = split;\nsetValue.cache = new Map();\nsetValue.clear = () => {\n  setValue.cache = new Map();\n};\n\nmodule.exports = setValue;\n","/*!\n * is-primitive <https://github.com/jonschlinkert/is-primitive>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isPrimitive(val) {\n  if (typeof val === 'object') {\n    return val === null;\n  }\n  return typeof val !== 'function';\n};\n","/*!\n * get-value <https://github.com/jonschlinkert/get-value>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nconst isObject = require('isobject');\n\nmodule.exports = function(target, path, options) {\n  if (!isObject(options)) {\n    options = { default: options };\n  }\n\n  if (!isValidObject(target)) {\n    return typeof options.default !== 'undefined' ? options.default : target;\n  }\n\n  if (typeof path === 'number') {\n    path = String(path);\n  }\n\n  const isArray = Array.isArray(path);\n  const isString = typeof path === 'string';\n  const splitChar = options.separator || '.';\n  const joinChar = options.joinChar || (typeof splitChar === 'string' ? splitChar : '.');\n\n  if (!isString && !isArray) {\n    return target;\n  }\n\n  if (isString && path in target) {\n    return isValid(path, target, options) ? target[path] : options.default;\n  }\n\n  let segs = isArray ? path : split(path, splitChar, options);\n  let len = segs.length;\n  let idx = 0;\n\n  do {\n    let prop = segs[idx];\n    if (typeof prop === 'number') {\n      prop = String(prop);\n    }\n\n    while (prop && prop.slice(-1) === '\\\\') {\n      prop = join([prop.slice(0, -1), segs[++idx] || ''], joinChar, options);\n    }\n\n    if (prop in target) {\n      if (!isValid(prop, target, options)) {\n        return options.default;\n      }\n\n      target = target[prop];\n    } else {\n      let hasProp = false;\n      let n = idx + 1;\n\n      while (n < len) {\n        prop = join([prop, segs[n++]], joinChar, options);\n\n        if ((hasProp = prop in target)) {\n          if (!isValid(prop, target, options)) {\n            return options.default;\n          }\n\n          target = target[prop];\n          idx = n - 1;\n          break;\n        }\n      }\n\n      if (!hasProp) {\n        return options.default;\n      }\n    }\n  } while (++idx < len && isValidObject(target));\n\n  if (idx === len) {\n    return target;\n  }\n\n  return options.default;\n};\n\nfunction join(segs, joinChar, options) {\n  if (typeof options.join === 'function') {\n    return options.join(segs);\n  }\n  return segs[0] + joinChar + segs[1];\n}\n\nfunction split(path, splitChar, options) {\n  if (typeof options.split === 'function') {\n    return options.split(path);\n  }\n  return path.split(splitChar);\n}\n\nfunction isValid(key, target, options) {\n  if (typeof options.isValid === 'function') {\n    return options.isValid(key, target);\n  }\n  return true;\n}\n\nfunction isValidObject(val) {\n  return isObject(val) || Array.isArray(val) || typeof val === 'function';\n}\n","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('isobject');\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","import getValue from 'get-value';\nexport function isTrack(arg) {\n    return (arg === null || arg === void 0 ? void 0 : arg.label) && typeof arg.label === 'string';\n}\nexport function isSource(arg) {\n    return (arg === null || arg === void 0 ? void 0 : arg.url) && typeof arg.url === 'string';\n}\nexport function deepUpdate(a, b) {\n    for (const prop of Object.keys(b)) {\n        if (prop in a &&\n            typeof b[prop] === 'object' &&\n            typeof a[prop] === 'object') {\n            deepUpdate(a[prop], b[prop]);\n        }\n        else if (a[prop] === undefined || b[prop] !== undefined) {\n            a[prop] = b[prop];\n        }\n    }\n    return a;\n}\nexport function fillTemplate(template, fillWith) {\n    return template.replaceAll(/{([\\s\\w.]+)}/g, (match, varName) => {\n        varName = varName.replaceAll(/\\s+/g, '');\n        const fill = getValue(fillWith, varName);\n        if (fill !== undefined) {\n            return typeof fill === 'function' ? fill(varName) : fill;\n        }\n        if (fillWith.callback) {\n            const v = fillWith.callback.call(this, varName);\n            if (v !== undefined) {\n                return v;\n            }\n        }\n        return match;\n    });\n}\nexport function structuredClone(src) {\n    if (!src ||\n        typeof src !== 'object' ||\n        Object.prototype.toString.call(src) === '[object Function]') {\n        return src;\n    }\n    if (src.nodeType && 'cloneNode' in src) {\n        return src.cloneNode(true);\n    }\n    if (src instanceof Date) {\n        return new Date(src);\n    }\n    if (src instanceof RegExp) {\n        return new RegExp(src);\n    }\n    let r;\n    if (Array.isArray(src)) {\n        r = [];\n        for (let i = 0, l = src.length; i < l; ++i) {\n            if (i in src) {\n                r[i] = structuredClone(src[i]);\n            }\n        }\n    }\n    else {\n        r = src.constructor ? new src.constructor() : {};\n    }\n    return mixin(r, src, a => structuredClone(a));\n}\nfunction mixin(dest, source, copyFunc) {\n    const empty = {};\n    for (const name in source) {\n        const s = source[name];\n        if (!(name in dest) ||\n            (dest[name] !== s && (!(name in empty) || empty[name] !== s))) {\n            dest[name] = copyFunc ? copyFunc(s) : s;\n        }\n    }\n    return dest;\n}\n","import { objectHash } from '@jbrowse/core/util';\nimport getValue from 'get-value';\nimport setValue from 'set-value';\nimport { isSource, isTrack } from './util';\nexport function parseJB1Json(config, url) {\n    if (typeof config === 'string') {\n        let parsedConf;\n        try {\n            parsedConf = JSON.parse(config);\n        }\n        catch (error) {\n            throw new Error(`${error} when parsing configuration.`);\n        }\n        return regularizeConf(parsedConf, url);\n    }\n    return regularizeConf(config, url);\n}\nexport function parseJB1Conf(config, url) {\n    let parsedConf;\n    try {\n        parsedConf = parse(config, url);\n    }\n    catch (error) {\n        throw new Error(`${error} when parsing configuration.`);\n    }\n    return regularizeConf(parsedConf, url);\n}\nfunction isAlwaysArray(varName) {\n    if (varName === 'include') {\n        return true;\n    }\n    return false;\n}\nfunction parse(text, url) {\n    let section = [];\n    let keyPath;\n    let operation;\n    let value;\n    const data = { tracks: {} };\n    let lineNumber;\n    function recordVal() {\n        if (value !== undefined) {\n            let parsedValue;\n            try {\n                const match = /^json:(.+)/i.exec(value);\n                if (match) {\n                    parsedValue = JSON.parse(match[1]);\n                }\n                else if (/^[+-]?[\\d.,]+([eE][-+]?\\d+)?$/.test(value)) {\n                    parsedValue = Number.parseFloat(value.replaceAll(',', ''));\n                }\n                else {\n                    parsedValue = value;\n                }\n                if (!keyPath) {\n                    throw new Error(`Error parsing in section ${section.join(' - ')}`);\n                }\n                const path = [...section, ...keyPath].join('.');\n                if (operation === '+=') {\n                    let existing = getValue(data, path);\n                    if (existing) {\n                        if (!Array.isArray(existing)) {\n                            existing = [existing];\n                        }\n                    }\n                    else {\n                        existing = [];\n                    }\n                    existing.push(parsedValue);\n                    parsedValue = existing;\n                }\n                if (parsedValue === 'true') {\n                    parsedValue = true;\n                }\n                if (parsedValue === 'false') {\n                    parsedValue = false;\n                }\n                setValue(data, path, parsedValue);\n            }\n            catch (e) {\n                throw new Error(`syntax error${url ? ` in ${url}` : ''}${lineNumber ? ` at line ${lineNumber - 1}` : ''}`);\n            }\n        }\n    }\n    for (const [i, textLine] of text.split(/\\n|\\r\\n|\\r/).entries()) {\n        lineNumber = i + 1;\n        const line = textLine.replace(/^\\s*#.+/, '');\n        let match;\n        if ((match = /^\\s*\\[([^\\]]+)/.exec(line))) {\n            recordVal();\n            keyPath = undefined;\n            value = undefined;\n            section = match[1].trim().split(/\\s*\\.\\s*/);\n            if (section.length === 1 && section[0].toLowerCase() === 'general') {\n                section = [];\n            }\n        }\n        else if ((match = line.match(value === undefined ? /^([^+=]+)(\\+?=)(.*)/ : /^(\\S[^+=]+)(\\+?=)(.*)/))) {\n            recordVal();\n            keyPath = match[1].trim().split(/\\s*\\.\\s*/);\n            [, , operation] = match;\n            if (isAlwaysArray([...section, ...keyPath].join('.'))) {\n                operation = '+=';\n            }\n            value = match[3].trim();\n        }\n        else if (keyPath !== undefined &&\n            (match = /^\\s{0,4}\\+\\s*(.+)/.exec(line))) {\n            recordVal();\n            operation = '+=';\n            value = match[1].trim();\n        }\n        else if (value !== undefined && (match = /^\\s+(\\S.*)/.exec(line))) {\n            const m = match[1];\n            value += value.length ? ` ${m.trim()}` : m.trim();\n        }\n        else {\n            recordVal();\n            keyPath = undefined;\n            value = undefined;\n        }\n    }\n    recordVal();\n    return data;\n}\nexport function regularizeConf(conf, url) {\n    if (conf.tracks && !Array.isArray(conf.tracks)) {\n        if (isTrack(conf.tracks)) {\n            conf.tracks = [conf.tracks];\n        }\n        else {\n            const tracks = [];\n            for (const label of Object.keys(conf.tracks)) {\n                const track = conf.tracks[label];\n                if (isTrack(track)) {\n                    tracks.push(track);\n                }\n                else {\n                    tracks.push({ label, ...track });\n                }\n            }\n            conf.tracks = tracks;\n        }\n    }\n    const meta = conf.trackMetadata;\n    if (meta === null || meta === void 0 ? void 0 : meta.sources) {\n        if (typeof meta.sources === 'string') {\n            meta.sources = [meta.sources];\n        }\n        if (isSource(meta.sources)) {\n            meta.sources = [meta.sources];\n        }\n        if (!Array.isArray(meta.sources)) {\n            const sources = [];\n            for (const name of Object.keys(meta.sources)) {\n                const source = meta.sources[name];\n                if (!('name' in source)) {\n                    source.name = name;\n                }\n                sources.push(source);\n            }\n            meta.sources = sources;\n        }\n        meta.sources = meta.sources.map((sourceDef) => {\n            if (typeof sourceDef === 'string') {\n                const newSourceDef = { url: sourceDef };\n                const typeMatch = /\\.(\\w+)$/.exec(sourceDef);\n                if (typeMatch) {\n                    newSourceDef.type = typeMatch[1].toLowerCase();\n                }\n                return newSourceDef;\n            }\n            return sourceDef;\n        });\n    }\n    conf.sourceUrl = conf.sourceUrl || url;\n    if (conf.sourceUrl.startsWith('/')) {\n        conf.sourceUrl = new URL(conf.sourceUrl, window.location.href).href;\n    }\n    conf.baseUrl = conf.baseUrl || new URL('.', conf.sourceUrl).href;\n    if (conf.baseUrl.length && !conf.baseUrl.endsWith('/')) {\n        conf.baseUrl += '/';\n    }\n    if (conf.sourceUrl) {\n        const addBase = [];\n        if (conf.tracks) {\n            addBase.push(...conf.tracks);\n        }\n        if (conf.stores) {\n            addBase.push(...Object.values(conf.stores));\n        }\n        if (conf.names) {\n            addBase.push(conf.names);\n        }\n        for (const t of addBase) {\n            if (!t.baseUrl) {\n                t.baseUrl = conf.baseUrl || '/';\n            }\n        }\n        if (conf.refSeqs && typeof conf.refSeqs === 'string') {\n            conf.refSeqs = new URL(conf.refSeqs, conf.sourceUrl).href;\n        }\n        if (conf.nameUrl) {\n            conf.nameUrl = new URL(conf.nameUrl, conf.sourceUrl).href;\n        }\n    }\n    conf.stores = conf.stores || {};\n    for (let trackConfig of conf.tracks || []) {\n        if (trackConfig.config) {\n            const c = trackConfig.config;\n            trackConfig.config = undefined;\n            trackConfig = { ...c, ...trackConfig };\n        }\n        if (trackConfig.store) {\n            continue;\n        }\n        let trackClassName;\n        if (trackConfig.type === 'FeatureTrack') {\n            trackClassName = 'JBrowse/View/Track/HTMLFeatures';\n        }\n        else if (trackConfig.type === 'ImageTrack') {\n            trackClassName = 'JBrowse/View/Track/FixedImage';\n        }\n        else if (trackConfig.type === 'ImageTrack.Wiggle') {\n            trackClassName = 'JBrowse/View/Track/FixedImage/Wiggle';\n        }\n        else if (trackConfig.type === 'SequenceTrack') {\n            trackClassName = 'JBrowse/View/Track/Sequence';\n        }\n        else {\n            trackClassName = regularizeClass('JBrowse/View/Track', trackConfig.type);\n        }\n        trackConfig.type = trackClassName;\n        synthesizeTrackStoreConfig(conf, trackConfig);\n        if (trackConfig.histograms) {\n            if (!trackConfig.histograms.baseUrl) {\n                trackConfig.histograms.baseUrl = trackConfig.baseUrl;\n            }\n            synthesizeTrackStoreConfig(conf, trackConfig.histograms);\n        }\n    }\n    return conf;\n}\nfunction regularizeClass(root, className) {\n    if (!className) {\n        return '';\n    }\n    if (!className.includes('/')) {\n        className = `${root}/${className}`;\n    }\n    className = className.replace(/^\\//, '');\n    return className;\n}\nfunction guessStoreClass(trackConfig, urlTemplate) {\n    var _a, _b;\n    if (!trackConfig) {\n        return '';\n    }\n    if ((_a = trackConfig.type) === null || _a === void 0 ? void 0 : _a.includes('/FixedImage')) {\n        return `JBrowse/Store/TiledImage/Fixed${trackConfig.backendVersion === 0 ? '_v0' : ''}`;\n    }\n    if (/\\.jsonz?$/i.test(urlTemplate)) {\n        return `JBrowse/Store/SeqFeature/NCList${trackConfig.backendVersion === 0 ? '_v0' : ''}`;\n    }\n    if (/\\.bam$/i.test(urlTemplate)) {\n        return 'JBrowse/Store/SeqFeature/BAM';\n    }\n    if (/\\.cram$/i.test(urlTemplate)) {\n        return 'JBrowse/Store/SeqFeature/CRAM';\n    }\n    if (/\\.gff3?$/i.test(urlTemplate)) {\n        return 'JBrowse/Store/SeqFeature/GFF3';\n    }\n    if (/\\.bed$/i.test(urlTemplate)) {\n        return 'JBrowse/Store/SeqFeature/BED';\n    }\n    if (/\\.vcf.b?gz$/i.test(urlTemplate)) {\n        return 'JBrowse/Store/SeqFeature/VCFTabix';\n    }\n    if (/\\.gff3?.b?gz$/i.test(urlTemplate)) {\n        return 'JBrowse/Store/SeqFeature/GFF3Tabix';\n    }\n    if (/\\.bed.b?gz$/i.test(urlTemplate)) {\n        return 'JBrowse/Store/SeqFeature/BEDTabix';\n    }\n    if (/\\.(bw|bigwig)$/i.test(urlTemplate)) {\n        return 'JBrowse/Store/SeqFeature/BigWig';\n    }\n    if (/\\.(bb|bigbed)$/i.test(urlTemplate)) {\n        return 'JBrowse/Store/SeqFeature/BigBed';\n    }\n    if (/\\.(fa|fasta)$/i.test(urlTemplate)) {\n        return 'JBrowse/Store/SeqFeature/IndexedFasta';\n    }\n    if (/\\.(fa|fasta)\\.b?gz$/i.test(urlTemplate)) {\n        return 'JBrowse/Store/SeqFeature/BgzipIndexedFasta';\n    }\n    if (/\\.2bit$/i.test(urlTemplate)) {\n        return 'JBrowse/Store/SeqFeature/TwoBit';\n    }\n    if ((_b = trackConfig.type) === null || _b === void 0 ? void 0 : _b.endsWith('/Sequence')) {\n        return 'JBrowse/Store/Sequence/StaticChunked';\n    }\n    return '';\n}\nfunction synthesizeTrackStoreConfig(mainConf, trackConfig) {\n    var _a;\n    const { urlTemplate = '' } = trackConfig;\n    const storeClass = trackConfig.storeClass\n        ? regularizeClass('JBrowse/Store', trackConfig.storeClass)\n        : guessStoreClass(trackConfig, urlTemplate);\n    if (!storeClass) {\n        console.warn(`Unable to determine an appropriate data store to use with track '${trackConfig.label}', please explicitly specify a storeClass in the configuration.`);\n        return;\n    }\n    const storeConf = { ...trackConfig, type: storeClass };\n    storeConf.name =\n        (storeClass === 'JBrowse/Store/Sequence/StaticChunked' ||\n            storeClass === 'JBrowse/Store/Sequence/IndexedFasta' ||\n            storeClass === 'JBrowse/Store/SeqFeature/IndexedFasta' ||\n            storeClass === 'JBrowse/Store/SeqFeature/BgzipIndexedFasta' ||\n            storeClass === 'JBrowse/Store/SeqFeature/TwoBit' ||\n            storeClass === 'JBrowse/Store/Sequence/TwoBit' ||\n            trackConfig.useAsRefSeqStore) &&\n            !((_a = mainConf.stores) === null || _a === void 0 ? void 0 : _a.refseqs)\n            ? 'refseqs'\n            : `store${objectHash(storeConf)}`;\n    if (!mainConf.stores) {\n        mainConf.stores = {};\n    }\n    mainConf.stores[storeConf.name] = storeConf;\n    trackConfig.store = storeConf.name;\n}\n","import { openLocation } from '@jbrowse/core/util/io';\nimport { parseJB1Conf, parseJB1Json, regularizeConf } from './jb1ConfigParse';\nimport { deepUpdate, fillTemplate } from './util';\nfunction isUriLocation(location) {\n    return location.uri !== undefined;\n}\nfunction isLocalPathLocation(location) {\n    return location.localPath !== undefined;\n}\nexport async function fetchJb1(dataRoot = { uri: '', locationType: 'UriLocation' }, baseConfig = {\n    include: ['{dataRoot}/trackList.json', '{dataRoot}/tracks.conf'],\n}, baseConfigRoot = { uri: '', locationType: 'UriLocation' }) {\n    const protocol = 'uri' in dataRoot ? 'uri' : 'localPath';\n    const dataRootReg = JSON.parse(JSON.stringify(dataRoot));\n    let dataRootLocation = '';\n    if (isUriLocation(dataRoot)) {\n        dataRootLocation = dataRoot.uri;\n    }\n    if (isLocalPathLocation(dataRoot)) {\n        dataRootLocation = dataRoot.localPath;\n    }\n    if (dataRootLocation.endsWith('/')) {\n        dataRootReg[protocol] = dataRootLocation.slice(0, -1);\n    }\n    if ((isUriLocation(baseConfigRoot) && baseConfigRoot.uri) ||\n        (isLocalPathLocation(baseConfigRoot) && baseConfigRoot.localPath)) {\n        const baseProtocol = 'uri' in baseConfigRoot ? 'uri' : 'localPath';\n        let baseConfigLocation = '';\n        if (isUriLocation(baseConfigRoot)) {\n            baseConfigLocation = baseConfigRoot.uri;\n        }\n        if (isLocalPathLocation(baseConfigRoot)) {\n            baseConfigLocation = baseConfigRoot.localPath;\n        }\n        if (baseConfigLocation.endsWith('/')) {\n            baseConfigLocation = baseConfigLocation.slice(0, -1);\n        }\n        let newConfig = {};\n        for (const conf of ['jbrowse.conf', 'jbrowse_conf.json']) {\n            let fetchedConfig = null;\n            try {\n                fetchedConfig = await fetchConfigFile({\n                    [baseProtocol]: `${baseConfigLocation}/${conf}`,\n                });\n            }\n            catch (error) {\n                console.error(`tried to access ${baseConfigLocation}/${conf}, but failed`);\n            }\n            newConfig = mergeConfigs(newConfig, fetchedConfig) || {};\n        }\n        if (dataRootReg[protocol]) {\n            newConfig.dataRoot = dataRootReg[protocol];\n        }\n        return createFinalConfig(newConfig);\n    }\n    const newConfig = regularizeConf(baseConfig, window.location.href);\n    if (dataRootReg[protocol]) {\n        newConfig.dataRoot = dataRootReg[protocol];\n    }\n    return createFinalConfig(newConfig);\n}\nexport async function createFinalConfig(baseConfig, defaults = configDefaults) {\n    const configWithDefaults = deepUpdate(structuredClone(defaults), baseConfig);\n    let finalConfig = await loadIncludes(configWithDefaults);\n    finalConfig = mergeConfigs(finalConfig, baseConfig) || finalConfig;\n    fillTemplates(finalConfig, finalConfig);\n    validateConfig(finalConfig);\n    return finalConfig;\n}\nexport async function fetchConfigFile(location) {\n    const result = await openLocation(location).readFile('utf8');\n    if (isUriLocation(location)) {\n        return parseJb1(result, location.uri);\n    }\n    if (isLocalPathLocation(location)) {\n        return parseJb1(result, location.localPath);\n    }\n    return parseJb1(result);\n}\nexport function parseJb1(config, url = '') {\n    if (config.trim().startsWith('{')) {\n        return parseJB1Json(config, url);\n    }\n    return parseJB1Conf(config, url);\n}\nfunction mergeConfigs(a, b) {\n    if (b === null) {\n        return null;\n    }\n    if (a === null) {\n        a = {};\n    }\n    for (const prop of Object.keys(b)) {\n        if (prop === 'tracks' && prop in a) {\n            const aTracks = a[prop] || [];\n            const bTracks = b[prop] || [];\n            if (Array.isArray(aTracks) && Array.isArray(bTracks)) {\n                a[prop] = mergeTrackConfigs(aTracks, bTracks);\n            }\n            else {\n                throw new Error(`Track config has not been properly regularized: ${aTracks} ${bTracks}`);\n            }\n        }\n        else if (!noRecursiveMerge(prop) &&\n            prop in a &&\n            typeof b[prop] === 'object' &&\n            typeof a[prop] === 'object') {\n            a[prop] = deepUpdate(a[prop], b[prop]);\n        }\n        else if (prop === 'dataRoot') {\n            if (a[prop] === undefined ||\n                (a[prop] === 'data' && b[prop] !== undefined)) {\n                a[prop] = b[prop];\n            }\n        }\n        else if (a[prop] === undefined || b[prop] !== undefined) {\n            a[prop] = b[prop];\n        }\n    }\n    return a;\n}\nfunction mergeTrackConfigs(a, b) {\n    if (!b.length) {\n        return a;\n    }\n    const aTracks = {};\n    for (const [i, t] of a.entries()) {\n        t.index = i;\n        aTracks[t.label] = t;\n    }\n    for (const bT of b) {\n        const aT = aTracks[bT.label];\n        if (aT) {\n            mergeConfigs(aT, bT);\n        }\n        else {\n            a.push(bT);\n        }\n    }\n    return a;\n}\nasync function loadIncludes(inputConfig) {\n    inputConfig = structuredClone(inputConfig);\n    async function loadRecur(config, upstreamConf) {\n        const sourceUrl = config.sourceUrl || config.baseUrl;\n        if (!sourceUrl) {\n            throw new Error(`Could not determine source URL: ${JSON.stringify(config)}`);\n        }\n        const newUpstreamConf = mergeConfigs(structuredClone(upstreamConf), config);\n        if (!newUpstreamConf) {\n            throw new Error('Problem merging configs');\n        }\n        const includes = fillTemplates(regularizeIncludes(config.include || []), newUpstreamConf);\n        config.include = undefined;\n        const loads = includes.map(async (include) => {\n            include.cacheBuster = inputConfig.cacheBuster;\n            const includedData = await fetchConfigFile({\n                uri: new URL(include.url, sourceUrl).href,\n                locationType: 'UriLocation',\n            });\n            return loadRecur(includedData, newUpstreamConf);\n        });\n        const includedDataObjects = await Promise.all(loads);\n        for (const includedData of includedDataObjects) {\n            config = mergeConfigs(config, includedData) || config;\n        }\n        return config;\n    }\n    return loadRecur(inputConfig, {});\n}\nfunction regularizeIncludes(includes) {\n    if (!includes) {\n        return [];\n    }\n    if (!Array.isArray(includes)) {\n        includes = [includes];\n    }\n    return includes.map((include) => {\n        if (typeof include === 'string') {\n            include = { url: include };\n        }\n        if (!('format' in include)) {\n            include.format = include.url.endsWith('.conf') ? 'conf' : 'JB_json';\n        }\n        if (include.format === 'JB_json' && !('version' in include)) {\n            include.version = 1;\n        }\n        return include;\n    });\n}\nfunction fillTemplates(subconfig, config) {\n    if (!subconfig) {\n        return subconfig;\n    }\n    if (Array.isArray(subconfig)) {\n        for (let i = 0; i < subconfig.length; i += 1) {\n            subconfig[i] = fillTemplates(subconfig[i], config);\n        }\n    }\n    else if (typeof subconfig === 'object') {\n        const sub = subconfig;\n        for (const name of Object.keys(sub)) {\n            sub[name] = fillTemplates(sub[name], config);\n        }\n    }\n    else if (typeof subconfig === 'string') {\n        return fillTemplate(subconfig, config);\n    }\n    return subconfig;\n}\nfunction noRecursiveMerge(propName) {\n    return propName === 'datasets';\n}\nconst configDefaults = {\n    tracks: [],\n    containerID: 'GenomeBrowser',\n    dataRoot: 'data',\n    show_tracklist: true,\n    show_nav: true,\n    show_menu: true,\n    show_overview: true,\n    show_fullviewlink: true,\n    update_browser_title: true,\n    updateBrowserURL: true,\n    refSeqs: '{dataRoot}/seq/refSeqs.json',\n    include: ['jbrowse.conf', 'jbrowse_conf.json'],\n    nameUrl: '{dataRoot}/names/root.json',\n    datasets: {\n        _DEFAULT_EXAMPLES: true,\n        volvox: { url: '?data=sample_data/json/volvox', name: 'Volvox Example' },\n        modencode: {\n            url: '?data=sample_data/json/modencode',\n            name: 'MODEncode Example',\n        },\n        yeast: { url: '?data=sample_data/json/yeast', name: 'Yeast Example' },\n    },\n    highlightSearchedRegions: false,\n    highResolutionMode: 'auto',\n};\nfunction validateConfig(config) {\n    if (!config.tracks) {\n        config.tracks = [];\n    }\n    if (!config.baseUrl) {\n        throw new Error('Must provide a `baseUrl` in configuration');\n    }\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4,5,6,7]}