{"version":3,"file":"static/chunks/796.82d701d20167c7f6.js","mappings":"oHAKe,SACf,wBAIA,EACA,CAJA,cACA,gBAAgB,0BAA6C,aAI7D,YAHA,gDAGA,CACA,UACA,qDAEA,4BACA,SAEA,+BACA,8BACA,EACA,iBAGA,IAEA,QACA,CACA,QAKA,GAJA,IACA,kBACA,UAEA,aACA,0BACA,cACA,EAEA,OAGA,UAGA,qBACA,eACA,iDAEA,MAEA,KAEA,eACA,iBACA,WACA,iBACA,uEAGA,gBACA,QAEA,iBACA,QACA,CACA,mBACA,eACA,kCACA,YACA,wDAAwB,EAAI,iBAAiB,cAAgB,MAAM,EAAM,EAEzE,gBACA,eACA,wBAEA,cACA,CACA,GACA,eAEA,CACA,YACA,CC9De,QACf,oBACA,aACA,gBAAgB,0BAA6C,aAI7D,YAHA,mBACA,mCAAsD,GAAG,GACzD,EACA,CACA,UACA,yCAEA,4BAGA,0BACA,EACA,UACA,eACA,iBACA,4BAPA,SAWA,UAAiC,EAAQ,eAAW,EAAa,EACjE,gBAGA,6BACA,YACA,kEAAgC,cAAc,MAAM,UAAiB,EACrE,MALA,uBAMA,WACA,+BAAmD,OAAc,GAEjE,qBACA,0CAA8D,OAAc,EAE5E,oBACA,CACA,GACA,eAEA,CACA,YACA,CChEO,qBACP,SACA,eACA,WACA,UAGA,cACA,eAA2B,GAAa,0BAA0B,uBAAyC,IAAI,aAAyB,EAExI,CCFe,gBAA0B,EACzC,IAD+C,QAC/C,KACA,SAA6B,oBAAgC,CAC7D,CACA,WACA,MACA,0BACA,4BAA4C,aAAa,uDAEzD,0CACA,0BACY,EAAgC,kCAA0C,EAAU,GAChG,eACA,aACA,iBACA,YACA,OACA,EACA,yBACA,6BACA,qBAA6C,GAAW,uCAExD,wBAEA,CADA,8BACA,iBACA,6BAAyD,GAAW,2DAGpE,CACA,QACA,EAEA,4CAGA,yBAEc,GACd,mBACA,GACA,gBAEA,CACA,CAOA,YACA,MACA,iBACA,qBAAqC,GAAW,iBAEhD,UACA,IACA,EAEA,4CAEA,gBAEU,GACV,SAEA,aADA,YACA,IACA,mBACA,KACA,iCACA,MAGA,CACA,QACA,CACA,CC5Ee,gBAA0B,EACzC,IAD+C,KAC/C,wBAEA,2BACA,+EAEA,yCACY,EAAgC,cAAmC,EAAW,EAE1F,CACA,CCTe,UDM6B,MCNP,EACrC,MAD6C,IAC7C,CACQ,EAAgC,uEACxC,CACA,CCPe,QACf,eACA,gBACA,UACA,uBAAoC,GAAG,EACvC,kBAA2B,EAAQ,GACnC,GADmC,CACnC,eACA,gBAA0B,EAAQ,GAClC,GADkC,CAClC,yBACA,gBAA0B,EAAW,gBACrC,iBACA,CAAS,CACT,CACA,cACA,gCACA,qEAEQ,EAAgC,cACxC,MACA,UAFwC,GAGxC,YACA,QACA,iBACA,CACA,CACA,wBACA,kCACA,8EAEA,CACA,4DEnCO,oBAEP,WAAe,EADf,MAAkC,GACR,EADQ,aAAY,qBAE9C,CACO,oBAEP,WAAe,EADf,MAAuB,GACG,EADH,aAAY,qBAEnC,CACO,gBACP,OACA,6CACA,0BACA,CACA,CACO,kBACP,sBACA,CACO,gBACP,SACA,CACA,MACA,wBACA,EACA,CACA,MACA,0BACA,CACA,CACO,gBACP,yBE5BO,oBAA0B,0DAA8D,EAC/F,eACA,aACA,iBACA,YACA,OACA,EACA,8BACA,cACA,MACA,SAAgB,GAAO,EACvB,qCAGA,CACA,SACA,IACA,EACA,qDAEA,kBACA,yBAEc,GAEd,OADA,YACA,CACA,UACA,UACA,eACA,CACA,iBAA8C,EAAO,eAA2B,IAAI,YAAgB,OAEpG,EAA4B,CACX,CACjB,UACA,gBACA,EACA,oCACA,eACA,gBACA,YAgBA,CAA2B,iDAA8C,EACzE,MACA,SAAY,GAAO,EACnB,eACA,mBACA,qBACA,uDACA,uDACA,EAAkB,mBAAa,IAC/B,qBACA,8CACA,WAEA,QACU,EAAO,OACC,GAClB,aACA,OACA,uBACA,OACA,wBACA,SACA,kBACA,cACA,OACA,WAC0B,EAAU,KAAgB,EAAW,CAA3B,GAA2B,KACrC,EAAQ,KAAgB,CAAhB,CAA2B,MAC7D,CAAiB,CACJ,EAGb,cACA,OACA,uBACA,OACA,wBACA,SACA,mBACA,eACA,eACsB,EAAU,KAAgB,EAAW,CAA3B,IAA2B,KACrC,EAAQ,KAAgB,CAAhB,CAA2B,QACzD,iBACA,CAAa,EAGb,gBACA,OACA,yBACA,OACA,wBACA,SACA,qBACA,gBACA,CAAa,EAGb,uBACA,OACA,oBACA,OACA,wBACA,SACA,qBACA,gBACA,CAAa,EAGb,kBACA,OACA,oBACA,OACA,wBACA,SACA,uBACA,gBACA,OACA,WAC0B,EAAU,KAAgB,EAAW,CAA3B,GAA2B,KACrC,EAAQ,KAAgB,CAAhB,CAA2B,MAC7D,CAAiB,CACJ,OAGb,aACA,OACA,gBACA,OACA,wBACA,SACA,kBACA,aACA,CAAa,OAIb,MAAe,8BAAwB,KAEvC,EAnHA,CACA,QACA,aACA,UACA,iBACA,CAAiB,CACjB,CACA,CACA,CAAK,EACL,OAAgB,UAAQ,EACxB,SACA,KACA,yBAAkC,gBAAU,IAAI,EAChD,kBACA,CAAK,CACL,CCnDO,oBACP,MACA,kBAAY,GAAgB,CAAE,WAAM,IACpC,EAAoB,gBAAU,IAC9B,KACA,IACA,MAAgC,aAAO,qBACvC,QAAkC,kBAAY,qBAC9C,EAAuB,EAAO,iBAC9B,iBAAgB,GAAkB,EAClC,gCAEA,WAAoB,YADpB,IAA4B,EAAa,GAEzC,SACA,qBACA,UAEA,sBACA,OACA,cACA,UACA,8BACA,UACA,UACA,mBACA,CACA,qBAA0D,EAAO,mBAA+B,IAAI,gBAAqB,OAEzH,EAAoC,CACX,CACzB,WAAoC,EAAW,GAAG,YAAM,GAAG,EAC3D,SACA,qBACA,gBACA,IAAqC,EAAO,oBAC5C,CAA6B,CAC7B,oBACA,IAAqC,EAAO,oBAC5C,CAA6B,CACJ,CACJ,CACrB,uBACA,CACA,gBACA,SACA,qBACA,IAAyC,EAAO,sBAChD,CACA,CACA,EACA,EAA4B,CACX,EAEjB,eACA,EAAoC,aAAO,2BAC3C,EAA8B,EAAc,CAC5C,UACA,CAF4C,UAE5C,EACA,eACA,kBACA,SACA,CAAa,EACb,mBACA,wDACA,UACA,WACA,aACA,qBACA,CAAa,CACb,KACA,CAEA,MADA,IAAgC,EAAO,GACvC,EADuC,EACvC,aACA,MACA,4CAEA,MAA2B,EAAO,iBAClC,IACA,CACA,IAAyB,EAAO,kBAChC,aACA,EACA,CACA,YACA,gCACA,EACA,QAAsC,EAAgB,GACtD,KACA,MAFsD,CAEtD,gCACA,MAAsC,aAAO,oBAC7C,8BACA,SAEA,eACA,OACA,UACA,QACA,CACA,qBACA,MACA,4CAEA,mBACA,IACA,CACA,sBACA,0BACA,EACA,CACA,YACA,gCACA,EACA,QAAsC,EAAgB,GACtD,EAAwC,SADc,GACd,CAAO,2BAC/C,EAA+B,EAAc,CAC7C,UACA,CAF6C,UAE7C,EACA,eACA,kBACA,SACA,CAAiB,EACjB,mBACA,cAEA,wBACA,WACA,sCAAwD,EACxD,gBAA4C,GAAK,GAAG,GAAK,UACzD,WAAgC,EAChC,GACA,WACA,uCAAyD,aAA+B,EACxF,GACA,mDACA,CACA,CACA,SACA,iBACA,iBAA+B,aAAO,WAAe,KAAK,EAAE,MAC5D,sDACA,CACA,CFpJe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAC","sources":["webpack://_N_E/./node_modules/@gmod/ucsc-hub/esm/raStanza.js","webpack://_N_E/./node_modules/@gmod/ucsc-hub/esm/raFile.js","webpack://_N_E/./node_modules/@gmod/ucsc-hub/esm/util.js","webpack://_N_E/./node_modules/@gmod/ucsc-hub/esm/trackDbFile.js","webpack://_N_E/./node_modules/@gmod/ucsc-hub/esm/genomesFile.js","webpack://_N_E/./node_modules/@gmod/ucsc-hub/esm/hubFile.js","webpack://_N_E/./node_modules/@gmod/ucsc-hub/esm/singleFileHub.js","webpack://_N_E/./node_modules/@gmod/ucsc-hub/esm/index.js","webpack://_N_E/./node_modules/@jbrowse/plugin-data-management/esm/UCSCTrackHub/util.js","webpack://_N_E/./node_modules/@jbrowse/plugin-data-management/esm/UCSCTrackHub/ucscAssemblies.js","webpack://_N_E/./node_modules/@jbrowse/plugin-data-management/esm/UCSCTrackHub/ucscTrackHub.js","webpack://_N_E/./node_modules/@jbrowse/plugin-data-management/esm/UCSCTrackHub/doConnect.js"],"sourcesContent":["/**\n * Class representing an ra file stanza. Each stanza line is split into its key\n * and value and stored as a Map, so the usual Map methods can be used on the\n * stanza.\n */\nexport default class RaStanza {\n    constructor(stanza = [], options) {\n        this.data = {};\n        const { checkIndent = true, skipValidation = false } = options !== null && options !== void 0 ? options : {};\n        const stanzaLines = typeof stanza === 'string' ? stanza.trimEnd().split(/\\r?\\n/) : stanza;\n        let currentIndent;\n        let continuedLine;\n        for (const line of stanzaLines) {\n            if (line === '') {\n                throw new Error('Invalid stanza, contained blank lines');\n            }\n            if (line.trim().startsWith('#')) {\n                continue;\n            }\n            if (line.trimEnd().endsWith('\\\\')) {\n                const trimmedLine = line.trimEnd().slice(0, -1);\n                if (continuedLine) {\n                    continuedLine += trimmedLine.trimStart();\n                }\n                else {\n                    continuedLine = trimmedLine;\n                }\n                continue;\n            }\n            let combinedLine = line;\n            if (continuedLine) {\n                combinedLine = continuedLine + combinedLine.trimStart();\n                continuedLine = undefined;\n            }\n            if (currentIndent !== null && currentIndent !== void 0 ? currentIndent : checkIndent) {\n                const indent = /^([ \\t]+)/.exec(combinedLine);\n                if (currentIndent === undefined) {\n                    if (indent) {\n                        ;\n                        [, currentIndent] = indent;\n                    }\n                    else {\n                        currentIndent = '';\n                    }\n                }\n                else if ((currentIndent === '' && indent !== null) ||\n                    (currentIndent && indent && currentIndent !== indent[1])) {\n                    throw new Error('Inconsistent indentation of stanza');\n                }\n            }\n            else {\n                currentIndent = '';\n            }\n            const trimmedLine = combinedLine.trim();\n            const sep = trimmedLine.indexOf(' ');\n            if (sep === -1) {\n                if (!this.nameKey) {\n                    throw new Error('First line in a stanza must have both a key and a value');\n                }\n                // Adding a key that already exists and has no value is a no-op\n                if (this.data[trimmedLine]) {\n                    continue;\n                }\n                this.data[trimmedLine] = '';\n                continue;\n            }\n            const key = trimmedLine.slice(0, sep);\n            const value = trimmedLine.slice(sep + 1);\n            if (this.data[key] && value !== this.data[key]) {\n                throw new Error('Got duplicate key with a different value in stanza: ' +\n                    `\"${key}\" key has both ${this.data[key]} and ${value}`);\n            }\n            if (!this.nameKey) {\n                this.nameKey = key;\n                this.name = trimmedLine.slice(sep + 1);\n            }\n            this.data[key] = value;\n        }\n        if (!skipValidation) {\n            this.validate();\n        }\n    }\n    validate() { }\n}\n//# sourceMappingURL=raStanza.js.map","import RaStanza from './raStanza';\n/**\n * Class representing an ra file. Each file is composed of multiple stanzas, and\n * each stanza is separated by one or more blank lines. Each stanza is stored in\n * a Map with the key being the value of the first key-value pair in the stanza.\n * The usual Map methods can be used on the file. An additional method `add()`\n * is available to take a raw line of text and break it up into a key and value\n * and add them to the class. This should be favored over `set()` when possible,\n * as it performs more validity checks than using `set()`.\n * @property {undefined|string} nameKey - The key of the first line of all the\n * stanzas (`undefined` if the stanza has no lines yet).\n * @throws {Error} Throws if an empty stanza is added, if the key in the first\n * key-value pair of each stanze isn't the same, or if two stanzas have the same\n * value for the key-value pair in their first lines.\n * @param {(string|string[])} [raFile=[]] - An ra file, either as a single\n * string or an array of strings with one stanza per entry. Supports both LF\n * and CRLF line terminators.\n * @param {object} options\n * @param {boolean} options.checkIndent [true] - Check if a the stanzas within\n * the file are indented consistently and keep track of the indentation\n */\nexport default class RaFile {\n    constructor(raFile = [], options) {\n        this.data = {};\n        const { checkIndent = true, skipValidation = false } = options !== null && options !== void 0 ? options : {};\n        const stanzas = typeof raFile === 'string'\n            ? raFile.trimEnd().split(/(?:[\\t ]*\\r?\\n){2,}/)\n            : raFile;\n        for (const stanza of stanzas) {\n            if (stanza === '') {\n                throw new Error('Invalid stanza, was empty');\n            }\n            if (stanza.startsWith('include')) {\n                continue;\n            }\n            if (stanza.trim().startsWith('#')) {\n                const stanzaLines = stanza\n                    .trimEnd()\n                    .split(/\\r?\\n/)\n                    .map(line => line.trim());\n                if (stanzaLines.every(line => line.startsWith('#'))) {\n                    continue;\n                }\n            }\n            const raStanza = new RaStanza(stanza, { checkIndent });\n            if (!this.nameKey) {\n                this.nameKey = raStanza.nameKey;\n            }\n            else if (raStanza.nameKey !== this.nameKey) {\n                throw new Error('The first line in each stanza must have the same key. ' +\n                    `Saw both ${this.nameKey} and ${raStanza.nameKey}`);\n            }\n            if (!raStanza.name) {\n                throw new Error(`No stanza name: ${raStanza.name}`);\n            }\n            if (this.data[raStanza.name]) {\n                throw new Error(`Got duplicate stanza name: ${raStanza.name}`);\n            }\n            this.data[raStanza.name] = raStanza;\n        }\n        if (!skipValidation) {\n            this.validate();\n        }\n    }\n    validate() { }\n}\n//# sourceMappingURL=raFile.js.map","// validate that all required fields are present in the map\nexport function validateRequiredFieldsArePresent(map, requiredFields, description = '') {\n    const missingFields = [];\n    for (const field of requiredFields) {\n        if (!map.data[field]) {\n            missingFields.push(field);\n        }\n    }\n    if (missingFields.length > 0) {\n        throw new Error(`${description} is missing required entr${missingFields.length === 1 ? 'y' : 'ies'}: ${missingFields.join(', ')}`);\n    }\n}\n//# sourceMappingURL=util.js.map","import RaFile from './raFile';\nimport { validateRequiredFieldsArePresent } from './util';\n/**\n * Class representing a genomes.txt file.\n * @extends RaFile\n * @param {(string|string[])} [trackDbFile=[]] - A trackDb.txt file as a string\n * @throws {Error} Throws if \"track\" is not the first key in each track or if a\n * track is missing required keys\n */\nexport default class TrackDbFile extends RaFile {\n    constructor(trackDbFile, options) {\n        super(trackDbFile, { ...options, checkIndent: false });\n    }\n    validate() {\n        var _a;\n        if (this.nameKey !== 'track') {\n            throw new Error(`trackDb has \"${this.nameKey}\" instead of \"track\" as the first line in each track`);\n        }\n        for (const [trackName, track] of Object.entries(this.data)) {\n            const trackKeys = Object.keys(track.data);\n            validateRequiredFieldsArePresent(track, ['track', 'shortLabel'], `Track ${trackName}`);\n            const parentTrackKeys = new Set([\n                'superTrack',\n                'compositeTrack',\n                'container',\n                'view',\n            ]);\n            if (!trackKeys.some(key => parentTrackKeys.has(key))) {\n                if (!trackKeys.includes('bigDataUrl')) {\n                    throw new Error(`Track ${trackName} is missing required key \"bigDataUrl\"`);\n                }\n                if (!trackKeys.includes('type')) {\n                    const settingsKeys = Object.keys(this.settings(trackName));\n                    if (!settingsKeys.includes('type')) {\n                        throw new Error(`Neither track ${trackName} nor any of its parent tracks have the required key \"type\"`);\n                    }\n                }\n            }\n            let currentTrackName = trackName;\n            do {\n                // @ts-expect-error\n                currentTrackName = (_a = this.data[currentTrackName]) === null || _a === void 0 ? void 0 : _a.parent;\n                if (currentTrackName) {\n                    ;\n                    [currentTrackName] = currentTrackName.split(' ');\n                }\n            } while (currentTrackName);\n            const currentTrack = this.data[trackName];\n            if (currentTrack) {\n                this.data[trackName] = currentTrack;\n            }\n        }\n    }\n    /**\n     * Gets all track entries including those of parent tracks, with closer\n     * entries overriding more distant ones\n     * @param {string} trackName The name of a track\n     * @throws {Error} Throws if track name does not exist in the trackDb\n     */\n    settings(trackName) {\n        var _a;\n        if (!this.data[trackName]) {\n            throw new Error(`Track ${trackName} does not exist`);\n        }\n        const parentTracks = [trackName];\n        let currentTrackName = trackName;\n        do {\n            // @ts-expect-error\n            currentTrackName = (_a = this.data[currentTrackName]) === null || _a === void 0 ? void 0 : _a.parent;\n            if (currentTrackName) {\n                parentTracks.push(currentTrackName);\n            }\n        } while (currentTrackName);\n        const settings = {};\n        parentTracks.reverse();\n        for (const parentTrack of parentTracks) {\n            const ret = this.data[parentTrack];\n            if (ret) {\n                for (const [key, value] of Object.entries(ret)) {\n                    settings[key] = value;\n                }\n            }\n        }\n        return settings;\n    }\n}\n//# sourceMappingURL=trackDbFile.js.map","import RaFile from './raFile';\nimport { validateRequiredFieldsArePresent } from './util';\n/**\n * Class representing a genomes.txt file.\n * @extends RaFile\n * @param {(string|string[])} [genomesFile=[]] - A genomes.txt file as a string\n * @throws {Error} Throws if the first line of the hub.txt file doesn't start\n * with \"genome <genome_name>\" or if it has invalid entries\n */\nexport default class GenomesFile extends RaFile {\n    validate(requiredFields = ['genome', 'trackDb']) {\n        // TODO: check if genome is hosted by UCSC and if not, require twoBitPath and groups\n        if (this.nameKey !== 'genome') {\n            throw new Error('Genomes file must begin with a line like \"genome <genome_name>\"');\n        }\n        for (const [genomeName, genome] of Object.entries(this.data)) {\n            validateRequiredFieldsArePresent(genome, requiredFields, `genome ${genomeName}`);\n        }\n    }\n}\n//# sourceMappingURL=genomesFile.js.map","import RaStanza from './raStanza';\nimport { validateRequiredFieldsArePresent } from './util';\n/**\n * Class representing a hub.txt file.\n * @extends RaStanza\n * @param {(string|string[])} [hubFile=[]] - A hub.txt file as a string\n * @throws {Error} Throws if the first line of the hub.txt file doesn't start\n * with \"hub <hub_name>\", if it has invalid entries, or is missing required\n * entries\n */\nexport default class HubFile extends RaStanza {\n    validate() {\n        validateRequiredFieldsArePresent(this, ['hub', 'shortLabel', 'longLabel', 'genomesFile', 'email'], 'Hub file');\n    }\n}\n//# sourceMappingURL=hubFile.js.map","import RaStanza from './raStanza';\nimport TrackDbFile from './trackDbFile';\nimport { validateRequiredFieldsArePresent } from './util';\n/**\n * Class representing a \"single-file\" hub.txt file that contains all the\n * sections of a hub in a single file.\n */\nexport default class SingleFileHub {\n    constructor(hubText) {\n        const [hubSection, genomeSection, ...trackSections] = hubText\n            .trimEnd()\n            .split(/(?:[\\t ]*\\r?\\n){2,}/);\n        this.hubData = new RaStanza(hubSection);\n        this.validateHub();\n        this.genome = new RaStanza(genomeSection);\n        this.validateGenomeSection();\n        this.tracks = new TrackDbFile(trackSections.join('\\n\\n'), {\n            skipValidation: false,\n        });\n    }\n    validateHub() {\n        if (this.hubData.nameKey !== 'hub') {\n            throw new Error('Hub file must begin with a line like \"hub <hub_name>\"');\n        }\n        validateRequiredFieldsArePresent(this.hubData, [\n            'hub',\n            'shortLabel',\n            'longLabel',\n            'email',\n            'descriptionUrl',\n        ]);\n    }\n    validateGenomeSection() {\n        if (this.genome.nameKey !== 'genome') {\n            throw new Error('Genomes file must begin with a line like \"genome <genome_name>\"');\n        }\n    }\n}\n//# sourceMappingURL=singleFileHub.js.map","export { default as RaFile } from './raFile';\nexport { default as TrackDbFile } from './trackDbFile';\nexport { default as RaStanza } from './raStanza';\nexport { default as GenomesFile } from './genomesFile';\nexport { default as HubFile } from './hubFile';\nexport { default as SingleFileHub } from './singleFileHub';\n//# sourceMappingURL=index.js.map","import { GenomesFile, TrackDbFile } from '@gmod/ucsc-hub';\nimport { openLocation } from '@jbrowse/core/util/io';\nexport async function fetchGenomesFile(genomesLoc) {\n    const genomesFileText = await openLocation(genomesLoc).readFile('utf8');\n    return new GenomesFile(genomesFileText);\n}\nexport async function fetchTrackDbFile(trackDbLoc) {\n    const text = await openLocation(trackDbLoc).readFile('utf8');\n    return new TrackDbFile(text);\n}\nexport function makeLoc(first, base) {\n    return {\n        uri: new URL(first, new URL(base.uri, base.baseUri)).href,\n        locationType: 'UriLocation',\n    };\n}\nexport function makeLocAlt(first, alt, base) {\n    return first ? makeLoc(first, base) : makeLoc(alt, base);\n}\nexport function makeLoc2(first, alt) {\n    return first\n        ? {\n            uri: first,\n            locationType: 'LocalPath',\n        }\n        : {\n            uri: alt,\n            locationType: 'UriLocation',\n        };\n}\nexport function resolve(uri, baseUri) {\n    return new URL(uri, baseUri).href;\n}\n","export default `ailMel1\nallMis1\nanoCar1\nanoCar2\nanoGam1\nanoGam3\napiMel1\napiMel2\naplCal1\naptMan1\naquChr2\nbalAcu1\nbisBis1\nbosTau2\nbosTau3\nbosTau4\nbosTau6\nbosTau7\nbosTau8\nbraFlo1\ncaeJap1\ncaePb1\ncaePb2\ncaeRem2\ncaeRem3\ncalJac1\ncalJac3\ncalMil1\ncanFam1\ncanFam3\ncavPor3\ncb3\nce10\nce11\nce2\nce4\nce6\ncerSim1\nchlSab2\nchoHof1\nchrPic1\nci1\nci2\nci3\ncriGri1\ncriGriChoV1\ndanRer10\ndanRer11\ndanRer3\ndanRer4\ndanRer5\ndanRer6\ndanRer7\ndasNov3\ndipOrd1\ndm1\ndm2\ndm3\ndm6\ndp2\ndp3\ndroAna1\ndroAna2\ndroEre1\ndroGri1\ndroMoj1\ndroMoj2\ndroPer1\ndroSec1\ndroSim1\ndroVir1\ndroVir2\ndroYak1\ndroYak2\neboVir3\nechTel1\nechTel2\nequCab1\nequCab2\neriEur1\neriEur2\nfelCat3\nfelCat4\nfelCat5\nfelCat8\nfr1\nfr2\nfr3\ngadMor1\ngalGal2\ngalGal3\ngalGal4\ngalGal5\ngalGal6\ngalVar1\ngasAcu1\ngeoFor1\ngorGor3\ngorGor4\ngorGor5\nhetGla1\nhetGla2\nhg16\nhg18\nhg19\nhg38\nlatCha1\nloxAfr3\nmacEug2\nmacFas5\nmanPen1\nmelGal1\nmelGal5\nmelUnd1\nmicMur1\nmicMur2\nmm10\nmm7\nmm8\nmm9\nmonDom2\nmonDom4\nmonDom5\nmusFur1\nmyoLuc2\nnanPar1\nnasLar1\nnomLeu1\nnomLeu2\nnomLeu3\nochPri2\nochPri3\noreNil2\nornAna1\nornAna2\noryCun2\noryLat2\notoGar3\noviAri1\noviAri3\noviAri4\npanPan1\npanPan2\npanTro1\npanTro2\npanTro3\npanTro4\npanTro5\npanTro6\npapAnu2\npapHam1\npetMar1\npetMar2\nponAbe2\nponAbe3\npriPac1\nproCap1\npteVam1\nrheMac2\nrheMac3\nrheMac8\nrhiRox1\nrn4\nrn5\nrn6\nsacCer1\nsacCer2\nsacCer3\nsaiBol1\nsarHar1\nsorAra1\nsorAra2\nspeTri2\nstrPur1\nstrPur2\nsusScr11\nsusScr2\nsusScr3\ntaeGut1\ntaeGut2\ntarSyr1\ntarSyr2\ntetNig1\ntetNig2\nthaSir1\ntriMan1\ntupBel1\nturTru2\nventer1\nvicPac1\nvicPac2\nxenLae2\nxenTro1\nxenTro2\nxenTro3\nxenTro7\nxenTro9`.split(/\\r?\\n/);\n","import { isUriLocation, notEmpty, objectHash } from '@jbrowse/core/util';\nimport { generateUnknownTrackConf } from '@jbrowse/core/util/tracks';\nimport { makeLoc2, makeLoc, makeLocAlt, resolve } from './util';\nexport function generateTracks({ trackDb, trackDbLoc, assemblyName, sequenceAdapter, baseUrl, }) {\n    const parentTrackKeys = new Set([\n        'superTrack',\n        'compositeTrack',\n        'container',\n        'view',\n    ]);\n    return Object.entries(trackDb.data)\n        .map(([trackName, track]) => {\n        var _a;\n        const { data } = track;\n        if (Object.keys(data).some(key => parentTrackKeys.has(key))) {\n            return undefined;\n        }\n        else {\n            const parentTracks = [];\n            let currentTrackName = trackName;\n            do {\n                currentTrackName = ((_a = trackDb.data[currentTrackName]) === null || _a === void 0 ? void 0 : _a.data.parent) || '';\n                if (currentTrackName) {\n                    currentTrackName = currentTrackName.split(' ')[0];\n                    parentTracks.push(trackDb.data[currentTrackName]);\n                }\n            } while (currentTrackName);\n            parentTracks.reverse();\n            return {\n                metadata: {\n                    ...track.data,\n                    ...(track.data.html\n                        ? {\n                            html: `<a href=\"${resolve(track.data.html, baseUrl)}\">${track.data.html}</a>`,\n                        }\n                        : {}),\n                },\n                category: [\n                    track.data.group,\n                    ...parentTracks\n                        .map(p => p === null || p === void 0 ? void 0 : p.data.group)\n                        .filter((f) => !!f),\n                ].filter(f => !!f),\n                ...makeTrackConfig({\n                    track,\n                    trackDbLoc,\n                    trackDb,\n                    sequenceAdapter,\n                }),\n            };\n        }\n    })\n        .filter(notEmpty)\n        .map(r => ({\n        ...r,\n        trackId: `ucsc-trackhub-${objectHash(r)}`,\n        assemblyNames: [assemblyName],\n    }));\n}\nfunction makeTrackConfig({ track, trackDbLoc, trackDb, sequenceAdapter, }) {\n    var _a;\n    const { data } = track;\n    const parent = data.parent || '';\n    const bigDataUrl = data.bigDataUrl || '';\n    const bigDataIdx = data.bigDataIndex || '';\n    const trackType = data.type || ((_a = trackDb.data[parent]) === null || _a === void 0 ? void 0 : _a.data.type) || '';\n    const name = (data.shortLabel || '') + (bigDataUrl.includes('xeno') ? ' (xeno)' : '');\n    const isUri = isUriLocation(trackDbLoc);\n    let baseTrackType = trackType.split(' ')[0] || '';\n    if (baseTrackType === 'bam' && bigDataUrl.toLowerCase().endsWith('cram')) {\n        baseTrackType = 'cram';\n    }\n    const bigDataLocation = isUri\n        ? makeLoc(bigDataUrl, trackDbLoc)\n        : makeLoc2(bigDataUrl);\n    if (baseTrackType === 'bam') {\n        return {\n            type: 'AlignmentsTrack',\n            name,\n            description: data.longLabel,\n            adapter: {\n                type: 'BamAdapter',\n                bamLocation: bigDataLocation,\n                index: {\n                    location: isUri\n                        ? makeLocAlt(bigDataIdx, `${bigDataUrl}.bai`, trackDbLoc)\n                        : makeLoc2(bigDataIdx, `${bigDataUrl}.bai`),\n                },\n            },\n        };\n    }\n    else if (baseTrackType === 'cram') {\n        return {\n            type: 'AlignmentsTrack',\n            name,\n            description: data.longLabel,\n            adapter: {\n                type: 'CramAdapter',\n                cramLocation: bigDataLocation,\n                craiLocation: isUri\n                    ? makeLocAlt(bigDataIdx, `${bigDataUrl}.crai`, trackDbLoc)\n                    : makeLoc2(bigDataIdx, `${bigDataUrl}.crai`),\n                sequenceAdapter,\n            },\n        };\n    }\n    else if (baseTrackType === 'bigWig') {\n        return {\n            type: 'QuantitativeTrack',\n            name,\n            description: data.longLabel,\n            adapter: {\n                type: 'BigWigAdapter',\n                bigWigLocation: bigDataLocation,\n            },\n        };\n    }\n    else if (baseTrackType.startsWith('big')) {\n        return {\n            type: 'FeatureTrack',\n            name,\n            description: data.longLabel,\n            adapter: {\n                type: 'BigBedAdapter',\n                bigBedLocation: bigDataLocation,\n            },\n        };\n    }\n    else if (baseTrackType === 'vcfTabix') {\n        return {\n            type: 'VariantTrack',\n            name,\n            description: data.longLabel,\n            adapter: {\n                type: 'VcfTabixAdapter',\n                vcfGzLocation: bigDataLocation,\n                index: {\n                    location: isUri\n                        ? makeLocAlt(bigDataIdx, `${bigDataUrl}.tbi`, trackDbLoc)\n                        : makeLoc2(bigDataIdx, `${bigDataUrl}.tbi`),\n                },\n            },\n        };\n    }\n    else if (baseTrackType === 'hic') {\n        return {\n            type: 'HicTrack',\n            name,\n            description: data.longLabel,\n            adapter: {\n                type: 'HicAdapter',\n                hicLocation: bigDataLocation,\n            },\n        };\n    }\n    else {\n        return generateUnknownTrackConf(name, baseTrackType);\n    }\n}\nexport { default as ucscAssemblies } from './ucscAssemblies';\n","import { HubFile, SingleFileHub } from '@gmod/ucsc-hub';\nimport { getConf } from '@jbrowse/core/configuration';\nimport { getEnv, getSession } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { nanoid } from '@jbrowse/core/util/nanoid';\nimport { generateTracks } from './ucscTrackHub';\nimport { fetchGenomesFile, fetchTrackDbFile, resolve } from './util';\nexport async function doConnect(self) {\n    var _a;\n    const { pluginManager } = getEnv(self);\n    const session = getSession(self);\n    const notLoadedAssemblies = [];\n    try {\n        const hubFileLocation = getConf(self, 'hubTxtLocation');\n        const hubFileText = await openLocation(hubFileLocation).readFile('utf8');\n        const hubUri = resolve(hubFileLocation.uri, hubFileLocation.baseUri);\n        const { assemblyManager } = session;\n        if (hubFileText.includes('useOneFile on')) {\n            const hub = new SingleFileHub(hubFileText);\n            const { genome, tracks } = hub;\n            const genomeName = genome.name;\n            const shortLabel = genome.data.description;\n            const asm = assemblyManager.get(genomeName);\n            if (!asm) {\n                session.addSessionAssembly({\n                    name: genomeName,\n                    displayName: shortLabel,\n                    sequence: {\n                        type: 'ReferenceSequenceTrack',\n                        metadata: {\n                            ...genome.data,\n                            ...(genome.data.htmlPath\n                                ? {\n                                    htmlPath: `<a href=\"${resolve(genome.data.htmlPath, hubUri)}\">${genome.data.htmlPath}</a>`,\n                                }\n                                : {}),\n                        },\n                        trackId: `${genomeName}-${nanoid()}`,\n                        adapter: {\n                            type: 'TwoBitAdapter',\n                            twoBitLocation: {\n                                uri: resolve(genome.data.twoBitPath, hubUri),\n                            },\n                            chromSizesLocation: {\n                                uri: resolve(genome.data.chromSizes, hubUri),\n                            },\n                        },\n                    },\n                    ...(genome.data.chromAliasBb\n                        ? {\n                            refNameAliases: {\n                                adapter: {\n                                    type: 'BigBedAdapter',\n                                    uri: resolve(genome.data.chromAliasBb, hubUri),\n                                },\n                            },\n                        }\n                        : {}),\n                });\n            }\n            const asm2 = assemblyManager.get(genomeName);\n            const sequenceAdapter = getConf(asm2, ['sequence', 'adapter']);\n            const tracksNew = generateTracks({\n                trackDb: tracks,\n                trackDbLoc: hubFileLocation,\n                assemblyName: genomeName,\n                sequenceAdapter,\n                baseUrl: hubUri,\n            });\n            self.addTrackConfs(tracksNew);\n            pluginManager.evaluateExtensionPoint('LaunchView-LinearGenomeView', {\n                session,\n                assembly: genomeName,\n                tracklist: true,\n                loc: genome.data.defaultPos,\n            });\n        }\n        else {\n            const hubFile = new HubFile(hubFileText);\n            const genomeFile = hubFile.data.genomesFile;\n            if (!genomeFile) {\n                throw new Error('genomesFile not found on hub');\n            }\n            const hubUri = resolve(hubFileLocation.uri, hubFileLocation.baseUri);\n            const genomesFileLocation = hubUri\n                ? {\n                    uri: resolve(genomeFile, hubUri),\n                    locationType: 'UriLocation',\n                }\n                : {\n                    localPath: genomeFile,\n                    locationType: 'LocalPathLocation',\n                };\n            const genomesFile = await fetchGenomesFile(genomesFileLocation);\n            const map = {};\n            for (const [genomeName, genome] of Object.entries(genomesFile.data)) {\n                const assemblyNames = getConf(self, 'assemblyNames');\n                if (assemblyNames.length > 0 && !assemblyNames.includes(genomeName)) {\n                    continue;\n                }\n                const asm = assemblyManager.get(genomeName);\n                if (!asm) {\n                    notLoadedAssemblies.push(genomeName);\n                    continue;\n                }\n                const db = genome.data.trackDb;\n                if (!db) {\n                    throw new Error('genomesFile not found on hub');\n                }\n                const base = new URL(genomeFile, hubUri);\n                const loc = hubUri\n                    ? {\n                        uri: new URL(db, base).href,\n                        locationType: 'UriLocation',\n                    }\n                    : {\n                        localPath: db,\n                        locationType: 'LocalPathLocation',\n                    };\n                const trackDb = await fetchTrackDbFile(loc);\n                const sequenceAdapter = getConf(asm, ['sequence', 'adapter']);\n                const tracks = generateTracks({\n                    trackDb,\n                    trackDbLoc: loc,\n                    assemblyName: genomeName,\n                    sequenceAdapter,\n                    baseUrl: hubUri,\n                });\n                self.addTrackConfs(tracks);\n                map[genomeName] = tracks.length;\n            }\n            const loadedAssemblies = Object.entries(map);\n            const str1 = loadedAssemblies.length\n                ? `Loaded data from these assemblies: ${loadedAssemblies\n                    .map(([key, val]) => `${key} (${val} tracks)`)\n                    .join(', ')}`\n                : '';\n            const str2 = notLoadedAssemblies.length\n                ? `Skipped data from these assemblies: ${notLoadedAssemblies.join(', ')}`\n                : '';\n            session.notify([str1, str2].filter(f => !!f).join('. '), 'success');\n        }\n    }\n    catch (e) {\n        console.error(e);\n        session.notifyError(`${getConf(self, 'name')}: \"${e}\"`, e);\n        (_a = session.breakConnection) === null || _a === void 0 ? void 0 : _a.call(session, self.configuration);\n    }\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}