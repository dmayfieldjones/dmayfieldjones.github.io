{"version":3,"file":"static/chunks/2930.d1d36215c9134d9c.js","mappings":"oJACO,oBACP,IAAY,gBAA0B,CAAE,uBAAkB,IAC1D,YAAY,GAAa,CAAE,eAAU,IACrC,EAAiB,uBAAiB,IAClC,8DACA,OAEA,iBACA,iDACA,YACA,qCACA,oBACA,8BACK,EACL,kBACA,gBACA,CCdO,gBAIP,cACA,YACA,MACA,OAEA,yBACA,GAGA,cAGA,oCACA,mBACA,aACA,wBACA,mCACA,iCACA,CArBI,QAAa,aACjB,MAAc,EAAW,EACzB,CAAK,EAAI,IADgB,EAChB,IAAa,EAoBlB,QAAa,aACjB,MAAqB,uBAAiB,GACtC,iCACA,IAEA,CAAK,EACD,QAAa,aAEjB,EADqB,uBAAiB,IAEtC,CAAK,EAAI,UAAa,CACtB","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/shared/fetchChains.js","webpack://_N_E/./node_modules/@jbrowse/plugin-alignments/esm/shared/afterAttach.js"],"sourcesContent":["import { getContainingTrack, getContainingView, getSession, } from '@jbrowse/core/util';\nexport async function fetchChains(self) {\n    const { rpcSessionId: sessionId } = getContainingTrack(self);\n    const { rpcManager } = getSession(self);\n    const view = getContainingView(self);\n    if (!view.initialized || self.error || !self.statsReadyAndRegionNotTooLarge) {\n        return;\n    }\n    self.setLoading(true);\n    const ret = (await rpcManager.call(sessionId, 'PileupGetReducedFeatures', {\n        sessionId,\n        regions: view.staticBlocks.contentBlocks,\n        filterBy: self.filterBy,\n        adapterConfig: self.adapterConfig,\n    }));\n    self.setChainData(ret);\n    self.setLoading(false);\n}\n","import { getContainingView } from '@jbrowse/core/util';\nimport { createAutorun } from '../util';\nimport { fetchChains } from './fetchChains';\nexport function doAfterAttach(self, cb) {\n    createAutorun(self, async () => {\n        await fetchChains(self);\n    }, { delay: 1000 });\n    function draw(view) {\n        const canvas = self.ref;\n        if (!canvas) {\n            return;\n        }\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n            return;\n        }\n        if (!self.chainData) {\n            return;\n        }\n        ctx.clearRect(0, 0, canvas.width, self.height * 2);\n        ctx.resetTransform();\n        ctx.scale(2, 2);\n        cb(self, ctx, canvas.width, self.height);\n        self.setLastDrawnOffsetPx(view.offsetPx);\n        self.setLastDrawnBpPerPx(view.bpPerPx);\n    }\n    createAutorun(self, async () => {\n        const view = getContainingView(self);\n        if (view.bpPerPx !== self.lastDrawnBpPerPx) {\n            draw(view);\n        }\n    });\n    createAutorun(self, async () => {\n        const view = getContainingView(self);\n        draw(view);\n    }, { delay: 1000 });\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0,1]}