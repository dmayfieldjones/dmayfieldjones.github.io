{"version":3,"file":"static/chunks/7275.c7bcc0aac93cfb3d.js","mappings":"yMAOA,iBAAyB,wBAAsB,CAC/C,cACA,oBACA,qBACA,CACA,oBAA6B,EAC7B,yBACA,8BACA,QAA6B,wBAAkB,CAAC,kBAAY,SAC5D,uBACA,0DAGA,UADA,oBAA+C,SAAa,YAC5D,mCACA,KACA,IACA,KAAe,iCAA8C,IAC7D,aAEA,mBACA,KACA,KAAe,WAAkB,KACjC,WACA,iBACA,cACA,OACA,UAEA,YACA,CACA,8BACA,MAA2B,GAAG,UAAG,EAAS,EAC1C,8BACA,8BACA,yBAGA,OACA,SACA,WACA,SACA,cACA,cACA,SACA,SATA,yBAUA,OATA,sBAUA,CACA,CACA,mBAA4B,EAO5B,OANA,kBACA,8CAEA,MADA,wBACA,CACA,EAAa,EAEb,iBAEA,sBAA+B,EAC/B,IAAgB,YAAW,uBAC3B,qBACA,CACA,oBAA6B,EAC7B,IAAgB,UAAS,uBACzB,QACA,CACA,iBACA,IAAgB,wBAAsB,sBACtC,YACA,SAGA,MADA,qCACA,OACA,uCACA,EACA,SACA,WACA,iBACA,MACA,CACA,uCACA,WAAgB,yDAA0D,sBAC1E,OACA,MACA,OAEA,4BACA,MAAiC,IAAY,CAC7C,YAAwB,WAAkB,KAC1C,WACA,KAAgC,QAAQ,GAAG,EAAQ,GAAG,EAAE,EACxD,MAA6B,eAAa,CAAC,QAAW,EACtD,OACA,SACA,WACA,SACA,cACA,SACA,WACA,OACA,CAAa,GACb,yCACA,CACA,QACA,CACA,iCAOA,OANA,uBACA,uEAEA,MADA,6BACA,CACA,EAAa,EAEb,sBAEA,kBAAgC,EAChC,MAAe,sBAAgB,WAC/B,UAAoB,mBAAsB,EAC1C,wCACA,iCACA,KACA,eACA,UAGA,YACA,CAAS,aACT,CACA,iBACA,CACA,6CACA,MAAe","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-bed/esm/BedAdapter/BedAdapter.js"],"sourcesContent":["import IntervalTree from '@flatten-js/interval-tree';\nimport BED from '@gmod/bed';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { SimpleFeature, fetchAndMaybeUnzip } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { featureData } from '../util';\nclass BedAdapter extends BaseFeatureDataAdapter {\n    constructor() {\n        super(...arguments);\n        this.intervalTrees = {};\n    }\n    async loadDataP(opts = {}) {\n        const pm = this.pluginManager;\n        const bedLoc = this.getConf('bedLocation');\n        const buffer = await fetchAndMaybeUnzip(openLocation(bedLoc, pm), opts);\n        if (buffer.length > 536870888) {\n            throw new Error('Data exceeds maximum string length (512MB)');\n        }\n        const data = new TextDecoder('utf8', { fatal: true }).decode(buffer);\n        const lines = data.split(/\\n|\\r\\n|\\r/).filter(f => !!f);\n        const headerLines = [];\n        let i = 0;\n        for (; i < lines.length && lines[i].startsWith('#'); i++) {\n            headerLines.push(lines[i]);\n        }\n        const header = headerLines.join('\\n');\n        const features = {};\n        for (; i < lines.length; i++) {\n            const line = lines[i];\n            const tab = line.indexOf('\\t');\n            const refName = line.slice(0, tab);\n            if (!features[refName]) {\n                features[refName] = [];\n            }\n            features[refName].push(line);\n        }\n        const autoSql = this.getConf('autoSql');\n        const parser = new BED({ autoSql });\n        const columnNames = this.getConf('columnNames');\n        const scoreColumn = this.getConf('scoreColumn');\n        const colRef = this.getConf('colRef');\n        const colStart = this.getConf('colStart');\n        const colEnd = this.getConf('colEnd');\n        return {\n            header,\n            features,\n            parser,\n            columnNames,\n            scoreColumn,\n            colRef,\n            colStart,\n            colEnd,\n        };\n    }\n    async loadData(opts = {}) {\n        if (!this.bedFeatures) {\n            this.bedFeatures = this.loadDataP(opts).catch((e) => {\n                this.bedFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.bedFeatures;\n    }\n    async getRefNames(opts = {}) {\n        const { features } = await this.loadData(opts);\n        return Object.keys(features);\n    }\n    async getHeader(opts = {}) {\n        const { header } = await this.loadData(opts);\n        return header;\n    }\n    async getNames() {\n        const { header, columnNames } = await this.loadData();\n        if (columnNames.length) {\n            return columnNames;\n        }\n        const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f);\n        const defline = defs.at(-1);\n        return (defline === null || defline === void 0 ? void 0 : defline.includes('\\t'))\n            ? defline\n                .slice(1)\n                .split('\\t')\n                .map(field => field.trim())\n            : undefined;\n    }\n    async loadFeatureIntervalTreeHelper(refName) {\n        const { colRef, colStart, colEnd, features, parser, scoreColumn } = await this.loadData();\n        const lines = features[refName];\n        if (!lines) {\n            return undefined;\n        }\n        const names = await this.getNames();\n        const intervalTree = new IntervalTree();\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n            const uniqueId = `${this.id}-${refName}-${i}`;\n            const feat = new SimpleFeature(featureData({\n                line,\n                colRef,\n                colStart,\n                colEnd,\n                scoreColumn,\n                parser,\n                uniqueId,\n                names,\n            }));\n            intervalTree.insert([feat.get('start'), feat.get('end')], feat);\n        }\n        return intervalTree;\n    }\n    async loadFeatureIntervalTree(refName) {\n        if (!this.intervalTrees[refName]) {\n            this.intervalTrees[refName] = this.loadFeatureIntervalTreeHelper(refName).catch((e) => {\n                this.intervalTrees[refName] = undefined;\n                throw e;\n            });\n        }\n        return this.intervalTrees[refName];\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { start, end, refName } = query;\n            const intervalTree = await this.loadFeatureIntervalTree(refName);\n            const features = intervalTree === null || intervalTree === void 0 ? void 0 : intervalTree.search([start, end]);\n            if (features) {\n                for (const f of features) {\n                    observer.next(f);\n                }\n            }\n            observer.complete();\n        }, opts.stopToken);\n    }\n    freeResources() { }\n}\nBedAdapter.capabilities = ['getFeatures', 'getRefNames'];\nexport default BedAdapter;\n"],"names":[],"sourceRoot":"","ignoreList":[0]}