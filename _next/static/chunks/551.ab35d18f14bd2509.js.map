{"version":3,"file":"static/chunks/551.ab35d18f14bd2509.js","mappings":"4JAKO,gBACP,aAAY,qDAAwD,EACpE,OACA,EAAkB,oBAAc,mBAChC,EAAuB,oBAAc,wBACrC,EAAqB,oBAAc,eACnC,EAAqB,oBAAc,eACnC,EAAkB,oBAAc,YAChC,EAAsB,oBAAc,gBACpC,kCACA,EAAkB,cAAQ,EAC1B,KACA,sBACA,kCACK,EACL,EAAmB,cAAQ,EAAG,iBAAkC,EAChE,aACA,YACA,OAA8B,oBAAc,oBAAoB,UAAgB,EAChF,aACA,OACA,OACA,2BACA,KACA,KACA,yBACA,SAAkC,mBAAa,QAC/C,gCACA,UACA,KAEA,qBACA,cACA,UAnCA,EAoCA,oBACA,mBACA,CAEA,GADA,SACA,EAEA,aADA,cACA,aACA,SAAsC,mBAAa,QACnD,MA5CA,GA6CA,gBACA,KACgB,iBAAW,OA9C3B,EA8C2B,GAE3B,0BACgB,iBAAW,OAjD3B,EAiD2B,EAE3B,CAGA,OADA,YACA,iBAAa,EACb","sources":["webpack://_N_E/./node_modules/@jbrowse/plugin-wiggle/esm/drawDensity.js"],"sourcesContent":["import { readConfObject } from '@jbrowse/core/configuration';\nimport { featureSpanPx } from '@jbrowse/core/util';\nimport { fillRectCtx, getScale } from './util';\nconst fudgeFactor = 0.3;\nconst clipHeight = 2;\nexport function drawDensity(ctx, props) {\n    const { features, regions, bpPerPx, scaleOpts, height, config } = props;\n    const region = regions[0];\n    const pivot = readConfObject(config, 'bicolorPivot');\n    const pivotValue = readConfObject(config, 'bicolorPivotValue');\n    const negColor = readConfObject(config, 'negColor');\n    const posColor = readConfObject(config, 'posColor');\n    const color = readConfObject(config, 'color');\n    const clipColor = readConfObject(config, 'clipColor');\n    const crossing = pivot !== 'none' && scaleOpts.scaleType !== 'log';\n    const scale = getScale({\n        ...scaleOpts,\n        pivotValue: crossing ? pivotValue : undefined,\n        range: crossing ? [negColor, 'white', posColor] : ['white', posColor],\n    });\n    const scale2 = getScale({ ...scaleOpts, range: [0, height] });\n    const cb = color === '#f0f'\n        ? (_, score) => scale(score)\n        : (feature, score) => readConfObject(config, 'color', { feature, score });\n    const domain = scale2.domain();\n    const niceMin = domain[0];\n    const niceMax = domain[1];\n    let prevLeftPx = Number.NEGATIVE_INFINITY;\n    let hasClipping = false;\n    const reducedFeatures = [];\n    for (const feature of features.values()) {\n        const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx);\n        if (Math.floor(leftPx) !== Math.floor(prevLeftPx)) {\n            reducedFeatures.push(feature);\n            prevLeftPx = leftPx;\n        }\n        const score = feature.get('score');\n        hasClipping = hasClipping || score > niceMax || score < niceMin;\n        const w = rightPx - leftPx + fudgeFactor;\n        ctx.fillStyle = cb(feature, score);\n        ctx.fillRect(leftPx, 0, w, height);\n    }\n    ctx.save();\n    if (hasClipping) {\n        ctx.fillStyle = clipColor;\n        for (const feature of features.values()) {\n            const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx);\n            const w = rightPx - leftPx + fudgeFactor;\n            const score = feature.get('score');\n            if (score > niceMax) {\n                fillRectCtx(leftPx, 0, w, clipHeight, ctx);\n            }\n            else if (score < niceMin && scaleOpts.scaleType !== 'log') {\n                fillRectCtx(leftPx, 0, w, clipHeight, ctx);\n            }\n        }\n    }\n    ctx.restore();\n    return { reducedFeatures };\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0]}